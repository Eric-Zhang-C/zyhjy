<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>python字符串操作</title>
    <url>/zyhjy/2022/05/21/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<table>
<colgroup>
<col style="width: 42%" />
<col style="width: 42%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">操作符/ 函数</th>
<th style="text-align: left;">描述</th>
<th style="text-align: left;">实例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">[ : ]</td>
<td
style="text-align: left;">截取字符串中的一部分，遵循左闭右开原则，str[0:2]
是不包含第 3 个字符的</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">r/R</td>
<td style="text-align: left;">原始字符串 -
原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符</td>
<td
style="text-align: left;"><code>print(r'\n')</code><br><code>print(R'\n')</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">rfind(str, beg=0,end=len(string))</td>
<td
style="text-align: left;">返回字符串最后一次出现的位置，如果没有匹配项则返回-1</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<p>Check out the <a
href="https://www.runoob.com/python3/python3-string.html">python3
string</a> for more info.</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>LLVM与clang的关系</title>
    <url>/zyhjy/2022/05/24/llvm%E4%B8%8Eclang%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p><strong>LLVM</strong>最初是底层虚拟机（<strong>L</strong>ow
<strong>L</strong>evel <strong>V</strong>irtual
<strong>M</strong>achine）的缩写，指<strong>架构编译器</strong>的框架系统，用C++编写而成。<br>
我们可以认为LLVM已经类似于一个商标,是一个完整的编译器架构，也可以认为它是一系列模块化和可重用的编译器和工具链技术的集合。<br></p>
<h3 id="llvm的子项目">LLVM的子项目：</h3>
<ol type="1">
<li>LLVM Core<br> <strong>LLVM Core</strong>
libraries提供了一个源代码无关和目标架构无关的独立配置器，以及许多流行CPU（以及一些不太常见的CPU）的架构后端生成支持。这些库是围绕一个称为LLVM中间码（LLVM
intermediate representation, "LLVM
IR"）的的工具来构建的。LLVM核心库的文档特别详细，所以用LLVM作为优化器和代码生成器来形成自己的语言（或移植现有编译器）是非常容易的。</li>
<li><strong>Clang</strong><br> Clang是一个LLVM“原配”的C/C
++/Objective-C编译器，旨在提供高效快速的编译效率（例如，在debug模式下编译Objective-C代码时比GCC快3倍），风格良好的warning和error信息，以及作为开源库来构建第三方语言的编译器。
<img src="/pics/20160718211639694.png" title="clangAndLLVM"
alt="clangAndLLVM" /> Clang Static
Analyzer是一个静态的自动查找代码中的错误的工具，是使用Clang前端作为依赖库来解析C/C++代码的工具类型的一个很好的例子。</li>
<li>LLDB<br>
LLDB项目以LLVM和Clang提供的库为基础，提供了一个出色的native级别调试器。它使用Clang
AST和表达式解析器、LLVM
JIT、LLVM反汇编器等元生组件，所以跟它们配合的很好。在加载调试符号时，它也比GDB快多了而且能够更好的节约内存。</li>
<li>libc++ and libc++ ABI<br> libc++和libc++
ABI项目提供了符合C++标准库的高性能实现，而且还包括对C++11和C++14的完整支持。</li>
<li>compiler-rt<br>
compiler-rt项目为动态测试工具（如AddressSanitizer，ThreadSanitizer，MemorySanitizer和DataFlowSanitizer）提供了运行时库的实现。它还为像“__fixunsdfdi”这样的低级代码生成器支持进程提供高层面的调整实现，也提供当目标没有用于实现核心IR操作的短序列本机指令时生成的其他调用。</li>
<li>OpenMP项目提供了一个OpenMP运行时，用于Clang中的OpenMP实现。</li>
<li>polly项目使用多面体模型实现一组缓存局部优化以及自动并行和矢量化。</li>
<li>libclc项目旨在实现OpenCL标准库。</li>
<li>klee项目实现了一个“符号虚拟机”，它使用一个定理证明器来尝试评估程序中的所有动态路径，以发现错误并证明函数的属性。
klee的一个主要特性是它可以在检测到错误时生成测试用例。</li>
<li>SAFECode项目是用于C / C ++程序的内存安全编译器。
它通过运行时检查来检测代码，以便在运行时检测内存安全错误（例如，缓冲区溢出）。
它可用于保护软件免受安全攻击，也可用作Valgrind等内存安全错误调试工具。</li>
<li>LLD项目是一个新的链接器。
可以作为系统链接器的直接替代品，有更快的运行速度。</li>
</ol>
<h3 id="llvm的功能介绍">LLVM的功能介绍</h3>
<ul>
<li>以C/C++为例，LLVM编译系统包括以下内容：
<ul>
<li>一个良好的前端；GCC 4.2解析器能解析的语言，比如C，C
++，Objective-C，Fortran等，它都能提供同能能力的支持；另外它还能支持一些GCC的扩展插件。</li>
<li>LLVM指令集的稳定实现；不管代码处于何种状态，都可以在汇编（ASCII）和字节码（二进制）之间自由转换。</li>
<li>一个功能强大的<strong>Pass</strong>管理系统，它根据它们的依赖性自动对<strong>Pass</strong>（包括分析，转换和代码生成Pass）进行排序，并将它们管道化以提高效率。</li>
<li>广泛的全局标量优化。</li>
<li>包含丰富的分析和转换的链接时过程优化框架，包括复杂的完整程序指针分析、调用图构建以及对配置文件引导优化的支持。</li>
<li>易于重定向的代码生成器，目前支持X86，X86-64，PowerPC，PowerPC-64，ARM，Thumb，SPARC，Alpha，CellSPU，MIPS，MSP430，SystemZ和XCore。</li>
<li>Just-In-Time（JIT）即时编译器，目前支持X86，X86-64，ARM，AArch64，Mips，SystemZ，PowerPC和PowerPC-64。</li>
<li>支持生成DWARF调试信息。</li>
<li>用于测试和生成除上面列出的目标之外的目标的本机代码的C后端。</li>
<li>与gprof类似的分析系统。</li>
<li>具有许多基准代码和应用程​​序的测试框架。</li>
<li>API和调试工具，以简化LLVM组件的快速开发。 <img
src="/pics/223786_M9G9ETTWNHNZP65.png" alt="LLVM" /></li>
</ul></li>
</ul>
<p>Check out the <a href="https://llvm.org">LLVM docs</a> for more info
on how to get the most out of LLVM.</p>
]]></content>
      <categories>
        <category>clang llvm</category>
      </categories>
  </entry>
  <entry>
    <title>macOS teminal主题设置</title>
    <url>/zyhjy/2022/05/26/mac-terminal/</url>
    <content><![CDATA[<ul>
<li>操作系统: <code>macOS Catalina version 10.15.3</code></li>
<li>shell环境: <code>zsh</code></li>
</ul>
<h2 id="主题">主题</h2>
<p>原先terminal的主题看着很不舒服。在reddit上看到大家推荐使用Tomorrow
Night，所以尝试一下。<br> 1. 下载<a
href="https://github.com/chriskempson/tomorrow-theme/tree/master/OS%20X%20Terminal">Tomorrow
Night git</a>需要的.terminal文件。 2. 导入<code>Terminal</code>: 1.
shell &gt;&gt; 导入... <img src="/pics/2022-05-27-terminal.png"
title="Import" alt="import" /> 2. 终端 &gt;&gt; 偏好设置 &gt;&gt;
描述文件, 在左侧选择相应的theme。</p>
<h2 id="oh-my-zsh">oh my zsh</h2>
<h3 id="为什么要用-zsh">1. 为什么要用 Zsh</h3>
<p>相比于默认的 Bash，Zsh 有更多的自定义选项，并支持扩展。因此 Zsh
可以实现更强大的命令补全，命令高亮等一系列酷炫功能.<br>
不过代价就是启动速度稍微有点慢（1秒左右，不过相比Bash还是慢了点），而且据说语法和标准
Shell
有点区别（至少我是在使用中完全没有碰到兼容性问题）。因此现在几乎所有的
Linux / Unix 版本的默认 Shell 仍然是 Bash。<br></p>
<h3 id="oh-my-zsh-1">2. oh my zsh</h3>
<p>默认的 Zsh 配置有点麻烦。因此一个叫 robbyrussel 的用户在 GitHub
上制作了一个配置文件 oh-my-zsh，这是目前为止最流行的 Zsh 配置：<a
href="https://ohmyz.sh">oh my zsh官网</a><br> #### 安装 1.
官网给出了两种安装方法：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</span><br><span class="line">$ sh -c &quot;$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)&quot;</span><br></pre></td></tr></table></figure>
但是在mac上均会出错，试了网上各种方法均无效，原因未知：<br>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zyh@zyhs-MBP tools % sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</span><br><span class="line">curl: (35) LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to raw.github.com:443 </span><br><span class="line">zyh@zyhs-MBP tools % sh -c &quot;$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)&quot;</span><br><span class="line">--2022-05-27 16:15:36--  https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh</span><br><span class="line">正在解析主机 raw.github.com (raw.github.com)... 185.199.111.133, 185.199.110.133, 185.199.109.133, ...</span><br><span class="line">正在连接 raw.github.com (raw.github.com)|185.199.111.133|:443... 已连接。</span><br><span class="line">无法建立 SSL 连接</span><br></pre></td></tr></table></figure>
其实我们仔细观察上面那个命令，只是去拿了一个.sh脚本然后执行，如果我们手动把它下载下来或者创建一份然后执行呢？
2. 复制install.sh安装脚本内容<br> <a
href="https://gitee.com/mirrors/oh-my-zsh/blob/master/tools/install.sh">oh
my zsh on gitee</a>是oh my
zsh这个项目在码云Gitee里的镜像仓库中具体安装脚本install.sh的位置，打开这个URL点击一键复制按钮将内容复制下来
3. 新建脚本文件粘贴脚本内容<br> 在本地新建 install.sh
文件，并将刚刚复制的内容粘贴进去 4. 添加执行权限并安装<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zyh@zyhs-MBP tools % chmod +x install.sh </span><br><span class="line">zyh@zyhs-MBP tools % sh -c ./install.sh</span><br><span class="line">Cloning Oh My Zsh...</span><br><span class="line">remote: Enumerating objects: 1295, done.</span><br><span class="line">remote: Counting objects: 100% (1295/1295), done.</span><br><span class="line">remote: Compressing objects: 100% (1249/1249), done.</span><br><span class="line">remote: Total 1295 (delta 26), reused 1253 (delta 26), pack-reused 0</span><br><span class="line">Receiving objects: 100% (1295/1295), 1.06 MiB | 4.90 MiB/s, done.</span><br><span class="line">Resolving deltas: 100% (26/26), done.</span><br><span class="line">From https://github.com/ohmyzsh/ohmyzsh</span><br><span class="line">...</span><br><span class="line">➜  tools </span><br></pre></td></tr></table></figure>
注意到提示符变化了，安装成功。 5. 删除无用的安装脚本<br>
<code>$ rm install.sh</code></p>
<h4 id="主题配置">主题配置</h4>
<p>你可能会觉得现在的主题已经超棒了，但是记得吗，我说过Zsh支持很多个性化配置和插件。现在，编辑<code>~/.zshrc</code>文件（比如用<code>Vim</code>或者<code>VSCode</code>），我们来尝试一下各种主题：<br>
你会看到有一行<code>ZSH_THEME="robbyrussell"</code>，把它替换成<code>ZSH_THEME="agnoster"</code>。<br>
然后回到终端，输入<code>source ~/.zshrc</code>，你会发现你的Zsh主题变了<br>
现在你的主题名称是Agnoster，如果你觉得不太好看，你可以改。<br> 前往
oh-my-zsh 的 Wiki 就可以看到大多数 oh-my-zsh
的内置主题以及它们的截图。如果你看中的其中的一款，可以重复上面的步骤，编辑<code>~/.zshrc</code>，并更改<code>ZSH_THEME="xxx"</code>。<br>
比如你看中了 ys 主题（我的最爱），你可以把 ZSH_THEME 改成
"ys"，然后回到终端，执行 <code>source ~/.zshrc</code> 命令。<br> P.S.
这些主题都保存在 <code>~/.oh-my-zsh/themes</code> 目录中<br></p>
<h4 id="插件">插件</h4>
<p>oh-my-zsh 的自带插件都储存在 <code>~/.oh-my-zsh/plugins</code>
目录中，如果你希望安装一个插件，可以在 <code>~/.zshrc</code> 的
<code>plugins=(xxx, xxx, ...)</code> 这一行里加入插件名称<br>
如果你需要安装第三方插件和主题，你可以在 <code>~/.zshrc</code>
的某一行（比如末尾）加入 <code>source /path/to/plugin</code><br>
比如你希望添加一个 <code>zsh-syntax-highlighting</code> 插件<br>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ~/.zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span><br><span class="line"># 这里要根据你自己的输入目录，而不是抄我的，否则然并卵</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>mac</category>
      </categories>
  </entry>
  <entry>
    <title>mac使用brew update无反应,更新慢，断链等解决办法</title>
    <url>/zyhjy/2022/05/27/mac%E4%BD%BF%E7%94%A8brew%20update%E6%97%A0%E5%8F%8D%E5%BA%94,%E6%9B%B4%E6%96%B0%E6%85%A2%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<h2 id="问题">问题</h2>
<p>由于国内某种特殊原因，我们访问很多repo源是有一定难度的，比如在Mac上非常好用的包管理软件Brew安装各种工具时发现居然报错，下载不了这，连接那又timeout，什么也安装不了，心肝迷茫和无助。<br>
参考<a
href="https://blog.csdn.net/weixin_36562804/article/details/107872131">brew
docs</a>。<br></p>
<p>https://www.jianshu.com/p/2dcfc3de4fa3</p>
<h2 id="安装valgrind">安装valgrind</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew remove valgrind # remove previous attempts at installing it (if any)</span><br><span class="line">brew tap LouisBrunner/valgrind</span><br><span class="line">brew install --HEAD LouisBrunner/valgrind/valgrind</span><br></pre></td></tr></table></figure>
<h2 id="github-433">github 433</h2>
<p>根据vpn端口设置代理</p>
<p>https://stackoverflow.com/questions/48987512/ssl-connect-ssl-error-syscall-in-connection-to-github-com443</p>
<p>https://gist.github.com/laispace/666dd7b27e9116faece6</p>
<p>git config --global http.proxy http://127.0.0.1:62019</p>
<h2 id="破解staruml">破解starUML</h2>
<ol type="1">
<li>安装npm brew install npm</li>
<li>安装asar</li>
</ol>
<p>npm install asar -g</p>
<ol start="3" type="1">
<li>进入目录，解压文件app.asar</li>
</ol>
<p>cd /Applications/StarUML.app/Contents/Resources/ asar extract
app.asar app</p>
<ol start="4" type="1">
<li>修改新生成的app目录下的lisence文件</li>
</ol>
<p>vim app/src/engine/license-manager.js</p>
<ol start="5" type="1">
<li>找到checkLicenseValidity()函数，125行开始的，原代码：</li>
</ol>
<p>checkLicenseValidity () { this.validate().then(() =&gt; {
setStatus(this, true) }, () =&gt; { setStatus(this, false)
UnregisteredDialog.showDialog() }) }</p>
<p>修改为：</p>
<p>checkLicenseValidity () { this.validate().then(() =&gt; {
setStatus(this, true) }, () =&gt; { setStatus(this, true) }) }</p>
<ol start="6" type="1">
<li>打包覆盖原app.asar</li>
</ol>
<p>asar pack app app.asar</p>
]]></content>
      <categories>
        <category>mac</category>
      </categories>
  </entry>
  <entry>
    <title>git clone常见报错</title>
    <url>/zyhjy/2022/05/18/git-clone%E6%8A%A5%E9%94%99443/</url>
    <content><![CDATA[<ul>
<li>环境: <code>Mac</code> ; 蓝灯代理全部流量 ## 问题1
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  tools git clone https://github.com/llvm/llvm-project</span><br><span class="line">Cloning into &#x27;llvm-project&#x27;...</span><br><span class="line">fatal: unable to access &#x27;https://github.com/llvm/llvm-project/&#x27;: Failed to connect to github.com port 443: Operation timed out</span><br></pre></td></tr></table></figure></li>
<li>解决办法:
<code>➜  tools git config --global https.proxy https://127.0.0.1:1080</code></li>
</ul>
<h2 id="问题2">问题2</h2>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  tools git clone https://github.com/llvm/llvm-project</span><br><span class="line">Cloning into &#x27;llvm-project&#x27;...</span><br><span class="line">error: RPC failed; curl 7 LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 60</span><br><span class="line">fatal: the remote end hung up unexpectedly</span><br></pre></td></tr></table></figure> - 解决办法:
<code>➜  tools git config --global https.proxy https://127.0.0.1:62019</code>
- ps : <code>https://127.0.0.1:62019</code>是蓝灯代理服务器</p>
<p>git config --global http.proxy http://127.0.0.1:62019</p>
<h5
id="附git常用命令总结jekyll-docs-git-config常用命令总结jekyll-gh">附:<a
href="http://t.zoukankan.com/fanyegong-p-5127780.html">git常用命令总结</a>;
<a href="https://blog.csdn.net/zhw21w/article/details/124109159">git
config常用命令总结</a></h5>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>LLVM安装!</title>
    <url>/zyhjy/2022/05/30/llvm%20install/</url>
    <content><![CDATA[<h2 id="简介">简介</h2>
<ul>
<li><p>mac
OS系统并没有LLVM工具，但是安装Xcode之后能调用基本的LLVM编译命令如clang，而如果想要调用llc等命令的话只能下载并安装完整的LLVM工具。</p></li>
<li><p>操作系统: <code>macOS Catalina version 10.15.3</code></p></li>
</ul>
<h2 id="安装">安装</h2>
<ul>
<li><code>brew install llvm</code>
<code>llvm</code>会被安装在<code>/usr/local/opt/llvm</code>的路径下。<br>
打开<code>～/.zshrc</code>:<br>
<code>export PATH=/usr/local/opt/llvm/bin:$PATH</code><br>
使用<code>source ~/.zshrc</code>使.<code>zshrc</code>文件文件生效<br></li>
</ul>
<p>输入<code>llvm-dis --version</code>测试<br></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">To use the bundled libc++ please add the following LDFLAGS:</span><br><span class="line">  LDFLAGS=&quot;-L/usr/local/opt/llvm/lib -Wl,-rpath,/usr/local/opt/llvm/lib&quot;</span><br><span class="line"></span><br><span class="line">llvm is keg-only, which means it was not symlinked into /usr/local,</span><br><span class="line">because macOS already provides this software and installing another version in</span><br><span class="line">parallel can cause all kinds of trouble.</span><br><span class="line"></span><br><span class="line">If you need to have llvm first in your PATH, run:</span><br><span class="line">  echo &#x27;export PATH=&quot;/usr/local/opt/llvm/bin:$PATH&quot;&#x27; &gt;&gt; ~/.zshrc</span><br><span class="line"></span><br><span class="line">For compilers to find llvm you may need to set:</span><br><span class="line">  export LDFLAGS=&quot;-L/usr/local/opt/llvm/lib&quot;</span><br><span class="line">  export CPPFLAGS=&quot;-I/usr/local/opt/llvm/include&quot;</span><br></pre></td></tr></table></figure>
<h2 id="使用">使用</h2>
<h3 id="场景1">场景1</h3>
<p>建立build目录并且在该目录下进行编译，注意LLVM禁止源码内编译（in-tree
build is not supported） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; cd /usr/local/opt/llvm</span><br><span class="line">&gt; mkdir build</span><br><span class="line">&gt; cd build</span><br><span class="line">&gt; cmake -G &quot;Unix Makefiles&quot; \</span><br><span class="line">  -DCMAKE_BUILD_TYPE=Release \</span><br><span class="line">  -DCMAKE_EXPORT_COMPILE_COMMANDS=ON \</span><br><span class="line">  -DLLVM_BUILD_LLVM_DYLIB=ON \</span><br><span class="line">  --enable-optimized \</span><br><span class="line">  --enable-targets=host-only \</span><br><span class="line">  ../../llvm</span><br><span class="line">&gt; make</span><br></pre></td></tr></table></figure> -G = 指定生成编译器
-DCMAKE_BUILD_TYPE = 调试版本（Debug）或者发布版本（Release）
-DCMAKE_EXPORT_COMPILE_COMMANDS = 是否输出编译命令
-DLLVM_BUILD_LLVM_DYLIB = 是否添加libLLVM共享库 更多的编译项可以参考<a
href="https://llvm.org/docs/CMake.html">LLVM compile
docs</a>的编译文档。</p>
<h3 id="场景2">场景2</h3>
<p>创建一个C语言文件test.c <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">  printf(&quot;hello world\n&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> - 编译生成可执行文件<br>
<code>clang test.c -o test</code></p>
<ul>
<li><p>运行可执行文件<br> <code>test</code></p></li>
<li><p>生成llvm字节码文件<br>
<code>clang -O1 -emit-llvm test.c -c -o test.bc</code></p></li>
<li><p>生成LLVM 的汇编代码 .ll 文件(可视化字节码文件)
<code>clang -O1 -emit-llvm test.c -S -o test.ll</code></p></li>
<li><p>运行字节码文件<br> <code>lli test.bc</code> 结果: "hello world"
.ll文件也可以用lli来执行</p></li>
<li><p>将 .bc 文件转化为 .ll 文件:
<code>llvm-dis test.bc</code></p></li>
<li><p>将 .ll 文件转化为 .bc 文件: <code>llvm-as test.ll</code></p></li>
<li><p>编译字节码文件为汇编文件<br>
<code>llc test.bc -o test.s</code></p></li>
<li><p>将 .bc 或 .ll 文件转化为本机平台的汇编代码<br>
<code>llc test.bc</code> <code>llc test.ll</code></p></li>
</ul>
]]></content>
      <categories>
        <category>llvm</category>
      </categories>
  </entry>
  <entry>
    <title>VSCode使用指南!</title>
    <url>/zyhjy/2022/05/30/VSCode%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="必备开发插件">必备开发插件</h2>
<ul>
<li>TODO Tree<br>
这个插件能帮你组织和管理<code>TODO</code>注释，你在代码中注释的带<code>TODO</code>的标签会统一在侧边栏显示出来，当然不限于<code>TODO</code>注释，可以自定义管理标签比如<code>FIXME</code>等，可以基于标签过滤和筛选。</li>
<li>Bookmarks<br>
「书签」这个插件的功能就和它名字一样直接，没错它就是一个你的源码书签，当我们看大工程源码的时候，往往需要在成千上万个源文件之间跳转，此时
Bookmarks 能帮你方便的创建和管理书签，看到哪个位置想加个书签就按快捷键
<code>command + option + K</code>
，多按一次就是删除，不仅如此他还提供了在书签之前跳跃和查看管理的功能，更多功能可以自己体验</li>
<li>Git Graph<br> 可视化Git仓库</li>
<li>GitLens<br>
它可以在文件中改动的位置后面直接显示出本次改动的提交信息，然后你可以直接通过显示的提交信息跳转到提交文件对比，其实还有其他丰富的功能.</li>
<li>Bracket Pair Colorizer<br> 彩虹括号插件</li>
<li>koroFileHeader<br>
用于自动的插入头文件开头的说明和函数的说明。安装插件之后你只需要简单配置想要的格式，然后按下快捷键<code>Command + Option +i</code>即可自动即可自动生成这样一个模板。类似的对函数的说明注释模板，只需按下快捷键<code>Command + Option +t</code>即可完成</li>
<li>shellman<br> 件是 Linux shell 脚本辅助工具。在 Linux
下工作难免随手写一个脚本，这个插件能提供了便捷的shell script
自动补全和联想等功能，提高你的脚本编写速度和准确性。</li>
</ul>
<h2 id="常用快捷键">常用快捷键</h2>
<table>
<thead>
<tr class="header">
<th>｜shortcut</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>cmd + U</td>
<td>撤销光标上次操作</td>
</tr>
<tr class="even">
<td>cmd+K cmd+0</td>
<td>折叠所有代码块</td>
</tr>
<tr class="odd">
<td>cmd+option+k</td>
<td>增加/删除书签</td>
</tr>
<tr class="even">
<td><code>Cmd + ,</code></td>
<td>打开设置</td>
</tr>
</tbody>
</table>
<p>https://code.visualstudio.com/shortcuts/keyboard-shortcuts-macos.pdf</p>
<ul>
<li><p><code>Option + 上/下箭头</code>
将该行代码与上一行或下一行替换。</p></li>
<li><p><code>Command + 左/右箭头</code>
前进或者后退到行末或行尾。</p></li>
<li><p><code>Command + Shift + P</code>
这个必须要放在第一位，这个命令是所有「命令之母」。这么说一点也不过分，它会打开
VsCode
命令窗口，在这个窗口下输入上述的插件名称就能知道这个插件支持哪些特性了，顺带还会说明特性快捷键。</p></li>
<li><p><code>Command + P</code>
文件查找。快速打开文件列表，输入关键字匹配文件，优先显示最新打开过的文件，方便的在指定文件之间跳转。</p></li>
<li><p><code>F12</code>
跳转到定义，这个没啥好说的，跳转到函数或符号的定义，这是高频操作。</p></li>
<li><p><code>Option + F12</code>
以预览方式在当前页面显示定义，都是查看定义，相对 <code>F12</code>
的优点是不会跳出当前文件到定义文件</p></li>
<li><p><code>Shift + F12</code> 查看光标所在函数或变量的引用，就像
<code>Option + F12</code>
一样以预览方式在当前文件打开引用的文件列表</p></li>
<li><p><code>Command + Shift + O</code>
查看当前文件的符号，可以用关键字过滤符号，当然你也可以在左侧的大纲视图中查找符号，不过大纲视图不能查找匹配符号，所以我更习惯用快捷键方式查找符号</p></li>
</ul>
<h2 id="代码格式">代码格式</h2>
<p>要在VS Code中设置C++代码的格式，您可以按照以下步骤进行操作：</p>
<ol type="1">
<li><p>安装C/C++扩展：打开VS
Code，点击左侧边栏中的扩展图标（四个方块的图标），搜索并安装"C/C++"扩展。安装完成后，重新启动VS
Code。</p></li>
<li><p>安装clang-format：为了格式化C++代码，我们将使用clang-format工具。您需要先安装clang-format。可以通过以下方法安装：</p>
<ul>
<li>Windows：可以使用Chocolatey包管理器，在命令提示符中运行<code>choco install llvm</code>来安装clang-format。</li>
<li>macOS：可以使用Homebrew包管理器，在终端中运行<code>brew install llvm</code>来安装clang-format。</li>
<li>Linux：在终端中使用适当的包管理器安装clang-format。</li>
</ul></li>
<li><p>配置VS
Code设置：按下<code>Ctrl + ,</code>（或者在macOS上是<code>Cmd + ,</code>）打开VS
Code的设置。</p></li>
<li><p>配置<code>settings.json</code>：在设置面板中，找到"C/C++"，然后点击"Edit
in
settings.json"链接。这将打开一个名为<code>settings.json</code>的文件，其中包含C/C++扩展的设置。</p></li>
<li><p>配置clang-format路径：在<code>settings.json</code>文件中，添加以下配置行，指定clang-format的路径。根据您的操作系统和clang-format的安装位置，将路径替换为正确的值。</p></li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;C_Cpp: Clang_format_fallback Style&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123; BasedOnStyle: Google , IndentWidth: 4, TabWidth: 4 &#125;&quot;</span></span><br><span class="line"><span class="attr">&quot;C_Cpp: Clang_format_path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/clang-format&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可执行文件， <code>which clang-format</code></li>
</ul>
<ol start="6" type="1">
<li>配置自动格式化：为了使VS
Code在保存文件时自动格式化代码，添加以下配置行到<code>settings.json</code>文件中：</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;editor.formatOnSave&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br></pre></td></tr></table></figure>
<ol start="7" type="1">
<li>自定义格式化选项（可选）：如果您想自定义C++代码的格式化选项，您可以添加一个<code>.clang-format</code>文件到您的项目根目录或您的用户主目录中。该文件指定了一系列格式化选项，例如缩进样式、换行规则等。您可以在<a
href="https://clang.llvm.org/docs/ClangFormatStyleOptions.html">clang-format文档</a>中找到所有可用选项的详细信息。在<code>.clang-format</code>文件中，您可以添加类似以下内容的配置：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BasedOnStyle: Google</span><br><span class="line">IndentWidth: 4</span><br></pre></td></tr></table></figure>
<ol start="8" type="1">
<li>保存文件并应用设置：保存<code>settings.json</code>文件，并在VS
Code中重新加载窗口以应用设置。</li>
</ol>
<p>现在，当您保存C++代码文件时，VS
Code将自动使用clang-format工具格式化代码，根据您的设置进行缩进、换行等操作。</p>
]]></content>
      <categories>
        <category>VSCode</category>
      </categories>
  </entry>
  <entry>
    <title>绕开网页js脚本的若干方法</title>
    <url>/zyhjy/2022/05/27/%E7%BB%95%E5%BC%80%E7%BD%91%E9%A1%B5js%E8%84%9A%E6%9C%AC%E7%9A%84%E8%8B%A5%E5%B9%B2%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>很多网站都会使用js限制用户进行复制、粘贴，本文列出一下绕开这些限制的方法。<br>
浏览器: Safari<br> 1. 使用阅读器视图。</p>
]]></content>
      <categories>
        <category>mac</category>
      </categories>
  </entry>
  <entry>
    <title>python3利用clang语法树识别文件中的函数</title>
    <url>/zyhjy/2022/06/09/python3%E5%88%A9%E7%94%A8clang%E8%AF%AD%E6%B3%95%E6%A0%91%E8%AF%86%E5%88%AB%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="背景">背景</h1>
<p>python3利用cindex库解析c文件时遇到空宏前缀、
<code>#ifdef</code>作用域内函数无法识别的问题。</p>
<h1 id="解决思路">解决思路</h1>
<p>将c文件对应的<code>compile_commands.json</code>文件导入cindex库，然后解析。</p>
<h1 id="具体步骤">具体步骤</h1>
<ol type="1">
<li><p>编译生成文件对应的<code>compile_commands.json</code>。
公司里相关的项目没有用cmake,直接使用的make。
这种情况比较好处理，make改为bear make即可。 具体见<a
href="https://github.com/rizsotto/Bear">bear工具</a></p></li>
<li><p>cindex导入<code>compile_commands.json</code>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">from clang import cindex</span><br><span class="line"></span><br><span class="line">index = cindex.Index.create()</span><br><span class="line"># Step 1: load the compilation database</span><br><span class="line">compdb = cindex.CompilationDatabase.fromDirectory(your_cc.json_path)</span><br><span class="line"></span><br><span class="line"># Step 2: query compilation flags</span><br><span class="line">commands = compdb.getCompileCommands(you_target.c)</span><br><span class="line">file_args = []</span><br><span class="line">for command in commands:</span><br><span class="line">    for argument in command.arguments:</span><br><span class="line">        file_args.append(argument)</span><br><span class="line"></span><br><span class="line">translation_unit = index.parse(you_target.c, file_args[:-1]) # the last command it the target file self</span><br></pre></td></tr></table></figure></p></li>
</ol>
]]></content>
      <categories>
        <category>python3 clang AST</category>
      </categories>
  </entry>
  <entry>
    <title>在LLVM中使用PASS!</title>
    <url>/zyhjy/2022/06/09/%E5%9C%A8llvm%E7%BC%96%E5%86%99pass/</url>
    <content><![CDATA[<h1 id="pass简介">pass简介</h1>
<ul>
<li>LLVM
的pass框架是LLVM系统的一个很重要的部分。LLVM的优化和转换工作就是由多个pass来一起完成的。类似流水线操作一样，每个pass完成特定的优化工作。
要想真正发挥LLVM的威力，掌握pass是不可或缺的一环。LLVM中pass架构的可重用性和可控制性都非常好，这允许用户自己开发pass或者关闭一些默认提供的pass。</li>
<li>pass分为两类, 一类是分析(analysis)pass, 负责收集信息共其它pass使用,
辅助调试或使程序可视化; 另一类是转换(transform)pass, 改变程序的dataflow
/ controlflow. LLVM中实现了几十种优化pass, 其中许多pass运行不止一次.
analysis pass存放在lib/Analysis下, transform
pass存放在lib/Transforms下.</li>
</ul>
<h1 id="hello-world"><code>Hello World</code></h1>
<ul>
<li>我的<code>llvm</code>安装在<code>/usr/local/opt/llvm</code>的路径下。<br></li>
</ul>
<p>打开<code>～/.zshrc</code>:<br>
<code>export PATH=/usr/local/opt/llvm/bin:$PATH</code><br>
使用<code>source ~/.zshrc</code>使.<code>zshrc</code>文件文件生效<br></p>
<p>输入<code>llvm-dis --version</code>测试<br></p>
<h2 id="使用">使用</h2>
<h3 id="场景1">场景1</h3>
<p>建立build目录并且在该目录下进行编译，注意LLVM禁止源码内编译（in-tree
build is not supported） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; cd /usr/local/opt/llvm</span><br><span class="line">&gt; mkdir build</span><br><span class="line">&gt; cd build</span><br><span class="line">&gt; cmake -G &quot;Unix Makefiles&quot; \</span><br><span class="line">  -DCMAKE_BUILD_TYPE=Release \</span><br><span class="line">  -DCMAKE_EXPORT_COMPILE_COMMANDS=ON \</span><br><span class="line">  -DLLVM_BUILD_LLVM_DYLIB=ON \</span><br><span class="line">  --enable-optimized \</span><br><span class="line">  --enable-targets=host-only \</span><br><span class="line">  ../../llvm</span><br><span class="line">&gt; make</span><br></pre></td></tr></table></figure> -G = 指定生成编译器
-DCMAKE_BUILD_TYPE = 调试版本（Debug）或者发布版本（Release）
-DCMAKE_EXPORT_COMPILE_COMMANDS = 是否输出编译命令
-DLLVM_BUILD_LLVM_DYLIB = 是否添加libLLVM共享库 更多的编译项可以参考<a
href="https://llvm.org/docs/CMake.html">LLVM compile
docs</a>的编译文档。</p>
<h3 id="场景2">场景2</h3>
<p>创建一个C语言文件test.c <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">  printf(&quot;hello world\n&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> - 编译生成可执行文件<br>
<code>clang test.c -o test</code></p>
<ul>
<li><p>运行可执行文件<br> <code>test</code></p></li>
<li><p>生成llvm字节码文件<br>
<code>clang -O1 -emit-llvm test.c -c -o test.bc</code></p></li>
<li><p>生成LLVM 的汇编代码 .ll 文件(可视化字节码文件)
<code>clang -O1 -emit-llvm test.c -S -o test.ll</code></p></li>
<li><p>运行字节码文件<br> <code>lli test.bc</code> 结果: "hello world"
.ll文件也可以用lli来执行</p></li>
<li><p>将 .bc 文件转化为 .ll 文件:
<code>llvm-dis test.bc</code></p></li>
<li><p>将 .ll 文件转化为 .bc 文件: <code>llvm-as test.ll</code></p></li>
<li><p>编译字节码文件为汇编文件<br>
<code>llc test.bc -o test.s</code></p></li>
<li><p>将 .bc 或 .ll 文件转化为本机平台的汇编代码<br>
<code>llc test.bc</code> <code>llc test.ll</code></p></li>
</ul>
]]></content>
      <categories>
        <category>llvm pass</category>
      </categories>
  </entry>
  <entry>
    <title>科学上网记录</title>
    <url>/zyhjy/2022/06/10/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="基础教程">基础教程</h1>
<ul>
<li>具体见<a
href="https://github.com/mku228/trojan/blob/main/README.md">vpn傻瓜教程</a>
# 注意事项 ## 机器选择</li>
<li>Location: singapore</li>
<li>CPU chose: 选$12, 后面选size变成$5，已经没有$3.5的了</li>
<li>ssh-key填了没用</li>
<li>左下角month选1，每月一续</li>
</ul>
<h2 id="安装trojan">安装Trojan</h2>
<ol type="1">
<li>SElinux开启:
<ul>
<li>选择重启</li>
</ul></li>
<li>域名解析失败
<ul>
<li>我申请的是xxx.tk,则输入www.xxx.tk</li>
</ul></li>
<li>证书申请失败
<ul>
<li>运行<code>curl https://get.acme.sh | sh -s email=my@example.com</code>,
邮箱可不管</li>
<li>然后运行安装脚本</li>
</ul></li>
</ol>
<h2 id="mac端使用">Mac端使用</h2>
<ol type="1">
<li><p>下载 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">======================================================================</span><br><span class="line">Trojan已安装完成，请使用以下链接下载trojan客户端，此客户端已配置好所有参数</span><br><span class="line">1、复制下面的链接，在浏览器打开，下载客户端</span><br><span class="line">Windows客户端下载:http://www.fxxkhwclose.tk/21439b51a3756814/trojan-cli.zip</span><br><span class="line">MacOS客户端下载:http://www.fxxkhwclose.tk/21439b51a3756814/trojan-mac.zip</span><br><span class="line">2、Windows将下载的客户端解压，打开文件夹，打开start.bat即打开并运行Trojan客户端</span><br><span class="line">3、MacOS将下载的客户端解压，打开文件夹，打开start.command即打开并运行Trojan客户端</span><br><span class="line">Trojan推荐使用 Mellow 工具代理（WIN/MAC通用）下载地址如下:</span><br><span class="line">https://github.com/mellow-io/mellow/releases  (exe为Win客户端,dmg为Mac客户端)</span><br><span class="line">======================================================================</span><br></pre></td></tr></table></figure></p>
<ul>
<li>下载后打开<code>config.json</code>文件,
两个<code>verify</code>改成false</li>
<li>run
<code>cd path_to/trojan &amp;&amp; ./trojan -c config.json</code></li>
</ul></li>
<li><p>安装<code>SwitchyOmega</code>插件</p>
<ul>
<li>Chrome应用商店安装<code>Proxy SwitchyOmega</code></li>
<li>插件配置见<a
href="https://trojan123.com/index.php/2020/03/29/trojan-chrome-switchyomega-zidong/">说明</a></li>
</ul></li>
<li><p>系统代理还没配，只能Chrome使用</p></li>
<li><p>ssh免密登陆:</p>
<ul>
<li>将id_rsa.pub 内容拷贝到~/.ssh/authorized_keys即可</li>
</ul></li>
</ol>
<h1 id="测速">测速</h1>
<ol type="1">
<li>安装iperf3:
<ul>
<li>CentOS : <code>yum install iperf3</code></li>
<li>MacOS : <code>brew  install iperf3</code></li>
</ul></li>
<li>测试:
<ul>
<li>在服务端启动server端的程序: <code>iperf3 -s</code></li>
<li>接着在client端执行: <code>iperf3 -c 48.77.234.178</code></li>
</ul></li>
<li>可能出现错误:
<code>iperf3: error - unable to connect to server: Connection refused</code>
<ul>
<li>原因: 防火墙端口未打开</li>
<li>solution: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --list-ports</span><br><span class="line">firewall-cmd --zone=public --add-port=5201/tcp --permanent </span><br><span class="line">firewall-cmd --reload</span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ol>
<ul>
<li>iperf3默认5201端口,TCP</li>
</ul>
]]></content>
      <categories>
        <category>vpn</category>
      </categories>
  </entry>
  <entry>
    <title>CMU CSAPP LAB指南</title>
    <url>/zyhjy/2022/06/10/CMU-CSAPP-LAB%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="背景">背景</h1>
<ul>
<li>记录在做LAB时遇到的问题。</li>
<li>OS: Mac</li>
</ul>
<h1 id="archlab">archlab</h1>
<h2 id="背景知识来源于csapp中文版第4章">0.
背景知识（来源于CSAPP中文版第4章）</h2>
<ul>
<li><p>Architecture:(also ISA: instruction set architecture)</p>
<ul>
<li>assembly(text representation)/machine(byte-level) code</li>
</ul></li>
<li><p>Microarchitecture: implement of Architecture</p>
<ul>
<li>cache sizes, core freq</li>
</ul></li>
<li><p>{.c, .h} -&gt; .i -&gt; .s -&gt; .o</p></li>
<li><p>需阅读内容4.1</p></li>
<li><p>Y86-64的程序员可见状态:</p>
<ul>
<li>15 registers:
<ul>
<li>%rax, %rcx, %rdx, %rbx, %rsp(栈指针), %rbp, %rsi, %rdi</li>
<li>%r8, ... %r14</li>
</ul></li>
<li>条件码:
<ul>
<li>ZF, SF, OF</li>
</ul></li>
<li>PC</li>
<li>内存</li>
<li>Stat
<ul>
<li>AOK, HLT, ADR, INS</li>
</ul></li>
</ul></li>
<li><p>Y86-64的指令:</p>
<ul>
<li>见P246图4-2</li>
</ul></li>
<li><p>汇编器伪指令(assembler directives):</p>
<ul>
<li>.quad (4字(word),8字节)</li>
<li>".rodata"：只读数据段。const全局变量。比如printf语句中的格式串和开关（switch）语句的跳转表。</li>
<li>".data"：数据段。已初始化的非零全局变量和静态变量。它会在main函数之前被处理。</li>
<li>".bss"：未初始化（或初值为0）的全局变量。它在目标文件中不占实际的空间（不保存在bin文件中），是一个占位符。目标文件格式区分初始化和未初始化变量是为了提高空间效率。启动代码完成两方面：①未初始化变量的清0。②设置已初始化变量的初值。保存了BSS段和COMMON段（存放注释）的内容。
<ul>
<li>注释：为了让启动代码简单，编译链接器会把已初始化的变量放.data段，这个段的映像（包含了各个变量的初值）保存在“只读数据段”。启动代码复制这个映像到
.data
段，初始化所有变量。初始化为0的变量保存在bss段，未初始化变量保存在common段，链接时再将其放入bss段。启动代码调用
memset 把所有未初始化变量清0。</li>
</ul></li>
<li>".symtab"：符号表。存放被定义和引用的函数及全局变量。每个可重定位目标文件在.symtab中都有一张符号表。与编译器中的符号表不同，.symtab不包含局部变量的表目。不一定要通过-g编译程序，得到符号表信息。</li>
</ul>
<p>https://www.jianshu.com/p/7ec425403779</p></li>
<li><p>x86-64:</p>
<ul>
<li>push: 压入原始%rsp值再-8</li>
<li>pop: 将%rsp置为取出的值</li>
<li>寄存器传参顺序 https://zhuanlan.zhihu.com/p/27339191</li>
</ul></li>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/tk.h:86:11: fatal error: &#x27;X11/Xlib.h&#x27; file not found</span><br></pre></td></tr></table></figure>
<p>安装X11 Makefile -I/private/var/select/X11/include</p></li>
<li><p>valP : 计算后的PC的值</p></li>
<li><p>valA, valB: 译码阶段从rA(srcA) rB(srcB)取出的值</p></li>
<li><p>CC:3个</p></li>
<li><p>Cnd:ZF SF OF</p></li>
<li><p>valE : ALU计算出的, 写入dstE</p></li>
<li><p>valM: 内存中取出的，写出dstM</p></li>
</ul>
<h2 id="flex编译出错">1. flex编译出错</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flex yas-grammar.lex</span><br><span class="line">mv lex.yy.c yas-grammar.c</span><br><span class="line">gcc -O1 -c yas-grammar.c</span><br><span class="line">gcc -Wall -O1 -g yas-grammar.o yas.o isa.o -lfl -o yas</span><br><span class="line">ld: library not found for -lfl</span><br></pre></td></tr></table></figure>
<ul>
<li>原因: trying to use flex on OS/X</li>
<li>解决方案:
<ul>
<li>Try <code>-ll</code> instead of <code>-lfl</code></li>
<li>for more information look at <a
href="https://stackoverflow.com/questions/21298097/library-not-found-for-lfl">this</a></li>
</ul></li>
</ul>
<p>Task #1 - Extendible Hash Table unordered buckets insert/delete
key/value entries without specifying the max size of the table not need
shrink support checking</p>
<p>哈希表的原理如下
https://www.geeksforgeeks.org/extendible-hashing-dynamic-approach-to-dbms/</p>
<p>[Task #2] - LRU-K Replacement Policy
https://www.cs.cmu.edu/~natassa/courses/15-721/papers/p297-o_neil.pdf
https://blog.csdn.net/AntiO2/article/details/128439155</p>
<p>[Task #3] - Buffer Pool Manager Instance
https://zhuanlan.zhihu.com/p/593982056 the same Page object may contain
a different physical page throughout the life of the system</p>
<p>B+树是一种M路搜索树（其中M表示节点的最大子节点数），具有以下特性： •
它是完全平衡的（即每个叶节点都在同一深度）。 •
除根节点外的每个内部节点至少半满（M/2-1 &lt;= 键数 &lt;= M-1）。 •
具有k个键的每个内部节点都有k+1个非空子节点。
B+树中的每个节点都包含一个键/值对数组。这些对中的键是从索引所基于的属性派生出来的。值将根据节点是内部节点还是叶节点而异。对于内部节点，值数组将包含指向其他节点的指针。叶节点值有两种方法：记录ID和元组数据。记录ID是指向元组位置的指针。具有元组数据的叶节点在每个节点中存储元组的实际内容。
虽然按照B+树的定义并不需要，但几乎每个节点上的数组都按键排序。
从概念上讲，内部节点上的键可以被认为是指南针。它们引导树遍历，但不代表叶子节点上的键（因此也不代表它们的值）。这意味着您可能在内部节点（作为指南针）中拥有一个在叶子节点上找不到的键。尽管必须注意到，传统上内部节点只拥有在叶子节点中存在的键。</p>
<p>B+Tree插入和删除操作如下：</p>
<p>B+Tree 插入新条目的步骤如下：</p>
<p>找到正确的叶子节点 L。 按排序顺序将新条目添加到 L 中： • 如果 L
有足够的空间，则操作完成。 • 否则将 L 拆分为两个节点 L 和
L2。平均重新分配条目并复制中间键。将指向 L2 的索引条目插入 L 的父项中。
要拆分内部节点，请平均重新分配条目，但将中间键向上推。 const KeyType
&amp;key 删除：
当插入操作使得树变得过满时，我们有时需要拆分叶子节点，但如果删除操作导致树的大小小于一半，则必须合并以重新平衡树。
找到正确的叶子节点L。 删除条目： • 如果L至少半满，则操作完成。 •
否则，您可以尝试重新分配，从兄弟节点借用。 •
如果重新分配失败，则合并L和兄弟节点。
如果发生合并，则必须删除指向L的父项中的条目。</p>
<ol type="1">
<li>从右边借</li>
<li>借不到的话从右边拿所有</li>
<li>没有右边的话 从左边借</li>
<li>左边借不到的话，被左边吃</li>
</ol>
<p>B+Tree叶子页存储有序的m个键值对，其中键和值的数量相同。在实现中，值应该只是用于定位实际元组的64位记录ID，参见src/include/common/rid.h中定义的RID类。叶子页与内部页具有相同的键/值对数限制，并且应遵循合并、重新分配和拆分的相同操作。</p>
<p>您必须在指定的文件中实现B+Tree内部页。您只允许修改头文件(src/include/storage/page/b_plus_tree_leaf_page.h)及其相应的源文件(src/storage/page/b_plus_tree_leaf_page.cpp)。</p>
<p>重要提示：即使叶子页和内部页包含相同类型的键，它们可能具有不同类型的值，因此叶子和内部页的max_size可能不同。</p>
<p>每个B+Tree叶子/内部页对应于由缓冲池获取的内存页(即数据部分)。因此，每次尝试读取或写入叶子/内部页时，您都需要使用其唯一的page_id从缓冲池中获取页面，然后重新解释为叶子或内部页，并在任何写入或读取操作后取消固定页面。</p>
<p>Task #2 - B+Tree Data Structure
B+树索引应仅支持唯一键。也就是说，当您尝试将具有重复键的键值对插入索引时，它不应执行插入并返回false。如果删除导致某个页面低于占用阈值，则您的B+树索引还必须正确执行合并或重新分配（在教科书中称为“合并”）。</p>
<p>在第一检查点中，您的B+树索引仅需要支持插入（Insert（）），点搜索（GetValue（））和删除（Delete（））。如果插入触发拆分条件（插入后键/值对数等于叶节点的max_size，插入前子节点的数量等于内部节点的max_size），则应正确执行拆分。由于任何写操作都可能导致B+树索引中的root_page_id更改，因此您有责任在头部页面（src/include/storage/page/header_page.h）中更新root_page_id。这是为了确保索引在磁盘上是持久的。在BPlusTree类中，我们已经为您实现了一个名为UpdateRootPageId的函数；只需在B+Tree索引的root_page_id更改时调用此函数即可。</p>
<p>在这部分中，您需要更新您原来的单线程 B+Tree
索引，使其能够支持并发操作。
我们将使用课堂和教科书中描述的闩锁抓取技术。
遍历索引的线程将获取然后释放 B+Tree 页面上的闩锁。
如果子页面被认为是“安全的”，则线程只能释放父页面上的闩锁。
请注意，“安全”的定义可能会根据线程正在执行的操作类型而有所不同：</p>
<p>搜索：从根页面开始，抓取子页面上的读取 (R)
闩锁，然后在您到达子页面后立即释放父页面上的闩锁。
插入：从根页开始，抓取子页上的写 (W) 闩锁。
一旦孩子被锁上，检查它是否安全，在这种情况下，不是满的。
如果孩子是安全的，解除对祖先的所有锁定。
删除：从根页开始，抓取子页上的写 (W) 闩锁。
一旦孩子被锁上，检查它是否安全，在这种情况下，至少要半满。
（注意：对于根页面，我们需要检查不同的标准）如果孩子是安全的，释放对祖先的所有锁。
重要提示：本文仅描述闩锁抓取背后的基本概念，在开始实施之前，请参阅讲座和教科书第
15.10 章。</p>
<p>这段文字是关于在数据库系统中实现索引的第二个编程项目的说明。该项目要求实现一个索引，以便快速检索数据，而无需在数据库表中搜索每一行，从而为随机查找和有序记录的高效访问提供基础。在实现B+树动态索引结构之前，您需要实现B+树父页面、B+树内部页面和B+树叶页面。由于树结构动态增长和收缩，因此您需要处理拆分和合并的逻辑。此项目由以下任务组成，并且有两个检查点。在开始此项目之前，请确保已从公共BusTub
repo拉取了最新代码。您可以使用以下命令执行此操作：<code>git pull public master</code>。</p>
<p>在实现过程中，有一些限制和建议。例如，不允许使用全局作用域闩来保护数据结构。换句话说，在操作完成后，您不能锁定整个索引并仅在操作完成时解锁闩。我们将语法和手动检查以确保您正在正确进行闩抓取。我们已经提供了读写闩的实现（src/include/common/rwlatch.h），并已在页面头文件下添加了帮助程序函数以获取和释放闩（src/include/storage/page/page.h）。我们不会在B+Tree索引中添加任何强制性接口。只要保持所有原始公共接口不变以进行测试目的，就可以在您的实现中添加任何函数。</p>
<p>此外，不要使用malloc/new来分配大块内存以用于树。如果需要为树创建新节点或需要缓冲区进行某些操作，则应使用缓冲池。
对于此任务，您必须使用名为transaction（src/include/concurrency/transaction.h）的传递指针参数。它提供了存储在遍历B+树时获取闩的页面以及存储在Remove操作期间删除的页面的方法。我们建议您仔细查看B+树中的FindLeafPage方法，您可能需要修改先前的实现（请注意，您可能需要更改此方法的返回值），然后在此特定方法中添加闩抓取逻辑。</p>
<p>请注意，在缓冲池管理器中FetchPage()的返回值是指向Page实例（src/include/storage/page/page.h）的指针。您可以在Page上抓取闩，但不能在B+Tree节点上抓取闩（内部节点或叶节点均不可）。</p>
<p>常见的陷阱 您未在该项目中测试线程安全扫描（不会测试并发迭代器操作）。
然而，正确的实现将要求叶页在无法获取其兄弟上的闩锁时抛出 std::exception
以避免潜在的死锁。 仔细考虑缓冲池管理器类的 UnpinPage(page_id, is_dirty)
方法和页面类的 UnLock() 方法之间的顺序和关系。
在从缓冲池中取消固定同一页之前，您必须释放该页上的闩锁。
如果你正确地实现并发 B+tree 索引，那么每个线程总是会从根到底部获取
latch。 释放闩锁时，请确保遵循相同的顺序（也就是从根部到底部）。
一种极端情况是插入和删除时，成员变量root_page_id
(src/include/storage/index/b_plus_tree.h)也会被更新。
你有责任防止这个共享变量的并发更新（提示：在 B+
树索引中添加一个抽象层，你可以使用 std::mutex 来保护这个变量）</p>
<p>竞争基准
为确保您正确实施锁抓取，我们将使用竞争基准从您的实施中收集一些启发式，并根据启发式手动检查您的代码。
Contention ratio是B+树在多线程环境下使用时与单线程环境相比的减速。
通常，Gradescope 上的竞争比应在 [2.5, 3.5] 范围内。 争用率 &lt; 2.5
通常意味着你的锁抓取是不正确的（例如，可能持有一些全局锁，持有一些锁不必要的长时间），TA
将手动审查你的代码并应用正确性扣除。 争用率 &gt; 3.5
意味着您的实施中的锁争用太高，建议您调查正在发生的事情。</p>
<ol type="1">
<li>检查所有的unpin与页删除</li>
<li>加锁，从根节点到某一确定的叶子节点； 根节点有单独的锁
如果发生合并，需要将另外一个叶子结点及其路径加锁</li>
</ol>
]]></content>
      <categories>
        <category>os</category>
      </categories>
  </entry>
  <entry>
    <title>git常用操作(长期收藏更新)</title>
    <url>/zyhjy/2022/06/10/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="背景">背景</h1>
<ul>
<li>虽然习惯了使用IDE里集成的图形化git操作，但是有时候还是难免需要在命令行中使用git。</li>
</ul>
<h1 id="场景">场景</h1>
<h2 id="本地新建git仓并同步到远程">1. 本地新建git仓并同步到远程</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir CSAPP</span><br><span class="line">git init</span><br><span class="line">git remote add origin git@gitee.com:zyh-eric/csapp.git</span><br><span class="line">git checkout -b archlab</span><br><span class="line">...add some file...</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;archlab init&quot;</span><br><span class="line">git push -u origin archlab</span><br></pre></td></tr></table></figure>
<p>修改最后一次注释 git commit --amend</p>
<h2 id="git设置本地信息">2. git设置本地信息</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name zyh@docker</span><br><span class="line">git config --global user.email yuhangzhang22@m.fudan.edu.cn</span><br><span class="line">git config --list </span><br></pre></td></tr></table></figure>
<h2 id="mac-无法ping通github但是可以从网页打开github">3. Mac
无法ping通github但是可以从网页打开github</h2>
<ol type="1">
<li>在<code>https://ipaddress.com/website/github.com</code>查找github.com</li>
<li><code>vim /etc/hosts</code>
<ul>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">140.82.113.3 github.com</span><br><span class="line">199.232.69.194 github.global.ssl.fastly.net</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>重启DNS(ubuntu18可跳过这步)
<ul>
<li><code>killall -HUP mDNSResponder</code></li>
</ul></li>
<li><code>git clone https://github.com/xxx.git</code>提示下载失败
<ul>
<li>可以尝试把<code>https://</code>换成
<code>git://</code>或者<code>http://</code></li>
</ul></li>
</ol>
<h2 id="git-checkout后之前本地commit的内容消失">4. git
checkout后之前本地commit的内容消失</h2>
<p>https://blog.csdn.net/yupyuping/article/details/118106810</p>
<h2 id="push">5. push</h2>
<ul>
<li>把当前仓库的一个分支push到另一个仓库的指定分支 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push [remote repo] [local branch]:[remote branch]</span><br><span class="line"># git push origin o3_0320:o3  /// eg </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="git-push-命令没有任何反应"><code>git push</code>
命令没有任何反应</h3>
<ul>
<li>本地分支与远程分支不匹配：确保您的本地分支和远程分支之间的名称和关联正确。在执行
<code>git push</code> 命令时，Git
会将本地分支推送到与其关联的远程分支。如果本地分支与远程分支之间的关联存在问题，<code>git push</code>
命令可能会失败或无响应。
<ul>
<li>您可以使用以下命令检查本地分支与远程分支的关联： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -vv</span><br></pre></td></tr></table></figure></li>
<li>如果关联不正确，可以使用以下命令进行关联设置（假设您的本地分支名为
<code>local_branch</code>，远程分支名为
<code>origin/remote_branch</code>）： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/remote_branch local_branch</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>C++若干语法</title>
    <url>/zyhjy/2022/06/21/cpp%E7%9A%84%E8%8B%A5%E5%B9%B2%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="左值和右值">0. 左值和右值</h1>
<ul>
<li>右值：只能在<code>=</code>右边使用的值(字面量、中间结果、临时对象/匿名对象)，无法直接取地址，不能使用左值引用。</li>
<li>左值：可以在<code>=</code>左边使用的值</li>
</ul>
<h1 id="取地址和引用">1. 取地址和引用</h1>
<ul>
<li>在<code>=</code>左边的是引用</li>
<li>在<code>=</code>右边的是取地址</li>
</ul>
<h1 id="左值引用右值引用和万能引用">2. 左值引用、右值引用和万能引用</h1>
<ol type="1">
<li><p>左值引用只能接收左值，右值引用只能接收右值，</p></li>
<li><p>const左值引用可以初始化左值和右值。</p></li>
<li><p>引用变量的值的类型是左值，而不是左值引用或右值引用
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">(T arg)</span></span>&#123;..&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> temp;</span><br><span class="line">   <span class="type">int</span>&amp;&amp; a1 = <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span>&amp; a2 = temp;    <span class="comment">// </span></span><br><span class="line">   <span class="built_in">fn</span>(a1);            <span class="comment">// a1为int, </span></span><br><span class="line">   <span class="built_in">fn</span>(a2);            <span class="comment">// a2为int,</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>右值引用有且只有一个特性：限制了接收的参数必为右值，可利用其提供重载；
这之后，变量的使用上就退换成左值，见3. <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int&amp; fn()&#123;...&#125; //返回类型为左值引用，但是返回值为左值</span><br><span class="line">int&amp;&amp; fn()&#123;...&#125; //返回类型为右值引用，但是返回值为右值</span><br></pre></td></tr></table></figure></p></li>
<li><p>右值引用的类型是左值 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference</span><span class="params">(std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;左值&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference</span><span class="params">(std::string&amp;&amp; str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;右值&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string lv1 = <span class="string">&quot;string,&quot;</span>; <span class="comment">// lv1 是一个左值</span></span><br><span class="line">    <span class="comment">// std::string&amp;&amp; r1 = lv1; // 非法, 右值引用不能引用左值</span></span><br><span class="line">    std::string&amp;&amp; rv1 = std::<span class="built_in">move</span>(lv1); <span class="comment">// 合法, std::move可以将左值转移为右值</span></span><br><span class="line">    std::cout &lt;&lt; rv1 &lt;&lt; std::endl; <span class="comment">// string,</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> std::string&amp; lv2 = lv1 + lv1; <span class="comment">// 合法, 常量左值引用能够延长临时变量的生命周期</span></span><br><span class="line">    <span class="comment">// lv2 += &quot;Test&quot;; // 非法, 常量引用无法被修改</span></span><br><span class="line">    std::cout &lt;&lt; lv2 &lt;&lt; std::endl; <span class="comment">// string,string,</span></span><br><span class="line"></span><br><span class="line">    std::string&amp;&amp; rv2 = lv1 + lv2; <span class="comment">// 合法, 右值引用延长临时对象生命周期</span></span><br><span class="line">    rv2 += <span class="string">&quot;Test&quot;</span>; <span class="comment">// 合法, 非常量引用能够修改临时变量</span></span><br><span class="line">    std::cout &lt;&lt; rv2 &lt;&lt; std::endl; <span class="comment">// string,string,string,Test</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">reference</span>(rv2); <span class="comment">// 输出左值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> rv2
虽然引用了一个右值，但由于它是一个引用，所以 rv2 依然是一个左值</p></li>
</ol>
<h2
id="万能引用univesal-raferenceforwarding-raference">万能引用(univesal
raference)(forwarding raference)</h2>
<h3 id="场景">场景</h3>
<ol type="1">
<li>函数模版形参 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>条件:
<ol type="1">
<li>涉及<strong>型别推导</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="type">void</span> <span class="built_in">push_back</span>(T&amp;&amp; x); <span class="comment">/// rvalue referance</span></span><br><span class="line">   <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">   <span class="type">void</span> <span class="title">emplace_back</span><span class="params">(Args&amp;&amp;... args)</span></span>; <span class="comment">/// univesal referance</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>形如<code>T&amp;&amp;</code> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp;&amp; param)</span></span>; <span class="comment">/// rvalue referance</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::vector&lt;T&gt;&amp;&amp; param)</span></span>; <span class="comment">/// rvalue referance</span></span><br></pre></td></tr></table></figure></li>
</ol></li>
</ul></li>
<li><code>auto&amp;&amp;</code>
<ul>
<li>当其从花括号包围的初始化器列表推导时除外 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp;&amp; isUniversal = <span class="number">10</span>; <span class="comment">/// rvalue referance</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; z = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">/// rvalue referance</span></span><br></pre></td></tr></table></figure> ### 规则</li>
</ul></li>
</ol>
<ul>
<li>初始化物是右值，万能引用-&gt;右值引用。</li>
<li>初始化物是左值，万能引用-&gt;左值引用。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">emplace_back</span><span class="params">(T&amp;&amp; arg)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class Base&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Base a;</span><br><span class="line">    <span class="built_in">emplace_back</span>(a);      <span class="comment">// ok, lvalue</span></span><br><span class="line">    <span class="built_in">emplace_back</span>(<span class="built_in">Base</span>()); <span class="comment">// also ok, rvalue</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="6" type="1">
<li><p><code>forward</code>的语义为：
数据是左值就转发成左值，右值就转发成右值，哪怕在万能引用中也是如此;
使用场景为: 配合万能引用实现完美转发。</p></li>
<li><p><code>forward</code>和<code>move</code>的原理是:
c++编译器规定了函数返回的左值引用是左值，返回的右值引用是右值，通过这个特性配合static_cast的转换，返回了左值/右值。</p></li>
<li><p>模板的万能引用是通过引用折叠实现，而且，左值传递到万能引用上，模板类型会先被推导成左值引用以支持引用折叠推导,
右值不做处理，引用折叠推导后刚好是右值引用。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void fn(T&amp;&amp; arg)&#123;..&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">   int a = 0;</span><br><span class="line">   fn(a);             // T为int&amp;, 见1.4</span><br><span class="line">   fn(std::move(a));  // T为int, 见1.3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T &amp; t)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lvalue ref&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T &amp;&amp; t)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Rvalue ref&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span></span>&#123; </span><br><span class="line">    <span class="built_in">print</span>(v);<span class="comment">//v此时已经是个左值了,永远调用左值版本的print</span></span><br><span class="line">    <span class="built_in">print</span>(std::forward&lt;T&gt;(v)); <span class="comment">//本文的重点</span></span><br><span class="line">    <span class="built_in">print</span>(std::<span class="built_in">move</span>(v)); <span class="comment">//永远调用右值版本的print</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;======================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">testForward</span>(x); <span class="comment">//实参为左值</span></span><br><span class="line">    <span class="built_in">testForward</span>(std::<span class="built_in">move</span>(x)); <span class="comment">//实参为右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>在testForward中，虽然参数v是右值类型的，但此时v在内存中已经有了位置，所以v其实是个左值！（请仔细阅读这段话，保证你理解了）</li>
<li>本质问题在于，左值右值在函数调用时，都转化成了左值，使得函数转调用时无法判断左值和右值。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> _Tp&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> _Tp&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(!std::is_lvalue_reference&lt;_Tp&gt;::value, <span class="string">&quot;template argument&quot;</span></span><br><span class="line">        <span class="string">&quot; substituting _Tp is an lvalue reference type&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="转发左值为左值或右值依赖于-t">1 转发左值为左值或右值，依赖于
T</h3>
<h3 id="转发右值为右值并禁止右值的转发为左值">2
转发右值为右值并禁止右值的转发为左值</h3>
<h1 id="cout指定小数点输出位数">3. cout指定小数点输出位数</h1>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">cout &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">6</span>); <span class="comment">// 指定输出格式是6位小数</span></span><br><span class="line">cout &lt;&lt; std::defaultfloat;</span><br></pre></td></tr></table></figure></p>
<h1 id="寻找容器内最大元素">4. 寻找容器内最大元素</h1>
<ul>
<li>返回迭代器
<ul>
<li><code>std::max_element</code></li>
</ul></li>
</ul>
<h1 id="stdpriority_queue">5. <code>std::priority_queue</code></h1>
<ul>
<li><code>.top</code>的元素和<code>compare &gt; or &lt;</code>相反</li>
</ul>
<h1 id="asserte">6. assert(E)</h1>
<ul>
<li>访函数宏</li>
<li>若<code>E</code>不为<code>true</code>，则终止程序</li>
</ul>
<h1 id="stdadvance">7. std::advance</h1>
<ul>
<li><iterator> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt; class InputIt, class Distance &gt;</span><br><span class="line">void advance( InputIt&amp; it, Distance n );</span><br></pre></td></tr></table></figure></li>
<li>给it增加n个步长</li>
</ul>
<h1 id="stdstring">8. std::string</h1>
<ul>
<li><string></li>
<li><code>.find(string s)</code>
<ul>
<li>KMP</li>
<li>寻找子串</li>
<li>失败返回<code>nops</code></li>
</ul></li>
<li>void erase(int start=0,int count=-1):
从start开始，从字符串中删除count个字符。若是现有的字符串少于count个
字符，或者count为-1，则删除到字符串尾部的全部字符。默认状况下,start为0，函数
从字符串是起始位置开始删除字符串。默认状况下，函数也删除到字符串尾。
须要注意的是，不使用参数调用erase()函数时，将把字符串截断为长度为0的空字符串</li>
</ul>
<h1 id="lambda表达式">9. lambda表达式</h1>
<h2 id="说明符非必要">说明符（非必要）</h2>
<ul>
<li>不提供说明符
<ul>
<li>默认复制捕获的对象是const</li>
</ul></li>
<li>mutable
<ul>
<li>允许 函数体 修改复制捕获的对象，以及调用它们的非 const 成员函数</li>
</ul></li>
<li>constexpr (C++17 起)
<ul>
<li>显式指定函数调用运算符或运算符模板的任意特化为 constexpr
函数。如果没有此说明符但函数调用运算符或任意给定的运算符模板特化恰好满足针对
constexpr 函数的所有要求，那么它也会是 constexpr 的</li>
</ul></li>
<li>consteval (C++20 起)
<ul>
<li>指定函数调用运算符或任意给定的运算符模板特化为立即函数。不能同时使用
consteval 和 constexpr。</li>
</ul></li>
<li>static (C++23 起)
-指定函数调用运算符或任意给定的运算符模板特化为静态成员函数。不能同时使用
mutable 和 static，并且使用 static 时 捕获 必须为空。 ### example
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// use constexpr lambda to initialize array while compiling time</span></span><br><span class="line"><span class="comment">/// it can be use like myArray()[1][2]</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> myArray&#123;</span><br><span class="line">    []() &#123;</span><br><span class="line">        <span class="keyword">constexpr</span> <span class="type">size_t</span> size = <span class="number">36</span>;</span><br><span class="line">        array&lt;array&lt;<span class="type">int</span>, 2&gt;, size&gt; result&#123;&#125;;</span><br><span class="line">        result[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        result[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            result[i + <span class="number">1</span>][<span class="number">0</span>] = result[i][<span class="number">1</span>];</span><br><span class="line">            result[i + <span class="number">1</span>][<span class="number">1</span>] = result[i][<span class="number">0</span>] + result[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>值捕获、引用捕获都是已经在外层作用域声明的变量，因此这些捕获方式捕获的均为<strong>左值</strong></li>
<li>C++14允许捕获的成员用任意的表达式进行初始化，这就允许了<strong>右值的捕获</strong>，
<ul>
<li>被声明的捕获变量类型会根据表达式进行判断，判断方式与使用 auto
本质上是相同的 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> important = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> add = [v1 = <span class="number">1</span>, v2 = std::<span class="built_in">move</span>(important)](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x+y+v1+(*v2);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>Lambda
表达式的本质</strong>是一个和函数对象类型相似的类类型（称为闭包类型）的对象（称为闭包对象）
<ul>
<li>当 Lambda
表达式的捕获列表为空时，闭包对象还能够转换为函数指针值进行传递，例如：</li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> foo = <span class="built_in">void</span>(<span class="type">int</span>); <span class="comment">// 定义函数类型, using 的使用见上一节中的别名语法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">functional</span><span class="params">(foo f)</span> </span>&#123; <span class="comment">// 参数列表中定义的函数类型 foo 被视为退化后的函数指针类型 foo*</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>); <span class="comment">// 通过函数指针调用函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">auto</span> f = [](<span class="type">int</span> value) &#123;</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">functional</span>(f); <span class="comment">// 传递闭包对象，隐式转换为 foo* 类型的函数指针值</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>); <span class="comment">// lambda 表达式调用</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h1 id="对容器进行求和-accumulate">10. 对容器进行求和 / accumulate</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums&#123;...&#125;;</span><br><span class="line"><span class="type">int</span> sum1 = std::<span class="built_in">reduce</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>); <span class="comment">// cpp17</span></span><br><span class="line"><span class="type">int</span> sum2 = std::<span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; rect&#123;...&#125;;</span><br><span class="line"><span class="type">bool</span> sum3 = std::<span class="built_in">accumulate</span>(rect.<span class="built_in">begin</span>(), rect.<span class="built_in">end</span>(), <span class="literal">false</span>, <span class="built_in">bit_or</span>());</span><br></pre></td></tr></table></figure>
<ul>
<li>accumulate保证顺序遍历容器</li>
<li>reduce不保证顺序遍历容器，编译器会根据指令集进行优化(如SIMD指令),性能更好</li>
<li>accumulate也可对容器元素进行位运算</li>
</ul>
<h1 id="模板的特化">11. 模板的特化</h1>
<ul>
<li>模板参数分为：类型形参与非类型形参.
<ul>
<li>类型形参：模板参数列表中跟在<code>class</code>或者<code>typename</code>之类的参数类型名称.</li>
<li>非类型形参:
就是用一个<code>常量</code>作为类(函数)模板的一个参数，在类(函数)模板中可将该参数当成常量来使用.</li>
<li>注意：
<ul>
<li>浮点数、类对象以及字符串是不允许作为非类型模板参数的。</li>
<li>非类型的模板参数必须在编译期就能确认结果。 ## 问题引出</li>
</ul></li>
</ul></li>
<li>有时需要对模板进行特化。即在原模板类的基础上，针对特殊类型所进行特殊化的实现方式。</li>
<li>模板特化中分为函数模板特化与类模板特化</li>
<li>比如：</li>
<li>下面这个例子当IsEqual（）参数为整形或者浮点时都能判断两变量是否相等。</li>
<li>但是当两参数为字符串时，比较量字符串是否相同需常用strcmp(left,
right)来判断，而不是用 == 来判断地址是否相同。</li>
<li>这就需要针对此模板做出一个针对字符串参数特殊化处理的模板。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEqual</span><span class="params">(T&amp; left, T&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> left == right;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span>* p1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	<span class="type">char</span>* p2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">IsEqual</span>(p1, p2))</span><br><span class="line">		cout&lt;&lt;“==”&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout&lt;&lt;“!=”&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 函数模板特化</li>
<li>函数模板的特化规则：
<ol type="1">
<li>必须要先有一个基础的函数模板。</li>
<li>关键字template后面接一对空的尖括号&lt;&gt;</li>
<li>函数名后跟一对尖括号，尖括号中指定需要特化的类型</li>
<li>函数形参表:
必须要和模板函数的基础参数类型完全相同，如果不同编译器可能会报一些奇怪的错误</li>
</ol></li>
<li>函数模板不可偏特化</li>
<li>以下是针对上面问题中字符串指针的特殊化处理示例： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">bool</span> <span class="built_in">IsEqual</span>&lt;<span class="type">char</span>*&gt;(<span class="type">char</span>*&amp; left, <span class="type">char</span>*&amp; right)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(left, right) &gt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ##
类模板特化 ### 全特化</li>
<li>全特化即是将模板参数列表中所有的参数都确定化。</li>
<li>与函数模板的特化规则相似
<ol type="1">
<li>必须要先有一个基础的函数模板。</li>
<li>关键字template后面接一对空的尖括号&lt;&gt;</li>
<li>函数名后跟一对尖括号，尖括号中指定需要特化的类型</li>
<li>函数形参表:
必须要和模板函数的基础参数类型完全相同，如果不同编译器可能会报一些奇怪的错误
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Data</span>() &#123;cout&lt;&lt;<span class="string">&quot;Data&lt;T1, T2&gt;&quot;</span> &lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T1 _d1;</span><br><span class="line">	T2 _d2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全特化&lt;int,char&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>&lt;<span class="type">int</span>, <span class="type">char</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Data</span>() &#123;cout&lt;&lt;<span class="string">&quot;Data&lt;int, char&gt;&quot;</span> &lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T1 _d1;</span><br><span class="line">	T2 _d2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ### 偏特化</li>
</ol></li>
<li>偏特化也就是只特化了一部分参数。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Data</span>() &#123;cout&lt;&lt;<span class="string">&quot;Data&lt;T1, T2&gt;&quot;</span> &lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T1 _d1;</span><br><span class="line">	T2 _d2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将第二个参数特化为int</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>&lt;T1, <span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Data</span>() &#123;cout&lt;&lt;<span class="string">&quot;Data&lt;T1, int&gt;&quot;</span> &lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T1 _d1;</span><br><span class="line">	<span class="type">int</span> _d2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个参数偏特化为指针类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &lt;T1*, T2*&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Data</span>() &#123;cout&lt;&lt;<span class="string">&quot;Data&lt;T1*, T2*&gt;&quot;</span> &lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T1 _d1;</span><br><span class="line">	T2 _d2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个参数偏特化为引用类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &lt;T1&amp;, T2&amp;&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Data</span>(<span class="type">const</span> T1&amp; d1, <span class="type">const</span> T2&amp; d2): _d1(d1), _d2(d2)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;Data&lt;T1&amp;, T2&amp;&gt;&quot;</span> &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">const</span> T1 &amp; _d1;</span><br><span class="line">	<span class="type">const</span> T2 &amp; _d2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Data&lt;<span class="type">double</span> , <span class="type">int</span>&gt; d1; <span class="comment">// 调用特化的int版本</span></span><br><span class="line">	Data&lt;<span class="type">int</span> , <span class="type">double</span>&gt; d2; <span class="comment">// 调用基础的模板</span></span><br><span class="line">	Data&lt;<span class="type">int</span> *, <span class="type">int</span>*&gt; d3; <span class="comment">// 调用特化的指针版本</span></span><br><span class="line">	<span class="function">Data&lt;<span class="type">int</span>&amp;, <span class="type">int</span>&amp;&gt; <span class="title">d4</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>; <span class="comment">// 调用特化的指针版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 类型萃取</li>
<li>类型萃取是类模板特化的一种应用。</li>
<li>作用：通过类型萃取,萃取到变量类型,对不同变量进行不同处理,可以提升程序效率.</li>
<li>可以通过下面例子理解。
<ul>
<li>其中GetSum()函数是一个统一的接口，传入对象和一个数值
用来获取不同类型值（int/float）通过计算得到的值。</li>
<li>要求输入对象为IntArray则GetSum()的另一个参数和计算结果都为int类型，输入对象为FloatArray则GetSum()的另一个参数和计算结果都为float类型.</li>
<li>无论用int或float作为GetSum()函数的返回类型，都只能返回其中一种类型。这就需要用到萃取技术来萃取返回值的类型。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IntArray</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">IntArray</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">10</span>; ++i)</span><br><span class="line">			ar[i<span class="number">-1</span>] = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetSum</span><span class="params">(<span class="type">int</span> time)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">			sum += ar[i];</span><br><span class="line">		<span class="keyword">return</span> sum *time;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> ar[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FloatArray</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">FloatArray</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">			ar[i] = i + <span class="number">1.11</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">GetSum</span><span class="params">(<span class="type">float</span> time)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">float</span> sum = <span class="number">0.0f</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">			sum += ar[i];</span><br><span class="line">		<span class="keyword">return</span> sum *time;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">float</span> ar[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///萃取/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumTraits</span>    <span class="comment">//基础类--空类</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumTraits</span>&lt;IntArray&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">int</span> return_type;  <span class="comment">//萃取返回值类型  ---》 int</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">int</span> arg_type;     <span class="comment">//萃取参数类型    ---》 int</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumTraits</span>&lt;FloatArray&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">float</span> return_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">float</span> arg_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CApply</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//通过萃取技术，这里根据传入的参数类型不同，返回值类型也不同。</span></span><br><span class="line">	<span class="keyword">typename</span> NumTraits&lt;Type&gt;::<span class="function">return_type <span class="title">GetSum</span><span class="params">(Type &amp;obj,<span class="keyword">typename</span> NumTraits&lt;Type&gt;::arg_type time)</span></span></span><br><span class="line"><span class="function">	</span>&#123;   <span class="comment">//typename NumTraits&lt;Type&gt;::return_type   告诉编译器typename后面的这堆东西为一个类型 </span></span><br><span class="line">		<span class="comment">//这里可将NumTraits&lt;Type&gt;::return_type看作int或者float</span></span><br><span class="line">		<span class="keyword">return</span> obj.<span class="built_in">GetSum</span>(time);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IntArray intA;</span><br><span class="line">	FloatArray floatA;  </span><br><span class="line"></span><br><span class="line">	CApply&lt;IntArray&gt; obj;</span><br><span class="line">	cout&lt;&lt;obj.<span class="built_in">GetSum</span>(intA,<span class="number">3</span>)&lt;&lt;endl;  <span class="comment">//165</span></span><br><span class="line"></span><br><span class="line">	CApply&lt;FloatArray&gt; obj1;</span><br><span class="line">	cout&lt;&lt;obj1.<span class="built_in">GetSum</span>(floatA,<span class="number">2.3</span>)&lt;&lt;endl;  <span class="comment">//129.03</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h1 id="遍历双元素容器">12. 遍历双元素容器</h1>
<h1 id="运算符优先级">13. 运算符优先级</h1>
<ul>
<li>解引用* &lt; 指针调用-&gt;</li>
</ul>
<h1
id="unique_ptr-与-unique_ptr-之间无法直接转换必须把原指针取出来再进行转换">14.
unique_ptr<A> 与 unique_ptr<B>
之间无法直接转换，必须把原指针取出来再进行转换</h1>
<ul>
<li>即使B:A也不行 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;test&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;test2&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">auto</span> o = std::unique_ptr&lt;A&gt; <span class="built_in">b</span>(<span class="keyword">new</span> B);  <span class="comment">// 如何转换为 std::unique_ptr&lt;B&gt; ?</span></span><br><span class="line">   B* ptr = <span class="built_in">dynamic_cast</span>&lt;B*&gt;(o.<span class="built_in">get</span>());</span><br><span class="line">   std::unique_ptr&lt;B&gt; anotherptr;</span><br><span class="line">   <span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">       o.<span class="built_in">release</span>();</span><br><span class="line">       anotherptr.<span class="built_in">reset</span>(ptr);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="dynamic_cast并不是std库中的部件而是c关键字所以应该去掉std">15.
dynamic_cast并不是std库中的部件，而是C++关键字，所以应该去掉std</h1>
<ul>
<li>用于动态转换shared_ptr的std::dynamic_pointer_cast是std中的部件。其实也是显然的，因为shared_ptr是std中的部件</li>
</ul>
<h1 id="raii-resource-acquisition-is-initialization">16. RAII (Resource
Acquisition Is Initialization)</h1>
<ul>
<li>程序退出初始化时所在的空间时，自动释放资源(析构)</li>
<li>std内的锁是典型的这类设计</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// write lock</span></span><br><span class="line"><span class="function">std::unique_lock&lt;std::shared_mutex&gt; <span class="title">the_lock</span><span class="params">(latch_.GetMutex())</span></span>;</span><br><span class="line"><span class="comment">/// read lock</span></span><br><span class="line"><span class="function">std::shared_lock&lt;std::shared_mutex&gt; <span class="title">the_lock</span><span class="params">(latch_.GetMutex())</span></span>;</span><br><span class="line"><span class="comment">/// 获取多个锁</span></span><br><span class="line"><span class="function">std::scoped_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line">        <span class="comment">// 用 std::scoped_lock 取得二个锁，而无需担心</span></span><br><span class="line">        <span class="comment">// 其他对 assign_lunch_partner 的调用死锁我们</span></span><br><span class="line">        <span class="comment">// 而且它亦提供便利的 RAII 风格机制</span></span><br><span class="line">        <span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(e1.m, e2.m)</span></span>;</span><br><span class="line"><span class="comment">/// 可重入锁</span></span><br><span class="line">std::recursive_mutex m;</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function">std::lock_guard&lt;std::recursive_mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="stdhash">17 std::hash</h1>
<ul>
<li><code>&lt;functional&gt;</code> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">Key</span>&gt; <span class="keyword">struct</span> <span class="title class_">hash</span>;</span><br></pre></td></tr></table></figure></li>
<li><code>operator()</code>
<ol type="1">
<li>接收 Key 类型的单个参数</li>
<li>返回表示参数散列值的 std::size_t 类型。</li>
</ol></li>
<li>支持大部分built-in key</li>
<li>自定义Key需要特化散列函数 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    std::string first_name;</span><br><span class="line">    std::string last_name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> S&amp; lhs, <span class="type">const</span> S&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.first_name == rhs.first_name &amp;&amp; lhs.last_name == rhs.last_name;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 自定义散列函数能是独立函数对象：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyHash</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(S <span class="type">const</span>&amp; s)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::<span class="type">size_t</span> h1 = std::hash&lt;std::string&gt;&#123;&#125;(s.first_name);</span><br><span class="line">        std::<span class="type">size_t</span> h2 = std::hash&lt;std::string&gt;&#123;&#125;(s.last_name);</span><br><span class="line">        <span class="keyword">return</span> h1 ^ (h2 &lt;&lt; <span class="number">1</span>); <span class="comment">// 或使用 boost::hash_combine （见讨论）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// std::hash 的自定义特化能注入 namespace std</span></span><br><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;S&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">typedef</span> S argument_type;</span><br><span class="line">        <span class="keyword">typedef</span> std::<span class="type">size_t</span> result_type;</span><br><span class="line">        <span class="function">result_type <span class="title">operator</span><span class="params">()</span><span class="params">(argument_type <span class="type">const</span>&amp; s)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">result_type <span class="type">const</span> <span class="title">h1</span> <span class="params">( std::hash&lt;std::string&gt;&#123;&#125;(s.first_name) )</span></span>;</span><br><span class="line">            <span class="function">result_type <span class="type">const</span> <span class="title">h2</span> <span class="params">( std::hash&lt;std::string&gt;&#123;&#125;(s.last_name) )</span></span>;</span><br><span class="line">            <span class="keyword">return</span> h1 ^ (h2 &lt;&lt; <span class="number">1</span>); <span class="comment">// 或使用 boost::hash_combine （见讨论）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 自定义散列函数 令 在无序容器中使用自定义类型 可行</span></span><br><span class="line">    <span class="comment">// 此示例将使用注入的 std::hash 特化，</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="stdlist">18 std::list</h1>
<h2 id="基本信息">基本信息</h2>
<ul>
<li><code>&lt;list&gt;</code></li>
<li>定义： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">T</span>,</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Allocator</span> = std::allocator&lt;T&gt;</span><br><span class="line">&gt; <span class="keyword">class</span> list;</span><br></pre></td></tr></table></figure></li>
<li>T 必须满足可复制构造 (CopyConstructible) 的要求 ## 特点</li>
<li>支持常数时间从容器任何位置插入和移除元素</li>
<li>不支持快速随机访问</li>
<li>通常实现为双向链表 ## 成员函数</li>
<li>insert <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">( const_iterator pos, <span class="type">const</span> T&amp; value )</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">( const_iterator pos, T&amp;&amp; value )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 pos 前插入 value。</li>
</ul></li>
</ul>
<h1 id="stdunderlying_type">19. std::underlying_type</h1>
<ul>
<li>在 <type_traits> 定义 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">T</span> &gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">underlying_type</span>;</span><br></pre></td></tr></table></figure></li>
<li>若 T 是完整枚举类型，则提供指名 T 底层类型的成员 typedef type</li>
</ul>
<h1 id="禁用class的copy和move-宏">20. 禁用class的copy和move-宏</h1>
<ul>
<li>阻止编译器自动生成构造和赋值函数 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Macros to disable copying and moving</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISALLOW_COPY(cname)                                    \</span></span><br><span class="line"><span class="meta">  cname(const cname &amp;) = delete;                   <span class="comment">/* NOLINT */</span> \</span></span><br><span class="line"><span class="meta">  auto operator=(const cname &amp;)-&gt;cname &amp; = delete; <span class="comment">/* NOLINT */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISALLOW_MOVE(cname)                               \</span></span><br><span class="line"><span class="meta">  cname(cname &amp;&amp;) = delete;                   <span class="comment">/* NOLINT */</span> \</span></span><br><span class="line"><span class="meta">  auto operator=(cname &amp;&amp;)-&gt;cname &amp; = delete; <span class="comment">/* NOLINT */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISALLOW_COPY_AND_MOVE(cname) \</span></span><br><span class="line"><span class="meta">  DISALLOW_COPY(cname);               \</span></span><br><span class="line"><span class="meta">  DISALLOW_MOVE(cname);</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="抛出异常并打印错误日志-宏">21. 抛出异常并打印错误日志-宏</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UNIMPLEMENTED(message) throw std::logic_error(message)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNREACHABLE(message) throw std::logic_error(message)</span></span><br></pre></td></tr></table></figure>
<h1 id="timestamp">22. timestamp</h1>
<p>获取以毫秒为单位的时间戳 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    std::chrono::milliseconds ms = std::chrono::<span class="built_in">duration_cast</span>&lt; std::chrono::milliseconds &gt;(</span><br><span class="line">        std::chrono::system_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; ms.<span class="built_in">count</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="constexpr">23. constexpr</h1>
<ul>
<li>constexpr 修饰的函数可以使用递归</li>
<li>从 C++14 开始，constexpr
函数可以在内部使用局部变量、循环和分支等简单语句</li>
</ul>
<h1 id="if">24. if</h1>
<ul>
<li>C++17 消除了这一限制，使得我们可以在 if（或 switch）中完成这一操作：
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将临时变量放到 if 语句内</span></span><br><span class="line"><span class="keyword">if</span> (<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;::iterator itr = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    itr != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    *itr = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="stdbind-和-stdplaceholder">25. std::bind 和
std::placeholder</h1>
<ul>
<li>std::bind 则是用来绑定函数调用的参数的，
<ul>
<li>它解决的需求是我们有时候可能并不一定能够一次性获得调用某个函数的全部参数，通过这个函数，
我们可以将部分调用参数提前绑定到函数身上成为一个新的对象，然后在参数齐全后，完成调用。
eg1： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将参数1,2绑定到函数 foo 上，</span></span><br><span class="line">    <span class="comment">// 但使用 std::placeholders::_1 来对第一个参数进行占位</span></span><br><span class="line">    <span class="keyword">auto</span> bindFoo = std::<span class="built_in">bind</span>(foo, std::placeholders::_1, <span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 这时调用 bindFoo 时，只需要提供第一个参数即可</span></span><br><span class="line">    <span class="built_in">bindFoo</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> eg2: 结合std::forward</li>
</ul></li>
</ul>
<p>std::bind也可以直接指定全部参数，在调用时不再指定</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">submit</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;...args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt; ①</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Create a function with bounded parameter ready to execute</span></span><br><span class="line">    std::function&lt;<span class="keyword">decltype</span>(f(args...))()&gt; func = std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...); <span class="comment">// 连接函数和参数定义，特殊函数类型，避免左右值错误</span></span><br><span class="line">​    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="decltype">26. decltype</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="title">char</span> <span class="params">(&amp;left)</span>[6] </span>= <span class="string">&quot;01234&quot;</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 断言正确，确实是 const char [6] 类型，注意 decltype(expr) 在 expr 是左值</span></span><br><span class="line"> <span class="comment">// 且非无括号包裹的 id 表达式与类成员表达式时，会返回左值引用</span></span><br><span class="line"> <span class="built_in">static_assert</span>(std::is_same&lt;<span class="keyword">decltype</span>(<span class="string">&quot;01234&quot;</span>), <span class="type">const</span> <span class="built_in">char</span>(&amp;)[<span class="number">6</span>]&gt;::value, <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>
<h1 id="unique-移除容器中相邻的重复元素">27. unique
移除容器中相邻的重复元素</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">   <span class="built_in">sort</span>(arr2.<span class="built_in">begin</span>(), arr2.<span class="built_in">end</span>());</span><br><span class="line">arr2.<span class="built_in">erase</span>(<span class="built_in">unique</span>(arr2.<span class="built_in">begin</span>(), arr2.<span class="built_in">end</span>()), arr2.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<ul>
<li>erase消除unique后多余的空间</li>
</ul>
<h2 id="私有成员类">28. 私有成员类</h2>
<p>私有成员类被定义为外部类的嵌套类，因此它们具有对外部类的所有成员的访问权限，包括私有成员。</p>
<p>这意味着，从私有成员类的成员函数或成员变量中，可以直接访问外部类的私有成员。这种访问权限的机制使得私有成员类可以方便地访问和操作外部类的私有数据和功能。</p>
<p>以下是一个示例，展示了私有成员类如何访问外部类的私有成员：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">PrivateNestedClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">nestedMethod</span><span class="params">(OuterClass&amp; outer)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 可以访问外部类的私有成员</span></span><br><span class="line">            outer.privateData = <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">outerMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PrivateNestedClass nestedObj;</span><br><span class="line">        <span class="comment">// 可以访问私有成员类的公有成员</span></span><br><span class="line">        nestedObj.<span class="built_in">nestedMethod</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，<code>PrivateNestedClass</code> 是
<code>OuterClass</code> 的私有成员类。在 <code>nestedMethod()</code>
中，我们可以看到它访问了 <code>OuterClass</code> 的私有成员
<code>privateData</code>，并对其进行了赋值操作。</p>
<p>这种访问权限的设计使得私有成员类可以在内部实现外部类的辅助功能、封装和隐藏内部细节等。它们能够直接访问外部类的私有成员，但其他类或函数无法直接访问私有成员类或外部类的私有成员。</p>
<h1 id="crtp">29. CRTP</h1>
<h1 id="ebco">30 EBCO</h1>
<h1 id="最大公约数-与-最小公倍数">31. 最大公约数 与 最小公倍数</h1>
<p>在C++标准库中，可以使用<code>std::gcd</code>函数来计算最大公约数。这个函数在头文件<code>&lt;numeric&gt;</code>中定义。</p>
<p>C++标准库中并没有直接提供获取最小公倍数（LCM）的函数。然而，我们可以使用最大公约数（GCD）来计算最小公倍数。根据数学关系，<em>两个数的最小公倍数等于它们的乘积除以最大公约数</em>。</p>
<p>以下是使用<code>std::gcd</code>函数计算最大公约数和最小公倍数的示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> gcd = std::<span class="built_in">gcd</span>(a, b);</span><br><span class="line">    <span class="keyword">return</span> (a * b) / gcd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num1, num2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter two numbers: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; num1 &gt;&gt; num2;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = std::<span class="built_in">gcd</span>(num1, num2);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;GCD: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result2 = <span class="built_in">lcm</span>(num1, num2);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;LCM: &quot;</span> &lt;&lt; result2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，<code>std::gcd</code>函数在C++17标准中引入，因此需要使用支持C++17的编译器进行编译。</p>
<h1 id="stdarray">32 std::array</h1>
<p><code>std::array</code> 是 C++
标准库中的一个容器类，用于表示固定大小的数组。<code>std::array</code>
的大小是在编译时确定的，不允许动态调整大小。 ## 初始化
<code>std::array</code>
可以使用不同的方式进行初始化。下面是几种常见的初始化方法：</p>
<ol type="1">
<li><p>列表初始化： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::array&lt;<span class="type">int</span>, 3&gt; myArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure></p></li>
<li><p>使用 <code>std::array</code> 的 <code>fill</code>
函数进行初始化： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::array&lt;<span class="type">int</span>, 5&gt; myArray;</span><br><span class="line">myArray.<span class="built_in">fill</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure> 我们使用 <code>fill</code>
函数将数组的所有元素初始化为指定的值，这里是 0。</p></li>
<li><p>使用迭代器进行初始化： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">std::array&lt;<span class="type">int</span>, 5&gt; <span class="title">myArray</span><span class="params">(myVector.begin(), myVector.end())</span></span>;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>在这个示例中，我们首先创建了一个 <code>std::vector</code> 对象
<code>myVector</code>，并初始化了它的元素。然后，我们使用
<code>myVector</code> 的迭代器范围来初始化一个具有相同元素的
<code>std::array</code> 对象 <code>myArray</code>。</p>
<h1 id="upper_bound">33. upper_bound</h1>
<p>在C++中，<code>upper_bound</code>是一个算法函数，用于在已排序的容器中查找大于给定值的第一个元素的位置。</p>
<p>该函数的语法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">upper_bound</span><span class="params">(ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，<code>value</code>是要查找的值。这个函数返回一个迭代器，指向容器中第一个大于<code>value</code>的元素。</p>
<p>请注意，为了正确使用<code>upper_bound</code>函数，容器必须是已排序的。如果容器没有排序，你可以在调用<code>upper_bound</code>函数之前使用<code>std::sort</code>函数对容器进行排序。</p>
<p>下面是带有自定义比较函数的<code>upper_bound</code>函数的语法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T, <span class="keyword">class</span> Compare&gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">upper_bound</span><span class="params">(ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，<code>value</code>是要查找的值，<code>comp</code>是一个比较函数对象或函数指针，用于定义元素的比较规则。比较函数的返回值类型是<code>bool</code>，指示两个元素之间的相对顺序。</p>
<h1 id="tail">tail</h1>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++的定义和声明</title>
    <url>/zyhjy/2022/06/27/cpp%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%A3%B0%E6%98%8E/</url>
    <content><![CDATA[<h1 id="cpp-reference">cpp reference</h1>
<ul>
<li>定义是完全定义了声明中所引入的实体的声明。</li>
<li><a href="https://zh.cppreference.com/w/cpp/language/definition">cpp
reference</a>举例了所有声明，除此以外情况外的声明都是定义</li>
</ul>
<h1 id="c-primer">C++ primer</h1>
<ul>
<li>声明（declaration）:使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。</li>
<li>定义（definition）:负责创建与名字关联的实体。</li>
<li>别名声明(alias declaration): <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> SI = Sales_item;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="effective-c">Effective C++</h1>
<ul>
<li><em>声明式</em>(<code>declaration</code>):
<ul>
<li>告诉编译器一些声明式遗漏的细节</li>
<li>对象 : 拨发内存的地点</li>
<li>function/function template : 代码本体</li>
<li>class/class template : 列出成员</li>
</ul></li>
<li><em>定义式</em>(<code>definition</code>):
<ul>
<li>告诉编译器某个东西的名称和<em>类型</em>(<code>type</code>)</li>
<li>略去细节</li>
<li>函数的<em>声明式</em>揭示其<em>签名式</em>(<code>signature</code>)--(参数和返回类型)</li>
</ul></li>
</ul>
<h1 id="变量的声明和定义">变量的声明和定义</h1>
<ul>
<li><p>变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还<strong>申请存储空间</strong>，也可能会为变量<strong>赋一个初值</strong>。</p></li>
<li><p>如果想声明一个变量而非定义它，就在变量名前添加关键字<code>extern</code>，而且不要显式地初始化变量:
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i;  <span class="comment">/// declaration</span></span><br><span class="line"><span class="type">int</span> j;       <span class="comment">/// declaration and definition</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>任何包含了<strong>显式初始化</strong>的声明即成为定义。我们能给由<code>extern</code>关键字标记的变量赋一个初始值，但是这么做也就抵消了extern的作用。extern语句如果包含初始值就不再是声明，而变成定义了:
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">double</span> pi=<span class="number">3.1416</span>; <span class="comment">/// definition</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。</p></li>
<li><p>Note：变量能且只能被定义一次，但是可以被多次声明。</p></li>
<li><p>声明和定义的区别看起来微不足道，但实际上非常重要。如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。</p></li>
</ul>
<h1 id="函数的声明和定义">函数的声明和定义</h1>
<ul>
<li>函数声明:
<ul>
<li>无需函数体{}, 也称作函数原型(返回类型, 函数名, 形参类型)。</li>
</ul></li>
<li>函数定义:
<ul>
<li>完整的函数</li>
</ul></li>
<li>类的声明和定义与函数类似</li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>C++型别推导</title>
    <url>/zyhjy/2022/06/29/cpp%E5%9E%8B%E5%88%AB%E6%8E%A8%E5%AF%BC/</url>
    <content><![CDATA[<ul>
<li><code>auto</code></li>
<li><code>decltype</code></li>
</ul>
<h1 id="模版型别推导">模版型别推导</h1>
<h2 id="一般形式">一般形式:</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(expr);   <span class="comment">// 从expr推导T和ParamType的型别</span></span><br></pre></td></tr></table></figure>
<h2
id="情况一paramtype是指针或引用-但不是万能引用">情况一:<code>ParamType</code>是指针或引用,
但不是万能引用:</h2>
<ol type="1">
<li>若<code>expr</code>具有引用型别, 先将引用部分忽略</li>
<li><code>ParamType</code>和<code>expr</code>模式匹配 ==&gt;&gt;
<code>T</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x); <span class="comment">// T -&gt; int, ParamType -&gt; int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx); <span class="comment">// T -&gt; const int, ParamType -&gt; const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx); <span class="comment">// T -&gt; const int, ParamType -&gt; const int&amp;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>向持有<code>T&amp;</code>型别的模版传入<code>const</code>对象是安全的</li>
</ul>
<h2
id="情况二paramtype是万能引用">情况二:<code>ParamType</code>是万能引用:</h2>
<ol type="1">
<li>如果<code>expr</code>是个左值:
<ul>
<li><code>ParamType</code>和<code>T</code>都会被推导为左值引用</li>
</ul></li>
<li>如果<code>expr</code>是个右值:
<ul>
<li>与情况一相同</li>
</ul></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x); <span class="comment">// T -&gt; int, ParamType -&gt; int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx); <span class="comment">// T -&gt; const int&amp;, ParamType -&gt; const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx); <span class="comment">// T -&gt; const int&amp;, ParamType -&gt; const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">27</span>); <span class="comment">// T -&gt; int, ParamType -&gt; int&amp;&amp;</span></span><br></pre></td></tr></table></figure>
<h2
id="情况三paramtype既非指针也非引用">情况三:<code>ParamType</code>既非指针也非引用:</h2>
<ul>
<li>即按值传递,
<code>param</code>是传入对象的副本，是<strong>全新对象</strong></li>
</ul>
<ol type="1">
<li>若<code>expr</code>具有引用型别, 先将引用部分忽略</li>
<li>若是<code>const</code>,<code>volatile</code>对象，也忽略之</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x); <span class="comment">// T -&gt; int, ParamType -&gt; int</span></span><br><span class="line"><span class="built_in">f</span>(cx); <span class="comment">// T -&gt; int, ParamType -&gt; int</span></span><br><span class="line"><span class="built_in">f</span>(rx); <span class="comment">// T -&gt; int, ParamType -&gt; int</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">27</span>); <span class="comment">// T -&gt; int, ParamType -&gt; int</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> ptr = <span class="string">&quot;Fun&quot;</span>;</span><br><span class="line"><span class="built_in">f</span>(ptr); T -&gt; <span class="type">const</span> <span class="type">char</span>*, ParamType -&gt; <span class="type">const</span> <span class="type">char</span>*</span><br></pre></td></tr></table></figure>
<h2 id="其他情形">其他情形:</h2>
<h3 id="数组实参">数组实参</h3>
<ul>
<li>数组可退化成指针</li>
<li>没有任何函数形参具有数组型别:
<code>void myFunc(int param[]);</code>等价于<code>void myFunc(int param[]);</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> name = <span class="string">&quot;J. P. Briggs&quot;</span>; <span class="comment">// name的型别是const char[13]</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ptrToName = name; <span class="comment">// 数组退化成指针</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(name); <span class="comment">// T -&gt; const char*</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"><span class="built_in">f2</span>(name); <span class="comment">// T -&gt; const char [13], ParamType -&gt; const char (&amp;)[13]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以编译器常量形式返回数组尺寸</span></span><br><span class="line"><span class="comment">// 形参未起名字</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T， std::<span class="type">size_t</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> <span class="title">arraySize</span><span class="params">(T (&amp;)[N])</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数实参">函数实参</h3>
<ul>
<li>函数型别可退化成函数指针 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunc</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span></span>; <span class="comment">// 型别为void(int, double)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(T param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> name = <span class="string">&quot;J. P. Briggs&quot;</span>; <span class="comment">// name的型别是const char[13]</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ptrToName = name; <span class="comment">// 数组退化成指针</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f1</span>(someFunc); <span class="comment">// ParamType -&gt; void(*)(int, double)</span></span><br><span class="line"><span class="built_in">f2</span>(someFunc); <span class="comment">// ParamType -&gt; void(&amp;)(int, double)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="auto-型别推导">auto 型别推导</h1>
<ul>
<li>与模板型别一模一样（除了一个例外情况）
<ul>
<li><code>auto</code>是模板中的<code>T</code></li>
<li>变量的型别饰词是<code>ParamType</code> ## 例外情况: {}
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x3 = &#123;<span class="number">27</span>&#125;; <span class="comment">// T -&gt; std::initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="keyword">auto</span> x4 = &#123;<span class="number">27</span>&#125;; <span class="comment">// T -&gt; std::initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="keyword">auto</span> x5 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.0</span>&#125;; <span class="comment">// Error! </span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><code>auto</code> -&gt; <code>std::initializer_list</code>,
所以x5必须被推导为<code>std::initializer_list&lt;T&gt;</code>,
但<code>&#123;&#125;</code>内型别不统一,所以错误</li>
<li>模板不接受大括号初始化表达式 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// T -&gt; std::initializer_list&lt;int&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;); <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="auto返回值">auto返回值</h2>
<ul>
<li>使用模版型别推导规则 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">createOnitList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// Error!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="lambda式中的auto形参">lambda式中的auto形参</h2>
<ul>
<li>使用模版型别推导规则 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">auto</span> resetV = </span><br><span class="line">    [&amp;v](<span class="type">const</span> <span class="keyword">auto</span>&amp; newValue) &#123;v = newValue;&#125; <span class="comment">// c++14</span></span><br><span class="line"><span class="built_in">resetV</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;); <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="理解decltype">理解decltype</h1>
<ul>
<li>一般只会鹦鹉学舌 ## 实例</li>
<li>目标:
<ul>
<li>实现一个函数，形参包括一个容器(支持<code>[]</code>)和一个下标</li>
<li>并在返回下标操作结果前进行用户验证</li>
<li>返回值型别与容器下标的返回值型别相同</li>
</ul></li>
<li>背景知识:
<ul>
<li>一般而言，含有型别T的对象的容器，其operator[]返回T&amp;</li>
<li>std::vector(除std::vector<bool>外)均满足</li>
</ul></li>
<li>初步尝试:
<ul>
<li>能运作, 需改进 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">authAndAccess</span><span class="params">(Container&amp; c, Index i)</span></span></span><br><span class="line"><span class="function">    -&gt; <span class="title">decltype</span><span class="params">(c[i])</span>  <span class="comment">/// 返回值型别尾序语法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">authenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>Effective C++(1)--让自己习惯C++</title>
    <url>/zyhjy/2022/07/16/Effective%20C++(1)/</url>
    <content><![CDATA[<h1 id="视c为一个语言联邦">01 视C++为一个语言联邦</h1>
<ul>
<li>C++ :
多重范型编程语言(<code>multiparadigm programming language</code>)
<ul>
<li>过程形式(<code>procedural</code>)</li>
<li>面向对象(<code>object-oriented</code>)</li>
<li>函数形式(<code>functional</code>)</li>
<li>泛型形式(<code>generic</code>)</li>
<li>元编程形式(<code>metaprogramming</code>)</li>
</ul></li>
<li>语言联邦:
<ul>
<li>C(过程形式,函数形式)</li>
<li>object-oriented C++</li>
<li>Template C++(泛型形式,元编程)</li>
<li>STL(template程序库)</li>
</ul></li>
</ul>
<h1 id="尽量以constenuminline替换define">02
尽量以const,enum,inline替换#define</h1>
<ul>
<li>宁可以编译器替换预处理器 ## 原因 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ASPECT_RATIO 1.653</span></span><br></pre></td></tr></table></figure></li>
<li>记号名称ASPECT_RATIO从未被编译器看见
<ul>
<li>在编译器处理源码之前被预处理器移走了</li>
<li>记号名称ASPECT_RATIO未进入符号表</li>
<li>相关的错误信息显示1.653而非ASPECT_RATIO</li>
</ul></li>
<li>解决办法 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> aspect_ratio <span class="number">1.653</span>;</span><br></pre></td></tr></table></figure> ## class的专属常量</li>
<li>member</li>
<li>为确保只有一份实体
<ul>
<li>static <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Class GamePlayer&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> NumTurns = <span class="number">5</span>;  <span class="comment">// 常量声明式</span></span><br><span class="line">    <span class="type">int</span> scores[NumTurns];   <span class="comment">// 使用该常量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>todo:
<ul>
<li>why it is declaration</li>
</ul></li>
<li>通常C++要求你对你所使用的东西提供一个定义式
<ul>
<li>例外:
<ul>
<li>class专属常量 &amp;&amp; static &amp;&amp; integral type(ints,
chars, bools) -- 不取地址时无需定义式</li>
</ul></li>
<li>定义式: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> GamePlayer::NumTurns;  <span class="comment">// definition</span></span><br></pre></td></tr></table></figure>
<ul>
<li>写在实现文件而非头文件</li>
<li>由于常量声明时已经获得初值,此时无需再设初值</li>
</ul></li>
</ul></li>
<li>#define毫无封装性
<ul>
<li>无法定义class专属常量</li>
<li>在C++中不管宏是定义在类内部还是外部
都当做外部，使用时不需要限定域运算--即宏是全局的</li>
<li>https://blog.csdn.net/xiupong/article/details/119805554</li>
</ul></li>
</ul>
<h2 id="enum-hack">enum hack</h2>
<ul>
<li>一个属于枚举类型的数值可以权充ints被使用 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Class GamePlayer&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; NumTurns = <span class="number">5</span> &#125;;  <span class="comment">// 常量声明式</span></span><br><span class="line">    <span class="type">int</span> scores[NumTurns];   <span class="comment">// 使用该常量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>enum类型不会被取地址
<ul>
<li>enum不会导致非必要的内存分配</li>
<li>enum产生的常量是没有存储空间的，编译器编译后，只会成为汇编指令的立即数，也就是存在于_TEXT段</li>
</ul></li>
</ul>
<h2
id="使用template-inline函数取代替换宏函数">使用<code>template inline</code>函数取代替换宏函数</h2>
<h1 id="尽可能使用const">03 尽可能使用const</h1>
<ul>
<li>将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。</li>
<li>编译器强制实施 bitwise
constness，但你编写程序时应该使用“概念上的常量性”(conceptual
constness)。</li>
<li>当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。</li>
<li>const对象只能调用const成员函数 ## STL系根据指针塑模出来
<ul>
<li>迭代器类似T*</li>
<li>声明迭代器为const类似<code>T* const</code></li>
<li>const_iterator类似<code>const T*</code></li>
</ul></li>
</ul>
<h2 id="const成员函数">const成员函数</h2>
<ul>
<li>两个成员函数如果只是常量性不同，可以被重载
<ol type="1">
<li>在c++中其实是有最⼩权限原则的，⾮const对象是可以调⽤const成员函数的。</li>
<li>const成员函数是不能调⽤⾮const成员函数，只能通过强制或者定义mutable</li>
<li>构造与析构函数不能定义为const成员函数，构造跟析构会对对象做修改</li>
</ol></li>
<li>bitwise constness vs logical constness
<ul>
<li>bitwise constness:
<ul>
<li>不改变对象内任何一个bit</li>
<li>编译器检测不到修改指针成员变量所指的内容</li>
</ul></li>
<li>logical constness:
<ul>
<li>可以修改某些bit(在客户端侦测不到时)</li>
<li><code>mutable</code> : 在const成员函数内变量仍有可能被修改</li>
</ul></li>
</ul></li>
<li>在const和non-const成员函数中避免重复
<ul>
<li>使用non-const成员函数调用const成员函数(需要转型) <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> &amp;<span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="type">const</span></span><br><span class="line">    &#123; <span class="comment">//一如既往&#123;</span></span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> &amp;<span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="comment">//现在只调用const op[]</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            <span class="built_in">const_cast</span>&lt;<span class="type">char</span> &amp;&gt;( <span class="comment">//将op[]返回值的const转除</span></span><br><span class="line">                <span class="built_in">static_cast</span>&lt;<span class="type">const</span> TextBlock &amp;&gt;(*<span class="keyword">this</span>) <span class="comment">//为*this加上const</span></span><br><span class="line">                [position] <span class="comment">//调用const op[]</span></span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>禁止使用const成员函数调用non-const成员函数</li>
</ul></li>
</ul>
<h1 id="确定对象被使用前已经被初始化">04
确定对象被使用前已经被初始化</h1>
<ul>
<li>C part of C++5
<ul>
<li>初始化 --&gt; 运行期成本</li>
<li>不保证其内容被初始化，如array</li>
</ul></li>
<li>non-C part of C++
<ul>
<li>vector保证初始化(来自STL)</li>
</ul></li>
<li>在使用对象之前先将他初始化
<ul>
<li>内置类型
<ul>
<li>手工完成, 如int， pointer</li>
</ul></li>
<li>其他类型:
<ul>
<li>构造函数负责初始化
<ul>
<li>使用<code>member initialization list</code></li>
</ul></li>
</ul></li>
</ul></li>
<li>编译单元
<ul>
<li>产出单一目标文件的源码</li>
<li>单一源码文件 + #include files</li>
</ul></li>
<li>C++对"定义于不同编译单元内的non-local
static对象"的初始化次序并无明确定义
<ul>
<li>Singleton :
<ul>
<li>以local static对象替换non-local static对象</li>
<li>使用时返回local static对象的引用</li>
</ul></li>
<li>函数内的local static对象会在首次定义对象时被初始化</li>
<li>单例会导致多线程下的不确定性
<ul>
<li>可以在程序的单线程启动阶段手工调用所有的reference-returning</li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>各种linux小技巧</title>
    <url>/zyhjy/2022/07/19/%E5%90%84%E7%A7%8Dlinux%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1
id="已知pid已知fd号需要知道文件">已知PID，已知fd号，需要知道文件</h1>
<ul>
<li><code>ll /proc/[pid]/fd/</code></li>
</ul>
<h1 id="文件锁的情况">文件锁的情况</h1>
<ul>
<li><code>cat /proc/locks</code>
<ul>
<li>第一个是pid，:后是inode号</li>
</ul></li>
</ul>
<h1 id="查看进程打开所有文件信息lsof">查看进程打开所有文件信息lsof</h1>
<ul>
<li><code>lsof -p [pid]</code></li>
</ul>
<h1 id="linux-error-code">linux error code</h1>
<p>https://mariadb.com/kb/en/operating-system-error-codes/</p>
<h1 id="反向删除文件">反向删除文件</h1>
<ul>
<li><code>xargs</code>:
<ul>
<li>根据这个命令的名字, 就可以知道它的含义了:<code>x</code>: transmit
传递, <code>args</code>: 多个参数, 正是: 向命令(不能带多个参数的命令,
如<code>rpm -e</code>)传递多个参数,
循环遍历处理.<code>xargs</code>就相当于一个<code>for</code>循环.</li>
</ul></li>
<li>反向删除文件:
<ul>
<li><code>ls | grep -v 'install_falsh' | xargs rm -rf</code></li>
</ul></li>
</ul>
<h1 id="linux怎么查看当前登录用户">linux怎么查看当前登录用户</h1>
<ol type="1">
<li>使用“w”命令，可以显示目前登入系统的用户信息；</li>
<li>使用“who”命令，可以显示当前已登录的用户信息；</li>
<li>使用“last”命令；</li>
<li>使用“lastlog”命令</li>
<li>使用“ac”命令。</li>
</ol>
<h1 id="查看时间和日期">查看时间和日期</h1>
<ul>
<li>命令: “date”</li>
</ul>
<h1 id="grep显示目标附近的几行">grep显示目标附近的几行</h1>
<p>cat temp.txt | grep "Mis Predict! [commit]" -A9 -B1</p>
<h1 id="linux查看文件夹多大">linux查看文件夹多大</h1>
<ol type="1">
<li><code>ls</code>
<ul>
<li><code>ls -ll</code>，会显示成字节大小，</li>
<li><code>ls- lh</code>会以KB、MB等为单位进行显示，这样比较直观一些。</li>
</ul></li>
<li><code>du</code>
<ul>
<li><code>du -h --max-depth=1</code>，可以查看当前目录下各文件、文件夹的大小，这个比较实用。</li>
<li><code>du -h –-max-depth=0 *</code>，可以只显示直接子目录文件及文件夹大小统计值。</li>
<li>查询当前目录总大小可以使用<code>du -sh</code>，其中s代表统计汇总的意思，即只输出一个总和大小。
<ul>
<li>如果只想查看指定目录的总大小，可以使用du -sh 目录名称。</li>
</ul></li>
<li>对于指定文件夹也可以指定显示层次深度，如<code>du -h --max-depth=0 software/</code>及<code>du -h --max-depth=1 software/</code></li>
</ul></li>
</ol>
<h1 id="scons编译">scons编译</h1>
<ul>
<li><p>scons：进行代码文件编译</p></li>
<li><p>scons
-Q：进行代码文件编译，不显示Scons内部操作打印的信息，只显示编译信息</p></li>
<li><p>scons -c：清除编译中间文件和可执行文件</p></li>
</ul>
<h1 id="linux按照大小行数切割文件">Linux按照大小、行数切割文件</h1>
<ul>
<li>按照大小切割文件
<ol type="1">
<li>按照10k为大小切分：【 split -b 10k data.txt -d 】</li>
<li>按照5M为大小切分：【 split -b 5M data.txt -d 】</li>
</ol>
<ul>
<li>说明： -d 指定切割后的文件后缀名为数字</li>
</ul></li>
<li>按照行数据切割文件
<ol type="1">
<li>以100行作为基本单位切分data.txt文件
<ul>
<li><code>split -l 100 data.txt result.txt</code></li>
<li>输出文件：result.txtab result.txtac…结尾以 aa ab ac…</li>
</ul></li>
<li>指定切割后的文件前缀名与后缀名
<ul>
<li><code>split -l 100 data.txt -d -a 4 data_</code></li>
<li>说明：
<ul>
<li>1）-l 100：按100行切割</li>
<li>2）data_：指定切割后的文件前缀名</li>
<li>3）-d：指定切割后的文件后缀名为数字</li>
<li>4）-a 4：指定切割后的文件后缀名数字的长度</li>
</ul></li>
</ul></li>
</ol></li>
</ul>
<h1 id="linux-ls指令">Linux ls指令</h1>
<ul>
<li>文件大小以M为单位显示<code>ll -h</code></li>
<li>根据最近更新顺序排列<code>ls -lrt</code></li>
</ul>
<h1 id="解压缩">解压缩</h1>
<h2 id="解压.tar.bz2">解压<code>.tar.bz2</code></h2>
<ul>
<li><code>tar -jxvf 包名</code></li>
<li><code>-j</code> ： 打包后用zip2压缩，生成.tar.bz2文件</li>
<li><code>-x</code> ：解开一个打包文件</li>
<li><code>-v</code> ：过程中显示包内各文件</li>
<li><code>-f</code> ：使用文件名 后面只可以接文件名不可以加其他参数</li>
</ul>
<h1 id="查看cpu的核数">查看CPU的核数</h1>
<h2 id="物理-cpu-的个数">物理 CPU 的个数</h2>
<ul>
<li>物理核心就是计算机上实际配置的 CPU 个数。</li>
<li><code>wc -l</code> 是统计行数</li>
<li><code>cat /proc/cpuinfo | grep "physical id" | sort -u | wc -l</code></li>
</ul>
<h2 id="每个-cpu-的核数">每个 CPU 的核数</h2>
<ul>
<li>指 CPU 上集成的处理数据的 CPU 核心个数，单核指 CPU
核心数一个，双核则指的是两个。</li>
<li><code>uniq</code> 可以去重连续出现的相同记录</li>
<li><code>cat /proc/cpuinfo | grep "cpu cores" | uniq</code></li>
</ul>
<h1 id="限制某进程的cpu占用率----cpulimit">限制某进程的CPU占用率 --
CPULimit</h1>
<ul>
<li><code>-l</code> 限定CPU占据率0%~X00% X为CPU核数</li>
<li><code>-v</code> 显现控制的统计信息</li>
<li><code>-z</code>
当被控制的程式退出的时候，CPULimit程式也跟着退出</li>
<li><code>-i</code> 同时限定被控程式的子进程 #command</li>
<li><code>-p</code> 被控程式的PID</li>
<li><code>-e</code> 被控程式的程式称号</li>
</ul>
<h1 id="vim">VIM</h1>
<h2 id="删除多行">删除多行</h2>
<p>:3,5d
https://blog.csdn.net/ayychiguoguo/article/details/124926240</p>
<h1 id="交叉编译">交叉编译</h1>
<ol type="1">
<li>安装arm工具包</li>
</ol>
<ul>
<li><code>apt install gcc-8-aarch64-linux-gnu</code></li>
</ul>
<ol start="2" type="1">
<li>编译</li>
</ol>
<ul>
<li>动态链接-默认
<ul>
<li><code>aarch64-linux-gnu-gcc-8 main.c</code></li>
</ul></li>
<li>静态链接
<ul>
<li><code>aarch64-linux-gnu-gcc-8 -static main.c</code></li>
</ul></li>
</ul>
<h1 id="反汇编">反汇编</h1>
<ol type="1">
<li>arch64</li>
</ol>
<ul>
<li><code>aarch64-linux-gnu-objdump -d a.out</code></li>
</ul>
<ol start="2" type="1">
<li>host(x86)</li>
</ol>
<ul>
<li><code>objdump -d a.out</code></li>
</ul>
<h1 id="查看文件类型">查看文件类型</h1>
<ul>
<li><code>file a.out</code>　</li>
</ul>
<h1 id="调整磁盘分区">调整磁盘分区</h1>
<ol start="0" type="1">
<li>查看当前系统的磁盘情况：
<ul>
<li><code>df -h</code> 查看当前系统的磁盘大小</li>
<li><code>df -T</code> 查看当前系统的磁盘类型，
以下为xfs类型磁盘扩容</li>
</ul></li>
<li>将home目录进行备份,备份完成后,卸载/home 目录
<code>umount /home</code></li>
<li>移除home目录对应的分区
<code>lvremove /dev/mapper/centos-home</code></li>
<li>扩展根目录分区大小 (我们这里扩展到300G)
<code>lvextend -L 300G /dev/mapper/centos-root</code></li>
<li>同步 <code>xfs_growfs /dev/mapper/centos-root</code></li>
<li>查看硬盘分组 <code>pvs</code></li>
<li>将剩余空间分给Home目录
<code>lvcreate -l +100%Free -n home centos</code></li>
<li>写入分区 <code>mkfs.xfs /dev/mapper/centos-home</code></li>
<li>硬盘挂在 <code>mount /dev/mapper/centos-home /home</code></li>
<li>查看结果 <code>df -h</code></li>
</ol>
<h1 id="yum换源">yum换源</h1>
<ol type="1">
<li>进入yum源配置文件 <code>cd /etc/yum.repos.d</code></li>
<li>备份一下当前的源，以防出错后可以还原回来
<code>mv ./CentOS-Base.repo ./CentOS-Base-repo.bak</code></li>
<li>下载网易163的源<code>wget http://mirrors.163.com/.help/CentOS7-Base-163.repo</code>
<ul>
<li>我的机器在这一步遇到了问题，无法访问http，将http改为https</li>
<li>把下载下来文件 CentOS7-Base-163.repo设置成为默认源
<code>mv CentOS7-Base-163.repo CentOS-Base.repo</code></li>
</ul></li>
<li>清理一下旧包 <code>yum clean all</code></li>
<li>生成缓存即可用163源了 <code>yum makecache</code></li>
</ol>
<ul>
<li>我的机器在这一步遇到了问题，无法访问http: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://mirrors.163.com/centos/7/os/x86_64/repodata/repomd.xml: [Errno 14] curl#7 - &quot;Failed connect to mirrors.163.com:80; 拒绝连接&quot;</span><br><span class="line">http://mirrors.163.com/centos/7/os/x86_64/repodata/repomd.xml: [Errno 14] curl#7 - &quot;Failed connect to mirrors.163.com:80; 拒绝连接&quot;</span><br><span class="line">http://mirrors.163.com/centos/7/os/x86_64/repodata/repomd.xml: [Errno 14] curl#7 - &quot;Failed connect to mirrors.163.com:80; 拒绝连接&quot;</span><br></pre></td></tr></table></figure></li>
<li>解决方案: <code>vim CentOS-Base.repo</code>将http改成https</li>
</ul>
<h1 id="ubuntu换源">ubuntu换源</h1>
<p>如果您想将 Ubuntu
的软件源更改为清华大学镜像源，可以按照以下步骤进行操作：</p>
<ol type="1">
<li><p>打开终端：打开终端应用程序，以便在命令行中执行操作。</p></li>
<li><p>备份原有源配置（可选）：在更改软件源之前，建议备份原有的源配置文件，以防意外发生。您可以使用以下命令将原有源配置文件复制到其他位置进行备份：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup</span><br></pre></td></tr></table></figure></li>
<li><p>编辑源配置文件：使用文本编辑器打开源配置文件
<code>/etc/apt/sources.list</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/apt/sources.list</span><br></pre></td></tr></table></figure></li>
<li><p>获取清华大学镜像源地址：访问清华大学 TUNA
镜像源站点（https://mirrors.tuna.tsinghua.edu.cn/）或清华大学镜像源站点（https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/）查找可用的软件源地址。</p></li>
<li><p>更新软件源地址：在编辑器中，将现有的软件源地址替换为清华大学镜像源的地址。根据您的
Ubuntu 版本和软件源配置文件的格式，通常每个软件源地址占据一行。</p>
<p>以清华大学 TUNA 镜像源为例，对于 Ubuntu 20.04 LTS（Focal
Fossa）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span><br></pre></td></tr></table></figure>
<p>对于其他 Ubuntu 版本，请将 <code>focal</code>
替换为适合您版本的代号，例如 <code>bionic</code>（18.04 LTS）或
<code>impish</code>（21.10）。</p></li>
<li><p>保存更改：在编辑器中保存您对源配置文件的更改。</p></li>
<li><p>更新软件源缓存：执行以下命令来更新软件源缓存：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure></li>
<li><p>完成：软件源已经更换为清华大学镜像源。您现在可以使用清华大学镜像源获取和安装软件包。</p></li>
</ol>
<p>请注意，清华大学镜像源是一种可靠和高速的镜像源选择，但它可能会因网络和地理位置而有所不同。如果您遇到问题，您可以恢复先前的源配置文件或尝试其他可用的软件源。</p>
<h1 id="linux-批量杀死进程">Linux 批量杀死进程</h1>
<p><code>ps -ef|grep GSM_run.py|grep -v grep|cut -c 9-15|xargs kill -9</code>
- 命令说明 : 1. 管道符 "|"
用来隔开两个命令，管道符左边命令的输出会作为管道符右边命令的输入。 2.
<code>ps -ef</code> 是 查看所有进程,其中 <code>ps -aux</code>
也是查看所有进程,不过两者以下区别： 1.
<code>-ef</code>是<code>System V</code>展示风格，而<code>-aux</code>是<code>BSD</code>风格,Unix操作系统在操作风格上主要分为System
V和BSD 2.
<code>COMMADN</code>列如果过长，<code>-aux</code>会截断显示，而<code>-ef</code>不会
3.
<code>-aux</code>可以查看进程的CPU占用率和内存占用率，而<code>-ef</code>不能
3. <code>grep GSM_run.py</code>
列出含有关键字<code>GSM_run.py</code>的所有进程 4.
<code>grep -v grep</code>是在列出的进程中去除含有关键字<code>grep</code>的进程
5.
<code>cut -c 9-15</code>是截取输入行的第9个字符到第15个字符，而这正好是进程号PID
- 某些情况下 9-15 是 不够的 可以 写成 <code>awk '&#123;print $2&#125;'</code> 其
表示 按空格分割取第二个元素，即取进程号
PID。此时完整的命令为<code>ps -ef|grep GSM_run.py|grep -v grep|awk '&#123;print $2&#125;'|xargs kill -9</code>
6. <code>xargs kill -9</code> -
xargs命令把前面命令的输出结果（PID）作为<code>kill -9</code>命令的参数，并执行</p>
<h1
id="比较两个文件并找出它们之间不同的行">比较两个文件并找出它们之间不同的行</h1>
<p>要比较两个文件并找出它们之间不同的行，可以使用<code>diff</code>命令。<code>diff</code>命令用于比较文件之间的差异，并显示不同之处。</p>
<p>以下是使用<code>diff</code>命令比较两个文件并找出不同行的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff file1.txt file2.txt</span><br></pre></td></tr></table></figure>
<p>上述命令将比较名为<code>file1.txt</code>和<code>file2.txt</code>的两个文件，并显示它们之间的差异。<code>diff</code>命令将显示出两个文件中不同的行，并用"&lt;"和"&gt;"符号标记它们。"&lt;"表示该行在第一个文件中出现，而"&gt;"表示该行在第二个文件中出现。</p>
<p>如果只关注不同的行而不关心具体的差异内容，可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff --brief file1.txt file2.txt</span><br></pre></td></tr></table></figure>
<p>上述命令将仅显示文件之间的差异，并不显示具体的差异内容。</p>
<p>请注意，<code>diff</code>命令还有其他选项和用法，可以根据需要进行调整。您可以使用<code>man diff</code>命令查看完整的<code>diff</code>命令文档和更多选项。</p>
<h1
id="要在ubuntu上安装clang-format您可以按照以下步骤进行操作">要在Ubuntu上安装Clang
Format，您可以按照以下步骤进行操作：</h1>
<ol type="1">
<li><p>使用以下命令安装Clang和Clang Format： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install clang</span><br><span class="line">sudo apt install clang-format</span><br></pre></td></tr></table></figure>
这将更新软件包列表并安装Clang和Clang Format。</p></li>
<li><p>安装完成后，您可以使用以下命令验证是否成功安装Clang Format：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clang-format --version</span><br></pre></td></tr></table></figure> 如果安装成功，将显示Clang Format的版本信息。</p></li>
</ol>
<p>现在，您已经成功在Ubuntu上安装了Clang
Format。您可以使用它来格式化C、C++和其他受支持的语言的源代码文件。</p>
<h1 id="grep">grep</h1>
<ol type="1">
<li>或 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">grep -E <span class="string">&#x27;123|abc&#x27;</span> filename  // 找出文件（filename）中包含123或者包含abc的行</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="ssh">ssh</h1>
<ol type="1">
<li>"permissions are too open"
<ul>
<li><code>chmod 600 ~/.ssh/id_rsa</code></li>
</ul></li>
</ol>
<h1 id="perf">perf</h1>
<p>ubuntu无法安装perf
https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1844443</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>Effective C++(05-12)--构造 析构 赋值运算</title>
    <url>/zyhjy/2022/07/20/Effective%20C++(2)/</url>
    <content><![CDATA[<h1 id="了解c默默编写并调用哪些函数">05
了解C++默默编写并调用哪些函数</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>等价于: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Empty</span>() &#123;...&#125; <span class="comment">//default构造函数</span></span><br><span class="line">    <span class="built_in">Empty</span>(<span class="type">const</span> Empty&amp; rhs) &#123;...&#125; <span class="comment">//copy构造函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Empty</span>() &#123;...&#125; <span class="comment">//析构函数</span></span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Empty&amp; rhs) &#123;...&#125; <span class="comment">//copy assignment操作符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> - 唯有这些函数被调用时，编译器才会被创建出来 -
下面代码造成上述表示每个函数被编译器产出: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Empty e1;       <span class="comment">//default构造函数</span></span><br><span class="line">                <span class="comment">//析构函数</span></span><br><span class="line"><span class="function">Empty <span class="title">e2</span><span class="params">(e1)</span></span>;   <span class="comment">//copy构造函数</span></span><br><span class="line">e2 = e1;        <span class="comment">//copy assignment操作符</span></span><br></pre></td></tr></table></figure> -
编译器产出的析构函数是non-virtual, 除非类的base
class自身声明了virtual析构函数 - copy构造函数和copy assignment操作符: -
编译器创建的版本只是拷贝non-static对象 -
如果类声明了一个构造函数，编译器将不会创建default构造函数 -
编译器拒绝生成copy assignment操作符的情况: - 类内含reference成员 -
内含const成员 - base class将copy assignment操作符声明为private</p>
<h1 id="若不想使用编译器自动生成的函数就该明确拒绝">06
若不想使用编译器自动生成的函数，就该明确拒绝</h1>
<pre><code>- `class XX : private Uncopyable &#123;`
- `= delete`</code></pre>
<h1 id="为多态基类声明virtual析构函数">07
为多态基类声明virtual析构函数</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimeKeeper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TimerKeeper</span>();</span><br><span class="line">    ~<span class="built_in">TimerKeeper</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicClock</span> : <span class="keyword">public</span> TimeKeeper &#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaterClock</span> : <span class="keyword">public</span> TimeKeeper &#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WristClock</span> : <span class="keyword">public</span> TimeKeeper &#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 工厂函数：返回base指针，指向derived对象</span></span><br><span class="line"><span class="function">TimeKeeper* <span class="title">getTimeKeeper</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>防止derived指针以基类指针调用析构函数时仅析构基类部分</li>
<li>如果不想要多态，应避免使用virtual析构函数</li>
<li>可用final声明类不可被继承</li>
</ul>
<h1 id="别让异常逃离析构函数">08 别让异常逃离析构函数</h1>
<pre><code>- try ... catch
- 可提供普通函数而非在析构函数中执行该操作</code></pre>
<h1 id="绝不在构造和析构函数中使用virtual函数">09
绝不在构造和析构函数中使用virtual函数</h1>
<pre><code>- 此时调用不会下沉到派生函数</code></pre>
<h1 id="令operate返回一个reference-to-this">10
令operate返回一个reference to *this</h1>
<pre><code>- stl遵循，string，vector，complex，shared_ptr
- `=`, `+=`</code></pre>
<h1 id="在operate处理自我赋值">11 在operate=处理自我赋值</h1>
<pre><code>- 类型：资源管理对象
- 方法：
    - 证同测试
        - `if (this == &amp;rhs) return *this;`
        - 引入了新的控制流，有成本
    - copy and swap
        - 复制也存在开销</code></pre>
<h1 id="复制对象时勿忘其每一个成分">12 复制对象时勿忘其每一个成分</h1>
<pre><code>- 函数：
    - copy构造函数
    - copy assignment操作符
    - 两个函数的相互调用无意义，可将公共部分单独提出成一个函数
- 内容：
    - local成员变量
    - 调用base classes内的copying函数</code></pre>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>CS143 : Compilers学习笔记</title>
    <url>/zyhjy/2022/08/22/Compilers/</url>
    <content><![CDATA[<h2 id="the-structure-of-a-compiler">The Structure of a Compiler</h2>
<ol type="1">
<li>Lexical Analysis
<ul>
<li>identify words</li>
<li>recognize words</li>
<li>Lexical analyzer divides program text into “words” or “tokens”</li>
</ul></li>
<li>Parsing
<ul>
<li>identify sentences</li>
<li>DiagrammingSentences
<ul>
<li>The diagram is a tree</li>
</ul></li>
</ul></li>
<li>Semantic Analysis
<ul>
<li>analyse sentences</li>
</ul></li>
<li>Optimization
<ul>
<li>editing</li>
</ul></li>
<li>CodeGeneration
<ul>
<li>translation</li>
</ul></li>
</ol>
<ul>
<li>tips : Can be understood by analogy to how humans comprehend
English.</li>
</ul>
<h2 id="intermediate-representationsir">intermediate
representations(IR)</h2>
<ul>
<li>IRs are useful because lower levels expose features hidden by higher
levels
<ul>
<li>registers</li>
<li>memory layout</li>
<li>raw pointers</li>
<li>etc.</li>
</ul></li>
<li>But lower levels obscure high-level meaning
<ul>
<li>Classes</li>
<li>Higher-order functions</li>
<li>Even loops...</li>
</ul></li>
</ul>
<h2 id="cool-overview">Cool Overview</h2>
<ul>
<li>CS143设计了一门类似C++(03)的面向对象语言，后续的课程练习都围绕这门语言展开</li>
<li>Classroom Object Oriented Language</li>
<li>Designed to
<ul>
<li>Be implementable in a short time</li>
<li>Give a taste of implementation of modern
<ul>
<li>Abstraction</li>
<li>Static typing</li>
<li>Reuse (inheritance)</li>
<li>Memory management</li>
<li>And more...</li>
</ul></li>
</ul></li>
<li>But many things are left out</li>
<li>具体内容见lecture02</li>
</ul>
<h1 id="lexical-analysislecture03">lexical analysis(lecture03)</h1>
<ul>
<li>The goal of lexical analysis is to
<ul>
<li>Partition the input string into lexemes</li>
<li>Identify the token of each lexeme</li>
</ul></li>
<li>Left-to-right scan =&gt; lookahead sometimes required</li>
<li>之后介绍了一些正则表达式的知识</li>
</ul>
]]></content>
      <categories>
        <category>compilers</category>
      </categories>
  </entry>
  <entry>
    <title>OSTEP阅读笔记</title>
    <url>/zyhjy/2022/08/25/OSTEP%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="内存虚拟化-12-24">内存虚拟化 (12-24)</h2>
<h3 id="cp14">CP14</h3>
<ul>
<li>目的
<ul>
<li>易于使用（ease of use）</li>
<li>隔离（isolation）</li>
<li>保护（protection）</li>
</ul></li>
</ul>
<h4 id="unix内存操作api">UNIX内存操作API</h4>
<h5 id="内存类型">内存类型:</h5>
<ul>
<li>stack</li>
<li>申请和释放操作是编译器来隐式管理的</li>
<li>有时也称为自动（automatic）内存</li>
<li>heap
<ul>
<li>对长期内存的需求</li>
<li>申请和释放操作都由程序员显式地完成 ##### 库调用</li>
</ul></li>
<li>malloc</li>
<li>free</li>
<li>mmap
<ul>
<li>可以在程序中创建一个匿名（anonymous）内存区域</li>
<li>这个区域不与任何特定文件相关联，而是与交换空间（swap
space）相关联，稍后我们将在虚拟内存中详细讨论。</li>
<li>这种内存也可以像堆一样对待并管理</li>
</ul></li>
<li>calloc
<ul>
<li>分配内存，并在返回之前将其置零</li>
</ul></li>
<li>realloc
<ul>
<li>创建一个新的本大的内存区域，将旧区域复制到其中，并返回新区域的指针</li>
</ul></li>
</ul>
<h5 id="系统调用">系统调用</h5>
<ul>
<li>brk</li>
<li>sbrk</li>
</ul>
<h5 id="两级内存管理">两级内存管理。</h5>
<ul>
<li>第一级是由操作系统执行的内存管理，操作系统在进程运行时将内存交给进程，并在进程退出（或
以其他方式结束）时将其回收。</li>
<li>第二级管理在每个进程中，例如在调用 malloc()和
free()时，在堆内管理。</li>
<li>所以进程退出时不会内存泄漏</li>
<li>使用valgind找到与内存有关的问题的原因</li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
  </entry>
  <entry>
    <title>CppCoreGuideline笔记</title>
    <url>/zyhjy/2022/08/31/CppCoreGuideline%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="p-理念">P: 理念</h1>
<h2 id="p.1-在代码中直接表达你的想法">P.1: 在代码中直接表达你的想法</h2>
<ul>
<li>用恰当设计的程序库来表达设计意图(不要重复造轮子)</li>
<li>坚持一贯地使用
const（检查成员函数是否会修改对象；检查函数是否会修改以指针或引用形式传递的实参）</li>
<li>将强制转换标示出来（强制转换阉割了类型系统） ## P.3:
表达你的设计意图 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for_each(v, [](int x) &#123; /* 用 x 的值做一些事 */ &#125;);</span><br><span class="line">for_each(par, v, [](int x) &#123; /* 用 x 的值做一些事 */ &#125;);</span><br></pre></td></tr></table></figure></li>
<li>查找具有更加替代方案的一般模式：
<ul>
<li>范围式 for 循环(for_each) 替代简单 for 循环</li>
<li>f(span<T>) 接口替代f(T*, int) 接口</li>
<li>循环变量出现在过大的范围中</li>
<li>裸的 new 和 delete</li>
<li>带有大量内建类型的形参的函数</li>
</ul></li>
</ul>
<h2 id="p.4-理想情况下程序应当是静态类型安全的">P.4:
理想情况下，程序应当是静态类型安全的</h2>
<ul>
<li>union - 使用 variant（C++17 提供）</li>
<li>强制转换 - 尽可能减少其使用；使用模板有助于这点 void* -&gt; <T></li>
<li>数组退化 - 使用 span（来自 GSL）</li>
<li>范围错误 - 使用 span</li>
<li>窄化转换 - 尽可能减少其使用，必须使用时则使用 narrow 或者
narrow_cast（来自 GSL）</li>
</ul>
<h1 id="p.5-优先使用编译器检查而非运行期检查">P.5:
优先使用编译器检查而非运行期检查</h1>
<ul>
<li>检查int的位数 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Int is an alias used for integers</span></span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(Int) &gt;= <span class="number">4</span>);    <span class="comment">// do: compile-time check</span></span><br></pre></td></tr></table></figure>
<ul>
<li>use the type system and replace Int with int32_t.</li>
</ul></li>
<li>注意指针和数组范围</li>
</ul>
<h2 id="p.7-catch-run-time-errors-early">P.7: Catch run-time errors
early</h2>
<ul>
<li>Avoid “mysterious” crashes.</li>
<li>注意数组越界、指针窄化、结构体不要转成string、非法输入</li>
</ul>
<h2 id="p.8-dont-leak-any-resources">P.8: Don’t leak any resources</h2>
<ul>
<li>使用RAII</li>
</ul>
<h2 id="p.9-dont-waste-time-or-space">P.9: Don’t waste time or
space</h2>
<ul>
<li><code>--</code>比<code>++</code>更高效</li>
</ul>
<h2 id="p.10-prefer-immutable-data-to-mutable-data">P.10: Prefer
immutable data to mutable data</h2>
<h2
id="p.11-encapsulate-messy-constructs-rather-than-spreading-through-the-code">P.11:
Encapsulate messy constructs, rather than spreading through the
code</h2>
<h2
id="p.12-use-supporting-tools-as-appropriate-77-p.13-use-support-libraries-as-appropriate">P.12:
Use supporting tools as appropriate 77 P.13: Use support libraries as
appropriate</h2>
<ul>
<li>不要造轮子</li>
</ul>
<h1 id="i-interface">I : interface</h1>
<ul>
<li>易于理解 高效 没有错误诱导 支持测试</li>
</ul>
<h2 id="i.1-使接口明确">I.1: 使接口明确</h2>
<ul>
<li>【简单】
函数不能基于声明于命名空间作用域的变量来作出影响控制流的决定。</li>
<li>【简单】 函数不能对声明于命名空间作用域的变量进行写入操作。</li>
<li>通过非局部变量（比如 errno）进行的报告经常被忽略。
<ul>
<li>替代方案: 抛出异常。异常是无法被忽略的。</li>
<li>其他形式: 避免通过非局部或者隐含的状态来跨越接口传递信息。 注意，非
const 的成员函数会通过对象的状态来向其他成员函数传递信息。</li>
<li>其他形式: 接口应当是函数或者一组函数集合。
函数可以是函数模板，而函数集合可以是类或者类模板。</li>
</ul></li>
</ul>
<h2 id="i.2-避免非-const-全局变量">I.2: 避免非 const 全局变量</h2>
<ul>
<li>非 const
全局变量能够隐藏依赖关系，并使这些依赖项可能出现无法预测的变动。</li>
<li>警告: 全局对象的初始化并不是完全有序的。
<ul>
<li>当使用全局对象时，应当用常量为之初始化。</li>
<li>即便对于 const 对象，也可能发生未定义的初始化顺序。</li>
</ul></li>
<li>全局对象通常优于单例。</li>
<li>全局常量是有益的。</li>
<li>针对全局变量的规则同样适用于命名空间作用域的变量。</li>
<li>一种方案是把数据定义为某个对象的状态，而把操作定义为其成员函数。</li>
<li>当然是有（罕见）例外的，比如 cin、cout 和 cerr。</li>
</ul>
<h2 id="i.3-避免使用单例">I.3: 避免使用单例</h2>
<ul>
<li>单例基本上就是经过伪装的更复杂的全局对象。</li>
<li>static 对象初始化并不会蕴含竞争条件。
<ul>
<li>不过，如果 X 的销毁中涉及了需要进行同步的操作的话,需要谨慎处理</li>
</ul></li>
</ul>
<h2 id="i.4-使接口严格和强类型化">I.4: 使接口严格和强类型化</h2>
<p>理由
类型是最简单和最好的文档，它们有定义明确的含义并因而提高了易读性，并且是在编译期进行检查的。
而且，严格类型化的代码通常也能更好地进行优化。</p>
<p>示例，请勿这样做 考虑：</p>
<p>void pass(void* data); // 使用弱的并且缺乏明确性的类型 void*
是有问题的 调用者无法确定它允许使用哪些类型，而且因为它并没有指定
const， 也不确定其数据是否会被改动。注意，任何指针类型都可以隐式转换为
void*， 因此调用者很容易提供这样的值给它。</p>
<p>被调用方必须以 static_cast 将数据强制转换为某个无验证的类型以使用它。
这样做易于犯错，而且啰嗦。</p>
<p>应当仅在设计中无法以 C++ 来予以描述的数据的传递时才使用 const
void*。请考虑使用 variant 或指向基类的指针来代替它。</p>
<p>替代方案: 通常，利用模板形参可以把 void* 排除而改为 T* 或者 T&amp;。
对于泛型代码，这些个 T 可以是一般模板参数或者是概念约束的模板参数。</p>
<p>示例，不好 考虑：</p>
<p>draw_rect(100, 200, 100, 500); // 这些数值什么意思？</p>
<p>draw_rect(p.x, p.y, 10, 20); // 10 和 20 的单位是什么？
很明显调用者在描述一个矩形，不明确的是它们都和其哪些部分相关。而且 int
可以表示任何形式的信息，包括各种不同单位的值，因此我们必须得猜测这四个
int 的含义。前两个很可能代表坐标对偶 x 和 y，但后两个是什么呢？</p>
<p>注释和参数的名字可以有所帮助，但我们可以直截了当：</p>
<p>void draw_rectangle(Point top_left, Point bottom_right); void
draw_rectangle(Point top_left, Size height_width);</p>
<p>draw_rectangle(p, Point{10, 20}); // 两个角点 draw_rectangle(p,
Size{10, 20}); // 一个角和一对 (height, width)
显然，我们是无法利用静态类型系统识别所有的错误的，
例如，假定第一个参数是左上角这一点就依赖于约定（命名或者注释）。</p>
<p>示例，不好 考虑：</p>
<p>set_settings(true, false, 42); // 这些数值什么意思？
各参数类型及其值并不能表明其所指定的设置项是什么以及它们的值所代表的含义。</p>
<p>下面的设计则更加明确，安全且易读：</p>
<p>alarm_settings s{}; s.enabled = true; s.displayMode =
alarm_settings::mode::spinning_light; s.frequency =
alarm_settings::every_10_seconds; set_settings(s);
对于一组布尔值的情况，可以考虑使用某种标记
enum；这是一种用于表示一组布尔值的模式。</p>
<p>enable_lamp_options(lamp_option::on |
lamp_option::animate_state_transitions); 示例，不好
下例中，接口中并未明确给出 time_to_blink 的含义：按秒还是按毫秒算？</p>
<p>void blink_led(int time_to_blink) // 不好 -- 在单位上含糊 { // ... //
对 time_to_blink 做一些事 // ... }</p>
<p>void use() { blink_led(2); } 示例，好 std::chrono::duration
类型可以让时间段的单位明确下来。</p>
<p>void blink_led(milliseconds time_to_blink) // 好 -- 单位明确 { // ...
// 对 time_to_blink 做一些事 // ... }</p>
<p>void use() { blink_led(1500ms); }
这个函数还可以写成使其接受任何时间段单位的形式。</p>
<p>template&lt;class rep, class period&gt; void
blink_led(duration&lt;rep, period&gt; time_to_blink) // 好 --
接受任何单位 { // 假设最小的有意义单位是毫秒 auto milliseconds_to_blink
= duration_cast<milliseconds>(time_to_blink); // ... // 对
milliseconds_to_blink 做一些事 // ... }</p>
<p>void use() { blink_led(2s); blink_led(1500ms); } 强制实施 【简单】
报告将 void* 用作参数或返回类型的情况 【简单】 报告使用了多个 bool
参数的情况 【难于做好】 查找使用了过多基础类型的参数的函数。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>Cpp17学习笔记</title>
    <url>/zyhjy/2022/09/15/Cpp17%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="stdstring_view"><code>std::string_view</code></h1>
<p><code>std::string_view</code> 是在 C++17
中引入的一个类，它提供了一个轻量级的、非拥有（non-owning）的字符串视图。它定义在
<code>&lt;string_view&gt;</code>
头文件中，通常用于高效处理和操作字符串，而无需进行不必要的内存分配或复制。</p>
<p>以下是一个简单示例，演示了如何使用
<code>std::string_view</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::string_view <span class="title">strView</span><span class="params">(<span class="string">&quot;Hello, World!&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;strView: &quot;</span> &lt;&lt; strView &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;长度: &quot;</span> &lt;&lt; strView.<span class="built_in">length</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 访问单个字符</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">char</span> c : strView) &#123;</span><br><span class="line">    std::cout &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 子字符串视图</span></span><br><span class="line">  std::string_view subView = strView.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;子字符串: &quot;</span> &lt;&lt; subView &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们创建了一个 <code>std::string_view</code> 对象
<code>strView</code>，它引用字符串 "Hello,
World!"。我们可以像操作常规字符串一样使用
<code>strView</code>，尽管它并不拥有底层的内存。我们可以打印视图，访问单个字符，获取视图的长度，并使用
<code>substr()</code> 函数获取子字符串视图。</p>
<p>以上代码的输出将会是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strView: Hello, World!</span><br><span class="line">长度: 13</span><br><span class="line">H e l l o ,   W o r l d !</span><br><span class="line">子字符串: Hello</span><br></pre></td></tr></table></figure>
<h2 id="参数传递">参数传递</h2>
<p>当使用 <code>std::string_view</code>
作为函数的参数时，通常推荐以传值（pass by value）的方式传递参数。由于
<code>std::string_view</code>
是一个轻量级的非拥有字符串视图，它本身只包含指向原始字符串的指针和长度信息，因此拷贝它的开销非常小。</p>
<p>传值方式的好处是，函数在接收 <code>std::string_view</code>
参数时会自动计算并存储指向原始字符串的指针和长度信息，这使得函数内部可以直接使用和操作该视图，而无需担心原始字符串的生命周期或内存管理。</p>
<p>传值方式的另一个好处是它允许函数在调用时对
<code>std::string_view</code> 参数进行隐式类型转换。这意味着您可以传递
<code>const char*</code>、<code>std::string</code>
或其他兼容类型的参数给函数，它们会自动转换为
<code>std::string_view</code>。</p>
<p>总之，当函数参数类型为 <code>std::string_view</code>
时，通常建议以传值方式传递参数，以获得较好的性能和灵活性。</p>
<h1 id="for_each"><code>for_each</code></h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ExecutionPolicy, <span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> UnaryFunction2 &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">for_each</span><span class="params">( ExecutionPolicy&amp;&amp; policy, ForwardIt first, ForwardIt last, UnaryFunction2 f )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>将<code>f</code>应用在<code>(first, last)</code>范围内<em>解引用</em>的结果</li>
<li><code>&lt;algorithm&gt;</code></li>
<li><code>for_each_n</code>
<ul>
<li>应用一个函数对象到序列的前 n 个元素</li>
</ul></li>
</ul>
<h1 id="stdvariant"><code>std::variant</code></h1>
<ul>
<li><code>&lt;variant&gt;</code></li>
<li>类型安全的union
<ul>
<li>类型不可为引用、数组、void</li>
<li>默认构造函数为第一个类型的构造函数
<ul>
<li><code>std::variant&lt;int, float&gt; v, w;</code></li>
<li>第一个类型必须拥有默认构造函数 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::variant&lt;std::monostate, S&gt; var; </span><br><span class="line"></span><br><span class="line"><span class="comment">// var.index() 现为 0 ——首个元素</span></span><br><span class="line"><span class="comment">// std::get&lt;S&gt; 将抛异常！我等需要赋一个值</span></span><br><span class="line"></span><br><span class="line">var = <span class="number">12</span>; </span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;S&gt;(var).i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
</ul>
<h1
id="decomposition-declarations"><code>Decomposition declarations</code></h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">queue&lt;tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">q.<span class="built_in">emplace</span>(sx, sy, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">auto</span> [x, y, state] = q.<span class="built_in">front</span>();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>Cpp20学习笔记</title>
    <url>/zyhjy/2022/09/17/Cpp20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="stdspant"><code>std::span&lt;T&gt;</code></h1>
<ul>
<li><code>#include &lt;span&gt;</code></li>
<li>a view/refer on contiguous sequence of objects
<ul>
<li>string_view 的扩展版，可以用于任何连续的对象上，包括string<br />
</li>
<li>not a owner</li>
</ul></li>
<li>由指向首元素的指针和长度组成</li>
<li>避免了一个array在传递给函数时退化成指针的情况</li>
<li>span可以推断出数组的长度 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// printSpan.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;span&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMe</span><span class="params">(std::span&lt;<span class="type">int</span>&gt; container)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;container.size(): &quot;</span> &lt;&lt; container.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">// (4)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e : container) std::cout &lt;&lt; e &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> arr[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;              <span class="comment">// (1)</span></span><br><span class="line">    <span class="built_in">printMe</span>(arr);</span><br><span class="line"></span><br><span class="line">    std::vector vec&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;     <span class="comment">// (2)</span></span><br><span class="line">    <span class="built_in">printMe</span>(vec);</span><br><span class="line"></span><br><span class="line">    std::array arr2&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;; <span class="comment">// (3)</span></span><br><span class="line">    <span class="built_in">printMe</span>(arr2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建方式 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::vector myVec&#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">	</span><br><span class="line">std::span mySpan1&#123;myVec&#125;;                                        // (1)</span><br><span class="line">std::span mySpan2&#123;myVec.data(), myVec.size()&#125;;                   // (2)</span><br></pre></td></tr></table></figure></li>
<li>常数时间 拷贝 移动 赋值<br />
</li>
<li>span可以修改指向的对象
<ul>
<li>string_view不可 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::transform(span2.begin(), span2.end(),            // (3)  </span><br><span class="line">           span2.begin(), </span><br><span class="line">           [](int i)&#123; return i * i; &#125;);</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>Gem5</title>
    <url>/zyhjy/2022/09/22/gem5/</url>
    <content><![CDATA[<p>ROB</p>
<p>Branch Misspeculation 时钟触发tick() 遍历所有线程（what is thread） -
检查stall/squash 如果exe不在squash - IEW::executeInsts() - Check if
branch prediction was correct, if not then we need to tell commit to
squash in flight instructions. - squashDueToBranch</p>
<p>build/ARM/gem5.opt configs/example/se.py
--cmd=tests/test-progs/hello/bin/arm/linux/hello --cpu-type=O3CPU
--caches --l1d_size=64kB --l1i_size=16kB /home/zyh/2022fall/gem5#
build/X86/gem5.opt configs/example/se.py
--cmd=tests/test-progs/hello/bin/x86/linux/hello --cpu-type=O3CPU
--caches --l1d_size=64kB --l1i_size=16kB</p>
<h1 id="fetch">Fetch</h1>
<p>set(toIEW-&gt;commitInfo[tid].pc, fromIEW-&gt;pc[tid]);</p>
<p>squash(*fromCommit-&gt;commitInfo[tid].pc,
fromCommit-&gt;commitInfo[tid].doneSeqNum,
fromCommit-&gt;commitInfo[tid].squashInst, tid);</p>
<p>Fetch::doSquash（）</p>
<p>set(pc[tid], new_pc); decoder[tid]-&gt;reset(); memReq[tid] = NULL;
fetchStatus[tid] = Squashing; fetchQueue[tid].clear();</p>
<p>cpu-&gt;removeInstsNotInROB(tid);</p>
<pre><code>    squashInstIt(inst_it, tid);
            (*instIt)-&gt;setSquashed();
            removeList.push(instIt);</code></pre>
<p>cpu的instList里存了所有当前在流水线中的指令(包括在ROB的)</p>
<h1 id="commit">commit</h1>
<p>rob-&gt;squash() Status[tid] = Squashing;</p>
<h1 id="decode">decode</h1>
<p>fromFetch-&gt;insts[i]-&gt;setSquashed();
toFetch-&gt;decodeUnblock[tid] = 1;</p>
<h1 id="rename">rename</h1>
<p>toDecode-&gt;renameUnblock[tid] = 1; serializeInst[tid] = NULL;
Status[tid] = Squashing; renameStatus[tid] = Squashing;</p>
<h1 id="iew">iew</h1>
<p>收到通知 IEW::checkSignalsAndUpdate - squash(tid);
instQueue.squash(tid);
ldstQueue.squash(fromCommit-&gt;commitInfo[tid].doneSeqNum, tid);
emptyRenameInsts(tid);</p>
<p>通知 set(toCommit-&gt;pc[tid], inst-&gt;pcState());
inst-&gt;staticInst-&gt;advancePC(*toCommit-&gt;pc[tid]);</p>
<pre><code>    toCommit-&gt;mispredictInst[tid] = inst;
    toCommit-&gt;includeSquashInst[tid] = false;</code></pre>
<p>加了一页cpu状态和thread状态，gem5这边thread状态是跟流水线相关的，之后cpustate统称为thread状态
1、目标加一个当前整理gem5 cpu
state的原因，是由于之前是FMTM紧耦合，现在FM到QEMU去了，希望看到misprediction的时候可以用cpustate但是不会提交修改其状态，qemu给其需要的错误路径，让TM这边可以有中间结果进行流转
2、分支预测或cpu流水线流程执行的时候，相关cpu状态是copy备份了一份还是有更新把中间结果存到队列里？是否有ROB队列，其作用是什么？
主要整理一下分支预测到分支预测结果出来前，这些中间结果是怎么流转的。(似乎没有备份，有队列来存后面回退)</p>
<p>scoreboard 跟踪记录物理reg是否可使用 renameMap记录了idx-&gt;对应的reg
Rename::renameDestRegs(const DynInstPtr &amp;inst, ThreadID
tid)将inst-&gt;destRegIdx对应的reg的指针取出由inst保存，并将map中inst-&gt;destRegIdx对应的reg换成从freelist取出的reg
指令执行后由forward恢复</p>
<p>instruction’s view of the register file(s) -&gt; actual storage
locations -
类似虚拟内存到物理内存的映射，我们需要把指令视角下的寄存器映射到扁平化的物理内存上
- 该部分工作由cpu完成， - ISA负责解码后的指令需要的寄存器(指令视角)
,cpu将寄存器翻译成物理内存(寄存器) - %g1 --&gt; phy index[9]</p>
<p>/// 使用直接映射的问题
虚拟内存空间可能非常大（可能有间隙）并映射到较小的物理空间，
或者它可能很小并映射到较大的物理空间，其中额外的空间用于其他时间使用的其他虚拟空间。
您需要确保使用正确的尺寸（展平后）来调整表格的大小，因为这是可能的选择空间</p>
<p>另一个棘手的部分来自我们在索引中添加偏移量以区分整数、浮点数和杂项。
这些偏移在预展平世界中可能是一回事，但在展平后世界中需要是另一回事，以防止事物相互重叠而不会留下间隙。在这里很容易犯错，这也是我不喜欢这种抵消想法作为将不同类型分开的一种方式的原因之一。我宁愿看到一个二维索引，其中第二个坐标是寄存器类型。但在当今世界上，这是你必须跟踪的事情。</p>
<p>gem5选择使用rename and map</p>
<p>Relative
相对寄存器索引是在机器指令中编码的索引。每类寄存器（整数、浮点等）都有一个单独的索引空间，从
0
开始。寄存器类由操作码隐含。因此，源寄存器字段中的值“1”可能意味着整数寄存器1（例如，“%r1”）或浮点寄存器1（例如，“%f1”），这取决于指令的类型</p>
<p>Unified
虽然相对寄存器索引有助于保持指令编码紧凑，但它们是模棱两可的，因此不便于管理依赖项等事情。为了避免这种歧义，解码器通过添加特定于类的偏移量将每个相对索引范围重新定位到唯一位置，将相对寄存器索引映射到统一的寄存器空间。整数寄存器未修改，并继续从零开始。浮点寄存器索引（至少）偏移整数寄存器的数量，以便第一个
FP
寄存器（例如，“%f0”）获得大于最后一个整数寄存器的统一索引。类似地，杂项（又名控制）寄存器映射到
FP 寄存器索引空间的末尾</p>
<p>Flattened
统一的寄存器索引提供了对在执行中的给定点可作为指令操作数访问的所有寄存器的明确描述。不幸的是，由于某些
ISA
的复杂特性，它们并不总是明确地识别指令所引用的实际状态。例如，在具有寄存器窗口（尤其是
SPARC）的 ISA
中，特定的寄存器标识符（例如“%o0”）在“保存”或“恢复”操作后将引用与以前不同的寄存器。一些
ISA 具有在正常操作中隐藏的寄存器，但在发生中断时（例如，ARM
的特定于模式的寄存器）或在显式管理器控制下（例如，SPARC
的“备用全局变量”）被映射到普通寄存器之上。</p>
<p>我们通过维护一个扁平的寄存器空间来解决这个问题，该空间为每个唯一的寄存器存储位置提供不同的索引。例如，SPARC扁平寄存器空间的整数部分对全局变量和备用全局变量以及每个可用寄存器窗口都有不同的索引。从统一或相对寄存器索引转换为扁平寄存器索引的“扁平化”过程因
ISA 而异。在某些 ISA
上，映射是微不足道的，而另一些则使用表查找来进行转换。</p>
<p>生成统一寄存器索引和扁平寄存器索引之间的一个关键区别是前者总是可以静态完成，而后者通常取决于动态处理器状态。也就是说，从相对索引到统一索引的转换仅取决于指令本身提供的上下文（这很方便，因为转换是在解码器中完成的）。相反，到扁平寄存器索引的映射可能取决于处理器状态，例如中断级别或
SPARC 上的当前窗口指针。</p>
<p>组合寄存器索引类型 尽管修改寄存器索引的典型过程是相对 -&gt; 统一
-&gt; 扁平 ，但事实证明，相对与统一以及 扁平 与非 扁平
是正交属性。相对与统一指示索引是相对于其寄存器类（整数、FP
或杂项）的基址寄存器还是添加了其类的基址偏移量。扁平化与非扁平化表明索引是否已调整到帐户用于运行时上下文，例如寄存器窗口调整或备用寄存器文件模式。因此，相对扁平化的寄存器索引是其中已经考虑了运行时上下文，但仍相对于其类的基本偏移量表示的索引。</p>
<p>一组特定于类的偏移量用于从相对索引生成统一索引，无论索引是扁平的还是非扁平的。因此，即使在使用扁平地址时，偏移量也必须足够大以分隔寄存器类。因此，非扁平的统一寄存器空间通常是不连续的。</p>
<p>诸如 O3 之类的无序 CPU
模型通过将这些架构寄存器（使用扁平寄存器索引）重命名为底层物理寄存器文件，增加了另一层复杂性</p>
<p>静态工具 StaticInst 为二进制指令提供所有静态信息和方法。</p>
<p>它包含以下信息/方法：</p>
<p>指示它是哪种指令的标志（整数、浮点、分支、内存屏障等） 指令的 op 类
源和目标寄存器的数量 使用的整数和 FP 寄存器的数量 将二进制指令解码为
StaticInst 的方法 虚函数
execute()，它定义了如何为指令采取特定的架构操作（例如读取
r1、r2、添加它们并存储在 r3 中。） 处理启动和完成内存操作的虚函数
用于将内存操作拆分为两个操作的模型分别执行地址计算和内存访问的虚拟函数
反汇编指令的方法，以人类可读的格式打印出来。（例如 addq r1 r2 r3）
它没有动态信息，例如指令的 PC 或源寄存器的值或结果。这允许将 StaticInst
一对一映射到唯一的二进制机器指令。我们通过在 hash_map 中缓存二进制指令到
StaticInst
的映射来利用这一事实，允许我们只解码二进制指令一次，并在其余时间直接使用
StaticInst。</p>
<p>每条 ISA 指令都从 StaticInst 派生并实现自己的构造函数 execute()
函数，如果是内存指令，则实现内存访问函数。有关如何指定这些 ISA
指令的详细信息，请参阅 ISA_description_system。</p>
<p>动力装置 DynInst
用于保存有关指令的动态信息。这对于更详细的模型或无序模型是必要的，这两种模型都可能需要静态指令之外的额外信息才能正确执行指令。它存储的一些动态信息包括：</p>
<p>指令的PC 源寄存器和目标寄存器的重命名寄存器索引 预测的下一代 PC
指令结果 指令的线程号 正在执行指令的 CPU 指令是否被压缩 此外，DynInst
提供了 ExecContext 接口。当 ISA 指令执行时，DynInst 作为 ExecContext
传入，处理 ISA 对 CPU 状态的所有访问。</p>
<p>详细的 CPU 模型可以从 DynInst 派生并创建自己的特定 DynInst
子类，这些子类实现可能需要的任何其他状态或功能。有关此示例，请参见
src/cpu/o3/alpha/dyn_inst.hh。</p>
<p>decode收到squash信号后将该线程的，指令标记为Squashed，在随后的执行中，直接删除指令</p>
<p>-- help 打印所有指令</p>
<h1 id="ldmstm">ldmstm</h1>
<ul>
<li>arm32中使用，arm64已不再用</li>
<li>load multiple registers
<ul>
<li>包括pc</li>
<li>修改pc时被认为是控制指令</li>
</ul></li>
</ul>
<h1 id="gem5执行所有指令时都会检查cc-reg">gem5执行所有指令时都会检查CC
reg</h1>
<ul>
<li>如果不满足xc-&gt;setPredicate(false);
<ul>
<li>不会真正执行指令</li>
</ul></li>
<li>问： testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV,
condCode)是根据什么判断是否mis branch</li>
</ul>
]]></content>
      <categories>
        <category>Gem5</category>
      </categories>
  </entry>
  <entry>
    <title>Effective C++(3)--资源管理</title>
    <url>/zyhjy/2022/07/20/Effective%20C++(3)/</url>
    <content><![CDATA[<h1 id="ch3-资源管理">Ch3 资源管理</h1>
<ul>
<li>资源：使用后要还给系统</li>
</ul>
<h2 id="以对象管理资源">13 以对象管理资源</h2>
<ul>
<li>RAII （Resource Acquisition Is Initialization）</li>
<li>把资源放入对象内，可倚赖C++析构函数自动调用机制确保函数被释放
<ul>
<li>如 auto_ptr， shared_ptr， heap_based</li>
</ul></li>
</ul>
<h2 id="在资源管理类中小心copy行为">14 在资源管理类中小心copy行为</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">(Mutex* pm)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">(Mutex* pm)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex* pm)</span></span></span><br><span class="line"><span class="function">        : mutexPtr(pm)</span></span><br><span class="line"><span class="function">    &#123;</span> <span class="built_in">lock</span>(mutexPtr); &#125;</span><br><span class="line">    ~<span class="built_in">Lock</span>() &#123; <span class="built_in">unlock</span>(mutexPtr); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex* mutexPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>当发生复制时，有两种选择：
<ol type="1">
<li>禁止复制 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span> : <span class="keyword">private</span> Uncopyable &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>对底部资源使用引用计数法
<ul>
<li>用shared_ptr替换Lock中的raw pointer</li>
</ul></li>
<li>复制底部资源</li>
<li>转移底部资源所有权</li>
</ol></li>
</ul>
<h2 id="在资源管理类中提供对原始资源的访问">15
在资源管理类中提供对原始资源的访问</h2>
<ul>
<li>APIs往往有这样的需求
<ul>
<li>智能指针重载了operator-&gt;和operator*</li>
</ul></li>
<li>显式转换较为安全</li>
<li>隐式转换对客户比较方便 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">FontHandle <span class="title">getFont</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">releaseFont</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Font</span><span class="params">(FontHandle fh)</span></span></span><br><span class="line"><span class="function">        : f(fh)</span></span><br><span class="line"><span class="function">    &#123;</span> &#125;</span><br><span class="line">    ~<span class="built_in">Font</span>() &#123; <span class="built_in">releaseFont</span>(f); &#125;</span><br><span class="line">    <span class="function">FontHandle <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> f; &#125; <span class="comment">/// 显式转换函数</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">FontHandle</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> f; &#125; <span class="comment">/// 隐式转换函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FontHandle f;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="成对使用new和delete时要采用相同的形式">16
成对使用new和delete时要采用相同的形式</h2>
<ul>
<li>new -- delete</li>
<li>new [] -- delete []</li>
<li>不要对数组形式做typedf</li>
</ul>
<h2 id="以独立语句将newed对象置入智能指针">17
以独立语句将newed对象置入智能指针</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">priority</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processWidget</span><span class="params">(std::shared_ptr&lt;Widget&gt; pw, <span class="type">int</span> priority)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">processWidget</span>(<span class="keyword">new</span> Widget, <span class="built_in">priority</span>()); <span class="comment">/// wrong! std::shared_ptr&lt;Widget&gt;的构造函数是explicit的，无法隐式转换</span></span><br><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">priority</span>()); <span class="comment">/// maybe resource leak! 假如执行顺序为 new --&gt; priority() --&gt; shared_ptr 并且 priority() 出错</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line"><span class="built_in">processWidget</span>(pw, <span class="built_in">priority</span>()); <span class="comment">/// ok, no leak!</span></span><br></pre></td></tr></table></figure>
<ul>
<li>编译器只在一条语句内拥有执行顺序的自由度</li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>Effective C++(4)--设计与声明</title>
    <url>/zyhjy/2022/10/22/Effective%20C++(4)/</url>
    <content><![CDATA[<h2 id="让接口容易被正确使用不易被误用">18
让接口容易被正确使用，不易被误用</h2>
<h3 id="考虑用户可能犯怎样的错误">考虑用户可能犯怎样的错误</h3>
<ul>
<li>容易引起错误的做法 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> month, <span class="type">int</span> day, <span class="type">int</span> year);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>wrapper types
<ul>
<li>enum不具备类型安全性，可被用作ints <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Day</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Day</span><span class="params">(<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function">    : val(d) &#123;</span>&#125;    </span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">const</span> Month&amp; m, <span class="type">const</span> Day&amp; d, <span class="type">int</span> year);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Date</span>(<span class="number">30</span>, <span class="number">3</span>, <span class="number">1995</span>); <span class="comment">/// wrong! 不正确的类型</span></span><br><span class="line"><span class="built_in">Date</span>(<span class="built_in">Day</span>(<span class="number">30</span>), <span class="built_in">Month</span>(<span class="number">3</span>), <span class="built_in">Year</span>(<span class="number">1995</span>)); <span class="comment">/// wrong! 不正确的类型</span></span><br><span class="line"><span class="built_in">Date</span>(<span class="built_in">Month</span>(<span class="number">3</span>), <span class="built_in">Day</span>(<span class="number">30</span>), <span class="built_in">Year</span>(<span class="number">1995</span>)); <span class="comment">/// OK! 类型正确</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Month</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Month <span class="title">Jan</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Month</span>(<span class="number">1</span>); &#125; <span class="comment">/// 每次调用都会触发一次构造函数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Month <span class="title">Feb</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="type">static</span> <span class="keyword">auto</span> feb = <span class="built_in">Month</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> feb; </span><br><span class="line">    &#125; <span class="comment">/// only call once</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">static</span> Month <span class="title">Dec</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Month</span>(<span class="number">12</span>); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Month</span><span class="params">(<span class="type">int</span> m)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Date</span>(Month::<span class="built_in">Mar</span>(), <span class="built_in">Day</span>(<span class="number">30</span>), <span class="built_in">Year</span>(<span class="number">1995</span>));</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3
id="限制类型内什么事可做什么事不可做">限制类型内什么事可做，什么事不可做</h3>
<pre><code>- 常见的限制是加上const</code></pre>
<h3
id="除非有好理由尽量使types的行为与内置类型一致">除非有好理由，尽量使types的行为与内置类型一致</h3>
<pre><code>- 如ints，对a*b赋值不合法
- STL基本一致</code></pre>
<h3 id="消除客户的管理资源责任">消除客户的管理资源责任</h3>
<ul>
<li>例，工厂函数：返回智能指针
<ul>
<li><code>std::shared_ptr&lt;TimeKeeper&gt; getTimeKeeper();</code></li>
</ul></li>
<li><code>std::shared_ptr</code>允许指针被建立起来时指定一个资源释放函数（删除器，deleter）
<ul>
<li>auto_ptr不支持 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;TimeKeeper&gt; <span class="title">pTime</span><span class="params">(<span class="keyword">static_cast</span>&lt;TimeKeeper*&gt;(<span class="number">0</span>), getRidOfClock)</span></span>;</span><br><span class="line"><span class="comment">/// getRidOfClock是函数，删除器</span></span><br></pre></td></tr></table></figure></li>
<li>避免了DLL问题</li>
<li><code>std::shared_ptr</code>
<ul>
<li>是raw pointer两倍大（计数，删除器）</li>
<li>以virtual形式调用删除器</li>
<li>修改引用计数时线程同步化带来开销</li>
</ul></li>
</ul></li>
</ul>
<h2 id="设计class犹如设计type">19 设计class犹如设计type</h2>
<ul>
<li>对象应该如何被创建和销毁
<ul>
<li>构造函数</li>
<li>析构函数</li>
<li>内存分配和释放函数
<ul>
<li>operator new</li>
<li>operator new[]</li>
<li>operator delete</li>
<li>operator delete[]</li>
</ul></li>
</ul></li>
<li>对象的初始化和赋值该有什么的差别
<ul>
<li>拷贝构造函数 和 拷贝赋值函数</li>
</ul></li>
<li>什么是新type的合法值</li>
<li>新type需要配合inheritance graph吗</li>
<li>新type需要什么样的转换
<ul>
<li>如果允许T1对象被隐式转换为T2，
<ul>
<li>则需要在class T1内实现operator T2</li>
<li>或在class T2内实现一个non-explicit-one-argument的构造函数</li>
</ul></li>
</ul></li>
<li>什么样的操作符和函数对新type是合理的</li>
<li>什么样的标准函数应该驳回</li>
<li>谁该去用新type
<ul>
<li>哪些成员为 pubulic protected private</li>
<li>哪些class function为friends</li>
</ul></li>
<li>什么是新type的未声明接口</li>
<li>新type有多么一般化
<ul>
<li>如果定义一整个types家族，考虑template</li>
</ul></li>
<li>真的需要一个新type吗
<ul>
<li>如果定义新的derived
class只是为已有的class添加机能，考虑non-member函数或templates</li>
</ul></li>
</ul>
<h2 id="prefer-pass-by-reference-to-const-to-pass-by-value">20 Prefer
pass-by-reference-to-const to pass-by-value</h2>
<ul>
<li>前者效率高，且避免切割问题</li>
<li>以上规则并不适用于内置类型，STL的迭代器和函数对象。
<ul>
<li>pass-by-value往往更合适</li>
</ul></li>
<li>对象小并不意味着copy构造函数不昂贵
<ul>
<li>许多对象如大多数STL容器，内含的东西只比指针多一些，但复制这种对象却包括复制那些指针指向的每一样东西</li>
</ul></li>
</ul>
<h2 id="必须返回对象时别妄想返回其reference">21
必须返回对象时，别妄想返回其reference</h2>
<ul>
<li>构造函数是必须承担的成本</li>
</ul>
<h2 id="将成员变量声明为private">22 将成员变量声明为private</h2>
<ul>
<li>为class提供充分实现弹性</li>
<li><code>protected</code>成员变量的封装性并没有高过<code>public</code>成员变量
<ul>
<li><code>protected</code>成员变量的改变将会影响所有的<code>derived class</code></li>
</ul></li>
</ul>
<h2 id="prefer-non-member-non-friend-fuctions-to-member-functions">23
Prefer non-member non-friend fuctions to member functions</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrowser</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearHistory</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeCookies</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>许多用户想一次执行所有这些动作，那么哪种实现好呢？ <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// member函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrowser</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearEverything</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// non-member函数，更好的实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    wb.<span class="built_in">clearCache</span>();</span><br><span class="line">    wb.<span class="built_in">clearHistory</span>();</span><br><span class="line">    wb.<span class="built_in">removeCookies</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>non-member</code>函数
<ul>
<li>可允许对WebBrowser相关机能有较大的包裹弹性，最终导致较低的编译相依度，增加WebBrowser的可延展性
<ul>
<li>通过namespace分割不同类别的功能，并可以向namespace中添加新的non-member函数扩充</li>
</ul></li>
<li>原因，该函数并不需要看到WebBrowser内部的成员变量</li>
</ul></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// non-member函数，一般的做法，将两者放在同一个namespace</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WebBrowser</span> &#123; ... &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>namespace可跨越多个源码文件而classes不同，例如： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webbrowser.h -- 这个头文件针对class WebBrowser自身及其核心机能</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WebBrowser</span> &#123; ... &#125;;</span><br><span class="line">    ... <span class="comment">// 核心机能，例如所有客户都需要的non-member函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webbrowserbookmarks.h</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line">    ... <span class="comment">// 与书签相关的便利函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webbrowsercookies.h</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line">    ... <span class="comment">// 与cookie相关的便利函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这正是C++标准程序库的组织方式
<ul>
<li>std命名空间分散在许多头文件
<ul>
<li><vector>, <algorithm>, <memory> ...</li>
</ul></li>
<li>允许客户只对他们所用的一小部分系统形成编译相依
<ul>
<li>此方式并不适用于class成员函数，一个class必须整体定义，不能被分割为片段</li>
</ul></li>
</ul></li>
</ul>
<h2 id="若所有参数皆需类型转换请为此采用non-member函数">24
若所有参数皆需类型转换，请为此采用non-member函数</h2>
<ul>
<li>令class支持隐式转换通常是糟糕的主意
<ul>
<li>有例外，如建立在数值类型 ### 设计一个class表示有理数 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">int</span> numerator = <span class="number">0</span>,       <span class="comment">/// 构造函数刻意不为explicit</span></span><br><span class="line">             <span class="type">int</span> denominator = <span class="number">1</span>);    <span class="comment">/// 允许int-to-Rational隐式转换</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numerator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">denominator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
#### Rational支持算术运算诸如加法、乘法</li>
</ul></li>
<li>member or non-member func？ ##### member函数 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">const</span> Rational <span class="keyword">operator</span>* (<span class="type">const</span> Rational&amp; rhs) <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>可以支持两个有理数相乘</li>
<li>但是混合算术只有一半行得通,不满足交换律 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">result = oneHalf * <span class="number">2</span>;   <span class="comment">// good</span></span><br><span class="line">result = <span class="number">2</span> * oneHalf;   <span class="comment">// wrong</span></span><br></pre></td></tr></table></figure></li>
<li>oneHalf是一个内含operator*的class的对象，所以编译器调用该函数</li>
<li>然而整数2没有相应的class，也就是没有operator<em>成语函数；编译器会尝试寻找形如以下这般调用的non-member
operator</em>(在命名空间或global作用域内): <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">result = operator*(2, oneHalf);   // wrong,本例并不存在这样的函数，查找失败</span><br></pre></td></tr></table></figure></li>
<li>第一种发生了隐式转换 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// result = oneHalf * 2;   // good, non-expicit构造函数</span></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="function"><span class="type">const</span> Rational <span class="title">temp</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">result = oneHalf * temp;</span><br></pre></td></tr></table></figure></li>
<li>第二种无法触发non-expicit构造函数 ##### non-member函数</li>
<li>允许编译器在每一个实惨上执行隐式类型转换 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>* (<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(), </span><br><span class="line">                    lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominator</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Rational <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">result = oneHalf * <span class="number">2</span>;   <span class="comment">// ok</span></span><br><span class="line">result = <span class="number">2</span> * oneHalf;   <span class="comment">// ok</span></span><br></pre></td></tr></table></figure></li>
<li>此处不需要成为friend函数 ##### --&gt;&gt; template class</li>
<li>见条款46 ###
如果需要为某个函数的所有参数(包括this指针所指的隐喻参数)进行类型转换，则该函数必须为non-member</li>
</ul>
<h1 id="考虑写出一个不抛异常的swap函数">25
考虑写出一个不抛异常的swap函数</h1>
<ul>
<li>swap
<ul>
<li>STL的一部分</li>
<li>异常安全性编程的脊柱(见条款29)</li>
<li>处理自我赋值可能性的常见机制 ## 缺省情况下标准库的swap
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">        a = b;</span><br><span class="line">        b = a;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>只要T支持拷贝构造函数和拷贝赋值函数 ## pimpl手法 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetImpl</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; v;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs) &#123; <span class="comment">/// 复制Widget时，复制其WidgetImpl对象</span></span><br><span class="line">        ...</span><br><span class="line">        *pImpl = *(rhs.pImpl);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImpl* pImpl;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>要置换Widget时，我们只需要置换起pImpl指针,但缺省算法调用还复制了三个WidgetImpl对象
###
我们希望告诉std::swap当Widgets被置换时应该做的是置换其内部的pImpl指针</li>
<li>将std::swap针对Widget特化 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="comment">/// 表示它是std::swap的一个全特化</span></span><br><span class="line">    <span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt;(Widget&amp; a, Widget&amp; b) &#123; <span class="comment">/// &#x27;&lt;Widget&gt;&#x27;表明“针对T是Widget”而设计</span></span><br><span class="line">        <span class="built_in">swap</span>(a.pImpl, b.pImpl);     <span class="comment">/// 无法通过编译, pImpl is private data</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>当一般性的swap template施行于Widgets上时便会启用这个版本</li>
<li>通常我们不被允许改变std命名空间内的任何东西，但可以为标准template制造特化版本
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">const</span> Widget&amp; other)</span> </span>&#123; <span class="comment">/// 复制Widget时，复制其WidgetImpl对象</span></span><br><span class="line">        <span class="keyword">using</span> std::swap;</span><br><span class="line">        <span class="built_in">swap</span>(pImpl, other.pImpl);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="comment">/// 表示它是std::swap的一个全特化</span></span><br><span class="line">    <span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt;(Widget&amp; a, Widget&amp; b) &#123; <span class="comment">/// &#x27;&lt;Widget&gt;&#x27;表明“针对T是Widget”而设计</span></span><br><span class="line">        a.<span class="built_in">swap</span>(b);     <span class="comment">/// OK!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>该做法与STL容器具有一致性（public swap + std::swap特化版本） ##
Widget与WidgetImpl都是template <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetImpl</span> &#123;...&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;...&#125;;</span><br></pre></td></tr></table></figure> ### 偏特化</li>
<li>放个swap成员函数与之前相同，但是像上述方法一样特化std::swap会遇上乱流
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">const</span> Widget&amp; other)</span> </span>&#123; </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">    <span class="type">void</span> swap&lt;Widget&lt;T&gt;&gt;(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b) &#123; <span class="comment">/// 错误，不合法</span></span><br><span class="line">        a.<span class="built_in">swap</span>(b); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>C++只允许对<code>class template</code>偏特化，不允许对<code>function template</code>(<code>std::swap</code>)偏特化
<ul>
<li>全特化是所有的模板参数都被进行特化，偏特化也就是局部的参数特化</li>
<li>此处只对Widget特化，没有特化T，所以为偏特化</li>
</ul></li>
</ul>
<h3 id="重载1">重载(1)</h3>
<ul>
<li>当打算偏特化一个function
template时，惯常做法是<code>添加一个重载版本</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="comment">/// std::swap的重载版本</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span> </span>&#123; <span class="comment">/// 错误，不合法</span></span><br><span class="line">        a.<span class="built_in">swap</span>(b); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一般而言行得通，但是std是个特殊的命名空间
<ul>
<li>客户可以全特化std内的template</li>
<li>但不可添加新的template、class、function等任何东西</li>
</ul></li>
</ul></li>
<li><h3 id="重载2">重载(2)</h3></li>
<li>将<code>重载版本</code>放在新的命名空间 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Widget</span> &#123;...&#125;;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>现在，如果想置换两个Widget对象因而调用swap，C++的名称查找法则(<code>name lookup rules</code>;<code>argument-dependent lookup</code>或<code>Koenig lookup</code>)会找到WidgetStuff空间内的swap</li>
</ul>
<h2 id="应该调用哪个swap">应该调用哪个swap?</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(T&amp; obj1, T&amp; obj2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;    <span class="comment">// 令std::swap在此函数内可用</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">swap</span>(obj1, obj2);   <span class="comment">// 为T型对象调用最佳swap版本</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用优先级(以T是Widget为例):
<ol type="1">
<li><code>WidgetStuff::swap</code></li>
<li><code>template&lt;&gt; void swap&lt;Widget&gt;</code></li>
<li><code>std::swap</code></li>
</ol></li>
</ul>
<h2 id="总结">总结</h2>
<h3
id="如果swap的缺省实现代码提供足够的效率不需要额外做任何事">如果swap的缺省实现代码提供足够的效率，不需要额外做任何事</h3>
<h3
id="如果swap的缺省实现代码效率不足试着做以下事情">如果swap的缺省实现代码效率不足，试着做以下事情:</h3>
<ol type="1">
<li>提供一个public swap成员函数，高效置换
<ul>
<li>成员版的swap不可抛出异常
<ul>
<li>这是帮助class和class template提供强烈的异常安全保障</li>
</ul></li>
</ul></li>
<li>在class或template所在命名空间内提供一个non-member
swap，并调用上述成员函数</li>
<li>如果正在编写class而非class
template，为class特化std::swap,并调用成员函数</li>
</ol>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>Docker使用Tips</title>
    <url>/zyhjy/2022/10/26/Docker%E4%BD%BF%E7%94%A8tips/</url>
    <content><![CDATA[<h1 id="docker基本命令">docker基本命令</h1>
<h2 id="查看docker占用空间">查看docker占用空间</h2>
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker system df</span><br></pre></td></tr></table></figure></code></pre>
<h2 id="清理无用镜像缓存挂载数据">清理无用镜像、缓存、挂载数据：</h2>
<ul>
<li><code>docker system prune -a</code>
<ul>
<li>已停止的容器（container）</li>
<li>未被任何容器所使用的卷（volume）</li>
<li>未被任何容器所关联的网络（network）</li>
<li>所有悬空镜像（image）</li>
</ul></li>
</ul>
<h2 id="docker导出载入镜像库里的镜像">docker导出/载入镜像库里的镜像</h2>
<pre><code>- `docker save -o qemu-gem5-o3.tar  qemu-gem5-o3:v2.0` REPOSITORY:TAG
- 载入镜像`docker load &lt; images/qemu-gem5-o3.tar`</code></pre>
<h1 id="其他">其他</h1>
<h2 id="容器的磁盘占用">容器的磁盘占用</h2>
<pre><code>- 每次创建一个容器时，都会有一些文件和目录被创建，
    - 例如：`/var/lib/docker/containers/ID`目录，
    - 如果容器使用了默认的日志模式，他的所有日志都会以JSON形式保存到此目录下。
    - `/var/lib/docker/overlay2` 目录下含有容器的读写层，如果容器使用自己的文件系统保存了数据，那么就会写到此目录下。
- 进入到/var/lib/docker/containers 目录下 通过 du -h --max-depth=1 查找大文件占用,发现这些文件中占用空间最大的是***-json.log**文件。而此文件的内容为docker生成的日志文件。
- 然后可使用如下命令对该文件的内容进行清理：`cat /dev/null &gt; *-json.log`清理完成可不重启服务，
    - 但如果允许建议重启一下docker服务。在此执行`df -h`命令之后，你会发现overlay2所占的磁盘空间已经减小。

- 可以定期删除的地方，有3. ipch（可完全删除）</code></pre>
<h2 id="vscode-server-no-space-left-on-device">vscode-server : No space
left on device</h2>
<ul>
<li>删除diff和merged下的bin文件<code>rm -rf ~/.vscode-server/bin/*</code></li>
</ul>
<h2
id="docker中使用了叫overlay2的层叠式结构">docker中使用了叫overlay2的层叠式结构，</h2>
<ul>
<li><p>为了简化存储，一个容器运行后会直接把镜像的存储状况作为容器的存储状况，然后针对容器运行产生的任何改动，都会在容器下相关目录中进行存储差分信息，也就是说一个容器中的存储情况由镜像原始存储情况和改动差分内容共同组成。</p></li>
<li><p>以centos为例，docker的默认存储路径位于/var/lib/docker</p>
<ul>
<li>其中container文件夹保存着容器的相关信息，</li>
<li>image保存着镜像的相关信息，overlay2保存着容器虚拟文件系统的相关信息。
### overlay2中有diff目录和merged目录，</li>
</ul></li>
<li><p>diff中保存的就是差分信息</p></li>
<li><p>merged是在容器运行时才会出现的存储情况集合，我们可以直接对差分信息进行修改，也可以在merged中进行修改，修改后的结果也会出现在diff中，同时容器内部也会直观的看到我们的修改内容</p></li>
</ul>
<p>docker exec -it
f9922cef36973708172b909b7f3115248ebca48a359bef99c0051cd8c87ba89d bash
docker run -it -v ~/FDU/PPI/2023spring:/home gem5-amd64-env</p>
<h1 id="安装docker">安装docker</h1>
<ul>
<li>用国内 daocloud 一键安装命令：
<code>curl -sSL https://get.daocloud.io/docker | sh</code></li>
</ul>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title>Tomasulo算法</title>
    <url>/zyhjy/2022/11/13/Tomasulo%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="背景">背景</h3>
<ul>
<li>流水线运行的一个主要限制是：它们使用循序指令发射与执行的方式 ###
思想</li>
<li>动态调度 ### 乱序执行</li>
<li>操作数可用时立即执行程序</li>
<li>指令的循序发射以及乱序执行 ### 寄存器重命名</li>
<li>在写结果时，先将计算结果写到CDB（公共数据总线）中。然后CDB上进行广播，看这个计算结果有没有作为是其他指令源操作数的。如果保留站发现有，就会更新保留站源操作数的值。这样就代替了流水线寄存器。
### 循序提交</li>
<li>引入ROB(重排缓冲区, Reorder Buffer)</li>
<li>允许指令乱序执行，但必须循序提交</li>
<li>支持分支预测
<ul>
<li>对于推测错误就很好处理了，
<ul>
<li>因为哪怕已经执行了分支之后的命令，由于之前的指令还没有执行完毕，分支之后的指令就无法提交，所以很容易的就程序计数器改为正确的分支地址，而不影响其他指令结果。</li>
</ul></li>
<li>预测错误的概率还是相对较低的，在Intel Core
i7的分支预测器中错误预测率平均在5%以下</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CPU pipeline</category>
      </categories>
  </entry>
  <entry>
    <title>分支预测器-TAGE</title>
    <url>/zyhjy/2022/11/13/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E5%99%A8-TAGE/</url>
    <content><![CDATA[<h3 id="abstract">Abstract</h3>
<ul>
<li>conditional branch predicor
<ul>
<li>combine several predictions</li>
<li>adder tree?</li>
</ul></li>
<li>文章实现了一个组合预测器
<ul>
<li>预测器的下标代表该预测器对应的history length ### 背景</li>
</ul></li>
<li>流水线运行的一个主要限制是：它们使用循序指令发射与执行的方式 ###
思想</li>
<li>动态调度 ### 乱序执行</li>
<li>操作数可用时立即执行程序</li>
<li>指令的循序发射以及乱序执行 ### 寄存器重命名</li>
<li>在写结果时，先将计算结果写到CDB（公共数据总线）中。然后CDB上进行广播，看这个计算结果有没有作为是其他指令源操作数的。如果保留站发现有，就会更新保留站源操作数的值。这样就代替了流水线寄存器。
### 循序提交</li>
<li>引入ROB(重排缓冲区, Reorder Buffer)</li>
<li>允许指令乱序执行，但必须循序提交</li>
<li>支持分支预测
<ul>
<li>对于推测错误就很好处理了，
<ul>
<li>因为哪怕已经执行了分支之后的命令，由于之前的指令还没有执行完毕，分支之后的指令就无法提交，所以很容易的就程序计数器改为正确的分支地址，而不影响其他指令结果。</li>
</ul></li>
<li>预测错误的概率还是相对较低的，在Intel Core
i7的分支预测器中错误预测率平均在5%以下</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CPU pipeline</category>
      </categories>
  </entry>
  <entry>
    <title>Effective C++(5)--实现</title>
    <url>/zyhjy/2022/11/15/Effective%20C++(5)/</url>
    <content><![CDATA[<h1 id="条款26-尽量延后变量定义式出现的时间">条款26
尽量延后变量定义式出现的时间</h1>
<h2 id="循环">循环</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法A 定义于循环外</span></span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    w = 取决于某个i的值;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法B 定义于循环内</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="function">Widget <span class="title">w</span><span class="params">(取决于某个i的值)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="分析">分析</h3>
<ul>
<li>做法A
<ul>
<li>1个构造函数 + 1个析构函数 + n个赋值操作</li>
</ul></li>
<li>做法B
<ul>
<li>n个构造函数 + n个析构函数</li>
</ul></li>
<li>当classes的一个赋值成本低于一组构造+析构成本，做法A大体而言比较高效</li>
<li>此外A造成w的作用域比B更大，会对易维护性造成冲突 ### 结论</li>
<li>当满足以下两点时使用方法A，否则使用方法B
<ol type="1">
<li>赋值成本低于构造+析构</li>
<li>代码对效率高度敏感</li>
</ol></li>
</ul>
<h1 id="条款27-尽量少做转型动作">条款27 尽量少做转型动作</h1>
<ul>
<li>C++规则的设计目标之一:
<ul>
<li>保证<em>类型错误</em>绝不可能发生</li>
</ul></li>
<li>C风格转型/旧式转型 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(T)<span class="function">expression</span></span><br><span class="line"><span class="function"><span class="title">T</span><span class="params">(expression)</span> <span class="comment">/// 二者等价，将expression转型为T类型</span></span></span><br></pre></td></tr></table></figure></li>
<li>新式转型(<em>C++-style casts</em>) <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">const_cast</span>&lt;T&gt;( expression )         </span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;T&gt;( expression )</span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;T&gt;( expression )</span><br><span class="line"><span class="built_in">static_cast</span>&lt;T&gt;( expression )</span><br></pre></td></tr></table></figure> ###
新式转型更受欢迎:</li>
</ul>
<ol type="1">
<li>易辨识</li>
<li>转型动作的目标越窄化，编译器越可能诊断出错误的运用 ###
唯一使用旧式转型的时机</li>
</ol>
<ul>
<li>调用一个explicit构造函数将一个对象传递给一个函数 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(<span class="type">int</span> size)</span></span>; </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomeWork</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>;</span><br><span class="line"><span class="built_in">doSomeWork</span>(<span class="built_in">Widget</span>(<span class="number">15</span>));</span><br><span class="line"><span class="built_in">doSomeWork</span>(<span class="built_in">static_cast</span>&lt;Widget&gt;(<span class="number">15</span>));</span><br></pre></td></tr></table></figure> ##
const_cast</li>
<li>常量性转除</li>
<li>唯一有此功能的新式转型 ## dynamic_cast</li>
<li>安全向下转型(safe downcasting)</li>
<li>唯一无法由旧式语法执行的动作</li>
<li>唯一可能耗费重大运行成本的转型动作 ### 实现(一个普遍的版本)</li>
<li>基于class名称的字符串比较
<ul>
<li>调用strcmp</li>
<li>深度、多重继承体系成本更高 ## reinterpret_cast</li>
</ul></li>
<li>执行低级转型</li>
<li>不可移植
<ul>
<li>实际动作及结果取决于编译器</li>
<li>如将<code>pointer to int</code>转化为<code>int</code> ##
static_cast</li>
</ul></li>
<li>强迫隐式转换(implicit conversion)
<ul>
<li>non-const --&gt; const</li>
<li>void* --&gt; typed*</li>
<li>pointer-to-base --&gt; pointer-to-derived ##
转型往往真的令编译器编译出运行期执行的码</li>
</ul></li>
<li>不只是告诉编译器将某种类型视为另一种类型 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">...</span><br><span class="line"><span class="type">double</span> d = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(x) / y;</span><br></pre></td></tr></table></figure></li>
<li>将int转型为double几乎肯定会产生代码
<ul>
<li>在大部分计算机体系结构中，int的底层表述不同于double
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; ... &#125;;</span><br><span class="line">Derived d;</span><br><span class="line">Base* pb = &amp;d; <span class="comment">/// 隐喻地将Derived*转换为Base*</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>同一个对象的Derived指针与Base指针值可能并不相同
<ul>
<li>与编译器如何实现有关</li>
<li>有时候存在一个偏移量</li>
<li>运行时会计算偏移量以转型</li>
<li>多重继承中几乎必然发生，单一继承中可能发生</li>
</ul></li>
<li>避免做出“对象在C++中如何布局”的假设</li>
</ul>
<h1 id="条款28-避免返回handles指向对象内部分">条款28
避免返回handles指向对象内部分</h1>
<h1 id="条款29-strive-for-exception-safe-code.">条款29 Strive for
exception-safe code.</h1>
<ul>
<li>不泄露任何资源</li>
<li>不允许数据败坏 ## 异常安全函数提供以下三个保证之一:</li>
</ul>
<ol type="1">
<li>基本承诺:
<ul>
<li>异常抛出时，程序内的任何事物仍然保持在有效状态下。</li>
<li>但在哪个有效状态不可预料</li>
</ul></li>
<li>强烈保证:
<ul>
<li>异常抛出时，程序状态不改变。</li>
<li>成功 --&gt; 完全成功</li>
<li>失败 --&gt; 回复到</li>
<li>往往以copy-and-swap实现</li>
<li>并非对所有函数都可实现或具备意义</li>
</ul></li>
<li>不抛掷(nothrow)保证:
<ul>
<li>承诺绝不抛出异常</li>
<li>内置类型的操作均遵守</li>
</ul></li>
</ol>
<h1 id="条款30-透彻了解inline的里里外外">条款30
透彻了解inline的里里外外</h1>
<h2 id="inline">inline</h2>
<h3 id="优点">优点</h3>
<ul>
<li>免除函数调用成本</li>
<li>编译器最优化机制通常用于浓缩“不含函数调用的代码” ### 缺点</li>
<li>增加<code>object code</code>的大小
<ul>
<li>可能导致额外的的换页</li>
<li>降低cache命中率 ## inline是对编译器的一个申请，不是强制命令</li>
</ul></li>
<li>编译器拒绝inline复杂函数
<ul>
<li>如递归、循环、virtual(运行期决定)</li>
</ul></li>
<li>编译器无法inline将给出告警 ### 隐式申请</li>
<li>将函数定义为class定义式内 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">age</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> theAge; &#125; <span class="comment">// 一个隐喻的inline申请</span></span><br><span class="line">    ...                                <span class="comment">// age被定义与class定义式内</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> theAge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>这样的函数通常是成员函数，但是friend函数也可定义与class内(见 条款46)
### 显式申请</li>
<li>在定义式前加上关键字inline <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;algorithm&gt;</span></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">inline</span> <span class="type">const</span> T&amp; <span class="title">max</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ##
inline函数通常被置于头文件内</li>
<li>编译期进行inline</li>
<li>方便编译器将函数调用替换为函数本体</li>
<li>template的具现化与inline无关
<ul>
<li>通常被置于头文件内，方便编译器具现化 ##
有时即便编译器inline某个函数，可能还是为该函数生成一个函数本体</li>
</ul></li>
<li>例如要取某个inline函数的地址时</li>
<li>编译器不对通过函数指针进行的调用实施inline <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="built_in">void</span> ( *pf ) = f;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">f</span>();        <span class="comment">// inline</span></span><br><span class="line"><span class="built_in">pf</span>();       <span class="comment">// outline</span></span><br></pre></td></tr></table></figure></li>
<li>编译器有时会自动生成inline函数的ouline副本
<ul>
<li>比如生成构造和析构函数的副本，这样在array中可使用函数指针进行构造和析构
## 构造函数和析构函数时inline糟糕的候选人 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::srting bm1, bm2;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123; &#125;;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::srting dm1, dm2, dm3;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>看起来构造函数和析构函数没有什么代码量，但其实不然</li>
<li>例如，一种可能的编译器实现: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Derived::<span class="built_in">Derived</span>() &#123;</span><br><span class="line">    Base::<span class="built_in">Base</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123; dm1.std::string::<span class="built_in">string</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123; </span><br><span class="line">        Base::~<span class="built_in">Base</span>();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123; dm2.std::string::<span class="built_in">string</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123; </span><br><span class="line">        Base::~<span class="built_in">Base</span>();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123; dm3.std::string::<span class="built_in">string</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123; </span><br><span class="line">        Base::~<span class="built_in">Base</span>();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="条款31-将文件间的编译依存关系降至最低">条款31
将文件间的编译依存关系降至最低</h1>
<h2 id="编译依存关系">编译依存关系</h2>
<ul>
<li>class的定义式不只详细描述了class接口，还包括十足的实现细目
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name. <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;    <span class="comment">/// 实现细目</span></span><br><span class="line">    Date theBirthDate;      <span class="comment">/// 实现细目</span></span><br><span class="line">    Address theAddress;     <span class="comment">/// 实现细目</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>C++将实现细目置于定义式中
<ul>
<li>编译器需要根据定义式确定分配多大空间</li>
</ul></li>
<li>Person若要通过编译，需要classes string，Date，Address的定义式
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;date.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;address.h&quot;</span></span></span><br></pre></td></tr></table></figure></li>
<li>但是，如此一来，Person定义文件和其含入文件形成了编译依存关系
<ul>
<li>如果这些头文件有一个被改变，或者这些头文件所依赖的其他文件有任何改变，那么每一个含入和使用Person
class的文件也必须重新编译 ## 编译依存性最小化 -- 接口与实现分离</li>
</ul></li>
<li>通过Handle classes和Interface
classes解除了接口和实现之间的耦合，降低了文件之间的编译依存性 ### pimpl
idiom -- <code>Handle class</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>   <span class="comment">// 标准程序组件不该被前置声明</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>   <span class="comment">// for shared_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PresonImpl</span>;   <span class="comment">// Person实现类的前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;         <span class="comment">// Person接口用到的classes的前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;PresonImpl&gt; pImpl_;</span><br><span class="line">&#125;;</span><br><span class="line">Person::<span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr)</span><br><span class="line">    : <span class="built_in">pImpl</span>(<span class="keyword">new</span> <span class="built_in">PresonImpl</span>(name, birthday, addr))</span><br><span class="line">    &#123;&#125;</span><br><span class="line"><span class="function">std::string <span class="title">Person::name</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pImpl-&gt;<span class="built_in">name</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Person的客户端完全与Date，Address以及Person的实现细目分开 ###
抽象基类(abstract base class、Interface class)</li>
<li>详细一一描述derived class的接口
<ul>
<li>一组pure virtual函数</li>
</ul></li>
<li>通常不带成员变量，也没有构造函数</li>
<li>只有一个virtual析构函数(见条款7) <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>客户必须以Person的pointers和references来撰写应用程序
<ul>
<li>除非Interface class修改，否则不用编译</li>
</ul></li>
<li>客户必须有办法为这种class创建新对象
<ul>
<li>工厂函数
<ul>
<li>返回指针指向动态分配所得的对象</li>
<li>往往在Interface class中声明为static <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;Person&gt; <span class="title">create</span><span class="params">(<span class="type">const</span> std::string&amp; name, </span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> Date&amp; birthday, </span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> Address&amp; addr)</span></span>; <span class="comment">// why shared_ptr;见条款18</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 客户如此使用</span></span><br><span class="line">std::string; name, </span><br><span class="line">Date dateodBirth, </span><br><span class="line">Address address;</span><br><span class="line">...</span><br><span class="line"><span class="function">std::shared_ptr&lt;Person&gt; <span class="title">pp</span><span class="params">(Person::create(name, dateodBirth, address))</span></span>;</span><br><span class="line">...</span><br><span class="line">std::cout &lt;&lt; pp-&gt;<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li>当然，支持Interface
class接口的那个具象类(<code>concrete class</code>)必须被定义出来
<ul>
<li>一切都在virtual构造函数的实现码所在文件内秘密发生 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealPerson</span> : <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RealPerson</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr)</span><br><span class="line">        : <span class="built_in">theName</span>(name), <span class="built_in">theBirthDate</span>(birthday), <span class="built_in">theAddress</span>(addr)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">RealPerson</span>() &#123;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;    </span><br><span class="line">    Date theBirthDate;      </span><br><span class="line">    Address theAddress;     </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> std::shared_ptr&lt;Person&gt; <span class="title">Person::create</span><span class="params">(<span class="type">const</span> std::string&amp; name, </span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">const</span> Date&amp; birthday, </span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">const</span> Address&amp; addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> <span class="built_in">RealPerson</span>(name, dateodBirth, addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>更现实的Person::create实现代码会创建不同的derived class ### 开销
#### Handle classes</li>
</ul></li>
</ul>
<ol type="1">
<li>成员函数必须通过implementation pointer取得对象数据，
<ul>
<li>每次访问增加一次间接性</li>
</ul></li>
<li>每个对象的内存消耗多一个implementation pointer的大小</li>
<li>implementation pointer必须初始化，指向动态分配的implementation内存
<ul>
<li>涉及到动态分配 #### Interface class</li>
</ul></li>
<li>virtual函数带来间接跳跃(见条款7)</li>
<li>派生类对象有一个vptr(见条款7) ### 本质</li>
</ol>
<ul>
<li>声明的依存性 替换 定义的依存性</li>
<li>尽量让头文件自我满足，做不到则让它与其他头文件内的声明式而非定义式相依
## 方法 ### 如果使用object
reference/pointer可以完成任务，就不要使用object</li>
<li>前者仅需声明，后者需要定义 ###
如果能够，尽量用class声明式替换class定义式</li>
<li>注意，当声明一个函数而它用到某个class的定义时，并不需要该class的定义
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;                         <span class="comment">// class声明式</span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span></span>;                       <span class="comment">// 没问题，这里并不需要Date的定义式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>;</span><br></pre></td></tr></table></figure> ### 为声明式和定义式提供不同的头文件</li>
<li>程序库客户应该总是#include一个声明文件而非前置声明若干class或函数
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;datafw.h&quot;</span>  <span class="comment">// 这个头文件内声明单未定义class Date</span></span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span></span>;                      </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>只含声明式的头文件名为"datefw.h",命名方式取法C++标准库的<iosfwd>
<ul>
<li><iosfwd>内含iostream各组件的声明式，其定义则分布在相应的头文件，包括<sstream>,<streambuf>,<fstream>,<iostream></li>
</ul></li>
<li>此方法同样适用于template
<ul>
<li>export关键字同样可以，但很少使用</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>Effective C++(6)--继承与面向对象设计</title>
    <url>/zyhjy/2022/11/15/Effective%20C++(6)/</url>
    <content><![CDATA[<h1 id="条款32-确定public继承塑模出is-a关系">条款32
确定public继承塑模出is-a关系</h1>
<ul>
<li>public继承意味"is-a"</li>
<li>Liskov替换原则
<ul>
<li>class D : class B { ... }</li>
<li>适用于B身上的每一件事也适用于D，反之不然</li>
</ul></li>
</ul>
<h1 id="条款33-避免遮掩继承而来的名称">条款33
避免遮掩继承而来的名称</h1>
<h2 id="继承体系内的名称可视性">继承体系内的"名称可视性"</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>base class内所有名为mf1和mf3的函数都被derived
class内的mf1和mf3函数遮掩了 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.<span class="built_in">mf1</span>();    <span class="comment">/// ok</span></span><br><span class="line">d.<span class="built_in">mf1</span>(x);   <span class="comment">/// error, Base::mf1被遮掩</span></span><br><span class="line">d.<span class="built_in">mf2</span>();    <span class="comment">/// ok, Base::mf2</span></span><br><span class="line">d.<span class="built_in">mf3</span>();    <span class="comment">/// ok, Derived::mf3</span></span><br><span class="line">d.<span class="built_in">mf3</span>(x);   <span class="comment">/// error, Base::mf3被遮掩</span></span><br></pre></td></tr></table></figure></li>
<li>该机制的目的在于提醒base和derived class之间的is-a关系 ##
override缺省遮掩行为</li>
<li>一般不在public继承下使用，破坏了is-a的关系</li>
<li>在private继承下有用 ### 使用using声明式 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::mf1;    <span class="comment">/// 让Base class内名为mf1和mf3的所有东西</span></span><br><span class="line">    <span class="keyword">using</span> Base::mf3;    <span class="comment">/// 在Derived作用域内可见(且public)</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.<span class="built_in">mf1</span>();    <span class="comment">/// ok，Derived::mf1</span></span><br><span class="line">d.<span class="built_in">mf1</span>(x);   <span class="comment">/// ok, Base::mf1</span></span><br><span class="line">d.<span class="built_in">mf2</span>();    <span class="comment">/// ok, Base::mf2</span></span><br><span class="line">d.<span class="built_in">mf3</span>();    <span class="comment">/// ok, Derived::mf3</span></span><br><span class="line">d.<span class="built_in">mf3</span>(x);   <span class="comment">/// ok, Base::mf3</span></span><br></pre></td></tr></table></figure> ###
转交函数(forwarding function)</li>
<li>Derived private继承Base，且只想继承无参数版本的的mf1
<ul>
<li>using会导入所有同名函数 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span>  <span class="comment">/// 转交函数</span></span></span><br><span class="line"><span class="function">    </span>&#123; Base::mf1; &#125;      <span class="comment">/// 暗自成为inline函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">d.<span class="built_in">mf1</span>();    <span class="comment">/// ok，Derived::mf1</span></span><br><span class="line">d.<span class="built_in">mf1</span>(x);   <span class="comment">/// error, Base::mf1被遮掩</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h1 id="条款34-区分接口继承和实现继承">条款34
区分接口继承和实现继承</h1>
<ul>
<li>声明一个pure virtual函数的目的是为了让derived class只继承函数接口。
<ul>
<li>1个构造函数 + 1个析构函数 + n个赋值操作</li>
</ul></li>
<li>做法B
<ul>
<li>n个构造函数 + n个析构函数</li>
</ul></li>
<li>当classes的一个赋值成本低于一组构造+析构成本，做法A大体而言比较高效</li>
<li>此外A造成w的作用域比B更大，会对易维护性造成冲突 ### 结论</li>
<li>当满足以下两点时使用方法A，否则使用方法B
<ol type="1">
<li>赋值成本低于构造+析构</li>
<li>代码对效率高度敏感</li>
</ol></li>
</ul>
<h1 id="条款27-尽量少做转型动作">条款27 尽量少做转型动作</h1>
<ul>
<li>C++规则的设计目标之一:
<ul>
<li>保证<em>类型错误</em>绝不可能发生</li>
</ul></li>
<li>C风格转型/旧式转型 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(T)<span class="function">expression</span></span><br><span class="line"><span class="function"><span class="title">T</span><span class="params">(expression)</span> <span class="comment">/// 二者等价，将expression转型为T类型</span></span></span><br></pre></td></tr></table></figure></li>
<li>新式转型(<em>C++-style casts</em>) <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">const_cast</span>&lt;T&gt;( expression )         </span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;T&gt;( expression )</span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;T&gt;( expression )</span><br><span class="line"><span class="built_in">static_cast</span>&lt;T&gt;( expression )</span><br></pre></td></tr></table></figure> ###
新式转型更受欢迎:</li>
</ul>
<ol type="1">
<li>易辨识</li>
<li>转型动作的目标越窄化，编译器越可能诊断出错误的运用 ###
唯一使用旧式转型的时机</li>
</ol>
<ul>
<li>调用一个explicit构造函数将一个对象传递给一个函数 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(<span class="type">int</span> size)</span></span>; </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomeWork</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>;</span><br><span class="line"><span class="built_in">doSomeWork</span>(<span class="built_in">Widget</span>(<span class="number">15</span>));</span><br><span class="line"><span class="built_in">doSomeWork</span>(<span class="built_in">static_cast</span>&lt;Widget&gt;(<span class="number">15</span>));</span><br></pre></td></tr></table></figure> ##
const_cast</li>
<li>常量性转除</li>
<li>唯一有此功能的新式转型 ## dynamic_cast</li>
<li>安全向下转型(safe downcasting)</li>
<li>唯一无法由旧式语法执行的动作</li>
<li>唯一可能耗费重大运行成本的转型动作 ### 实现(一个普遍的版本)</li>
<li>基于class名称的字符串比较
<ul>
<li>调用strcmp</li>
<li>深度、多重继承体系成本更高 ## reinterpret_cast</li>
</ul></li>
<li>执行低级转型</li>
<li>不可移植
<ul>
<li>实际动作及结果取决于编译器</li>
<li>如将<code>pointer to int</code>转化为<code>int</code> ##
static_cast</li>
</ul></li>
<li>强迫隐式转换(implicit conversion)
<ul>
<li>non-const --&gt; const</li>
<li>void* --&gt; typed*</li>
<li>pointer-to-base --&gt; pointer-to-derived ##
转型往往真的令编译器编译出运行期执行的码</li>
</ul></li>
<li>不只是告诉编译器将某种类型视为另一种类型 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">...</span><br><span class="line"><span class="type">double</span> d = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(x) / y;</span><br></pre></td></tr></table></figure></li>
<li>将int转型为double几乎肯定会产生代码
<ul>
<li>在大部分计算机体系结构中，int的底层表述不同于double
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; ... &#125;;</span><br><span class="line">Derived d;</span><br><span class="line">Base* pb = &amp;d; <span class="comment">/// 隐喻地将Derived*转换为Base*</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>同一个对象的Derived指针与Base指针值可能并不相同
<ul>
<li>与编译器如何实现有关</li>
<li>有时候存在一个偏移量</li>
<li>运行时会计算偏移量以转型</li>
<li>多重继承中几乎必然发生，单一继承中可能发生</li>
</ul></li>
<li>避免做出“对象在C++中如何布局”的假设</li>
</ul>
<h1 id="条款28-避免返回handles指向对象内部分">条款28
避免返回handles指向对象内部分</h1>
<h1 id="条款29-strive-for-exception-safe-code.">条款29 Strive for
exception-safe code.</h1>
<ul>
<li>不泄露任何资源</li>
<li>不允许数据败坏 ## 异常安全函数提供以下三个保证之一:</li>
</ul>
<ol type="1">
<li>基本承诺:
<ul>
<li>异常抛出时，程序内的任何事物仍然保持在有效状态下。</li>
<li>但在哪个有效状态不可预料</li>
</ul></li>
<li>强烈保证:
<ul>
<li>异常抛出时，程序状态不改变。</li>
<li>成功 --&gt; 完全成功</li>
<li>失败 --&gt; 回复到</li>
<li>往往以copy-and-swap实现</li>
<li>并非对所有函数都可实现或具备意义</li>
</ul></li>
<li>不抛掷(nothrow)保证:
<ul>
<li>承诺绝不抛出异常</li>
<li>内置类型的操作均遵守</li>
</ul></li>
</ol>
<h1 id="条款30-透彻了解inline的里里外外">条款30
透彻了解inline的里里外外</h1>
<h2 id="inline">inline</h2>
<h3 id="优点">优点</h3>
<ul>
<li>免除函数调用成本</li>
<li>编译器最优化机制通常用于浓缩“不含函数调用的代码” ### 缺点</li>
<li>增加<code>object code</code>的大小
<ul>
<li>可能导致额外的的换页</li>
<li>降低cache命中率 ## inline是对编译器的一个申请，不是强制命令</li>
</ul></li>
<li>编译器拒绝inline复杂函数
<ul>
<li>如递归、循环、virtual(运行期决定)</li>
</ul></li>
<li>编译器无法inline将给出告警 ### 隐式申请</li>
<li>将函数定义为class定义式内 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">age</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> theAge; &#125; <span class="comment">// 一个隐喻的inline申请</span></span><br><span class="line">    ...                                <span class="comment">// age被定义与class定义式内</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> theAge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>这样的函数通常是成员函数，但是friend函数也可定义与class内(见 条款46)
### 显式申请</li>
<li>在定义式前加上关键字inline <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;algorithm&gt;</span></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">inline</span> <span class="type">const</span> T&amp; <span class="title">max</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ##
inline函数通常被置于头文件内</li>
<li>编译期进行inline</li>
<li>方便编译器将函数调用替换为函数本体</li>
<li>template的具现化与inline无关
<ul>
<li>通常被置于头文件内，方便编译器具现化 ##
有时即便编译器inline某个函数，可能还是为该函数生成一个函数本体</li>
</ul></li>
<li>例如要取某个inline函数的地址时</li>
<li>编译器不对通过函数指针进行的调用实施inline <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="built_in">void</span> ( *pf ) = f;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">f</span>();        <span class="comment">// inline</span></span><br><span class="line"><span class="built_in">pf</span>();       <span class="comment">// outline</span></span><br></pre></td></tr></table></figure></li>
<li>编译器有时会自动生成inline函数的ouline副本
<ul>
<li>比如生成构造和析构函数的副本，这样在array中可使用函数指针进行构造和析构
## 构造函数和析构函数时inline糟糕的候选人 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::srting bm1, bm2;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123; &#125;;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::srting dm1, dm2, dm3;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>看起来构造函数和析构函数没有什么代码量，但其实不然</li>
<li>例如，一种可能的编译器实现: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Derived::<span class="built_in">Derived</span>() &#123;</span><br><span class="line">    Base::<span class="built_in">Base</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123; dm1.std::string::<span class="built_in">string</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123; </span><br><span class="line">        Base::~<span class="built_in">Base</span>();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123; dm2.std::string::<span class="built_in">string</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123; </span><br><span class="line">        Base::~<span class="built_in">Base</span>();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123; dm3.std::string::<span class="built_in">string</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123; </span><br><span class="line">        Base::~<span class="built_in">Base</span>();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="条款31-将文件间的编译依存关系降至最低">条款31
将文件间的编译依存关系降至最低</h1>
<h2 id="编译依存关系">编译依存关系</h2>
<ul>
<li>class的定义式不只详细描述了class接口，还包括十足的实现细目
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name. <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;    <span class="comment">/// 实现细目</span></span><br><span class="line">    Date theBirthDate;      <span class="comment">/// 实现细目</span></span><br><span class="line">    Address theAddress;     <span class="comment">/// 实现细目</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>C++将实现细目置于定义式中
<ul>
<li>编译器需要根据定义式确定分配多大空间</li>
</ul></li>
<li>Person若要通过编译，需要classes string，Date，Address的定义式
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;date.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;address.h&quot;</span></span></span><br></pre></td></tr></table></figure></li>
<li>但是，如此一来，Person定义文件和其含入文件形成了编译依存关系
<ul>
<li>如果这些头文件有一个被改变，或者这些头文件所依赖的其他文件有任何改变，那么每一个含入和使用Person
class的文件也必须重新编译 ## 编译依存性最小化 -- 接口与实现分离</li>
</ul></li>
<li>通过Handle classes和Interface
classes解除了接口和实现之间的耦合，降低了文件之间的编译依存性 ### pimpl
idiom -- <code>Handle class</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>   <span class="comment">// 标准程序组件不该被前置声明</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>   <span class="comment">// for shared_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PresonImpl</span>;   <span class="comment">// Person实现类的前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;         <span class="comment">// Person接口用到的classes的前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;PresonImpl&gt; pImpl_;</span><br><span class="line">&#125;;</span><br><span class="line">Person::<span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr)</span><br><span class="line">    : <span class="built_in">pImpl</span>(<span class="keyword">new</span> <span class="built_in">PresonImpl</span>(name, birthday, addr))</span><br><span class="line">    &#123;&#125;</span><br><span class="line"><span class="function">std::string <span class="title">Person::name</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pImpl-&gt;<span class="built_in">name</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Person的客户端完全与Date，Address以及Person的实现细目分开 ###
抽象基类(abstract base class、Interface class)</li>
<li>详细一一描述derived class的接口
<ul>
<li>一组pure virtual函数</li>
</ul></li>
<li>通常不带成员变量，也没有构造函数</li>
<li>只有一个virtual析构函数(见条款7) <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>客户必须以Person的pointers和references来撰写应用程序
<ul>
<li>除非Interface class修改，否则不用编译</li>
</ul></li>
<li>客户必须有办法为这种class创建新对象
<ul>
<li>工厂函数
<ul>
<li>返回指针指向动态分配所得的对象</li>
<li>往往在Interface class中声明为static <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;Person&gt; <span class="title">create</span><span class="params">(<span class="type">const</span> std::string&amp; name, </span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> Date&amp; birthday, </span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> Address&amp; addr)</span></span>; <span class="comment">// why shared_ptr;见条款18</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 客户如此使用</span></span><br><span class="line">std::string; name, </span><br><span class="line">Date dateodBirth, </span><br><span class="line">Address address;</span><br><span class="line">...</span><br><span class="line"><span class="function">std::shared_ptr&lt;Person&gt; <span class="title">pp</span><span class="params">(Person::create(name, dateodBirth, address))</span></span>;</span><br><span class="line">...</span><br><span class="line">std::cout &lt;&lt; pp-&gt;<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li>当然，支持Interface
class接口的那个具象类(<code>concrete class</code>)必须被定义出来
<ul>
<li>一切都在virtual构造函数的实现码所在文件内秘密发生 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealPerson</span> : <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RealPerson</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr)</span><br><span class="line">        : <span class="built_in">theName</span>(name), <span class="built_in">theBirthDate</span>(birthday), <span class="built_in">theAddress</span>(addr)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">RealPerson</span>() &#123;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;    </span><br><span class="line">    Date theBirthDate;      </span><br><span class="line">    Address theAddress;     </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> std::shared_ptr&lt;Person&gt; <span class="title">Person::create</span><span class="params">(<span class="type">const</span> std::string&amp; name, </span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">const</span> Date&amp; birthday, </span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">const</span> Address&amp; addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> <span class="built_in">RealPerson</span>(name, dateodBirth, addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>更现实的Person::create实现代码会创建不同的derived class ### 开销
#### Handle classes</li>
</ul></li>
</ul>
<ol type="1">
<li>成员函数必须通过implementation pointer取得对象数据，
<ul>
<li>每次访问增加一次间接性</li>
</ul></li>
<li>每个对象的内存消耗多一个implementation pointer的大小</li>
<li>implementation pointer必须初始化，指向动态分配的implementation内存
<ul>
<li>涉及到动态分配 #### Interface class</li>
</ul></li>
<li>virtual函数带来间接跳跃(见条款7)</li>
<li>派生类对象有一个vptr(见条款7) ### 本质</li>
</ol>
<ul>
<li>声明的依存性 替换 定义的依存性</li>
<li>尽量让头文件自我满足，做不到则让它与其他头文件内的声明式而非定义式相依
## 方法 ### 如果使用object
reference/pointer可以完成任务，就不要使用object</li>
<li>前者仅需声明，后者需要定义 ###
如果能够，尽量用class声明式替换class定义式</li>
<li>注意，当声明一个函数而它用到某个class的定义时，并不需要该class的定义
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;                         <span class="comment">// class声明式</span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span></span>;                       <span class="comment">// 没问题，这里并不需要Date的定义式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>;</span><br></pre></td></tr></table></figure> ### 为声明式和定义式提供不同的头文件</li>
<li>程序库客户应该总是#include一个声明文件而非前置声明若干class或函数
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;datafw.h&quot;</span>  <span class="comment">// 这个头文件内声明单未定义class Date</span></span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span></span>;                      </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>只含声明式的头文件名为"datefw.h",命名方式取法C++标准库的<iosfwd>
<ul>
<li><iosfwd>内含iostream各组件的声明式，其定义则分布在相应的头文件，包括<sstream>,<streambuf>,<fstream>,<iostream></li>
</ul></li>
<li>此方法同样适用于template
<ul>
<li>export关键字同样可以，但很少使用</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>ARM64汇编</title>
    <url>/zyhjy/2022/11/15/ARM64%E6%B1%87%E7%BC%96/</url>
    <content><![CDATA[<h1 id="寄存器">寄存器</h1>
<ul>
<li>在arm64架构下，所有的寄存器都是64位，并且每个寄存器都有名字的，按照功能来划分，可分为一下几类，分别为：
<ol type="1">
<li>通用寄存器</li>
<li>程序计数器</li>
<li>堆栈指针</li>
<li>链接寄存器</li>
<li>程序状态寄存器</li>
<li>零寄存器</li>
</ol></li>
<li>下面分别说明这些寄存器的作用</li>
</ul>
<h2 id="通用寄存器">通用寄存器</h2>
<ul>
<li>64bit : x0 ~ x28 ，每个寄存器都是64bit</li>
<li>32bit：w0 ~ w28，实际上是x0~x28寄存器的低32bit</li>
<li>x0~x7：通过用来存储函数的参数，如果函数有更多的参数使用堆栈来传递</li>
<li>x0：通常用来存放函数的返回值</li>
</ul>
<h2 id="程序计数器">程序计数器</h2>
<ul>
<li>程序计数器叫<code>Program Counter</code>，俗称<code>PC</code>，也就是<code>x32</code>寄存器，存储着CPU当前正在执行的地址。</li>
</ul>
<h2 id="堆栈指针">堆栈指针</h2>
<ul>
<li><code>SP</code>
(<code>Stack Pointer</code>)，就是<code>x31</code>寄存器，存储的是栈顶的地址</li>
<li><code>FP</code>
(<code>Frame Pointer</code>)，<code>FP</code>也就是<code>x29</code>寄存器，存储着栈底的地址</li>
<li>随着函数的调用，<code>SP</code>、<code>FP</code>会不断的变化。</li>
</ul>
<h2 id="链接寄存器">链接寄存器</h2>
<p><code>LR</code>（<code>Link Register</code>），也就是<code>x30</code>寄存器，存储着函数的返回地址。
-
当函数结束时，就是通过LR寄存器的值，跳转到调用函数的位置继续往下执行。</p>
<h2 id="程序状态寄存器">程序状态寄存器</h2>
<ul>
<li><code>CPSR</code>
(<code>Current Program Status Register</code>)</li>
<li><code>SPSR</code>
(<code>Saved Program Status Register</code>)，在异常状态下使用，当发生异常时，会把<code>CPSR</code>的内容写入<code>SPSR</code>,
等异常恢复之后，又会把<code>SPSR</code>写会到<code>CPSR</code>中。</li>
</ul>
<p>零寄存器 WZR XZR 里面存储的值都是0。</p>
<p>常用指令 算术运算指令 mov 赋值指令</p>
<p>mov x0, #2 // 把2这个值赋值给x0寄存器 mov x0, x1 //
把x1寄存器中的值赋值给x0寄存器中 add
两个操作数相加，相加的结果存放到一个寄存器中</p>
<p>add, x2, x0, x1 //把x0的值与x1的值相加，得到的结果存放到x2寄存器中
add, x2, x0, #3 // 把x0的值与3相加，得到的结果存放到x2寄存器中 sub
第一个操作数减第一个操作数，得到的结果存放到一个寄存器中</p>
<p>sub, x2, x1, x0 //
x1的值减去x0的值，得到的结果存放到<em>x2</em>寄存器中 sub, x2, x1, #4 //
x1的值减去4，得到的结果存放到x2寄存器中 mul 乘法指令</p>
<p>mul x3, x1, x2 // x1 乘以 x2 的结果存放在 x3 中 sdiv 除法指令</p>
<p>sdiv w0, w0, w1 // w0 除以 w1 的结果存放在 w0 中 逻辑运算指令
这里的运算是指位运算</p>
<p>LSL 逻辑左移 按操作数所指定的数量向左移位，低位用零来填充 ASL
算术左移 通逻辑左移，ASL 与 LSL等价 lsl x0, x0, #1 asl x1, x1, x0 LSR
逻辑右移 按操作数所指定的数量向右移位，左端用零来填充。</p>
<p>ASR 算术右移 按操作数所指定的数量向右移位，左端用最高位位的值来填充
，如果是负数，最高位为1</p>
<p>lsr w1, w2, #1 asr x1, x2, #2 ROR 循环右移
按操作数所指定的数量向右循环移位，
左端用右端移出的位来填充。其中，操作数可以是通用寄存器，也可以是立即数。
当进行寄存器bit位数的循环右移操作时，通用寄存器中的值不改变。 ror x0, #6
ror w0, #32 // 循环移动了32位，w0的值不变 跳转指令 ret
相当于高级编程语言的return，函数返回。</p>
<p>cmp 将两个操作数相减，相减的结果会影响cpsr
寄存器的标志位，当结果小于0时，CPSR寄存器的N位为1， 等于0时，
CPSR寄存器的Z为位1。 cmp x0, x1</p>
<p>b
跳转指令，跳转找指定的标记处执行；可以带条件跳转，一般跟cmp配合使用，使用到的条件域如下：</p>
<p>EQ：equal NE：not equal GT：great than GE：great equal LT：less than
LE：less equal 普通跳转 b testCode，testCode是汇编代码中的一个标记</p>
<p>条件跳转，当x0和x1的值相等时，才跳转到testCode标记处执行代码</p>
<p>cmp x0, x1 beq testCode bl
带返回值的跳转指令，这个指令会做两个操作</p>
<p>将下一条指令的地址存储到lr （x30）寄存器中 跳转到标记处开始执行代码
bl
testCode，当执行完testCode标记处代码后，又会返回来执行bl指令下面的指令。
内存操作 load从内存中读取数据</p>
<p>ldr 地址没有偏移或者偏移为正数时使用 ldur 地址偏移为负数时使用 a) str
x5 [x0] x0中是内存的地址，读取的值存放在x5寄存器中, x寄存器读取8个字节
b）str w6 [x0] x0中是内存的地址，读取的值存放在w5寄存器中,
w寄存器读取4个字节 说明: 地址还可以偏移 str x5 [x0, #0x4] , stur x5 [x0,
#-0x4] ,
偏移量为正数往高地址偏移，使用str指令、偏移量为负数往低地址偏移，使用stur指令。</p>
<p>ldp 从指定内存中读取数据到一对寄存器中， p 是
pair的意思，这一对寄存器必须是同类型的，要么x类型,
要么w类型。其中低位读取到第一个寄存器、高位读取到第二个寄存器 ldp w5,
w6, [x0] , 地址可以偏移 ldp x5, x6, [x0, #-x04] store
往指定的内存写入数据</p>
<p>str str x1, [x0] str w2, [x1] str w3, [x1, #4] stur stur x3, [x0,
#-4] stur w2, [x1, #-4] stp stp x2, x3, [x0] stp w4, w5, [x0]
使用方法与从内存中读取数据类似，只不过是往内存写入数据。</p>
<p>总结
本文整理了一些在逆向iOS程序时常见的一些汇编指令，当然在实际逆向的过程所看到的汇编指令更加复杂，比如还有函数调用栈，这是下篇的内容。如有错误请指正。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>SPEC2006交叉编译</title>
    <url>/zyhjy/2023/01/14/spec2006%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h1 id="spec2006说明">1. SPEC2006说明</h1>
<ul>
<li>CPU Benchmark</li>
<li>用例具体内容见官网<code>http://www.spec.org/cpu2006/docs/用例名.html</code></li>
<li>运行时注意不要漏掉参数(Input)</li>
<li>例:</li>
</ul>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="header">
<th>子项目</th>
<th>类别</th>
<th>语言</th>
<th>说明</th>
<th>Web</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>462.libquantum</td>
<td>物理：量子计算</td>
<td>ISO/IEC 9899:1999(“C99”)</td>
<td>libquantum是模拟量子计算机的库文件，用来进行量子计算机应用的研究</td>
<td>http://www.spec.org/cpu2006/docs/462.libquantum.html</td>
</tr>
</tbody>
</table>
<h1 id="交叉编译">2. 交叉编译</h1>
<ol type="1">
<li>解压下载的SPEC2006压缩包</li>
<li>安装SPEC <code>./install.sh</code></li>
<li>安装aarch64交叉编译环境
<ul>
<li>gcc、g++、gfortran</li>
<li><code>sudo apt install gfortran-8-aarch64-linux-gnu</code></li>
</ul></li>
<li>加载环境变量
<ul>
<li>只要需要用到SPEC2006的指令，都需要在打开终端时加入<code>source ./shrc</code></li>
</ul></li>
<li>交叉编译配置
<ol type="1">
<li>进入<code>config</code>目录下，复制<code>Example-linux64-amd64-gcc43+</code>的配置文件（这个文件的选择根据Gem5中模拟的核模型来选择），将其重命名为<code>aarch64.cfg</code>（可以任意命名为其它名称）</li>
<li>修改配置文件<code>aarch64.cfg</code>，指定编译工具
<ul>
<li>分别找到CC，CXX，FC</li>
<li>改成如下格式： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CC =  your-cross-compiler-gcc</span><br><span class="line"></span><br><span class="line">CXX = your-cross-compiler-g++</span><br><span class="line"></span><br><span class="line">FC = your-cross-compiler-gfortran</span><br></pre></td></tr></table></figure></li>
<li>在gem5中运行的样例需要静态编译，故对COPTIMIZE、CXXOPTIMIZE、FOPTIMIZE加上<code>-static</code>标签</li>
<li>修改完后保存退出，其他地方不用改。</li>
</ul></li>
</ol></li>
<li>编译speccpu:</li>
</ol>
<ul>
<li><p><code>runspec --action=build --config=aarch64.cfg --tune=base int</code>
（只编译int型benchmark，不运行）</p></li>
<li><p>生成可执行文件<code>runspec --config=&lt;你的配置文件名&gt; --size=ref --noreportable --tune=base --iterations=1 &lt;样例名称&gt;</code></p></li>
</ul>
<ol start="7" type="1">
<li>将编译好的文件（在源码目录下，如<code>benchspec/CPU2006/400.perlbench/build/</code>）拷贝出来就可以在目标板或者模拟器上运行了。</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>Qemu使用记录</title>
    <url>/zyhjy/2023/02/07/Qemu%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="qemu说明">1. Qemu说明</h1>
<ul>
<li>通用的开源机器和用户空间模拟器和虚拟器</li>
<li>具体内容见官网<code>https://github.com/qemu/qemu</code></li>
<li>比如：Qemu可以模拟出一个ARM系统中的：CPU. 内存.
IO设备等，然后在这个模拟层之上，可以跑一台ARM虚拟机，这个ARM虚拟机认为自己在和硬件进行打交道，但实际上这些硬件都是Qemu模拟出来的。</li>
</ul>
<h2 id="qemu的两种模式">Qemu的两种模式</h2>
<ol type="1">
<li>用户模式(User
mode)：利用动态代码翻译机制来执行不同主机架构的代码，例如：在x86平台上模拟执行ARM代码，也就是说：我们写一条ARM指令，传入整个模拟器中，模拟器会把整个指令翻译成x86平台的指令，然后在x86的CPU中执行。</li>
<li>系统模式(System mode)：模拟整个电脑系统，利用其它VMM(Xen,
KVM)来使用硬件提供的虚拟化支持，创建接近于主机性能的全功能虚拟机。</li>
</ol>
<h1 id="qemu执行流程">2. qemu执行流程</h1>
<h2 id="宏">0. 宏</h2>
<ul>
<li><code>#ifdef PPI_QR_FUNC</code> 宏是我们所有改动加的宏 ## 1.
qemu启动</li>
<li>file: softmmu/vl.c</li>
<li>初始化参数</li>
<li>调用vcpu初始化。 ## 2. vcpu初始化</li>
<li>file: target/arm/cpu64.c</li>
<li>func:
<ul>
<li>aarch64_cpu_class_init</li>
<li>aarch64_cpu_instance_init
<ul>
<li>对cpu实例进行初始化</li>
<li>共享内存初始化(包括qemu要用的向gem5传输的共享内存)
<ul>
<li>ringbuf_init 进行初始化环形队列。</li>
<li>第二块共享内存是shm_init。</li>
</ul></li>
<li>每个qemu vcpu会初始化调用一次aarch64_cpu_instance_init
<ul>
<li>eg：run.sh里是16 cpu，那么就调用16次aarch64_cpu_instance_init，所以
也会初始化16个ringbuf_init，共享内存队列，每个核维护一个。key_insoff+channel_d+i是每个共享内存的id。</li>
</ul></li>
<li>这里面的cpu以及cpu-&gt;env就是
qemu的vcpu，其中cpu-&gt;env就是cpuarmstate。这个时候已经初始化完毕。 ##
3. 翻译</li>
</ul></li>
</ul></li>
<li>初始化之后开始主流程翻译</li>
<li>翻译是两步，
<ol type="1">
<li>guest-&gt;ir</li>
<li>ir-&gt;host</li>
</ol>
<ul>
<li>eg: 也就是比如 用户程序是 arm，arm-&gt;ir ir-&gt;x86
code，host运行x86
code。如果是用户程序是x86，host也是，那么不用翻译，直接在host上执行。
### guest-&gt;ir</li>
</ul></li>
</ul>
<ol type="1">
<li>调用<code>tb_find</code>[accel/tcg/cpu-exec.c]
<ul>
<li>找是否有翻译过,若无则进行2.(刚开始肯定无)</li>
</ul></li>
<li>调用<code>tb_gen_code</code>[accel/tcg/cpu-exec.c]
<ul>
<li>翻译主函数</li>
</ul></li>
<li>这个又调用gen_intermediate_code，
<ul>
<li>进行guest-&gt;ir的翻译。</li>
</ul></li>
<li>上面又继续调用translator_loop
<ul>
<li>来到accel/tcg/translator.c。</li>
<li>translator_loop 函数 对tb里的每一个指令 进行翻译。</li>
<li>while (true)就是每条指令循环翻译。</li>
</ul></li>
<li>aarch64_tr_translate_insn函数。
<ul>
<li>添加函数名，target/arm/translate-a64.c</li>
</ul></li>
<li>调用disas_a64_insn
<ul>
<li>就是每个指令进行decoder</li>
<li>里面switch (extract32(insn, 25, 4)) { 看是哪类指令。</li>
</ul></li>
</ol>
<ul>
<li>至此完成了 guest-&gt;ir的翻译。 ### ir-&gt;host的暂不考虑</li>
</ul>
<h2 id="执行">4. 执行</h2>
<ul>
<li>翻译之后，host代码已经生成，需要执行。</li>
<li>我们采用在guest的tb开始和结束前插callback函数的方式
<ul>
<li>target/arm/translate.c 里的函数
<ul>
<li>helper_start_callback插在tb执行开始前的。插在它tb guest的开头，</li>
<li><code>helper_end_callback</code>在结尾</li>
<li>会随tb一起翻译。</li>
</ul></li>
</ul></li>
<li>那么执行就是先 helper_start_callback -&gt; tb -&gt;
helper_end_callback</li>
<li>当执行helper_end_callback的时候，整个tb都执行好了。</li>
<li>所以可以对下一个执行的tb进行预测。</li>
<li>tb-&gt;tt里存放我们记下来的tb的trace，包括 pc insn。</li>
<li>env-&gt;sendbuf-&gt;real_insn_num记了tb的实际指令数。</li>
<li>helper_end_callback调用lookupAndUpdateNextPC预测。</li>
<li>执行tb 是一串二进制代码，无法代码操作。 只能通过cb来操作。</li>
<li>bt-&gt;IsControl 是true 说明是分支指令，需要存。所以在这里可以存cpu
state</li>
</ul>
<h3 id="内存处理">内存处理</h3>
<ul>
<li>主函数如果是ld st指令</li>
<li>mem信息我们额外插了cb进行收集mem 访存信息。</li>
<li>ppi_insert_mem_st[tcg/tcg-op.c]进行ld st插桩。
<ul>
<li>函数体insert_mem_st[target/arm/translate.c]<br />
</li>
</ul></li>
<li><code>helper_load_callback</code> 里，env-&gt;sendbuf 是 cpu
armstate结构体里划出来的一块临时内存。</li>
<li>mem cb里会将mem trace 记在这里。</li>
<li>env里是否有mem的寄存器信息？</li>
<li>到end
cb的时候，helper_load_callback里的所有东西都记好了，env的sendbuf里有完整的tb里的mem
insn trace</li>
</ul>
<h2 id="qemu主函数调用">qemu主函数调用</h2>
<ol type="1">
<li><p>main[./softmmu/vl.c]</p></li>
<li><p>aarch64_cpu_instance_init[target/arm/cpu64.c]</p></li>
<li><p>aarch64_cpu_class_init[target/arm/cpu64.c]</p></li>
<li><p>cpu_exec[accel/tcg/cpu-exec.c]</p>
<ul>
<li>main execution loop</li>
</ul>
<ol type="1">
<li>tb_gen_code[accel/tcg/translate-all.c]
<ul>
<li>生成下一个tb块代码</li>
</ul>
<ol type="1">
<li>cpu_loop_exit[accel/tcg/cpu-exec-common.c]
<ul>
<li>exit the current TB</li>
<li>抛出异常时触发</li>
</ul>
<ol type="1">
<li>helper_end_callback[target/arm/translate.c]
<ul>
<li>移植了gem5的分支预测器</li>
</ul></li>
</ol></li>
</ol></li>
<li>cpu_loop_exec_tb[accel/tcg/cpu-exec.c]
<ol type="1">
<li>cpu_tb_exec[accel/tcg/cpu-exec.c]</li>
</ol></li>
</ol></li>
<li><p>cpu_exec_exit[accel/tcg/cpu-exec.c]</p></li>
</ol>
<ul>
<li>退出qemu<code>ctrl+A+X</code></li>
</ul>
<h1 id="问题">问题</h1>
<p>分支预测加在了每个tb运行结束的末尾，在运行到tb末尾时进行预测
当下一个tb运行完之后，取出该tb的头地址，并与上次预测结果比对验证</p>
<p>checkpoint是系统层面的快照接口 在程序内部调用不好处理</p>
<p>接下来首先篡改执行的tb路径，即迫使qemu按照分支预测结果执行</p>
<p>在cpu_exec中主循环通过调用tb_lookup/tb_gen_code来获得下一个执行的tb
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tb = tb_lookup(cpu, pc, cs_base, flags, cflags);</span><br><span class="line">tb = tb_gen_code(cpu, pc, cs_base, flags, cflags);</span><br></pre></td></tr></table></figure>
我们可以通过改变cpu的pc来控制下一个tb，既可以迫使其走上错误分支，也可以再恢复状态后安排它执行正确的pc
pc在这里取出<code>cpu_get_tb_cpu_state(cpu-&gt;env_ptr, &amp;pc, &amp;cs_base, &amp;flags);</code>，根据<code>cpu-&gt;env_ptr</code>内的值
这个指针实际指向CPUARMState
cpu_get_tb_cpu_state[target/arm/helper.c]中pc的值分两种情况 pc /
regs[15] 怎么选取?</p>
<p>core的时候打屏可以 写文件不行</p>
<ul>
<li>s0, add a new file to do the following things</li>
<li>s1, todo: secondery pointer, deep copy the whole struct</li>
<li>s2, todo: backup the memory</li>
<li>s3, checkpoint?</li>
<li>当前仅修改pc，不做备份，只为了篡改执行路径</li>
</ul>
<p>分支当前的pc是tb块的最后一条指令(有时为跳转指令)的pc</p>
<p>Tiny Code Generator (TCG)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tb_trace</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> insn_num;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> pc_start;     <span class="comment">/* tb first pc */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trace_info</span> <span class="title">ti</span>[512];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TranslationBlock</span> &#123;</span></span><br><span class="line">    target_ulong pc;   <span class="comment">/* simulated PC corresponding to this block (EIP + CS base) */</span></span><br><span class="line">    target_ulong cs_base; <span class="comment">/* CS base for this block */</span></span><br><span class="line">    <span class="type">uint32_t</span> flags; <span class="comment">/* flags defining in which context the code was generated */</span></span><br><span class="line">    <span class="type">uint32_t</span> cflags;    <span class="comment">/* compile flags */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Per-vCPU dynamic tracing state used to generate this TB */</span></span><br><span class="line">    <span class="type">uint32_t</span> trace_vcpu_dstate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Above fields used for comparing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* size of target code for this block (1 &lt;= size &lt;= TARGET_PAGE_SIZE) */</span></span><br><span class="line">    <span class="type">uint16_t</span> size;</span><br><span class="line">    <span class="type">uint16_t</span> icount;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tb_tc</span> <span class="title">tc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* first and second physical page containing code. The lower bit</span></span><br><span class="line"><span class="comment">       of the pointer tells the index in page_next[].</span></span><br><span class="line"><span class="comment">       The list is protected by the TB&#x27;s page(&#x27;s) lock(s) */</span></span><br><span class="line">    <span class="type">uintptr_t</span> page_next[<span class="number">2</span>];</span><br><span class="line">    <span class="type">tb_page_addr_t</span> page_addr[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* jmp_lock placed here to fill a 4-byte hole. Its documentation is below */</span></span><br><span class="line">    QemuSpin jmp_lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The following data are used to directly call another TB from</span></span><br><span class="line"><span class="comment">     * the code of this one. This can be done either by emitting direct or</span></span><br><span class="line"><span class="comment">     * indirect native jump instructions. These jumps are reset so that the TB</span></span><br><span class="line"><span class="comment">     * just continues its execution. The TB can be linked to another one by</span></span><br><span class="line"><span class="comment">     * setting one of the jump targets (or patching the jump instruction). Only</span></span><br><span class="line"><span class="comment">     * two of such jumps are supported.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint16_t</span> jmp_reset_offset[<span class="number">2</span>]; <span class="comment">/* offset of original jump target */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TB_JMP_RESET_OFFSET_INVALID 0xffff <span class="comment">/* indicates no jump generated */</span></span></span><br><span class="line">    <span class="type">uintptr_t</span> jmp_target_arg[<span class="number">2</span>];  <span class="comment">/* target address or offset */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Each TB has a NULL-terminated list (jmp_list_head) of incoming jumps.</span></span><br><span class="line"><span class="comment">     * Each TB can have two outgoing jumps, and therefore can participate</span></span><br><span class="line"><span class="comment">     * in two lists. The list entries are kept in jmp_list_next[2]. The least</span></span><br><span class="line"><span class="comment">     * significant bit (LSB) of the pointers in these lists is used to encode</span></span><br><span class="line"><span class="comment">     * which of the two list entries is to be used in the pointed TB.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * List traversals are protected by jmp_lock. The destination TB of each</span></span><br><span class="line"><span class="comment">     * outgoing jump is kept in jmp_dest[] so that the appropriate jmp_lock</span></span><br><span class="line"><span class="comment">     * can be acquired from any origin TB.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * jmp_dest[] are tagged pointers as well. The LSB is set when the TB is</span></span><br><span class="line"><span class="comment">     * being invalidated, so that no further outgoing jumps from it can be set.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * jmp_lock also protects the CF_INVALID cflag; a jump must not be chained</span></span><br><span class="line"><span class="comment">     * to a destination TB that has CF_INVALID set.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uintptr_t</span> jmp_list_head;</span><br><span class="line">    <span class="type">uintptr_t</span> jmp_list_next[<span class="number">2</span>];</span><br><span class="line">    <span class="type">uintptr_t</span> jmp_dest[<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PPI_QR_FUNC</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tb_trace</span> *<span class="title">tt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tb_mem</span> *<span class="title">tm</span>;</span></span><br><span class="line">    <span class="type">int</span> cpu_id;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>{standard input}: Assembler messages: {standard input}:166160:
Warning: end of file not at end of a line; newline inserted {standard
input}:166333: Error: expected comma after name
`_ZNSt8_Rb_treeIiSt4pairIKiSt3setI11met' in .size directive
x86_64-xxx-linux-g++: internal compiler error: Killed (program cc1plus)
Please submit a full bug report, with preprocessed source if
appropriate. See for instructions. make[3]: *** [mds/Server.lo] Error 1
make[3]: *** Waiting for unfinished jobs....</p>
<p>这个错误的原因通常是，host机器内存不够导致的。
解决的办法是增加内存。硬件上的增加内存可以解决，或者kill系统当前其他的applications。甚至重新启动host，给编译器一个较为宽松的运行环境</p>
<p>QEMU以TB为单位进行翻译并执行。这也就是说每当在code
cache执行完一个TB之后，控制权必须交还给QEMU。这很没有效率。所以只要TB执行完之后，它的跳跃目标确定且该跳跃目标也已经在code
cache里，那我们就把这两个TB串接起来。这个就叫做block
chaining。有时QEMU开始执行一个基本块，然后被中断。然后，它可能会从一开始就重新执行该块，或者转换尚未执行的块的一部分并执行它。这将导致edge
map中出现一些额外的edge。所以首先禁用QEMU的chaining特性。</p>
<p>Tcgout branch生成两条 条件分支 一条b翻译成四条 非条件 条件 8条 jmmj
tcg_out_bl 条件跳转 翻译成call指令 改pc calue target
Guest知道bb最后一条</p>
<p>Tcg gencode预测 翻译的时候记录指令 在此之前disas已经完成
在这里插入跳转指令</p>
<p>2&gt; 输出系统错误</p>
<p>guest -&gt; ir -&gt; host</p>
<p>printf会影响回调函数的个数?</p>
<ol type="1">
<li>start_callback
是当前block执行前执行的函数，在里面对当前block的最后一条分支指令进行分支预测。</li>
<li>在当前block跳转指令执行前确定分支指令的跳转情况，用这个真实的跳转信息更新预测器</li>
<li>修改ir的目标地址，使得下一个block为预测方向的block</li>
<li>在错误路径执行N个block后恢复上次保存的信息，恢复到正常流程(N可以先写个固定的interval
比如5个block)</li>
</ol>
<ul>
<li>cpu_gen_code 負責 guest binary → TCG IR → host binary 的翻譯。
<ul>
<li>gen_intermediate_code_internal (target-*/translate.c) 初始化並呼叫
disas_insn 反組譯 guest binary 成 TCG IR。
<ul>
<li>disas_insn 呼叫 tcg_gen_xxx (tcg/tcg-op.h) 產生 TCG IR。分別將
opcode 寫入 gen_opc_ptr 指向的緩衝區 (translate-all.c 裡的 gen_opc_buf);
operand 寫入 gen_opparam_ptr 指向的緩衝區 (translate-all.c 裡的
gen_opparam_buf )。</li>
</ul></li>
<li>tcg_gen_code (tcg/tcg.c) 呼叫 tcg_gen_code_common (tcg/tcg.c) 將 TCG
IR 轉成 host binary</li>
</ul></li>
<li>tb_find_fast/slow 傳回 translation block 後，交給 tcg_qemu_tb_exec
執行。</li>
</ul>
<ol start="0" type="1">
<li>插桩 start_cb, 插在BB块开始的部分，会随着BB一起翻译、执行</li>
<li>翻译代码 Guest ---(teg_gen)--&gt; IR ---(tcg_out)--&gt; Host
<ul>
<li>aarch64_tr_translate_insn 调用tcg_gen</li>
<li>在tcg_out_xxx中插桩，在执行阶段中会被执行</li>
</ul></li>
<li>执行host代码</li>
</ol>
<h2 id="以cbz指令为例">以cbz指令为例</h2>
<p>Guest(arrch64) ---(teg_gen)--&gt; IR ---(tcg_out)--&gt; Host(i386)
tcg_gen_brcondi_i64(tcg/tcg-op.c)生成 ir</p>
<p>brcond_i64 tmp2,<span class="math inline">\(0x0,eq,\)</span>L1</p>
<p>目标 找到一条arrch64的分支指令究竟被翻译成了哪些IR
这些IR又变成了哪些host指令(i386) 然后
在tcg_out中插桩，获得我想要的真实信息，篡改执行的BB块</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tcg_out_op</span><span class="params">(TCGContext* s, TCGOpcode opc, <span class="type">const</span> TCGArg* args, <span class="type">const</span> <span class="type">int</span>* const_args)</span></span><br><span class="line">&#123;</span><br><span class="line">    TCGArg a0, a1, a2;</span><br><span class="line">    <span class="type">int</span> c, const_a2, vexop, rexw = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取最常见的参数 Hoist the loads of the most common arguments.  */</span></span><br><span class="line">    a0 = args[<span class="number">0</span>];     <span class="comment">// = TCG_REG_EBP, 代表要比较的寄存器</span></span><br><span class="line">    a1 = args[<span class="number">1</span>];    <span class="comment">// = 0, 要比较的常数</span></span><br><span class="line">    a2 = args[<span class="number">2</span>];    <span class="comment">// = 0x9, 表示分支的条件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (opc) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> INDEX_op_brcond_i32:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            a2: 表示分支条件; </span></span><br><span class="line"><span class="comment">            a0 a1为要比较的变量和值, </span></span><br><span class="line"><span class="comment">            const_args[1]: 表示a1是否为常数</span></span><br><span class="line"><span class="comment">            arg_label(args[3]): 表示跳转目标的标签</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        tcg_out_brcond32(s, a2, a0, a1, const_args[<span class="number">1</span>], arg_label(args[<span class="number">3</span>]), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">accel/tcg/translate-all.c::tb_gen_code --&gt;&gt; </span><br><span class="line">tcg/tcg.c::tcg_gen_code --&gt;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TCGContext</span> &#123;</span></span><br><span class="line">    ...;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> gen_next_op_idx;    <span class="comment">//写入下一个操作码的位置</span></span><br><span class="line">    <span class="type">int</span> gen_next_parm_idx;    <span class="comment">//写入下一个操作数的位置</span></span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line"></span><br><span class="line">    TCGOp gen_op_buf[OPC_BUF_SIZE]; <span class="comment">//保存生成的中间指令</span></span><br><span class="line">    TCGArg gen_opparam_buf[OPPARAM_BUF_SIZE];   <span class="comment">//保存中间指令的操作数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> gen_insn_end_off[TCG_MAX_INSNS];</span><br><span class="line">    target_ulong gen_insn_data[TCG_MAX_INSNS][TARGET_INSN_START_WORDS];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line">    <span class="comment">/// 放Host指令的地方</span></span><br><span class="line">    <span class="type">void</span> *code_gen_buffer;      <span class="comment">//保存生成的指令的缓冲区</span></span><br><span class="line">    <span class="type">size_t</span> code_gen_buffer_size;    <span class="comment">//缓冲区大小</span></span><br><span class="line">    <span class="type">void</span> *code_gen_ptr;     <span class="comment">//写入下一个生成指令的位置, 位于code_gen_buffer内部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TCGCond</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    <span class="comment">/* non-signed */</span></span><br><span class="line">    TCG_COND_NEVER  = <span class="number">0</span> | <span class="number">0</span> | <span class="number">0</span> | <span class="number">0</span>,</span><br><span class="line">    TCG_COND_ALWAYS = <span class="number">0</span> | <span class="number">0</span> | <span class="number">0</span> | <span class="number">1</span>,</span><br><span class="line">    TCG_COND_EQ     = <span class="number">8</span> ,</span><br><span class="line">    TCG_COND_NE     = <span class="number">9</span>,</span><br><span class="line">    <span class="comment">/* signed */</span></span><br><span class="line">    TCG_COND_LT     = <span class="number">0</span> | <span class="number">0</span> | <span class="number">2</span> | <span class="number">0</span>,</span><br><span class="line">    TCG_COND_GE     = <span class="number">0</span> | <span class="number">0</span> | <span class="number">2</span> | <span class="number">1</span>,</span><br><span class="line">    TCG_COND_LE     = <span class="number">8</span> | <span class="number">0</span> | <span class="number">2</span> | <span class="number">0</span>,</span><br><span class="line">    TCG_COND_GT     = <span class="number">8</span> | <span class="number">0</span> | <span class="number">2</span> | <span class="number">1</span>,</span><br><span class="line">    <span class="comment">/* unsigned */</span></span><br><span class="line">    TCG_COND_LTU    = <span class="number">0</span> | <span class="number">4</span> | <span class="number">0</span> | <span class="number">0</span>,</span><br><span class="line">    TCG_COND_GEU    = <span class="number">0</span> | <span class="number">4</span> | <span class="number">0</span> | <span class="number">1</span>,</span><br><span class="line">    TCG_COND_LEU    = <span class="number">8</span> | <span class="number">4</span> | <span class="number">0</span> | <span class="number">0</span>,</span><br><span class="line">    TCG_COND_GTU    = <span class="number">8</span> | <span class="number">4</span> | <span class="number">0</span> | <span class="number">1</span>,</span><br><span class="line">&#125; TCGCond;</span><br></pre></td></tr></table></figure>
<p>armv8指令手册 page202 Unconditional branch BL Branch with link BR
Branch to register BLR Branch with link to register</p>
<p>Conditional branch B.cond Branch conditionally CBNZ Compare and
branch if nonzero CBZ Compare and branch if zero TBNZ Test bit and
branch if nonzero TBZ Test bit and branch if zero</p>
<p>翻译的时候已经拿到预测结果 所以可以强行在tcg_out加跳转指令，
但是同时还需要知道真实的跳转指令，以便决定后面是否需要恢复
我可以利用重定向来进行篡改</p>
<h1 id="prologue初始化">prologue初始化</h1>
<ul>
<li>prologue 用来切换 qemu 代码和 code cache 的代码上下文，在
tcg_prologue_init(tcg_ctx) 调用 host 的 tcg_target_qemu_prologue
来组装这块代码。</li>
</ul>
<p>在x86上组装出来的代码如下: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x5644ca0ab000:  push   %rbp               //函数调用过程中将callee saved的入栈保存,完成了callee本身需要做的事情，因此在执行tb代码时可以使用所有的寄存器，在tb执行过程中不遵循函数调用的接口规范了</span><br><span class="line">0x5644ca0ab001:  push   %rbx  </span><br><span class="line">0x5644ca0ab002:  push   %r12  </span><br><span class="line">0x5644ca0ab004:  push   %r13  </span><br><span class="line">0x5644ca0ab006:  push   %r14  </span><br><span class="line">0x5644ca0ab008:  push   %r15  </span><br><span class="line">0x5644ca0ab00a:  mov    %rdi,%r14      //env到r14中，本身指向CPULOONGARCHState的对象，tb操作的对象都在</span><br><span class="line">0x5644ca0ab00d:  add    $0xfffffffffffffb78,%rsp      //</span><br><span class="line">0x5644ca0ab014:  jmpq   *%rsi      //跳转的tb的起始位置</span><br><span class="line"></span><br><span class="line">0x5644ca0ab016:  xor    %eax,%eax           //epilogue位置，返回值为0. 主要是为了goto_ptr使用</span><br><span class="line">0x5644ca0ab018:  add    $0x488,%rsp      //正常退出</span><br><span class="line">0x5644ca0ab01f:  emms   </span><br><span class="line">0x5644ca0ab022:  pop    %r15          //saved寄存器出栈</span><br><span class="line">0x5644ca0ab024:  pop    %r14  </span><br><span class="line">0x5644ca0ab026:  pop    %r13  </span><br><span class="line">0x5644ca0ab028:  pop    %r12  </span><br><span class="line">0x5644ca0ab02a:  pop    %rbx  </span><br><span class="line">0x5644ca0ab02b:  pop    %rbp  </span><br><span class="line">0x5644ca0ab02c:  retq                    //退出到qemu中</span><br></pre></td></tr></table></figure></p>
<h1 id="frontend的翻译">frontend的翻译</h1>
<ul>
<li>在target指令翻译过程TB以跳转指令结束，其他指令只需要根据语义翻译成IR指令就可以。
<ul>
<li>其中比较特殊的是跳转指令，TB开始和TB结束时的一些特殊代码. ##
TB开始位置: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gen_tb_start</span><br><span class="line">    ld_i32 tmp0,env,$0xffffffffffffffe4        //env指向CPULOONGARCHState，偏移是CPUState.icount_decr.u32相对于env的偏移;</span><br><span class="line">    movi_i32 tmp1,$0x0</span><br><span class="line">    brcond_i32 tmp0,tmp1,lt,$L0        //如果icount_decr.u32小于0则跳转到label 0处</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<p>参考文档:
https://qemu.readthedocs.io/en/latest/devel/tcg-icount.html</p>
<ul>
<li>icount只有在SOFTMMU中才有用，并且不能用在multi-threaded TCG
中，主要用于执行过程中指令的计数，后面详细再讲。</li>
</ul>
<h2 id="tb结束">TB结束:</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gen_tb_end</span><br><span class="line">   set_label $L0            //生成一个label 0，给`br $label`或者`brcond_i32/i64 label`，`goto_tb`这些提供錨点</span><br><span class="line">   exit_tb $0x55f975f8bec3     //退出到tb_ret_addr</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>C语言内联汇编</title>
    <url>/zyhjy/2023/02/07/C%E8%AF%AD%E8%A8%80%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/</url>
    <content><![CDATA[<h1 id="basic-inline.">0. Basic Inline.</h1>
<ul>
<li>The format of basic inline assembly is very much straight forward.
Its basic form is ## 基本形式: <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;assembly code&quot;</span>);</span><br></pre></td></tr></table></figure> ## Example. <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;movl %ecx %eax&quot;</span>); <span class="comment">/* moves the contents of ecx to eax */</span></span><br></pre></td></tr></table></figure>
## 说明:</li>
</ul>
<ol type="1">
<li>asm的语法规定mov的方向是从左到右，即<code>mov %src %dst</code> # 1.
extended assembly</li>
</ol>
<ul>
<li>可指定输入、输出,与asm外部的C程序交互 ## 基本形式: <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span> ( assembler template </span><br><span class="line">    : output operands                  <span class="comment">/* optional */</span></span><br><span class="line">    : input operands                   <span class="comment">/* optional */</span></span><br><span class="line">    : <span class="built_in">list</span> of clobbered registers      <span class="comment">/* optional */</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure> ##
说明:</li>
</ul>
<ol type="1">
<li>output
operands代表输出值，即该值可在执行中从asm寄存器获取到外部C程序中</li>
<li>input
operands代表输入值，即该值可从外部C程序传递给asm中的寄存器</li>
<li>list of clobbered
registers代表这段内联汇编执行后，哪些寄存器的值被破坏，来告知编译器做好备份和恢复工作
## Example</li>
</ol>
<ul>
<li>Example1: <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>, b;</span><br><span class="line"><span class="keyword">asm</span> (<span class="string">&quot;movl %1, %%eax; </span></span><br><span class="line"><span class="string">      movl %%eax, %0;&quot;</span></span><br><span class="line">     :<span class="string">&quot;=r&quot;</span>(b)        <span class="comment">/* output */</span></span><br><span class="line">     :<span class="string">&quot;r&quot;</span>(a)         <span class="comment">/* input */</span></span><br><span class="line">     :<span class="string">&quot;%eax&quot;</span>         <span class="comment">/* clobbered register */</span></span><br><span class="line">     );  </span><br></pre></td></tr></table></figure>
<ul>
<li>第一行将a的内容写入<code>%eax</code></li>
<li>第二行将<code>%eax</code>的内容输出到b</li>
<li><code>%1</code>,<code>%0</code>是占位符，会根据顺序和位置在下面的output、input匹配对应的的变量
<ul>
<li><code>%src</code>匹配input ；<code>%dst</code>匹配output</li>
</ul></li>
</ul></li>
</ul>
<p>Check out the <a
href="https://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">GCC
Inline Assembly</a> for more info on how to get the most out of ASM.</p>
]]></content>
      <categories>
        <category>C/C++ asm</category>
      </categories>
  </entry>
  <entry>
    <title>Effective C++(7)--模版与范型编程</title>
    <url>/zyhjy/2023/03/21/Effective%20C++(7)/</url>
    <content><![CDATA[<h1 id="条款44-将参数无关的代码抽离templates">条款44
将参数无关的代码抽离templates</h1>
<ul>
<li><code>template</code>可能会带来膨胀的重复的二进制代码</li>
<li>在<code>template</code>代码中，重复是隐晦的 ## EG1.
固定尺寸的正方矩阵的template ### 原始版本</li>
<li>n * n矩阵，元素类型是<code>T</code>，支持矩阵求逆 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;	<span class="comment">/// n * n矩阵，元素类型是T</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/// ...</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">()</span></span>;	<span class="comment">/// 求逆矩阵</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SquareMatrix&lt;<span class="type">double</span>, <span class="number">5</span>&gt; sm1;</span><br><span class="line">sm1.<span class="built_in">invert</span>();	<span class="comment">/// 调用SquareMatrix&lt;double, 5&gt;::invert()</span></span><br><span class="line">SquareMatrix&lt;<span class="type">double</span>, <span class="number">10</span>&gt; sm2;</span><br><span class="line">sm2.<span class="built_in">invert</span>();	<span class="comment">/// 调用SquareMatrix&lt;double, 10&gt;::invert()</span></span><br></pre></td></tr></table></figure></li>
<li>这里具现化两份invert代码，但是除了常量5和10，代码完全相同 ### Mod1.
建立带参数的函数</li>
<li>以5和10调用函数，减少重复代码 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;	<span class="comment">/// 与尺寸无关的base class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">/// ...</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">(std::<span class="type">size_t</span> matrixSize)</span></span>;	<span class="comment">/// 求逆矩阵</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;	<span class="comment">/// n * n矩阵，元素类型是T</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> : <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">using</span> SquareMatrixBase&lt;T&gt;::invert;	<span class="comment">/// 避免遮掩，见条款33</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/// ...</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>-&gt;<span class="built_in">invert</span>(n); &#125;;	<span class="comment">/// inline版的的调用，why this-&gt;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><code>SquareMatrixBase</code>模板只对元素类型T初始化，不对矩阵的尺寸参数初始化</li>
<li>Eg1中的<code>sm1</code>和<code>sm2</code>将共享<code>SquareMatrixBase&lt;double&gt;::invert</code></li>
<li><code>SquareMatrixBase&lt;double&gt;::invert</code>避免派生类代码重复</li>
<li>inline : 额外的调用成本是0</li>
<li>若不使用this-&gt;，模板化基类SquareMatrixBase<T>内的函数名会被派生类遮掩(条款43？)</li>
<li>private继承，仅帮助实现，不是表现is-a的关系(条款39？) #### 问题</li>
<li><code>SquareMatrixBase&lt;T&gt;::invert</code>如何知道矩阵数据在哪
### Mod2. 令SquareMatrixBase储存一个指针 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">SquareMatrixBase</span>(<span class="type">size_t</span> Size, T *pMem) : <span class="built_in">size</span>(Size), <span class="built_in">pData</span>(pMem) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setDataPtr</span><span class="params">(T *PData)</span> </span>&#123; pData = PData; &#125;</span><br><span class="line">	<span class="comment">/// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::<span class="type">size_t</span> size;</span><br><span class="line">	T* pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>这允许Derived Classes决定内存分配方式 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 该版本将矩阵数据存储在SquareMatrix内部</span></span><br><span class="line"><span class="comment">/// 这种类型的对象不需要动态内存分配，但对象自身可能非常大</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;	<span class="comment">/// n * n矩阵，元素类型是T</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> : <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SquareMatrix</span>() : <span class="built_in">SquareMatrixBase</span>&lt;T&gt;(n, data) &#123;&#125;;</span><br><span class="line">	<span class="comment">/// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T data[n * n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 该版本将矩阵数据放入heap</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;	<span class="comment">/// n * n矩阵，元素类型是T</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> : <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SquareMatrix</span>()</span><br><span class="line">		: <span class="built_in">SquareMatrixBase</span>&lt;T&gt;(n, <span class="literal">nullptr</span>), <span class="built_in">pData</span>(<span class="keyword">new</span> T[n * n])</span><br><span class="line">		&#123; <span class="keyword">this</span>-&gt;<span class="built_in">setDataPtr</span>(pData.<span class="built_in">get</span>()); &#125;</span><br><span class="line">	<span class="comment">/// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::array&lt;T&gt; pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
### 总结</li>
<li>SquareMatrix成员函数可以单纯的以inline方式调用base class版本
<ul>
<li>后者由持相同T的矩阵共享</li>
</ul></li>
<li>强行绑定矩阵尺寸的invert[Eg1.]
<ul>
<li>可能有更好的编译器实现和优化，但是会有大量重复的二进制代码</li>
</ul></li>
<li>不绑定尺寸的invert[Mod1., Mod2.]
<ul>
<li>减少执行文件大小</li>
<li>降低程序的working
set大小，(一个在VM下执行的进程所使用的那一组内存页)</li>
<li>强化指令高速缓冲区内的引用集中化(locality) ## 小结</li>
</ul></li>
<li>template不该与造成膨胀的模板参产生关系</li>
<li>non-type template
parameters(非类型模板参数)造成的代码膨胀，往往可以消除，做法是用函数或class成员变量替换template参数
## type parameters(类型参数)也会带来代码膨胀</li>
<li>如许多平台上int和long有相同的二进制表述
<ul>
<li>vector<int>和vector<long>应该共用一份底层实现</li>
</ul></li>
<li>指针往往也具有相同的二进制表述</li>
<li>让有相同的二进制表述的具现类型(instantiation types)共享实现码</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>Clion使用指南!</title>
    <url>/zyhjy/2023/03/22/Clion%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="常用快捷键">常用快捷键</h2>
<table>
<thead>
<tr class="header">
<th>｜shortcut</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>cmd + opt + -&gt; / &lt;-</td>
<td>恢复/撤销光标上次操作</td>
</tr>
<tr class="even">
<td>cmd+shift+ -</td>
<td>折叠所有代码块</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Clion</category>
      </categories>
  </entry>
  <entry>
    <title>CPU体系结构专业术语</title>
    <url>/zyhjy/2023/05/18/CPU%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD/</url>
    <content><![CDATA[<h1 id="mmiomemory-mapped-io">MMIO（Memory-Mapped I/O）</h1>
<ul>
<li><p>代表内存映射输入/输出。</p></li>
<li><p>它是一种计算机系统中用于与外部设备进行通信的技术。在MMIO中，外部设备的寄存器或状态被映射到计算机的内存地址空间中的特定区域。通过读取或写入这些内存地址，计算机可以与外部设备进行数据交换和控制操作。</p></li>
<li><p>MMIO的基本原理是通过在内存地址空间中保留一些特定的地址范围，让计算机能够直接访问外部设备的寄存器或状态。当计算机读取或写入这些地址时，数据被传递到或从外部设备进行处理。这种方式相对于使用专门的I/O指令进行输入/输出操作，提供了更简化和统一的编程界面。</p></li>
<li><p>常见的MMIO设备包括网络接口卡、图形显示控制器、声卡、串口控制器等。通过使用MMIO技术，计算机可以通过内存访问方式与这些设备进行通信，从而实现数据传输、设备控制和信息交换等功能。</p></li>
</ul>
]]></content>
      <categories>
        <category>Qemu</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/zyhjy/2023/04/12/Chiplets/</url>
    <content><![CDATA[<p>该论文讨论了系统级芯片（SoC）的复杂性和硅成本的增加促使将SoC分解为更小的“芯片块”。基于芯片块的SoC设计过程有望通过使用先进的封装技术将多个不同的芯片（例如CPU、GPU、内存、FPGA）紧密集成到一起来实现快速的SoC构建。然而，当将芯片块组装成单个SoC时，由于芯片块之间路由的复杂性增加，会出现正确性和性能问题。该论文提出了一种模块化但无死锁的路由方法，用于具有各种拓扑结构的基于芯片块的系统。</p>
<h1 id="introduction">INTRODUCTION</h1>
<p>在越来越复杂的工艺技术中，大型片上系统（SoC）的成本不断上升，这促使了基于“芯片”设计的SoC的出现。这个概念将传统的单片式SoC分解成几个更小的芯片，每个芯片都可以更便宜地开发，更容易在多个产品中重复使用，并使用最合适的工艺技术进行实现。芯片方法正在学术界[1]-[4]、工业界[5]-[11]和政府机构[12]中得到积极的研究
基于芯片的体系结构存在许多研究和工程挑战；我们关注其中一个具体但关键的问题。遵循模块化设计方法，每个单独的芯片都应该在不了解整个系统的情况下进行设计和验证。当从多个芯片构建SoC时，即使每个单独的组件都经过了正确的验证，完全集成的系统仍然可能存在正确性问题。互连网络特别容易受到这种影响。每个单独的芯片可能包含其自己的本地网络芯片（NoC），该NoC对于芯片内部流量是本地死锁自由且正常运行的。但是，连接多个NoC在一起可能会引入新的资源周期，从而导致跨芯片的循环依赖关系。”
虽然已经宣布了相对简单的基于芯片的体系结构[13]，或者甚至已经可用[14]，但这项工作进一步展望了基于在活动硅中间层上堆叠多个芯片的新兴体系结构（尽管我们也解释了如何将我们的方法应用于更接近的集成方法，例如被动中间层）。我们首先提供一些有关芯片的背景，并描述现有多芯片体系结构所涉及的模块化挑战。然后，我们介绍了一种新的基于芯片的路由方法，使每个芯片都可以独立设计，而不需要了解其他芯片或中间层的NoC细节，这是先前技术不支持的关键属性。我们的可组合路由方法利用了一个简单而强大的见解：从单个芯片的角度来看，整个系统可以抽象为单个虚拟节点。转向限制仅应用于连接芯片与虚拟节点之间的边界路由器，从而实现了以单个芯片为粒度的可处理分析和优化。
# II. CHIPLET-BASED SYSTEMS
“摩尔定律”和“丹纳德缩放定律”的减速使得先进工艺技术变得越来越复杂和昂贵。为了抵消缩放的减速，许多芯片变得更大，以继续在功能和性能上进行世代改进；最近的例子是使用了815平方毫米芯片的NVidia“Volta”GPU
[15]。最近，行业和政府正在追求和倡导基于“芯片组”的SoC设计概念，其中一个大型昂贵的SoC可以分解成多个较小、产量更高、成本更低的芯片组，然后使用先进的封装技术重新组装起来。这些技术包括AMD的超级计算APU愿景[6]，[10]，NVidia的MCM-GPU
[11]，TSMC的CoWoS（芯片-在-晶片-在-基板）服务，Marvell的MoChiTM（模块化芯片）架构[7]，[8]和DARPA的CHIPS项目[12]。芯片组方法还使得SoC可以结合来自不同公司的硅，例如最近宣布的Intel
Core处理器与AMD Radeon
Graphics技术[13]。计算机体系结构研究文献也反映了这些趋势，涉及使用被动硅中间层[16]、带微流控冷却的被动中间层[17]、有源硅中间层[2]、[18]和光子芯片组[3]、[4]等芯片组类似体系结构的研究。
## A. Active-interposer Chiplet SoCs
尽管当前的多芯片架构采用硅中间层[6]和多芯片模块[11]，[14]等被动集成技术，但本文展望了基于新兴活性硅中间层的芯片组SoC设计，如图1所示（我们在第VI节中探讨了其他封装技术）。尽管被动基板（仅有线而没有逻辑）[19]-[21]是近期商业关注的焦点，但越来越多的学术界[2]，[4]，[22]，工业界和政府研究机构[23]-[28]正在关注活性中间层。已经展示了一种带有3D
NoC的工作活性中间层原型[29]。
多常见的SoC功能可以移动到有源中间层，例如外部存储器接口、芯片间连接（即NoC）、外部IO和系统管理和调试（例如复位、JTAG）。这使得单个芯片可以更简单（减少设计时间）和更小（提高产量/成本）。如果芯片在更昂贵的技术节点（例如14nm）上实现，而中间层在更成熟和更便宜的工艺（例如28nm、20nm）上实现，则从更昂贵的芯片中移动逻辑到中间层可以获得额外的成本效益[2]。最近的分析得出结论，与被动硅中间层相比，有源中间层对于大型SoC来说也可以具有成本效益[30]。
## B. Baseline Assumptions
虽然我们提出的方法适用于各种可能的基于芯片的SoC，但我们专注于特定的架构作为工作示例。我们考虑了一个多芯片异构计算系统（“APU”），由CPU和GPU组件组成。图2显示了针对GPU计算进行优化的基线系统。有四个GPU芯片，每个芯片提供16个GPU
SIMD计算单元（CUs），以及一个中央CPU芯片，用于支持GPGPU工作负载的CPU阶段。这五个芯片堆叠在一个实现自己的NoC以相互连接芯片和其他常见系统功能的活动中间层上。
我们的基线配置使用网格拓扑结构来连接芯片和互连器的NoC子网络。每个GPU芯片的16个CU排列成4×4网格，互连器层也有一个4×4网格连接芯片。所有NoC组件都使用静态路由，采用路由表实现，这是当前商业系统（例如HyperTransport
[31]或QuickPath
Interconnect（QPI）[32]）的典型特征。每个芯片的本地网格和互连器网格使用X-Y路由。有关其他详细信息，例如NoC路由器配置（例如缓冲区大小，管道深度），请参见第V-A节。我们的基线提供了一个APU，其中包含64个GPU计算单元，4个CPU核心和8个外部内存通道，同时保持相对简单的结构以帮助我们的解释、评估和分析。
# 3. MOTIVATION ## A -
NoC提供了一种统一的接口，用于连接不同系统组件。与强制系统设计者在每对通信块之间实现特定接口并(更糟糕的是)验证每个接口的正确行为相比,NoC方法使得更模块化和可扩展的设计方法成为可能，这是将不同芯片连接在一起的自然选择。
- 路由可以显著影响网络性能、可靠性和功能性
。设计不良的路由算法可能会导致网络中的资源依赖关系，从而导致死锁，这可能对系统产生致命影响。我们在基于芯片片的系统中开发了一种模块化但无死锁的路由方法，该方法具有各种拓扑结构。
## B. Chiplet Composability Challenges -
对于多芯片SoC，小芯片可能来自不同的供应商[13]，即使由单个供应商提供，也可能由不同的团队独立设计。小芯片可能部署在多个产品中，包括在小芯片设计时甚至没有定义的未来产品，全局SoC路由信息可能不可用。因此，设计用于可扩展SoC或拓扑的小芯片变得极具挑战性，因为尽管每个小芯片的NoC可能是无死锁的，但它们仍然可以以在最终SoC中引入死锁的方式连接在一起。图3a显示了一个例子，其中两个4×4网状小芯片通过额外的链路连接。尽管每个单独的小芯片使用无死锁的X-Y路由，但仍然存在可能导致死锁的信道依赖性。图3b显示了一个基于两个小芯片插入器的系统，其中突出显示了一些潜在的依赖循环
-
大多数现有的无死锁路由算法都假设有完整的系统级信息可用，而这在基于小芯片的系统中并不一定有效。因此，这些方法不适用于路由可在多种SoC设计和拓扑中重复使用的模块化、独立设计的小芯片。我们解决了这个问题，并为未来SoC的模块化设计提出了一种可组合的路由算法。
## C. Deadlock Avoidance -
死锁是通过防止NoC的资源依赖关系图中的循环来避免的。有两种主要技术可以避免循环依赖：（1）<code>虚拟通道</code>（<code>VC</code>）方法[34]，以及（2）转弯模型[35]，[36]。转向模型不依赖于额外的虚拟通道来防止死锁。相反，它们对某些路径施加转向限制，以防止循环形成。在这项工作中，我们利用转弯限制来确保多芯片、基于插入器的NoC的死锁自由度，但我们引入了一种路由方法，该方法只需要在小芯片和插入器之间的“边界”处选择一些转弯限制。我们现在讨论相关工作，并在基于可重复使用的模块化小芯片的SoC的背景下解释其限制。
### VC-based Approaches -
基于VC的方法以<em>时间复用</em>的方式将物理信道划分为多个虚拟信道。每个VC都是独立管理的，并且在每个NoC路由器中都有专用的（每个VC）微片缓冲区。通过将不同的网络流分配给不相交的VC来消除循环依赖。请注意，除了避免协议级死锁所需的虚拟网络之外，还有路由死锁自由的VC。因此，对于需要复杂一致性协议的异构系统，所需的VC数量可能相当大（影响NoC路由器面积、功率等）。对于可组合的基于小芯片的系统，<em>必须预先配置VC数量，以支持最大的系统</em>，系统中的所有个体都必须为最大数量的VC实现这一点，导致小型系统的过度供应和单个小芯片的更高成本。
-
增加VC的数量会直接影响NoC路由器的面积和功率，因为每个VC都有自己的输入缓冲器，并且仲裁逻辑会随着VC的数量而扩展。从基于小芯片的系统的角度来看，单个小芯片的NoC可以设计成具有不同数量的VC，以保证死锁自由，这取决于本地拓扑和路由方案；这使得在集成多个这样的网络时设计和验证VC分配/仲裁逻辑极其复杂。为了使用VC消除死锁，设计人员需要提前了解完整的系统细节，过度配置VC，和/或限制每个小芯片和/或插入器的允许NoC。出于这些原因，我们寻求基于VC的方法的替代方案，以解决多芯片、基于插入器的SoC中的死锁。
### Flat Networks -
将整个系统作为一个平面网络，并应用统一的全局路由算法。在这种背景下，已经提出了许多拓扑不可知的路由算法。第一个这样的算法是up<em>/down</em>[37]，它使用由根节点形成的广度优先搜索（BFS）生成树。指向根的链接是上行链路，而其余的是下行链路。通过禁止消息从下行链路切换到上行链路来避免信道依赖性。上行*/下行路由需要以全局方式分析和编程所有路由表，这<strong>不允许单个芯片使用（更好的）本地路由决策。这也严重降低了系统的模块性和可组合性</strong>。我们还发现，上下路由会导致<strong>流量不平衡</strong>，因为<strong>根节点附近的链路往往比叶节点附近的更拥塞</strong>。
-
基于分段的路由将网络划分为子网，将子网划分为分段，并在每个分段内设置双向切换限制[38]。对于形成循环的起始段，除了起始路由器外，任何路由器都可以设置转弯限制；对于常规段，通过在任何路由器上设置双向转向限制来打破循环；对于仅由一条链路组成的一个路段，不允许任何流量穿过该链路（因此，在链路的一侧，必须在该链路和其他相邻链路之间设置双向转弯限制）。优化是可能的，因为转弯限制可以在一个路段内自由设置，而不依赖于其他路段。
-
Nue[39]是InfiniBand的一种基于目的地的遗忘路由实现。在网络的完全信道依赖图（CDG）的基础上，Nue构建了一个生成树，保证了死锁的自由性和连通性。然后，它使用Dijkstra算法计算从一个源节点到完整CDG中所有其他节点的最短路径，同时保持无循环约束。Nue不依赖VC来提供死锁自由，尽管额外的VC确实提高了负载平衡和性能
### ALL -
所有这些平面路由方法都需要目标SoC的全局信息来构建CDG，在CDG上可以实现死锁自由。对CDG进行全面分析的成本可能高得令人望而却步[40]。如前所述，完整的SoC配置和拓扑信息预计不可用于基于小芯片的系统（例如，小芯片可能用于未来尚未指定的SoC）。虽然我们提供了与其中几种方法的实验比较，但我们强调，这些现有方法都不能满足实现真正模块化和可重复使用的小芯片与独立优化的小芯片本地NoC的目标。
### Hierarchical Approaches: -
另一种方法是将NoC拓扑分解为几个层次结构层。在内部路由中，设计者可以自由地为单个级别选择任何现有的路由算法；并且每个节点只知道其级别内的本地节点。目的地为另一个级别的消息首先转发到连接到另一个层次结构级别的富时路由器。消息从源边界路由器指向其目的地通过其他边界路由器。分层路由的一个优点是独立分析本地网络的每一级，并且可以应用局部最优路由算法。然而，正如我们前面所讨论的，当<strong>将单个网络组合在一起时，全局网络仍然可能出现死锁</strong>。因此，必须小心避免全局死锁，这通常会导致对所有可能的全局路由路径进行逐案分析[41]，[42]。先前的工作提出了基于规则拓扑（如总线、环形、网格和树）的分层NoC[42]-[44]。然而，<strong>来自不同制造商的小芯片可能没有使用规则NoC进行设计，并且集成SoC系统可能不是对称的</strong>。因此，系统级的死锁避免仍然需要付出很大的努力，而且很容易出错。
## D. Comparison of Modularity -
虽然“模块化”可能有很多可能的定义，但我们将重点放在表I中列出的关键属性上。
- Table I: Comparison of deadlock avoidance approaches</p>
<table style="width:100%;">
<colgroup>
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>Independently Designed Chiplets</th>
<th>Enables Local Op-timization</th>
<th>Global CDG</th>
<th>Not Required Future-proof Chiplets</th>
<th>HW Cost</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>VC-based</td>
<td>-</td>
<td>++</td>
<td>+</td>
<td>-</td>
<td>High</td>
</tr>
<tr class="even">
<td>Flat NoCs</td>
<td>--</td>
<td>-</td>
<td>--</td>
<td>-</td>
<td>Low</td>
</tr>
<tr class="odd">
<td>Hierarchical</td>
<td>-</td>
<td>+</td>
<td>-</td>
<td>--</td>
<td>Low</td>
</tr>
<tr class="even">
<td>Composable(this work)</td>
<td>+</td>
<td>++</td>
<td>++</td>
<td>++</td>
<td>Low</td>
</tr>
</tbody>
</table>
<h3 id="independently-designed-chiplets">Independently Designed
Chiplets:</h3>
<ul>
<li>单个芯片的架构师应该能够设计和优化他们的本地NoC，而对整个SoC的其余部分知之甚少。基于VC的方法要求小芯片架构要么拥有整个SoC组织的信息（小芯片设计不再独立），要么过度提供VC的数量，以支持所有可能使用小芯片的SoC。扁平和分层的NoC通常也需要完整的SoC信息来分析和确保锁定自由
### Enables Local Optimization</li>
<li>模块化设计方法应允许小芯片架构师在独立于最终SoC组织的情况下局部优化一个chiplet的NoC。扁平化方法需要全局SoC信息，因此影响本地拓扑、路由算法、负载平衡等的芯片内优化，不能孤立地进行。分层NoC确实实现了一定程度的局部小芯片级优化，尽管这可能仍然受到完整CDG的全局分析的限制，以消除死锁。基于VC的方法以及本文提出的可组合方案有效地允许任意小芯片级别的NoC组织和优化
### Global CDG Not Required</li>
<li>平面和分层的NoC不是模块化的，因为构建依赖图需要所有通道的连接，并且在所有小芯片网络最终确定之前无法执行路由分配。在不影响全局路由决策的情况下优化本地NoC也是极其困难的，因为修改本地网络会改变全局CDG。基于VC的方法在局部优化方面提供了更大的灵活性，并且不需要全局CDG；他们需要一些全局信息来分配VC。我们的可组合方法要求与SoC集成商共享关于小芯片的一些有限信息（但远低于全套信道依赖性），并要求在独立的小芯片设计之间共享节点依赖性信息。
### Future-proof Chiplets</li>
<li>一个小芯片可能会集成到未来尚未设计的SoC中。由于扁平化和分层NoC方法需要全局CDG，小芯片将很难重复使用，因为本地NoC设计和优化可能已经固定。基于风险投资的方法可能会更好，但为尚未考虑的SoC过度提供风险投资可能会很昂贵。我们的可组合方法将与到/从中介器到SoC设计时间的流量相关的NoC决策延迟绑定（与设计小芯片时相反），从而在新的SoC组织中部署小芯片所需的效率和返工最少
### Hardware Cost:</li>
<li>除了基于VC的设计外，其他方法修改不同NoC组件的路由表，因此硬件开销很小。对于基于VC的方法，特别是如果需要为未来的系统进行超额配置，则支持更多VC的区域影响可能会相对昂贵。</li>
</ul>
<h1 id="iv.-multi-chiplet-routing">IV. MULTI-CHIPLET ROUTING</h1>
<p>在本节中，我们为芯片组系统提出了一种可组合、拓扑无关、无死锁的路由方法。关键的洞察力是简单而强大的：从任何单个芯片的角度来看，整个系统（与其他芯片的总数或中间层复杂性无关）都可以抽象成一个单一的虚拟节点，这使得在芯片粒度上进行可处理性分析、优化和正确性成为可能。我们详细介绍了一种基于芯片的路由具体方法，但这只是我们的关键洞察力所能实现的一种可能解决方案。
## A. Overview - Before describing our methodology, we define some
terms. ### 定义1： -
芯片组的边界路由器通过边界链路将芯片组连接到中间层。从中间层到芯片组的流量称为入站流量；从芯片组到中间层的流量称为出站流量。
### 定义2： -
边界路由器b的入站可达性InR(b)是从中间层通过路由器b可以到达的芯片上路由器的比例；0
&lt; <em>InR(b)</em> ≤ 1。 ### 定义3： -
边界路由器b的出站可达性OutR(b)是可以通过路由器b到达中间层的芯片上路由器的比例；0
&lt; <em>OutR(b)</em> ≤ 1。 ### 定义4： -
<em>InD(r)</em>是芯片路由器r的入站距离，是从最近的可以到达r的边界路由器到路由器r的拓扑距离。
### 定义5： -
芯片上路由器r的出站距离<em>OutD(r)</em>是从r到其最近可达边界路由器的拓扑距离。</p>
<p>这段话是在讨论可组合路由方法的目标。该方法的目标是尽可能地隔离单个芯片和中间层的设计，允许对每个芯片和中间层进行独立的负载平衡优化，同时为整个系统提供无死锁路由。</p>
<p>具体来说，我们在每个芯片上的边界路由器上放置单向转向限制。当应用转向限制时，系统的其余部分被抽象为一个与所有边界路由器相连的单个节点。转向限制确定了每个边界路由器的入站和出站可达性，并保证每个芯片内不存在循环通道依赖关系。然后，可达性信息传播到中间层，中间层负责将消息从一个边界路由器路由到另一个边界路由器。有了边界路由器可达性的知识，消息就会被转发到正确的目标芯片。一旦消息到达目标边界路由器，本地芯片NoC将把消息路由到其最终目的地。这种分层方法使用两组路由表来为每个芯片提供服务。第一组表用于在同一芯片内本地路由消息（这是常规的芯片内部路由），而第二组表则将出站消息引导到适当的边界路由器。本节末提供了更多实现细节。与第一条路由表（芯片内部）相对应的路由决策可以完全独立于系统的其余部分进行，这可能甚至尚未定义。
## B. Chiplet Design Guidelines
在设计芯片级NoC时，边界路由器的数量和位置是两个关键的设计参数，它们可以影响整个系统的性能。这些与芯片和中介器之间的垂直（微颗粒）链接数量有关
### Number of Boundary Routers: -
边界路由器的数量决定了芯片可以维持发送/接收离片流量的吞吐量；边界路由器越多，离片流量带宽就越高。一个极端情况是将芯片上的每个路由器都连接到中介器上，使每个路由器都成为边界路由器，这是先前其他人考虑过的[2]，[22]。然而，这样的设计可能会超额配置预期的离片流量，并可能受到可用微颗粒密度的限制。
-
在确定每个芯片的边界路由器数量时，一个关键观察是，虽然可能的边界路由器最大数量是芯片面积的函数，但最大有用带宽是其周长的函数。对于一个n×n网格的芯片，我们已经分析确定，在本文考虑的中介器拓扑结构下，n个边界路由器就足够了（为简洁起见，完整分析被省略）。对于我们大多数实验中假定的4×4芯片，我们每个芯片使用四个边界路由器。虽然我们专注于网格，但我们的方法适用于其他拓扑结构（请参见第VI节）。
### Turn Restrictions at Boundary Routers -
图3中的简单示例表明，通过中介器、其他芯片等，可能存在大量潜在的依赖循环，导致需要分析的可能路径数量爆炸。为了使单个芯片级别的路由决策成为可能，并使芯片间依赖分析可行，我们将系统的其余部分抽象为单个节点，并将所有边界路由器连接到抽象节点上（图4）。与之前的工作不同，这种新颖的抽象步骤是实现芯片独立设计的关键，而不需要全局CDG信息。
-
我们使用转向限制来打破包含抽象节点和一对边界路由器的循环。抽象节点代表单个芯片设计者不需要了解的系统的其余部分，因此<strong>转向限制不适用于抽象节点</strong>。在为边界路由器选择禁止转向时，必须保持连通性（即，每个芯片路由器到抽象节点之间必须存在路径，反之亦然），因此<strong>禁止导致断开NoC的转向限制</strong>。
-
在保持连通性的同时打破所有循环足以确保与该芯片相关的操作的正确性。但是，为了性能原因，仍然需要仔细选择转向限制和路由。可以采用不同的启发式方法；我们描述了一种在实践中表现良好的可能方法。我们考虑负载平衡的入站和出站可达性。不平衡的入站或出站可达性可能会导致芯片和/或中介器拥塞。同时，所有芯片路由器的入站和出站距离的平均值应该最小化，因为当路由到芯片外时，如果消息有多个边界路由器候选，则首选最近的边界路由器。总体而言，在选择禁止转向时，我们的目标是最小化平均距离/平均可达性，其中距离和可达性在第IV-A节中定义，并且平均值是在所有芯片上计算的。具体而言，平均距离是芯片上所有路由器的入站和出站距离的平均值。平均可达性类似地计算每个边界路由器的入站和出站可达性。我们的启发式方法选择具有较低平均距离和较高平均可达性的组合。
-
为了可视化指标，图4给出了一个4×4网格的示例，其中有3个边界路由器a、b和c；其余的系统用x表示。假设本地芯片NoC采用X-Y路由，禁止转弯的箭头在边界路由器处被划掉。包含x和任意一对边界路由器的循环通过禁止某些转弯来打破。
在此示例中，a 的入站可达性 (InR(a)) 为
1/2，因为其入站转向限制与小芯片的本地 X-Y
路由相结合，使得小芯片的左半部分无法从节点 x 通过 a 到达。
由于a没有出站转向限制，其出站可达性OutR(a)为1，即每台路由器都可以通过a到达x。
x → a → c → x 的环路在 c 处因出站转弯限制而中断，导致 OutR(c) = 1/2。
或者，不是在路由器 c 处断开环路，而是可以在路由器 a 处放置入站转弯限制 x
→ a → (3, 3) 以断开相同的环路，为此 InR(a) 变为 1/4（仅列 编号 2
可通过路由器 a
到达，因为两个单独的入站转弯限制用于打破两个不同的环路），并且 OutR©
变为 1。 路由器 m 的入站距离为 3，从边界路由器 b 测量； 出站距离为 3，到
a 或 b。 同样，从路由器c测得的路由器InD(n)=1； OutD(n) = 2 到路由器 a。
虽然此示例出于说明目的有些特别，但我们提供了一个具体的算法来确定下面的所有这些。
### Boundary Router Placement -
给定一个内部芯片级路由算法，边界路由器的选择会影响它们的入站和出站可达性以及芯片上的流量分布。我们提出了以下选择边界路由器的准则。
首先，避免将边界路由器聚集在一起，以减少创建网络热点的机会。
其次，应该以一种使所有边界路由器的入站/出站可达性保持平衡的方式放置边界路由器。
第三，更喜欢具有较低基数的路由器。
前两个准则旨在优化网络性能和吞吐量。第三个准则旨在最小化电路复杂性。例如，在图4中，芯片中间的四个路由器每个都有五个端口（四个连接到相邻路由器，第五个连接到它连接的网络端点，例如GPU
CU）。向其中一个“内部”路由器添加垂直链接将强制该路由器实现六个端口，这会增加面积并可能影响电路时序。但是，向芯片边缘上的任何一个路由器添加垂直链接都可以使所有路由器继续具有五个或更少的端口。
### Boundary Router Placement and Turn Restriction Algorithm - 算法1
确定每个芯片的边界路由器位置和转向限制。
PlaceBoundaryRouter通过调用SetTurns迭代所有边界路由器位置，以查找更好的位置和转向限制。
对于每个放置，函数identifyAllBoundaryTurns枚举所有可能的边界转弯并将它们存储在列表bturn
[]中。另一个列表pturn
[]存储禁止的边界转弯，这在SetTurns中递归更新。变量max是消除所有死锁所需的最大禁止边界转弯数。
- 过程 SetTurns
使用启发式方法检查所有边界转弯组合，如果当前限制改进了用户指定的目标函数，则更新迄今为止找到的最佳位置。
我们使用 CDG [39]、[45] 的矩阵表示。 最初，允许所有边界转弯。
更新函数（第 16 行）使用 Floyd Warshall 全对最短路径算法 [46]
传播到整个图的通道连接的禁止边界转弯列表 pt[] 更新 CDG。
这提供了来自更新的 CDG 的连接信息、边界路由器可达性和跳数。
下一步检查用户指定的目标函数是否得到改进（第 17 行）。 在第 19
行，connected 函数检查 CDG
是否仍然连接，因为任何导致网络断开的转向限制都应该被丢弃。
如果图是连通的，hasLoop
会检测入站通道（从抽象节点到边界路由器）是否连接到出站通道（从边界路由器到抽象节点）。
如果没有找到循环，则在第 22 行更新最佳位置，递归终止。 第 24
行控制递归的深度，因为只需要一定数量的边界限制就可以消除死锁。 如果 CDG
已连接但循环仍然存在，则第 27-29 行调用对 SetTurns
的递归调用以根据需要添加更多转弯限制。 ## C. Interposer NoC
Configuration -
确定了芯片的进出转向限制后，我们现在解释如何编程中继器的路由表。请注意，当单独考虑中继器网络（不包括芯片）时，中继器网络本身也应该是无死锁的。中继器负责将消息从一个边界路由器路由到另一个边界路由器。为此，必须向中继器提供某些芯片级别的信息。
首先，我们需要知道每个单独边界路由器可达的芯片节点（终端节点）。我们使用这个来确保消息从可以到达目的地的芯片边界路由器路由。其次，我们可以选择使用每个边界路由器和其可达芯片节点之间的拓扑距离来优化路由距离和负载平衡。请注意，这些信息可以简单地以“列表”格式列出（例如，节点x可以从边界节点y到达）；不需要芯片的本地NoC的完整细节（例如，网络的拓扑和请求如何从y到x的路由决策），并且这些信息独立于interposer和任何其他芯片。
我们现在描述我们的互连路由方案。对于每个目标路由器的消息，以下算法决定将该消息发送到目标芯片的哪个边界路由器。如果目标只能通过单个边界路由器到达，则中间件必须将消息路由到该特定边界路由器。否则，我们选择边界路由器以在边界路由器之间平衡网络负载（平均利用芯片-中间件带宽），同时最小化路径长度（避免发送消息在高度迂回的情况下只是为了负载平衡）。下面，我们正式指定算法。
- 对于给定的边界路由器i，仅由i可到达的节点集合称为Ai。 -
对于可以被多个边界路由器到达的其余节点，列表Ci包含所有节点，这些节点在拓扑上比任何其他边界路由器更接近i。对于不同的边界路由器j和k，Cj∩Ck=∅。
-
剩余的节点与至少两个边界路由器等距。设Ei，j是同时等距于边界路由器i和j的节点列表。虽然可能等距于两个以上的边界路由器，但为简单起见，我们仅考虑两个路由器的情况。
• 执行以下步骤将芯片上的节点分配给边界路由器。 -
第1步。在所有边界路由器中，选择具有Ai中最小项目数的路由器i。 -
第2步。逐个将Ci中的节点分配给Ai，直到Ai中的项目数不再是最小值。将项目分配给Ai时，从Ci中删除该项。如果Ai仍然具有最小数量的项目，则逐个从Ei，j中分配节点到Ai。将项目分配给Ai后，从Ei，j和Ej，i中删除该项。
-
第3步。如果无法进行进一步分配，则完成对边界路由器i的节点分配。重复步骤1-3，直到Ci
= ∅且Ei，j = ∅对于所有边界路由器i和j。
完成后，每个边界路由器的节点分配信息都存储在Ai中。通过参考这些信息，配置相应的中间层路由表。系统集成商可以自由选择任何对于中间层网络来说是死锁自由的底层路由算法。
- 考虑图4中的示例。对于边界路由器a、b和c，Aa = {(2, 0),(2, 1),(2, 2),
a}，Ab = {(0, 0),(0, 1), m,(0, 3), b,(1, 1),(1, 2),(1, 3)}，Ac = ∅；Ca =
{(3, 3)}，Cb = ∅，Cc = {(3, 0), c,
n}。在这个网络中没有等距集。节点分配从边界路由器c开始，因为Ac为空。Cc中的所有元素都分配给Ac，Ac
= {(3, 0), c,
n}。对于c，不能进行进一步的分配，因此算法选择下一个路由器a。Ca中唯一的元素被分配给Aa，Aa
= {(2, 0),(2, 1),(2, 2), a,(3,
3)}。到目前为止，每个芯片上的节点都被分配给了一个边界路由器；这些分配存储在Aa、Ab和Ac中。有了上述信息，互连器就能将消息路由到正确的边界路由器（a、b或c），如果消息是发送到该芯片的话。
## D. Deadlock Freedom and Connectivity -
现在我们展示可组合路由方案是无死锁且连通的。假设存在一个循环r1，l1，r2，l2，…，rn，ln，其中r表示路由器，l是连接到r的链接。如果所有路由器和链接都属于同一个芯片，则与基本假设芯片级网络无死锁相矛盾。否则，如果循环的子集属于插板和其他芯片，则可以用单个节点x来抽象这个子集。因此，该循环转换为r1，l1，…，rj，x，rk，lk，…，rn，ln。因为删除了包含x的循环中的所有循环依赖项，所以新循环是无死锁的。因此，可组合路由方案是无死锁的。
-
单个芯片内的任何网络都是连接的，因为边界路由器转向限制不影响内部芯片网络。芯片上的任何节点都能通过至少一个边界路由器到达中间层。中间层网络是通过构造连接的（即，每个中间层路由器都可以到达其他中间层路由器）。对于任何一对芯片节点，都存在一条路径。因此，该系统是连接的。
## E. Microarchitectural Issues -
每个芯片需要实现两个不同的路由表。第一个处理从不到达互连器的芯片内部流量。这个路由表可以以芯片设计者认为合适的任何方式填充。第二个路由表将出站流量定向到适当的边界路由器。这种组织方式假定整个系统中所有路由器端点都有全局ID空间。类似于用于检测系统中所有内存和计算资源（特别是在多插槽SMP系统中）的引导序列，可组合的基于互连器的SoC需要一个类似的系统配置协议。这个过程的一部分将是检测可用的NoC端点，为每个端点分配唯一ID，并计算和填充次级路由表。与系统引导不同，这个过程只会由SoC集成器在物理组装SoC后执行一次（尽管也可以提供钩子以在以后的某个时间点更新表，例如处理失败的链接[32]）
-
在我们的设计中，每个网络接口（NI）都有一个查找表，将出站数据包的目标ID映射到边界路由器ID。然后将边界路由器ID嵌入标题flit中，并用于芯片内路由，直到数据包离开芯片。关于面积/功率开销，每个NI中的查找表需要针对给定产品的最大系统大小进行配置。路由表通常比其他路由器组件（如缓冲区和交叉点）小得多。此外，每个芯片中第二个路由表的大小仅与边界路由器的数量成比例；因此，它比第一个路由表小得多。有几种实现互连路由器的方法：1）为最大系统大小提供路由表，导致相对较大的互连路由表；或2）添加另一层目标映射以将目标ID转换为目标边界路由器ID，导致更小的路由表但更复杂的边界路由器。总体而言，与规范的两级路由器相比，我们的设计不应产生显着的额外功率/面积/时间影响。
# V. EVALUATION ## A. Experimental Methodology -
为了评估网络性能，我们使用由 gem5 [47] 和 GPU 模型 [48] 的修改版本组成的
APU 模拟平台进行周期级执行驱动模拟。 我们使用 Garnet [49]
来模拟使用每通道 4-flit 缓冲区的 2 级路由器的网络。 我们的初始实验使用图
2 所示的多芯片 APU 配置，包括四个 GPU 芯片、一个 CPU
芯片和一个有源中介层。 CPU chiplet 由 CPU 内核、专用 CPU L1 和 L2
缓存以及末级缓存组成。 每个 GPU 小芯片由 16 个计算单元 (CU) 和 8 个 GPU
L2 缓存组组成。 我们的内存模型使用内置的 gem5 模型
[50]，每个通道有八个内存通道和八个存储体。 图 2 还显示了由我们的算法从第
IV 节确定的边界节点的位置。 -
我们同时使用合成流量和基于应用程序的模拟。对于合成流量，每个数据包宽度为8个flits，并且网络模拟了200万个周期。对于系统级（非合成）模拟，我们使用AMD
SDK [51]、Rodinia [52]和Pannotia
[53]套件中的APU应用程序，其中芯片外通信包括GPU
CUs之间的缓存一致性和到主存储器的流量。 ## B. Comparison Points -
即使从定性上看，基于VC的方法是昂贵且不太吸引人的，但为了完整性，我们提供了一个比较。使用与EbDa
[40]类似的方法，我们实现了一个支持最小路径自适应路由的VC-based死锁避免机制：对于单个2D网格，需要两个VC来避免死锁；通过在芯片和interposer之间引入垂直连接，需要两个更多的VC来隔离入站和出站流量。我们还实现了第III-C节中描述的三种全局路由算法：up<em>/down</em>
[37]、基于段[38]和Nue路由[39]。请注意，所有三种算法都需要完整的CDG知识，并且不支持独立设计和芯片复用。我们将其与之进行比较作为我们所知道的最相关的工作，但它们无法满足我们的关键芯片模块化标准。
-
在应用转向限制之前，通过找到与所有其他节点的平均距离最小的节点来选择上<em>/下</em>路由中的根节点。基于段的路由中的起始段是从系统的左上角（左上GPU芯片的左上路由器）形成的。在我们的可组合路由方案中，本地芯片算法和互连器算法都使用维度排序路由。为了与基于VC的方法进行公平比较，我们为每个基于转向的方案提供了四个VC。
-
我们还将我们的结果与理想化系统（表示为最短路径）进行比较，该系统使用不切实际的大量虚拟通道来避免死锁。
路由表是使用全对最短路径 (APSP)
算法配置的（与现有技术和我们自己提出的一些路由可能不是最短的方案形成对比）。
请注意，这个理想化的系统不一定能提供真正的最佳性能，因为 APSP
仍然会导致某些链路中的拥塞程度高于其他链路。
然而在实践中，我们发现这种最短路径配置通常优于实际的替代方案，因此它提供了一个乐观的性能目标来进行比较。</p>
<h2
id="c.-basic-throughput-evaluations-with-synthetic-traffic-使用合成流量进行基本吞吐量评估">C.
Basic Throughput Evaluations with Synthetic Traffic
使用合成流量进行基本吞吐量评估</h2>
<ul>
<li>在本节中，我们评估了一个由四个芯片组成的64-CU系统，每个芯片组由16个CU组成，组织为4×4网格。每个芯片组通过四个边界路由器连接到中间层。中间层网络是4×4网格。</li>
<li>图5a和图5b显示了均匀随机和位补码流量下的负载延迟曲线。我们观察到，许多异构多芯片工作负载与均匀随机流量相似：实际系统具有混合的芯片内、芯片间、芯片到互连器和芯片到内存的流量，涵盖了一致性和主存储器请求和响应；这些在总体上“平均”，使得均匀随机流量的高级性能趋势与我们的几项应用驱动研究大致相符。位补码流量模式强制所有数据包离开芯片，因此进一步加重了互连器的压力并创建了网络热点。我们运行了其他合成流量模式，但总体趋势非常相似，因此没有显示。</li>
<li>我们的可组合方案优于up<em>/down</em>、基于段的和VC-based方法。在相同数量的虚拟通道下，可组合方案的性能优于VC-based方法，主要是因为额外的虚拟通道减少了头阻塞。典型的一致性协议需要3-5个虚拟网络，每个虚拟网络都需要四个VC以实现死锁自由。异构架构的一致性协议可能需要更多的虚拟网络，使得VC-based方法变得更加昂贵。虽然VC-based方法需要每个虚拟网络四个VC以实现正确性，但是由于VC-based和可组合方案之间的性能差距，需要更多的VC以实现更好的性能。</li>
<li>基于段的路由在零负载延迟方面存在问题，并且具有最低的饱和吞吐量。这主要是因为它是为2D网格状网络设计和优化的。虽然评估系统由多个网格网络组成，但全局拓扑结构仍然不规则，因此基于段的路由无法有效处理它。基线基于段的算法并不总是形成最优段；从边界路由器向中间件开始的段可能会绕到同一芯片上的路由器上结束，或者通过另一个芯片跨越多个跳跃，直到到达属于现有段的路由器。这样的链式段在较大的系统中可能非常长，并且在段内断开任何双向转弯将导致更多的非最小路径（对于基线APU，我们观察到平均路由距离近11个跳跃，而其他方法则为∼8个跳跃）。虽然拓扑感知优化可能会改善基于段的路由性能，但这超出了本文的范围。¹</li>
<li>上行<em>/下行</em>
路由具有低零负载延迟，这表明消息可能会在评估系统中采用最少的路由。
然而，与其他方法相比，它相对较早地饱和。
根节点附近的链路本质上比叶节点附近的链路更拥塞。
当注入率增加时，这些环节会饱和并成为瓶颈。 Nue
路由优于我们的可组合方法，但这只是因为它具有利用完整 CDG
知识优化其路由的优势，从而导致与理想的最短路径算法类似的行为。
有了足够的
VC（我们为其提供），它会找到优化的路径来平衡网络工作负载。</li>
<li>我们的组合方案优于up<em>/down和基于段的路由，因为芯片和互连网络更加负载平衡，芯片和互连器之间的垂直链接也是如此。Nue提供更好的负载平衡，因此表现接近理想的最短路径路由，但与其他先前的工作一样，它不适用于独立设计和重用芯片以进行模块化SoC构建。与理想的最短路径路由相比，我们的方案覆盖了从up/down</em>到理想化最短路径路由的吞吐量差距的大部分，但仍然存在一些余地。这是因为1）由于转向限制而仍然存在一些负载不平衡，以及2）理想化网络具有更多的虚拟通道以改善头部阻塞。总体而言，尽管我们提出的方法没有实现全局负载平衡优化的全部性能，但我们的结果表明，我们的方案确保了正确性，并提供了高性能的多芯片SoC，它独特地实现了一种模块化芯片设计方法论，不需要对整个系统的CDG有先验知识。
## D. Application-level Impact ### Network Latency:
我们使用执行驱动模拟对非合成工作负载评估了我们的可组合路由方案。图6a显示了平均网络延迟，归一化为理想的最短路径方法。基于段的路由未显示，因为在给定的系统大小下，它始终表现出色并且明显优于其余方法。我们省略了基于VC的方案，因为评估的异构系统需要大量的VC才能避免路由和协议级死锁，同时保持性能。总体而言，我们的可组合方法实现的网络延迟几乎与最短路径相同。在一些情况下（bfs、nw、srad），可组合路由比最短路径表现略好；正如前面所讨论的，最短路径并不是真正的最优解，有时会出现局部流量突发（这种情况在GPU工作负载中比传统CPU应用程序更常见），会导致最短路径配置中的拥塞/负载不平衡。
由于根节点在高负载下成为瓶颈，因此上下行方法的大多数基准测试的平均网络延迟增加了50%以上，如第V-C节所讨论的。这种瓶颈限制了系统的有效带宽，并导致了显着的网络缓冲延迟。
### Application Performance:
图6b显示了程序执行时间，归一化为理想的最短路径方法。总体而言，可组合路由与最短路径相比实现了类似（在1%以内）的系统性能。虽然APU/GPGPU应用程序会生成大量的NoC/内存流量（这对于压力网络来说非常好），但对应用程序执行时间的总体影响却很小，因为大多数GPU应用程序本质上对延迟不太敏感（即，丰富的SIMD并行性可以更容易地容忍增加的延迟）。虽然有流量突发，但应用程序的大部分部分不会使NoC接近饱和，因此对总执行时间的影响较小。尽管如此，我们仍然观察到一些工作负载使用up<em>/down</em>路由时性能下降了5-10%，而我们的方法在大约与最短路径方法相同的水平上执行。
### Case Study – HotSpot:
图7显示了执行HotSpot时最常用的链接的最大链接利用率。仅显示了互连网络和GPU芯片上的边界路由器，因为其余部分利用率较低。对于每个10000个周期，我们对每个链接的利用率进行了采样。链接的最大利用率是整个程序执行过程中观察到的最大采样结果。最大链接利用率向我们展示了在突发流量行为下最糟糕的链接拥塞发生在哪里，从而使我们能够可视化全局网络流量并定位任何NoC瓶颈。一般来说，可组合路由比最短路径具有更少的拥塞链接。但是，前者在互连器上具有略微不平衡的流量分布，这表明最大链接利用率更大。这是由于转向限制偏向边界路由器的可达性（即，某些边界路由器接收更多流量）。对于上<em>/下</em>路由，根节点位于互连器上。如预期所示，靠近根节点的链接比其他链接更加利用。
# VI. BROADER APPLICABILITY 更广泛的适用性
前一节展示了我们方法在一个特定的芯片组SoC上的有效性。在本节中，我们提供了额外的实验结果，因为各种系统假设被修改，然后我们还讨论了如何将该提议应用于没有活动互连器的芯片组系统。
## A. Design Guideline Justification 设计指南的证明
在第IV-B节中，我们描述了如何确定边界路由器的数量、选择转向限制的目标函数以及边界路由器的放置。为了证明所提出的指南的有效性，我们使用均匀随机流量评估了其他设计方案。图8a显示了从2个边界路由器增加到8个路由器时吞吐量的提高。在所有情况下，互连网络保持相同的大小；当有8个边界路由器时，2个边界路由器集中到一个互连路由器上，这增加了路由器的复杂性和面积。从4个边界路由器到8个边界路由器的改进要比从2个边界路由器到4个边界路由器的改进小得多。不足的边界路由器可能会影响系统吞吐量。通过提供更多的边界路由器，可以增加芯片外带宽，从而减少与芯片内通信的干扰。在16个边界路由器的极端情况下，每个芯片路由器都有一个垂直连接，与芯片外通信不会影响芯片内通信/拥塞。然而，这样的设计是不切实际的，因为需要大量垂直线。总体而言，在性能和硬件成本方面，4个边界路由器是一个合理的设计选择。
图8b比较了不同目标函数的系统吞吐量，包括最小化平均距离、最大化平均可达性和我们提出的度量（即最小化平均距离/平均可达性）。结果表明，我们提出的目标函数是有效的，并且与其他度量相比提供了最佳性能。仅考虑平均距离或平均可达性往往会创建不平衡的芯片内流量。
在某些情况下，设计者可能没有自由选择边界路由器放置位置的自由（例如，布局限制，物理设计约束）。图8c考虑了边界路由器位置已移动到较不理想的位置（例如，聚集在一起），分散到角落，位于同一行（即与我们的方法分配给它们的位置不同）。我们重新运行了确定转向限制的算法。结果表明，边界路由器的随机放置最终导致某些链接被使用得比其他链接更多，从而影响了系统吞吐量，但死锁自由仍然得以保持。
## B. Sensitivity Studies 我们考虑了以下基线的变体：
系统规模：基线具有4个GPU芯片，每个芯片有16个CU，总计算能力为64个CU。我们还考虑了两种128-CU配置（CPU数量保持不变），分别由（1）每个芯片32个CU的4个芯片和（2）每个芯片16个CU的8个芯片组成。在这两种情况下，每个芯片仍然有四个边界路由器。
Interposer
NoC拓扑结构：为了支持这一论点，即中介器的NoC可以独立于芯片设计，我们评估了基线系统，但将中介器的网状NoC替换为“双蝴蝶”拓扑结构[22]
不规则芯片拓扑结构：为了支持芯片的NoC拓扑结构可以独立设计的类似主张，我们评估了一个系统，其中每个GPU芯片都实现了一个不同的本地NoC拓扑结构，包括网格、环、蝴蝶和树形拓扑结构
结果：本节中的分析仅呈现了均匀随机流量的负载延迟曲线。我们也进行了应用程序级别的实验，但总体趋势非常一致，因此我们由于空间原因和重复性而省略了这些附加图形。这些实验的主要目的是证明我们的提议是一种在广泛的基于芯片组的系统可能性范围内实现高性能并确保死锁自由的强大方法。
图9a和b显示了更大的128-CU配置的结果，我们的组合方法轻松地优于上/下路由。这两个配置之间的主要区别是芯片内和芯片间流量的比例。与最短路径相比，我们的组合方法对流量分布不太敏感，因为具有更好的芯片级和互连器级负载平衡。”
的中文翻译是：“图9a和b显示了更大的128-CU配置的结果，我们的组合方法轻松地优于上/下路由。这两个配置之间的主要区别是芯片内和芯片间流量的比例。与最短路径相比，我们的组合方法对流量分布不太敏感，因为具有更好的芯片级和互连器级负载平衡。
图9c显示了当插层NoC具有蝴蝶式拓扑结构时的结果。结果与网格的基准系统类似，总体上这有助于证明可以轻松地独立设计单个芯片，而不受插层NoC拓扑结构的影响。
图9d显示了当每个GPU芯片组具有不同的本地NoC拓扑时的结果。这里的结果更有趣，因为我们的提议导致的饱和吞吐量比具有丰富虚拟通道和最短路径路由的“理想”情况更高。这是因为在处理芯片间通信时，最短路径会偏向于靠近互连器中心的边界路由器，而我们的提议方法实现了更好的互连器流量分布。”
的中文翻译是
“图9d显示了当每个GPU芯片组具有不同的本地NoC拓扑时的结果。这里的结果更有趣，因为我们的提议导致的饱和吞吐量比具有丰富虚拟通道和最短路径路由的“理想”情况更高。这是因为在处理芯片间通信时，最短路径会偏向于靠近互连器中心的边界路由器，而我们的提议方法实现了更好的互连器流量分布。
## C. Other Chiplet Packaging Options
到目前为止，我们的研究集中在基于新兴活性硅中间层技术构建的芯片组系统上。虽然活性硅中间层可能是实用的，特别是如果可以将用于逻辑的总中间层面积最小化[2]，[30]，但近期芯片组系统可能会受到被动基板的限制。无论是使用被动硅中间层[19]-[21]还是更传统的封装基板[7]，[11]，[14]，[54]，一个可能的担忧是芯片组下方缺乏活性层可能会限制我们方法的适用性。
图10a显示了一个在被动基板上具有芯片的示例系统。此布局假定提供了常见功能的中央芯片（否则将放置在活动互连器上，例如内存控制器、NoC、系统管理），计算芯片以星形拓扑结构从中央芯片向外扩展。使用这种类型的布局，我们的建议方法可以直接应用于此系统，无需进行任何修改，方法是将中央芯片与我们之前的工作示例中的活动互连器相同对待。选择最佳边界节点放置的过程可以更有效，因为芯片上可供选择的合理节点较少（即最靠近中央芯片的节点）。
## D. Other Chiplet Topologies
即使对于非星型拓扑的芯片，他们的方法也可以进行适应。图10b显示了一个基于芯片的系统，其中两个CPU芯片具有额外的点对点链接（例如，用于低延迟高速缓存一致性），这些链接不通过中央芯片进行路由。为了支持这一点，这两个CPU芯片被有效地视为单个虚拟芯片，以应用他们的方法来确定路由限制。仍然需要CPU芯片设计人员确保两个CPU芯片之间的直接路由是正确的（即无死锁），但设计人员无需担心从/到中央芯片进入/离开任一芯片的流量，因为他们的方法确定适当的转向限制以确保整个SoC的正常运行。
同样，图10c显示了一个没有单个“中央”芯片的系统，而是有两个芯片连接到其他芯片。在这里，我们应用了类似的技术，其中两个芯片被视为单个虚拟芯片，以便于此方法。与上面的两个CPU芯片示例类似，SoC设计人员必须确保一对芯片是相互/本地死锁自由的，但是任何剩余的与其他芯片的连接都将得到正确处理。大多数合理的芯片拓扑都可以迭代地合并，直到将拓扑转换为类似星形的组织为止，此时我们的方法可以直接应用。
# VII. RELATED WORK
平面网络：在第III-C节中，我们介绍了一种避免死锁的平面网络方法。对up<em>/down</em>路由的进一步优化已被提出：Koibuchi等人基于BFS生成树构建了一个从左到右的有向图，并在根节点周围分配流量[55]；Sancho等人使用深度优先搜索（DFS）生成树[56]；他们通过在每个周期中单独删除每个方向上的通道依赖关系来改善流量平衡[57]。
分层网络：HiRA
[41]是一种用于分层NoC中无死锁路由的方法。在HiRA中，网络被划分为子网（具有独立无死锁路由算法的网络）和外部链接（子网之间的链接）。通过在每个子网中选择安全边界节点并在边界节点上应用转向限制来避免死锁。当连接到其他子网时，如果边界节点不会发生死锁并且可以保证连通性而不修改子网的内部路由算法，则边界节点是安全的。在应用边界节点上的转向限制时，使用包含所有边界节点的CDG。虽然HiRA可应用于具有被动互连器的芯片组系统，但对于两个主要原因，它不适用于主动互连器SoC。首先，仍需要系统级CDG，并且转向限制在很大程度上取决于子网路由算法。其次，HiRA缺乏中央网络（即主动互连器）的路由算法，该网络连接到所有芯片组。
“3D NoC中的路由：常规3D
NoC的死锁避免技术包括DoR和基于转向的路由[35]，[58] -
[60]和基于VC的方法[61] -
[63]。其中许多技术不直接适用，因为它们的基于转向的算法要求每个路由器在堆栈中具有垂直连接（我们不做出这种假设），这会增加每个芯片TSV区域开销。其他3D
VC技术创建与芯片在堆叠中的垂直位置相关联的单调VC排序；芯片在中间层上的物理拓扑结构使得很难强制实施总排序。我们不提供这些作品的实验评估，因为不明显如何将它们适应不仅由单个垂直3D芯片堆栈组成的拓扑结构。”
# VIII. CONCLUSIONS
基于芯片组的复杂SoCs的构建非常令人兴奋，因为它可以实现各种类型的系统，但这些系统必须易于设计和组装。当使用来自第三方硅IP供应商的黑盒芯片构建系统时，确保正确性变得更加具有挑战性和重要性。本文对基于芯片组的SoC设计方法论做出了重大贡献，重点是互连；然而，仍有其他有益的研究领域。如果系统中的不同芯片要具有高速缓存一致性，则必须设计一个正确运行并跨不同物理芯片扩展（以性能为准）的高速缓存一致性协议。虽然不是严格的正确性问题，但可能需要设计服务质量机制，以确保不同的芯片集成在一起“友好地协作”，特别是在实时组件（例如图形和音频）或更高级别的性能目标（例如数据中心服务级别协议）方面。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Qemu TCG IR</title>
    <url>/zyhjy/2023/05/18/Qemu%20TCG%20IR/</url>
    <content><![CDATA[<h1
id="tcg-intermediate-representation-tcgtiny-code-generator中间表示">TCG
Intermediate Representation / TCG（Tiny Code Generator）中间表示</h1>
<h2 id="introduction-介绍">Introduction / 介绍</h2>
<ul>
<li>TCG（Tiny Code
Generator）最初是作为一个C编译器的通用后端而开始的。它经过简化后用于QEMU。</li>
<li>它还源于由Paul Brook编写的QOP代码生成器。</li>
</ul>
<h2 id="definitions-定义">Definitions / 定义</h2>
<ul>
<li><p>TCG的<em>目标</em>是我们生成代码的架构。</p></li>
<li><p>它当然不同于QEMU的"目标"，QEMU的目标是被模拟的架构。</p></li>
<li><p>当TCG作为一个用于交叉编译的通用C后端开始时，假设TCG的目标可能与主机不同，尽管对于QEMU来说永远不会是这种情况。</p></li>
<li><p>在这个文档中，我们使用<em>guest</em>来指定我们正在模拟的架构；<em>target</em>始终指的是TCG的目标，也就是我们运行QEMU的机器。</p></li>
<li><p>具有<em>未定义行为</em>的操作可能导致崩溃。</p></li>
<li><p>具有<em>未指定行为</em>的操作不会崩溃。然而，结果可能是多种可能性之一，因此可能被视为<em>未定义的结果</em>。</p></li>
</ul>
<h2 id="basic-blocks-基本块">Basic Blocks / 基本块</h2>
<ul>
<li><p>TCG的<em>基本块</em>是一个单入口、多出口的区域，对应于一系列指令，并以标签或任何跳转指令结尾。</p></li>
<li><p>TCG的<em>扩展基本块</em>是一个单入口、多出口的区域，对应于一系列指令，并以标签或无条件跳转指令结尾。</p></li>
<li><p>具体来说，扩展基本块是由零个或多个条件跳转指令的顺序连接起来的一系列基本块。</p></li>
</ul>
<h2 id="operations-操作">Operations / 操作</h2>
<ul>
<li><p>在TCG中，TCG指令或操作（ops）作用于TCG变量，它们都具有强类型。</p></li>
<li><p>每个指令都有固定数量的输出变量操作数、输入变量操作数和常量操作数。</p></li>
<li><p>向量指令具有指定向量中元素大小的字段。需要注意的例外是调用指令，它具有可变数量的输出和输入。</p></li>
<li><p>在文本形式中，输出操作数通常首先出现，然后是输入操作数，最后是常量操作数。</p></li>
<li><p>指令名称中包含输出类型。</p></li>
<li><p>常量以'$'前缀表示。</p></li>
<li><p>例如：</p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_i32 t0, t1, t2    /* (t0 &lt;- t1 + t2) */</span><br></pre></td></tr></table></figure>
<ul>
<li>上述示例中，<code>add_i32</code>表示整数相加的指令，<code>t0</code>是输出变量，<code>t1</code>和<code>t2</code>是输入变量。指令执行后，<code>t0</code>的值将等于<code>t1</code>和<code>t2</code>的和。</li>
</ul>
<h1 id="variables">Variables</h1>
<ul>
<li><p><code>TEMP_FIXED</code></p>
<p>There is one TCG <em>fixed global</em> variable,
<code>cpu_env</code>, which is live in all translation blocks, and holds
a pointer to <code>CPUArchState</code>. This variable is held in a host
cpu register at all times in all translation blocks.</p></li>
<li><p><code>TEMP_GLOBAL</code></p>
<p>A TCG <em>global</em> is a variable which is live in all translation
blocks, and corresponds to memory location that is within
<code>CPUArchState</code>. These may be specified as an offset from
<code>cpu_env</code>, in which case they are called <em>direct
globals</em>, or may be specified as an offset from a direct global, in
which case they are called <em>indirect globals</em>. Even indirect
globals should still reference memory within <code>CPUArchState</code>.
All TCG globals are defined during <code>TCGCPUOps.initialize</code>,
before any translation blocks are generated.</p></li>
<li><p><code>TEMP_CONST</code></p>
<p>A TCG <em>constant</em> is a variable which is live throughout the
entire translation block, and contains a constant value. These variables
are allocated on demand during translation and are hashed so that there
is exactly one variable holding a given value.</p></li>
<li><p><code>TEMP_TB</code></p>
<p>A TCG <em>translation block temporary</em> is a variable which is
live throughout the entire translation block, but dies on any exit.
These temporaries are allocated explicitly during translation.</p></li>
<li><p><code>TEMP_EBB</code></p>
<p>A TCG <em>extended basic block temporary</em> is a variable which is
live throughout an extended basic block, but dies on any exit. These
temporaries are allocated explicitly during translation.</p></li>
</ul>
<h1 id="types">Types</h1>
<ul>
<li><p><code>TCG_TYPE_I32</code></p>
<p>A 32-bit integer.</p></li>
<li><p><code>TCG_TYPE_I64</code></p>
<p>A 64-bit integer. For 32-bit hosts, such variables are split into a
pair of variables with <code>type=TCG_TYPE_I32</code> and
<code>base_type=TCG_TYPE_I64</code>. The <code>temp_subindex</code> for
each indicates where it falls within the host-endian
representation.</p></li>
<li><p><code>TCG_TYPE_PTR</code></p>
<p>An alias for <code>TCG_TYPE_I32</code> or <code>TCG_TYPE_I64</code>,
depending on the size of a pointer for the host.</p></li>
<li><p><code>TCG_TYPE_REG</code></p>
<p>An alias for <code>TCG_TYPE_I32</code> or <code>TCG_TYPE_I64</code>,
depending on the size of the integer registers for the host. This may be
larger than <code>TCG_TYPE_PTR</code> depending on the host
ABI.</p></li>
<li><p><code>TCG_TYPE_I128</code></p>
<p>A 128-bit integer. For all hosts, such variables are split into a
number of variables with <code>type=TCG_TYPE_REG</code> and
<code>base_type=TCG_TYPE_I128</code>. The <code>temp_subindex</code> for
each indicates where it falls within the host-endian
representation.</p></li>
<li><p><code>TCG_TYPE_V64</code></p>
<p>A 64-bit vector. This type is valid only if the TCG target sets
<code>TCG_TARGET_HAS_v64</code>.</p></li>
<li><p><code>TCG_TYPE_V128</code></p>
<p>A 128-bit vector. This type is valid only if the TCG target sets
<code>TCG_TARGET_HAS_v128</code>.</p></li>
<li><p><code>TCG_TYPE_V256</code></p>
<p>A 256-bit vector. This type is valid only if the TCG target sets
<code>TCG_TARGET_HAS_v256</code>.</p></li>
</ul>
<h2 id="helpers-辅助函数">Helpers / 辅助函数</h2>
<ul>
<li><p>在TCG中，辅助函数（helpers）通过在特定于客户机的<code>helper.h</code>中注册，并处理生成<code>tcg_gen_helper_*</code>函数。</p></li>
<li><p>借助这些函数，可以调用接受i32、i64、i128或指针类型的函数。</p></li>
<li><p>默认情况下，在调用辅助函数之前，所有全局变量都会存储在其规范位置上。</p></li>
<li><p>默认情况下，辅助函数允许修改CPU状态（包括由tcg全局变量表示的状态）或引发异常。</p></li>
<li><p>可以使用以下函数修饰符来覆盖默认行为：</p>
<ul>
<li><code>TCG_CALL_NO_WRITE_GLOBALS</code>
<ul>
<li>辅助函数不会修改任何全局变量，但可能会读取它们。</li>
<li>在调用辅助函数之前，全局变量将保存在其规范位置，但在调用后不需要重新加载。</li>
</ul></li>
<li><code>TCG_CALL_NO_READ_GLOBALS</code>
<ul>
<li>辅助函数不会直接或通过异常读取全局变量。</li>
<li>在调用辅助函数之前，它们将不会保存到其规范位置。</li>
<li>这意味着它隐含了<code>TCG_CALL_NO_WRITE_GLOBALS</code>。</li>
</ul></li>
<li><code>TCG_CALL_NO_SIDE_EFFECTS</code>
<ul>
<li>如果没有使用返回值，则可以删除对辅助函数的调用。这意味着它不能修改任何CPU状态，也不能引发异常。</li>
</ul></li>
</ul></li>
</ul>
<h2 id="code-optimizations">Code Optimizations</h2>
<ul>
<li><p>在生成指令时，可以依赖至少以下优化：</p>
<ul>
<li>单个指令会进行简化，例如： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and_i32 t0, t0, $0xffffffff</span><br></pre></td></tr></table></figure> 会被抑制。</li>
</ul></li>
<li><p>在基本块级别进行寄存器活跃性分析。</p></li>
<li><p>这些信息用于消除从一个无用变量到另一个无用变量的移动操作。</p></li>
<li><p>还可以用于删除计算无用结果的指令。</p></li>
<li><p>这对于QEMU中的条件代码优化特别有用。</p>
<ul>
<li>在下面的示例中： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_i32 t0, t1, t2</span><br><span class="line">add_i32 t0, t0, $1</span><br><span class="line">mov_i32 t0, $1</span><br></pre></td></tr></table></figure> 只会保留最后一条指令。</li>
</ul></li>
</ul>
<h2 id="instruction-reference">Instruction Reference</h2>
<h3 id="function-call">Function call</h3>
<p>.. list-table::</p>
<ul>
<li><ul>
<li><p>call <em><ret></em> <em><params></em> ptr</p></li>
<li><div class="line-block"> call function 'ptr' (pointer type)<br />
<br />
 <em><ret></em> optional 32 bit or 64 bit return value<br />
 <em><params></em> optional 32 bit or 64 bit parameters</div></li>
</ul></li>
</ul>
<h3 id="jumpslabels">Jumps/Labels</h3>
<p>.. list-table::</p>
<ul>
<li><ul>
<li><p>set_label $label</p></li>
<li><div class="line-block">Define label 'label' at the current program
point.</div></li>
</ul></li>
<li><ul>
<li><p>br $label</p></li>
<li><div class="line-block">Jump to label.</div></li>
</ul></li>
<li><ul>
<li><p>brcond_i32/i64 <em>t0</em>, <em>t1</em>, <em>cond</em>,
<em>label</em></p></li>
<li><div class="line-block">Conditional jump if <em>t0</em>
<em>cond</em> <em>t1</em> is true. <em>cond</em> can be:<br />
<br />
  <code>TCG_COND_EQ</code><br />
  <code>TCG_COND_NE</code><br />
  <code>TCG_COND_LT /* signed */</code><br />
  <code>TCG_COND_GE /* signed */</code><br />
  <code>TCG_COND_LE /* signed */</code><br />
  <code>TCG_COND_GT /* signed */</code><br />
  <code>TCG_COND_LTU /* unsigned */</code><br />
  <code>TCG_COND_GEU /* unsigned */</code><br />
  <code>TCG_COND_LEU /* unsigned */</code><br />
  <code>TCG_COND_GTU /* unsigned */</code></div></li>
</ul></li>
</ul>
<h3 id="arithmetic">Arithmetic</h3>
<p>.. list-table::</p>
<ul>
<li><ul>
<li><p>add_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> +
<em>t2</em></div></li>
</ul></li>
<li><ul>
<li><p>sub_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> -
<em>t2</em></div></li>
</ul></li>
<li><ul>
<li><p>neg_i32/i64 <em>t0</em>, <em>t1</em></p></li>
<li><div class="line-block"><em>t0</em> = -<em>t1</em> (two's
complement)</div></li>
</ul></li>
<li><ul>
<li><p>mul_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> *
<em>t2</em></div></li>
</ul></li>
<li><ul>
<li><p>div_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> / <em>t2</em>
(signed)<br />
Undefined behavior if division by zero or overflow.</div></li>
</ul></li>
<li><ul>
<li><p>divu_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> / <em>t2</em>
(unsigned)<br />
Undefined behavior if division by zero.</div></li>
</ul></li>
<li><ul>
<li><p>rem_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> % <em>t2</em>
(signed)<br />
Undefined behavior if division by zero or overflow.</div></li>
</ul></li>
<li><ul>
<li><p>remu_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> % <em>t2</em>
(unsigned)<br />
Undefined behavior if division by zero.</div></li>
</ul></li>
</ul>
<h3 id="logical">Logical</h3>
<p>.. list-table::</p>
<ul>
<li><ul>
<li><p>and_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> &amp;
<em>t2</em></div></li>
</ul></li>
<li><ul>
<li><p>or_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> |
<em>t2</em></div></li>
</ul></li>
<li><ul>
<li><p>xor_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> ^
<em>t2</em></div></li>
</ul></li>
<li><ul>
<li><p>not_i32/i64 <em>t0</em>, <em>t1</em></p></li>
<li><div class="line-block"><em>t0</em> = ~ <em>t1</em></div></li>
</ul></li>
<li><ul>
<li><p>andc_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> &amp;
~ <em>t2</em></div></li>
</ul></li>
<li><ul>
<li><p>eqv_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = ~(<em>t1</em> ^ <em>t2</em>),
or equivalently, <em>t0</em> = <em>t1</em> ^ ~ <em>t2</em></div></li>
</ul></li>
<li><ul>
<li><p>nand_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = ~(<em>t1</em> &amp;
<em>t2</em>)</div></li>
</ul></li>
<li><ul>
<li><p>nor_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = ~(<em>t1</em> |
<em>t2</em>)</div></li>
</ul></li>
<li><ul>
<li><p>orc_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> |
~ <em>t2</em></div></li>
</ul></li>
<li><ul>
<li><p>clz_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> ? clz(<em>t1</em>)
: <em>t2</em></div></li>
</ul></li>
<li><ul>
<li><p>ctz_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> ? ctz(<em>t1</em>)
: <em>t2</em></div></li>
</ul></li>
<li><ul>
<li><p>ctpop_i32/i64 <em>t0</em>, <em>t1</em></p></li>
<li><div class="line-block"><em>t0</em> = number of bits set in
<em>t1</em><br />
<br />
With <em>ctpop</em> short for "count population", matching<br />
the function name used in
<code>include/qemu/host-utils.h</code>.</div></li>
</ul></li>
</ul>
<h3 id="shiftsrotates">Shifts/Rotates</h3>
<p>.. list-table::</p>
<ul>
<li><ul>
<li><p>shl_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> &lt;&lt;
<em>t2</em><br />
Unspecified behavior if <em>t2</em> &lt; 0 or <em>t2</em> &gt;= 32 (resp
64)</div></li>
</ul></li>
<li><ul>
<li><p>shr_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> &gt;&gt;
<em>t2</em> (unsigned)<br />
Unspecified behavior if <em>t2</em> &lt; 0 or <em>t2</em> &gt;= 32 (resp
64)</div></li>
</ul></li>
<li><ul>
<li><p>sar_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> &gt;&gt;
<em>t2</em> (signed)<br />
Unspecified behavior if <em>t2</em> &lt; 0 or <em>t2</em> &gt;= 32 (resp
64)</div></li>
</ul></li>
<li><ul>
<li><p>rotl_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block">Rotation of <em>t2</em> bits to the
left<br />
Unspecified behavior if <em>t2</em> &lt; 0 or <em>t2</em> &gt;= 32 (resp
64)</div></li>
</ul></li>
<li><ul>
<li><p>rotr_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block">Rotation of <em>t2</em> bits to the
right.<br />
Unspecified behavior if <em>t2</em> &lt; 0 or <em>t2</em> &gt;= 32 (resp
64)</div></li>
</ul></li>
</ul>
<h3 id="misc">Misc</h3>
<p>.. list-table::</p>
<ul>
<li><ul>
<li><p>mov_i32/i64 <em>t0</em>, <em>t1</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em><br />
Move <em>t1</em> to <em>t0</em> (both operands must have the same
type).</div></li>
</ul></li>
<li><ul>
<li><p>ext8s_i32/i64 <em>t0</em>, <em>t1</em></p>
<p>ext8u_i32/i64 <em>t0</em>, <em>t1</em></p>
<p>ext16s_i32/i64 <em>t0</em>, <em>t1</em></p>
<p>ext16u_i32/i64 <em>t0</em>, <em>t1</em></p>
<p>ext32s_i64 <em>t0</em>, <em>t1</em></p>
<p>ext32u_i64 <em>t0</em>, <em>t1</em></p></li>
<li><div class="line-block">8, 16 or 32 bit sign/zero extension (both
operands must have the same type)</div></li>
</ul></li>
<li><ul>
<li><p>bswap16_i32/i64 <em>t0</em>, <em>t1</em>, <em>flags</em></p></li>
<li><div class="line-block">16 bit byte swap on the low bits of a 32/64
bit input.<br />
<br />
If <em>flags</em> &amp; <code>TCG_BSWAP_IZ</code>, then <em>t1</em> is
known to be zero-extended from bit 15.<br />
If <em>flags</em> &amp; <code>TCG_BSWAP_OZ</code>, then <em>t0</em> will
be zero-extended from bit 15.<br />
If <em>flags</em> &amp; <code>TCG_BSWAP_OS</code>, then <em>t0</em> will
be sign-extended from bit 15.<br />
<br />
If neither <code>TCG_BSWAP_OZ</code> nor <code>TCG_BSWAP_OS</code> are
set, then the bits of <em>t0</em> above bit 15 may contain any
value.</div></li>
</ul></li>
<li><ul>
<li><p>bswap32_i64 <em>t0</em>, <em>t1</em>, <em>flags</em></p></li>
<li><div class="line-block">32 bit byte swap on a 64-bit value. The
flags are the same as for bswap16, except they apply from bit 31 instead
of bit 15.</div></li>
</ul></li>
<li><ul>
<li><p>bswap32_i32 <em>t0</em>, <em>t1</em>, <em>flags</em></p>
<p>bswap64_i64 <em>t0</em>, <em>t1</em>, <em>flags</em></p></li>
<li><div class="line-block">32/64 bit byte swap. The flags are ignored,
but still present for consistency with the other bswap
opcodes.</div></li>
</ul></li>
<li><ul>
<li><p>discard_i32/i64 <em>t0</em></p></li>
<li><div class="line-block">Indicate that the value of <em>t0</em> won't
be used later. It is useful to force dead code elimination.</div></li>
</ul></li>
<li><ul>
<li><p>deposit_i32/i64 <em>dest</em>, <em>t1</em>, <em>t2</em>,
<em>pos</em>, <em>len</em></p></li>
<li><div class="line-block">Deposit <em>t2</em> as a bitfield into
<em>t1</em>, placing the result in <em>dest</em>.<br />
<br />
The bitfield is described by <em>pos</em>/<em>len</em>, which are
immediate values:<br />
<br />
    <em>len</em> - the length of the bitfield<br />
    <em>pos</em> - the position of the first bit, counting from the
LSB<br />
<br />
For example, "deposit_i32 dest, t1, t2, 8, 4" indicates a 4-bit field at
bit 8. This operation would be equivalent to<br />
<br />
    <em>dest</em> = (<em>t1</em> &amp; ~0x0f00) | ((<em>t2</em> &lt;&lt;
8) &amp; 0x0f00)</div></li>
</ul></li>
<li><ul>
<li><p>extract_i32/i64 <em>dest</em>, <em>t1</em>, <em>pos</em>,
<em>len</em></p>
<p>sextract_i32/i64 <em>dest</em>, <em>t1</em>, <em>pos</em>,
<em>len</em></p></li>
<li><div class="line-block">Extract a bitfield from <em>t1</em>, placing
the result in <em>dest</em>.<br />
<br />
The bitfield is described by <em>pos</em>/<em>len</em>, which are
immediate values, as above for deposit. For extract_<em>, the result
will be extended to the left with zeros; for sextract_</em>, the result
will be extended to the left with copies of the bitfield sign bit at
<em>pos</em> + <em>len</em> - 1.<br />
<br />
For example, "sextract_i32 dest, t1, 8, 4" indicates a 4-bit field at
bit 8. This operation would be equivalent to<br />
<br />
   <em>dest</em> = (<em>t1</em> &lt;&lt; 20) &gt;&gt; 28<br />
<br />
(using an arithmetic right shift).</div></li>
</ul></li>
<li><ul>
<li><p>extract2_i32/i64 <em>dest</em>, <em>t1</em>, <em>t2</em>,
<em>pos</em></p></li>
<li><div class="line-block">For N = {32,64}, extract an N-bit quantity
from the concatenation of <em>t2</em>:<em>t1</em>, beginning at
<em>pos</em>. The tcg_gen_extract2_{i32,i64} expander accepts 0 &lt;=
<em>pos</em> &lt;= N as inputs. The backend code generator will not see
either 0 or N as inputs for these opcodes.</div></li>
</ul></li>
<li><ul>
<li><p>extrl_i64_i32 <em>t0</em>, <em>t1</em></p></li>
<li><div class="line-block">For 64-bit hosts only, extract the low
32-bits of input <em>t1</em> and place it into 32-bit output
<em>t0</em>. Depending on the host, this may be a simple move, or may
require additional canonicalization.</div></li>
</ul></li>
<li><ul>
<li><p>extrh_i64_i32 <em>t0</em>, <em>t1</em></p></li>
<li><div class="line-block">For 64-bit hosts only, extract the high
32-bits of input <em>t1</em> and place it into 32-bit output
<em>t0</em>. Depending on the host, this may be a simple shift, or may
require additional canonicalization.</div></li>
</ul></li>
</ul>
<h3 id="conditional-moves">Conditional moves</h3>
<p>.. list-table::</p>
<ul>
<li><ul>
<li><p>setcond_i32/i64 <em>dest</em>, <em>t1</em>, <em>t2</em>,
<em>cond</em></p></li>
<li><div class="line-block"><em>dest</em> = (<em>t1</em> <em>cond</em>
<em>t2</em>)<br />
<br />
Set <em>dest</em> to 1 if (<em>t1</em> <em>cond</em> <em>t2</em>) is
true, otherwise set to 0.</div></li>
</ul></li>
<li><ul>
<li><p>movcond_i32/i64 <em>dest</em>, <em>c1</em>, <em>c2</em>,
<em>v1</em>, <em>v2</em>, <em>cond</em></p></li>
<li><div class="line-block"><em>dest</em> = (<em>c1</em> <em>cond</em>
<em>c2</em> ? <em>v1</em> : <em>v2</em>)<br />
<br />
Set <em>dest</em> to <em>v1</em> if (<em>c1</em> <em>cond</em>
<em>c2</em>) is true, otherwise set to <em>v2</em>.</div></li>
</ul></li>
</ul>
<h3 id="type-conversions">Type conversions</h3>
<p>.. list-table::</p>
<ul>
<li><ul>
<li><p>ext_i32_i64 <em>t0</em>, <em>t1</em></p></li>
<li><div class="line-block">Convert <em>t1</em> (32 bit) to <em>t0</em>
(64 bit) and does sign extension</div></li>
</ul></li>
<li><ul>
<li><p>extu_i32_i64 <em>t0</em>, <em>t1</em></p></li>
<li><div class="line-block">Convert <em>t1</em> (32 bit) to <em>t0</em>
(64 bit) and does zero extension</div></li>
</ul></li>
<li><ul>
<li><p>trunc_i64_i32 <em>t0</em>, <em>t1</em></p></li>
<li><div class="line-block">Truncate <em>t1</em> (64 bit) to <em>t0</em>
(32 bit)</div></li>
</ul></li>
<li><ul>
<li><p>concat_i32_i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block">Construct <em>t0</em> (64-bit) taking the
low half from <em>t1</em> (32 bit) and the high half from <em>t2</em>
(32 bit).</div></li>
</ul></li>
<li><ul>
<li><p>concat32_i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block">Construct <em>t0</em> (64-bit) taking the
low half from <em>t1</em> (64 bit) and the high half from <em>t2</em>
(64 bit).</div></li>
</ul></li>
</ul>
<h3 id="loadstore">Load/Store</h3>
<p>.. list-table::</p>
<ul>
<li><ul>
<li><p>ld_i32/i64 <em>t0</em>, <em>t1</em>, <em>offset</em></p>
<p>ld8s_i32/i64 <em>t0</em>, <em>t1</em>, <em>offset</em></p>
<p>ld8u_i32/i64 <em>t0</em>, <em>t1</em>, <em>offset</em></p>
<p>ld16s_i32/i64 <em>t0</em>, <em>t1</em>, <em>offset</em></p>
<p>ld16u_i32/i64 <em>t0</em>, <em>t1</em>, <em>offset</em></p>
<p>ld32s_i64 t0, <em>t1</em>, <em>offset</em></p>
<p>ld32u_i64 t0, <em>t1</em>, <em>offset</em></p></li>
<li><div class="line-block"><em>t0</em> = read(<em>t1</em> +
<em>offset</em>)<br />
<br />
Load 8, 16, 32 or 64 bits with or without sign extension from host
memory. <em>offset</em> must be a constant.</div></li>
</ul></li>
<li><ul>
<li><p>st_i32/i64 <em>t0</em>, <em>t1</em>, <em>offset</em></p>
<p>st8_i32/i64 <em>t0</em>, <em>t1</em>, <em>offset</em></p>
<p>st16_i32/i64 <em>t0</em>, <em>t1</em>, <em>offset</em></p>
<p>st32_i64 <em>t0</em>, <em>t1</em>, <em>offset</em></p></li>
<li><div class="line-block">write(<em>t0</em>, <em>t1</em> +
<em>offset</em>)<br />
<br />
Write 8, 16, 32 or 64 bits to host memory.</div></li>
</ul></li>
</ul>
<p>All this opcodes assume that the pointed host memory doesn't
correspond to a global. In the latter case the behaviour is
unpredictable.</p>
<h3 id="multiword-arithmetic-support">Multiword arithmetic support</h3>
<p>.. list-table::</p>
<ul>
<li><ul>
<li><p>add2_i32/i64 <em>t0_low</em>, <em>t0_high</em>, <em>t1_low</em>,
<em>t1_high</em>, <em>t2_low</em>, <em>t2_high</em></p>
<p>sub2_i32/i64 <em>t0_low</em>, <em>t0_high</em>, <em>t1_low</em>,
<em>t1_high</em>, <em>t2_low</em>, <em>t2_high</em></p></li>
<li><div class="line-block">Similar to add/sub, except that the
double-word inputs <em>t1</em> and <em>t2</em> are formed from two
single-word arguments, and the double-word output <em>t0</em> is
returned in two single-word outputs.</div></li>
</ul></li>
<li><ul>
<li><p>mulu2_i32/i64 <em>t0_low</em>, <em>t0_high</em>, <em>t1</em>,
<em>t2</em></p></li>
<li><div class="line-block">Similar to mul, except two unsigned inputs
<em>t1</em> and <em>t2</em> yielding the full double-word product
<em>t0</em>. The latter is returned in two single-word
outputs.</div></li>
</ul></li>
<li><ul>
<li><p>muls2_i32/i64 <em>t0_low</em>, <em>t0_high</em>, <em>t1</em>,
<em>t2</em></p></li>
<li><div class="line-block">Similar to mulu2, except the two inputs
<em>t1</em> and <em>t2</em> are signed.</div></li>
</ul></li>
<li><ul>
<li><p>mulsh_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p>
<p>muluh_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block">Provide the high part of a signed or
unsigned multiply, respectively.<br />
<br />
If mulu2/muls2 are not provided by the backend, the tcg-op generator can
obtain the same results by emitting a pair of opcodes, mul +
muluh/mulsh.</div></li>
</ul></li>
</ul>
<h3 id="memory-barrier-support">Memory Barrier support</h3>
<p>.. list-table::</p>
<ul>
<li><ul>
<li><p>mb <em>&lt;$arg&gt;</em></p></li>
<li><div class="line-block">Generate a target memory barrier instruction
to ensure memory ordering as being enforced by a corresponding guest
memory barrier instruction.<br />
<br />
The ordering enforced by the backend may be stricter than the ordering
required by the guest. It cannot be weaker. This opcode takes a constant
argument which is required to generate the appropriate barrier
instruction. The backend should take care to emit the target barrier
instruction only when necessary i.e., for SMP guests and when MTTCG is
enabled.<br />
<br />
The guest translators should generate this opcode for all guest
instructions which have ordering side effects.<br />
<br />
Please see :ref:<code>atomics-ref</code> for more information on memory
barriers.</div></li>
</ul></li>
</ul>
<h3 id="bit-guest-on-32-bit-host-support">64-bit guest on 32-bit host
support</h3>
<p>The following opcodes are internal to TCG. Thus they are to be
implemented by 32-bit host code generators, but are not to be emitted by
guest translators. They are emitted as needed by inline functions within
<code>tcg-op.h</code>.</p>
<p>.. list-table::</p>
<ul>
<li><ul>
<li><p>brcond2_i32 <em>t0_low</em>, <em>t0_high</em>, <em>t1_low</em>,
<em>t1_high</em>, <em>cond</em>, <em>label</em></p></li>
<li><div class="line-block">Similar to brcond, except that the 64-bit
values <em>t0</em> and <em>t1</em> are formed from two 32-bit
arguments.</div></li>
</ul></li>
<li><ul>
<li><p>setcond2_i32 <em>dest</em>, <em>t1_low</em>, <em>t1_high</em>,
<em>t2_low</em>, <em>t2_high</em>, <em>cond</em></p></li>
<li><div class="line-block">Similar to setcond, except that the 64-bit
values <em>t1</em> and <em>t2</em> are formed from two 32-bit arguments.
The result is a 32-bit value.</div></li>
</ul></li>
</ul>
<h3 id="qemu-specific-operations">QEMU specific operations</h3>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>operations</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>exit_tb <em>t0</em></td>
<td>退出当前的翻译块（Translation
Block）并返回变量<em>t0</em>的值（字类型）</td>
</tr>
<tr class="even">
<td>goto_tb <em>index</em></td>
<td>退出当前的翻译块（Translation Block）并根据条件跳转到索引为 index
的翻译块，如果当前的翻译块与目标翻译块相连。否则，继续执行下一条指令。只有索引为
0 和 1 是有效的，每个翻译块最多可以使用一次 tcg_gen_goto_tb
指令来跳转到每个索引。 tcg_gen_goto_tb may be issued at most once with
each slot index per TB.</td>
</tr>
<tr class="odd">
<td>lookup_and_goto_ptr <em>tb_addr</em></td>
<td>查找一个翻译块的地址<em>tb_addr</em>，并根据其有效性进行跳转。如果翻译块地址有效，则跳转到该地址；如果无效，则跳转到TCG的收尾部分以返回执行循环。</td>
</tr>
<tr class="even">
<td>qemu_ld_i32/i64/i128 <em>t0</em>, <em>t1</em>, <em>flags</em>,
<em>memidx</em><br>qemu_st_i32/i64/i128 <em>t0</em>, <em>t1</em>,
<em>flags</em>, <em>memidx</em><br>qemu_st8_i32 <em>t0</em>,
<em>t1</em>, <em>flags</em>, <em>memidx</em></td>
<td>加载位于虚拟地址 t1 处的数据到 t0，或者将 t0 中的数据存储到虚拟地址
t1 处。_i32/_i64/_i128 大小适用于输入/输出寄存器 t0 的大小。地址 t1
总是根据虚拟机的大小进行定位，而内存操作的宽度由 flags 控制。<br>在处理
64 位数据（在 32 位主机上）或 128 位数据（在 64 位主机上）时，t0 和 t1
可能会被拆分为按小端顺序排列的寄存器对。<br>memidx 用于选择要使用的 QEMU
TLB 索引（例如，用户或内核访问）。flags 是 MemOp
位，用于选择内存访问的符号、宽度和字节顺序。<br>对于 32 位主机，保证仅在
flags 中指定了 64 位内存访问时才使用 qemu_ld/st_i64。<br>对于
qemu_ld/st_i128，仅在 64 位主机上支持。<br>对于 i386，qemu_st8_i32 与
qemu_st_i32 完全相同，只是内存操作的大小已知为 8
位。这允许后端提供不同的寄存器约束。</td>
</tr>
</tbody>
</table>
<h2 id="host-vector-operations">Host vector operations</h2>
<p>All of the vector ops have two parameters, <code>TCGOP_VECL</code>
&amp; <code>TCGOP_VECE</code>. The former specifies the length of the
vector in log2 64-bit units; the latter specifies the length of the
element (if applicable) in log2 8-bit units. E.g. VECL = 1 -&gt; 64
&lt;&lt; 1 -&gt; v128, and VECE = 2 -&gt; 1 &lt;&lt; 2 -&gt; i32.</p>
<p>.. list-table::</p>
<ul>
<li><ul>
<li><p>mov_vec <em>v0</em>, <em>v1</em> ld_vec <em>v0</em>, <em>t1</em>
st_vec <em>v0</em>, <em>t1</em></p></li>
<li><div class="line-block">Move, load and store.</div></li>
</ul></li>
<li><ul>
<li><p>dup_vec <em>v0</em>, <em>r1</em></p></li>
<li><div class="line-block">Duplicate the low N bits of <em>r1</em> into
VECL/VECE copies across <em>v0</em>.</div></li>
</ul></li>
<li><ul>
<li><p>dupi_vec <em>v0</em>, <em>c</em></p></li>
<li><div class="line-block">Similarly, for a constant.<br />
Smaller values will be replicated to host register size by the
expanders.</div></li>
</ul></li>
<li><ul>
<li><p>dup2_vec <em>v0</em>, <em>r1</em>, <em>r2</em></p></li>
<li><div class="line-block">Duplicate <em>r2</em>:<em>r1</em> into
VECL/64 copies across <em>v0</em>. This opcode is only present for
32-bit hosts.</div></li>
</ul></li>
<li><ul>
<li><p>add_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p></li>
<li><div class="line-block"><em>v0</em> = <em>v1</em> + <em>v2</em>, in
elements across the vector.</div></li>
</ul></li>
<li><ul>
<li><p>sub_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p></li>
<li><div class="line-block">Similarly, <em>v0</em> = <em>v1</em> -
<em>v2</em>.</div></li>
</ul></li>
<li><ul>
<li><p>mul_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p></li>
<li><div class="line-block">Similarly, <em>v0</em> = <em>v1</em> *
<em>v2</em>.</div></li>
</ul></li>
<li><ul>
<li><p>neg_vec <em>v0</em>, <em>v1</em></p></li>
<li><div class="line-block">Similarly, <em>v0</em> =
-<em>v1</em>.</div></li>
</ul></li>
<li><ul>
<li><p>abs_vec <em>v0</em>, <em>v1</em></p></li>
<li><div class="line-block">Similarly, <em>v0</em> = <em>v1</em> &lt; 0
? -<em>v1</em> : <em>v1</em>, in elements across the vector.</div></li>
</ul></li>
<li><ul>
<li><p>smin_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p>
<p>umin_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p></li>
<li><div class="line-block">Similarly, <em>v0</em> = MIN(<em>v1</em>,
<em>v2</em>), for signed and unsigned element types.</div></li>
</ul></li>
<li><ul>
<li><p>smax_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p>
<p>umax_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p></li>
<li><div class="line-block">Similarly, <em>v0</em> = MAX(<em>v1</em>,
<em>v2</em>), for signed and unsigned element types.</div></li>
</ul></li>
<li><ul>
<li><p>ssadd_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p>
<p>sssub_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p>
<p>usadd_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p>
<p>ussub_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p></li>
<li><div class="line-block">Signed and unsigned saturating addition and
subtraction.<br />
<br />
If the true result is not representable within the element type, the
element is set to the minimum or maximum value for the type.</div></li>
</ul></li>
<li><ul>
<li><p>and_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p>
<p>or_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p>
<p>xor_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p>
<p>andc_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p>
<p>orc_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p>
<p>not_vec <em>v0</em>, <em>v1</em></p></li>
<li><div class="line-block">Similarly, logical operations with and
without complement.<br />
<br />
Note that VECE is unused.</div></li>
</ul></li>
<li><ul>
<li><p>shli_vec <em>v0</em>, <em>v1</em>, <em>i2</em></p>
<p>shls_vec <em>v0</em>, <em>v1</em>, <em>s2</em></p></li>
<li><div class="line-block">Shift all elements from v1 by a scalar
<em>i2</em>/<em>s2</em>. I.e.</div>
<p>.. code-block:: c</p>
<p>for (i = 0; i &lt; VECL/VECE; ++i) { v0[i] = v1[i] &lt;&lt; s2;
}</p></li>
</ul></li>
<li><ul>
<li><p>shri_vec <em>v0</em>, <em>v1</em>, <em>i2</em></p>
<p>sari_vec <em>v0</em>, <em>v1</em>, <em>i2</em></p>
<p>rotli_vec <em>v0</em>, <em>v1</em>, <em>i2</em></p>
<p>shrs_vec <em>v0</em>, <em>v1</em>, <em>s2</em></p>
<p>sars_vec <em>v0</em>, <em>v1</em>, <em>s2</em></p></li>
<li><div class="line-block">Similarly for logical and arithmetic right
shift, and left rotate.</div></li>
</ul></li>
<li><ul>
<li><p>shlv_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p></li>
<li><div class="line-block">Shift elements from <em>v1</em> by elements
from <em>v2</em>. I.e.</div>
<p>.. code-block:: c</p>
<p>for (i = 0; i &lt; VECL/VECE; ++i) { v0[i] = v1[i] &lt;&lt; v2[i];
}</p></li>
</ul></li>
<li><ul>
<li><p>shrv_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p>
<p>sarv_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p>
<p>rotlv_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p>
<p>rotrv_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p></li>
<li><div class="line-block">Similarly for logical and arithmetic right
shift, and rotates.</div></li>
</ul></li>
<li><ul>
<li><p>cmp_vec <em>v0</em>, <em>v1</em>, <em>v2</em>,
<em>cond</em></p></li>
<li><div class="line-block">Compare vectors by element, storing -1 for
true and 0 for false.</div></li>
</ul></li>
<li><ul>
<li><p>bitsel_vec <em>v0</em>, <em>v1</em>, <em>v2</em>,
<em>v3</em></p></li>
<li><div class="line-block">Bitwise select, <em>v0</em> = (<em>v2</em>
&amp; <em>v1</em>) | (<em>v3</em> &amp; ~ <em>v1</em>), across the
entire vector.</div></li>
</ul></li>
<li><ul>
<li><p>cmpsel_vec <em>v0</em>, <em>c1</em>, <em>c2</em>, <em>v3</em>,
<em>v4</em>, <em>cond</em></p></li>
<li><div class="line-block">Select elements based on comparison
results:</div>
<p>.. code-block:: c</p>
<p>for (i = 0; i &lt; n; ++i) { v0[i] = (c1[i] cond c2[i]) ? v3[i] :
v4[i]. }</p></li>
</ul></li>
</ul>
<p><strong>Note 1</strong>: Some shortcuts are defined when the last
operand is known to be a constant (e.g. addi for add, movi for mov).</p>
<p><strong>Note 2</strong>: When using TCG, the opcodes must never be
generated directly as some of them may not be available as "real"
opcodes. Always use the function tcg_gen_xxx(args).</p>
<h2 id="backend-后端">Backend / 后端</h2>
<ul>
<li><code>tcg-target.h</code> 是包含目标特定定义的文件。</li>
<li><code>tcg-target.c.inc</code> 是目标特定代码的文件，它通过
<code>#include</code> 被 <code>tcg/tcg.c</code>
包含，而不是作为一个独立的 C 文件存在。</li>
</ul>
<h3 id="assumptions-假设">Assumptions / 假设</h3>
<ul>
<li><p>目标字长（<code>TCG_TARGET_REG_BITS</code>）预期为32位或64位。</p></li>
<li><p>假设指针的大小与字长相同。</p></li>
<li><p>在32位目标上，所有64位操作都会转换为32位。</p></li>
<li><p>需要实现一些特定的操作来支持这一点（参见<code>add2_i32</code>，<code>sub2_i32</code>，<code>brcond2_i32</code>）。</p></li>
<li><p>在64位目标上，通过以下操作在32位和64位寄存器之间传输值：</p>
<ul>
<li><code>trunc_shr_i64_i32</code></li>
<li><code>ext_i32_i64</code></li>
<li><code>extu_i32_i64</code></li>
</ul></li>
<li><p>它们确保在从32位寄存器移动到64位寄存器或反之时，值被正确截断或扩展。请注意，<code>trunc_shr_i64_i32</code>是一个可选的操作。</p></li>
<li><p>如果满足以下所有条件，则不需要实现它：</p>
<ul>
<li>64位寄存器可以容纳32位值</li>
<li>64位寄存器中的32位值不需要保持零扩展或符号扩展</li>
<li>所有32位TCG操作忽略64位寄存器的高位部分</li>
</ul></li>
<li><p>此版本不支持浮点操作。代码生成器的先前版本对其有全面支持，但最好先集中精力处理整数操作。</p></li>
</ul>
<h3 id="constraints-限制">Constraints / 限制</h3>
<ul>
<li><p>这个版本使用类似GCC的约束来定义每个指令的限制条件。</p></li>
<li><p>不支持内存约束。</p></li>
<li><p>别名可以像GCC一样在输入操作数中指定。</p></li>
<li><p>即使没有明确指定别名，同一个寄存器可以用作输入和输出。</p></li>
<li><p>如果一个操作扩展为多个目标指令，需要注意避免破坏输入值。</p></li>
<li><p>支持GCC风格的"早期占用"输出，使用'<code>&amp;</code>'符号。</p></li>
<li><p>目标可以定义特定的寄存器或常量约束。</p></li>
<li><p>如果一个操作使用不允许所有常量的常量输入约束，为了有备用选项，必须同时接受寄存器。
（If an operation uses a constant input constraint which does not allow
all constants, it must also accept registers in order to have a
fallback.）</p></li>
<li><p>约束'<code>i</code>'是通用定义的，接受任何常量。</p></li>
<li><p>约束'<code>r</code>'没有通用定义，但每个后端一致使用它来表示所有寄存器。</p></li>
<li><p>movi_i32和movi_i64操作必须接受任何常量。</p></li>
<li><p>mov_i32和mov_i64操作必须接受相同类型的任何寄存器。</p></li>
<li><p>ld/st/sti指令必须接受带符号的32位常量偏移量。</p></li>
<li><p>如果偏移量太大，可以通过保留一个特定的寄存器来计算地址。</p></li>
<li><p>ld/st指令必须接受任何目标寄存器（ld）或源寄存器（st）。</p></li>
<li><p>sti指令可能会因无法存储给定的常量而失败。</p></li>
</ul>
<h3 id="function-call-assumptions-函数调用的假设">Function call
assumptions / 函数调用的假设</h3>
<ul>
<li>参数和返回值的支持类型仅限于32位和64位整数以及指针。</li>
<li>栈向下增长。</li>
<li>前N个参数通过寄存器传递。</li>
<li>接下来的参数通过将它们存储为字节的方式通过栈传递。</li>
<li>在调用期间，一些寄存器的值可能会被覆盖。</li>
<li>函数可以在寄存器中返回0或1个值。在32位目标平台上，函数必须能够以寄存器返回2个值，用于64位返回类型。</li>
</ul>
<h2 id="recommended-coding-rules-for-best-performance">Recommended
coding rules for best performance</h2>
<ul>
<li><p>使用全局变量来表示经常被修改的QEMU
CPU状态的部分，例如整数寄存器和条件码。</p></li>
<li><p>TCG将能够使用主机寄存器来存储它们。</p></li>
<li><p>对于复杂或不常用的客户指令，不要犹豫使用辅助函数。</p></li>
<li><p>在使用TCG实现的客户指令中，使用超过约二十条TCG指令的性能优势很小。</p></li>
<li><p>需要注意的是，这个经验法则更适用于执行复杂逻辑或算术运算的辅助函数，因为C编译器可以进行有效的优化；在大部分是加载和存储操作的指令中，这个规则的适用性较小，并且在这些情况下，内联TCG仍然可能比较长的序列更快。</p></li>
<li><p>如果你知道TCG无法证明在给定程序点上某个全局变量是"无用"的，可以使用"discard"指令。</p></li>
<li><p>x86客户机使用它来改进条件码的优化。</p></li>
</ul>
]]></content>
      <categories>
        <category>Qemu</category>
      </categories>
  </entry>
  <entry>
    <title>Qemu icount</title>
    <url>/zyhjy/2023/05/18/Qemu%20icount/</url>
    <content><![CDATA[<h1 id="tcg-instruction-counting-tcg指令计数">TCG Instruction Counting /
TCG指令计数</h1>
<ul>
<li><p>TCG长期支持一种称为icount的功能，允许在执行过程中进行指令计数。</p></li>
<li><p>这与周期精确的仿真不应混淆——QEMU不会尝试模拟指令在实际硬件上所需的时间。这是其他更详细（但更慢）的工具来模拟微体系结构的工作。</p></li>
<li><p>这个功能仅适用于系统仿真，并且与多线程TCG不兼容。它可用于更好地与挂钟时间（wall-clock
time）对齐执行时间，以防止“慢速”设备在现代硬件上运行过快。它还提供了一定程度的确定性执行，并且是QEMU中记录/回放支持的关键部分。</p></li>
</ul>
<h2 id="core-concepts-核心概念">Core Concepts / 核心概念</h2>
<ul>
<li><p>icount本质上是一个在QEMU计时器子系统的TimersState中存储的已执行指令计数。</p></li>
<li><p>已执行指令的数量可以用来计算QEMU_CLOCK_VIRTUAL，该值表示自执行开始以来系统中经过的时间。根据icount模式，这可能是每条指令固定的纳秒数，或者在执行过程中进行调整，以保持挂钟时间和虚拟时间同步。</p></li>
<li><p>为了能够计算已执行指令的数量，翻译器首先分配一定数量的待执行指令预算。指令预算受限于下一个定时器到期之前的时间长度。我们将这个预算作为vCPU的icount_decr字段的一部分进行存储，该字段与处理cpu_exit()的机制共享。在每个翻译块的开始处检查整个字段，并在退出时返回到外部循环以处理导致退出的原因。</p></li>
<li><p>对于icount，再检查标志之前，我们会减去翻译块将要执行的指令数。如果这会导致指令预算变为负数，我们将退出主循环，并重新生成一个新的翻译块，其中包含恰好足够数量的指令，使预算减为0，这意味着无论何时我们退出主运行循环，定时器都将会在该时刻到期。</p></li>
</ul>
<h2 id="dealing-with-mmio-处理mmio">Dealing with MMIO / 处理MMIO</h2>
<ul>
<li><p>虽然我们可以调整已知事件（如计时器到期）的指令预算，但对于MMIO来说我们无法做到同样的调整。</p></li>
<li><p>我们执行的每个加载/存储操作都可能触发一个I/O事件，在这种情况下，我们需要一个最新且准确的icount数的读取。</p></li>
<li><p>为了处理这种情况，当进行I/O访问时，我们会：</p>
<ol type="1">
<li>将未执行的指令恢复到icount预算中</li>
<li>为当前PC重新编译一个[1]指令块</li>
<li>退出CPU循环并执行重新编译的块</li>
</ol></li>
<li><p>新的块被创建时带有CF_LAST_IO编译标志，确保最终的指令转换从调用gen_io_start()开始，这样我们就不会进入一个永久循环，不断重新编译一个单独的指令块。对于使用常见的translator_loop的翻译器，这是自动完成的。</p></li>
</ul>
<h2 id="other-io-operations-其他io操作">Other I/O operations /
其他IO操作</h2>
<ul>
<li><p>MMIO不是唯一可能需要正确和准确时钟的操作类型。</p></li>
<li><p>IO端口指令和对系统寄存器的访问是常见的例子。</p></li>
<li><p>这些指令必须由具有了解哪些操作是I/O操作的各个翻译器处理。</p></li>
<li><p>当翻译器处理此类指令时：</p>
<ul>
<li>如果启用了icount，它必须在实际执行I/O操作的代码生成之前的某个时刻调用gen_io_start()，使用类似以下代码片段的代码：
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (tb_cflags(s-&gt;base.tb) &amp; CF_USE_ICOUNT) &#123;</span><br><span class="line">    gen_io_start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>必须立即结束该TB（翻译块）在执行完这条指令之后。</li>
</ul></li>
<li><p>以上是处理这类指令的要求。通过调用gen_io_start()，我们可以确保在执行I/O操作之前记录正确的icount计数，并且在完成指令后结束TB以防止进一步执行不必要的指令。</p></li>
</ul>
]]></content>
      <categories>
        <category>Qemu</category>
      </categories>
  </entry>
  <entry>
    <title>Qemu翻译器的内部机制</title>
    <url>/zyhjy/2023/05/18/Qemu%E7%BF%BB%E8%AF%91%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="translator-internals-翻译器的内部机制">Translator Internals /
翻译器的内部机制</h1>
<ul>
<li><p>QEMU是一个动态翻译器。</p></li>
<li><p>当它首次遇到一段代码时，它会将其转换为宿主机指令集。</p></li>
<li><p>通常，动态翻译器非常复杂且高度依赖于CPU。</p></li>
<li><p>QEMU使用一些技巧使其相对容易进行移植和简化，同时实现良好的性能。</p></li>
<li><p>QEMU的动态翻译后端称为TCG（Tiny Code Generator），见另一篇文章TCG
IR。</p></li>
<li><p>以下部分概述了QEMU动态翻译器的一些显著特点和实现细节。</p></li>
</ul>
<h1 id="cpu-state-optimisations-cpu状态优化">CPU state optimisations /
CPU状态优化</h1>
<ul>
<li>目标CPU具有许多内部状态，这些状态会影响它们执行指令的方式。</li>
<li>为了实现良好的速度，翻译阶段考虑到虚拟CPU的某些状态信息在其中不会改变。</li>
<li>状态信息被记录在翻译块（Translation Block，TB）中。</li>
<li>如果状态发生变化（例如特权级别），将生成一个新的TB，并且之前的TB将不再使用，直到状态与之前记录在先的TB中的状态匹配。</li>
<li>对于CPU状态的其他方面也可以应用相同的思想。例如，在x86架构中，如果SS、DS和ES段具有零基址，那么翻译器甚至不会为段基址生成一个加法操作。</li>
</ul>
<h2 id="direct-block-chaining-直接块链接">Direct block chaining /
直接块链接</h2>
<ul>
<li><p>在每个已执行的翻译的基本块之后，QEMU使用模拟的程序计数器（PC）和其他CPU状态信息（例如CS段基址）来找到下一个基本块。</p></li>
<li><p>在简单且未经优化的形式中，这是通过退出当前的翻译块，经过翻译块的收尾处理，然后返回到主循环来完成的。</p></li>
<li><p>在主循环中，QEMU寻找要执行的下一个翻译块，如果它尚未在内存中，则将其从客户体系结构翻译出来。</p></li>
<li><p>然后，QEMU继续执行下一个翻译块，从序言开始，然后继续执行已翻译的指令。</p></li>
<li><p>以这种方式退出翻译块将导致在执行其他指令之前重新评估<code>cpu_exec_interrupt()</code>回调函数。</p></li>
<li><p>在发生可能解除中断屏蔽的任何CPU状态更改后，以这种方式退出是必需的。</p></li>
<li><p>为了加速当新的模拟PC对应的翻译块已经可用的情况，QEMU具有机制允许直接链接多个翻译块，而无需返回到上述的主循环。这些机制包括：</p></li>
</ul>
<h3 id="lookup_and_goto_ptr"><code>lookup_and_goto_ptr</code></h3>
<ul>
<li>调用<code>tcg_gen_lookup_and_goto_ptr()</code>将生成对<code>helper_lookup_tb_ptr</code>的调用。</li>
<li>该辅助函数将查找与当前CPU状态匹配的现有翻译块。</li>
<li>如果目标翻译块可用，则返回其代码地址；否则返回JIT（即时编译）收尾部分的地址。</li>
<li>在调用辅助函数之后，总是紧随着tcg
<code>goto_ptr</code>指令，它会跳转到返回的地址。</li>
<li>这样，我们要么跳转到下一个翻译块，要么返回到主循环。</li>
</ul>
<h3 id="goto_tb-exit_tb"><code>goto_tb + exit_tb</code></h3>
<ul>
<li><p>翻译代码通常通过以下步骤来实现分支：</p>
<ol type="1">
<li>调用<code>tcg_gen_goto_tb()</code>，并将跳转槽索引（0或1）作为参数传递。</li>
<li>发出TCG指令来更新CPU状态，其中包括已假定为常量且主循环需要正确定位和执行下一个翻译块所需的信息。对于大多数客户机，这仅仅是分支目标的PC，但其他一些客户机可能会存储附加数据。在此步骤中更新的信息必须可以从<code>cpu_get_tb_cpu_state()</code>和<code>cpu_restore_state()</code>中推断出来。</li>
<li>调用<code>tcg_gen_exit_tb()</code>，再次传递当前翻译块的地址和跳转槽索引。</li>
</ol></li>
<li><p>第1步<code>tcg_gen_goto_tb()</code>将生成一个<code>goto_tb</code>
TCG指令，稍后会被翻译为跳转到与指定跳转槽相关联的地址。</p></li>
<li><p>初始时，这是第2步的指令的地址，用于更新CPU状态信息。</p></li>
<li><p>第3步<code>tcg_gen_exit_tb()</code>从当前翻译块退出，并返回由上一个执行的翻译块地址和跳转槽索引组成的标记指针。</p></li>
<li><p>第一次执行整个序列时，第1步简单地跳转到第2步。</p></li>
<li><p>然后，CPU状态信息会被更新，并从当前翻译块退出。</p></li>
<li><p>结果，行为与前面在本节中描述的较少优化的形式非常相似。</p></li>
<li><p>接下来，主循环使用当前CPU状态信息寻找要执行的下一个翻译块（如果尚未可用，则创建该翻译块），并在开始执行新翻译块的指令之前，通过将其跳转槽之一（在调用<code>tcg_gen_exit_tb()</code>时指定）与新翻译块的地址关联起来，来修补先前执行的翻译块。</p></li>
<li><p>下一次执行这个先前的翻译块，并到达同样的<code>goto_tb</code>步骤时，它将已经被修补（假设目标翻译块仍然在内存中），并直接跳转到目标翻译块的第一条指令，而无需返回到主循环。</p></li>
<li><p>要使用<code>goto_tb + exit_tb</code>机制，需要满足以下条件：</p>
<ul>
<li><p>CPU状态的更改必须是常量，例如直接分支而不是间接分支。</p></li>
<li><p>直接分支不能跨越页边界。内存映射可能会改变，导致目标地址的代码发生变化。</p></li>
</ul></li>
<li><p>需要注意的是，在第3步（<code>tcg_gen_exit_tb()</code>）中，除了跳转槽索引之外，还返回了刚刚执行的翻译块的地址。</p></li>
<li><p>这个地址对应于将要被修补的翻译块；如果该翻译块已经链接到其他翻译块，那么它可能与直接从主循环执行的翻译块不同。</p></li>
<li><p>Note that, on step 3 (<code>tcg_gen_exit_tb()</code>), in
addition to the jump slot index, the address of the TB just executed is
also returned.</p></li>
<li><p>This address corresponds to the TB that will be patched; it may
be different than the one that was directly executed from the main loop
if the latter had already been chained to other TBs.</p></li>
</ul>
<h2
id="self-modifying-code-and-translated-code-invalidation-自修改代码和翻译代码失效">Self-modifying
code and translated code invalidation / 自修改代码和翻译代码失效</h2>
<ul>
<li><p>在x86仿真中，自修改代码是一个特殊的挑战，因为当代码被修改时，应用程序不会向系统发出指示来使指令缓存失效。</p></li>
<li><p>在用户模式仿真中，每当为基本块生成翻译代码时，会将主机页面标记为写保护（如果它尚未是只读）。</p></li>
<li><p>然后，如果对该页面进行写访问，Linux会触发一个SEGV信号。</p></li>
<li><p>然后，QEMU会使该页面中的所有翻译代码失效，并允许对该页面进行写访问。</p></li>
<li><p>对于系统仿真，写保护是通过软件MMU实现的。</p></li>
<li><p>通过维护一个链接列表来高效地进行正确的翻译代码失效，该列表包含在给定页面中的每个翻译块。</p></li>
<li><p>还维护其他链接列表以撤消直接块链接。</p></li>
<li><p>Correct translated code invalidation is done efficiently by
maintaining a linked list of every translated block contained in a given
page.</p></li>
<li><p>Other linked lists are also maintained to undo direct block
chaining.</p></li>
<li><p>在RISC目标中，正确编写的软件使用内存屏障和缓存刷新，因此上述保护措施可能不是必需的。</p></li>
<li><p>然而，QEMU仍然要求生成的代码始终与目标指令在内存中匹配，以便正确处理异常情况。</p></li>
</ul>
<h2 id="exception-support-异常支持">Exception support / 异常支持</h2>
<ul>
<li><p>在遇到诸如除零等异常时，会使用longjmp()函数。</p></li>
<li><p>主机的SIGSEGV和SIGBUS信号处理程序用于获取无效的内存访问。</p></li>
<li><p>QEMU保持了一个从主机程序计数器（PC）到目标程序计数器（PC）的映射，并根据异常点处的主机程序计数器查找异常发生的位置。</p></li>
<li><p>在某些目标平台上，虚拟CPU状态的某些位直到翻译块结束之前才会刷新到内存中。</p></li>
<li><p>这是为了保存内部仿真状态，该状态很少直接被程序访问，且在翻译块的执行过程中经常发生变化，例如x86上的条件码、SPARC上的延迟槽、Arm上的条件执行等。</p></li>
<li><p>这些状态针对每个目标指令进行存储，并在发生异常时进行查找。</p></li>
</ul>
<h2 id="mmu-emulation-mmumemory-management-unit仿真">## MMU emulation /
MMU（Memory Management Unit）仿真</h2>
<ul>
<li><p>在系统仿真中，QEMU使用软件MMU。</p></li>
<li><p>在这种模式下，MMU会在每次内存访问时进行虚拟地址到物理地址的转换。</p></li>
<li><p>为了加快转换速度并避免在MMU映射发生变化时每次都刷新已翻译的代码，QEMU使用地址转换缓存（TLB）。</p></li>
<li><p>在QEMU中，所有缓存都是物理索引的，这意味着每个基本块都与其物理地址相关联。</p></li>
<li><p>为了避免在MMU映射发生变化时使基本块链无效，只有当跳转目标与执行跳转的基本块共享同一页时，才会执行链式操作。</p></li>
<li><p>MMU还可以区分RAM（随机存储器）和ROM（只读存储器）区域与MMIO（内存映射输入/输出）内存区域。</p></li>
<li><p>对于RAM和ROM的访问速度更快，因为转换缓存还存储了来宾地址和主机内存之间的偏移量。</p></li>
<li><p>而对MMIO内存区域的访问则调用C代码进行设备仿真。</p></li>
<li><p>最后，MMU有助于跟踪脏页和被翻译块引用的页。</p></li>
<li><p>这样可以有效地管理内存页面，并进行必要的操作，如脏页回写或内存页面回收。</p></li>
</ul>
<h2 id="profiling-jitted-code-对jit即时编译代码进行性能分析">Profiling
JITted code / 对JIT（即时编译）代码进行性能分析</h2>
<ul>
<li><p>Linux的perf工具在处理JIT（即时编译）代码时会将其视为单个代码块，因为与主要代码不同，它无法使用调试信息将单个程序计数器样本与较大的函数关联起来。</p></li>
<li><p>为了克服这个限制，可以使用<code>-perfmap</code>或<code>-jitdump</code>选项生成映射文件。</p></li>
<li><p><code>-perfmap</code>是轻量级的，只生成客户机-主机映射关系。</p></li>
<li><p><code>-jitdump</code>除此之外，还会保存JIT代码和客户机调试信息（如果有的话）；它的输出需要与<code>perf.data</code>文件集成，然后才能查看最终的报告。</p></li>
<li><p>示例代码如下：</p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">perf record $QEMU -perfmap $REMAINING_ARGS</span><br><span class="line">perf report</span><br><span class="line"></span><br><span class="line">perf record -k 1 $QEMU -jitdump $REMAINING_ARGS</span><br><span class="line">DEBUGINFOD_URLS= perf inject -j -i perf.data -o perf.data.jitted</span><br><span class="line">perf report -i perf.data.jitted</span><br></pre></td></tr></table></figure>
<ul>
<li><p>请注意，qemu-system仅为ELF格式的<code>-kernel</code>文件生成映射。</p></li>
<li><p>使用这些命令和选项，可以将JIT代码的性能分析结果与perf工具的报告集成在一起，以便更好地理解和分析JIT代码的性能。这将帮助开发人员针对性地进行优化和改进，提高QEMU的性能。</p></li>
</ul>
]]></content>
      <categories>
        <category>Qemu</category>
      </categories>
  </entry>
  <entry>
    <title>Qemu介绍</title>
    <url>/zyhjy/2023/05/19/Qemu%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>Qemu</category>
      </categories>
  </entry>
  <entry>
    <title>Qemu翻译实例--以arrch64 --&gt;&gt; x86-64为例</title>
    <url>/zyhjy/2023/02/07/Qemu%E7%BF%BB%E8%AF%91%E5%AE%9E%E4%BE%8B--%E4%BB%A5arrch64%20--%3E%3E%20x86-64%E4%B8%BA%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="qemu翻译实例--以arrch64----i386为例">Qemu翻译实例--以arrch64
--&gt;&gt; i386为例</h1>
<h2 id="前言">0.前言</h2>
<ul>
<li>QEMU 是一个仿真器(emulator)，可以user mode 或是system mode 运行。
<ul>
<li>user mode 可以运行不同ISA 同一OS 的binary;</li>
<li>system mode 可以在当前作业系统上运行另外一个OS.</li>
</ul></li>
<li>对QEMU 而言，被仿真的平台被称为guest，又称target; 运行QEMU
的平台称为host。
<ul>
<li>QEMU 是利用动态翻译(dynamic translation) 的技术将guest binary
动态翻译成host binary，并交由host 运行翻译所得的host binary。</li>
<li>Tiny Code Generator (TCG) 是QEMU 中负责动态翻译的组件。
<ul>
<li>对TCG 而言，target 有不同的含意，它代表TCG 是针对哪一个host 生成host
binary。</li>
</ul></li>
</ul></li>
<li>QEMU
极为依赖macro，这使得直接阅读源代码通常无法确定其函数呼叫，或是执行流程倒底为何。</li>
<li>请在编译QEMU
的时候加上<code>--extra-cflags="-save-temps"</code>，如此可得展开marco
的 <code>*.i</code> 档。</li>
</ul>
<h2 id="tcg">1. TCG</h2>
<ul>
<li>TCG 是QEMU 的核心。其基本流程如下:
<ul>
<li>guest binary -&gt; TCG IR -&gt; host binary</li>
</ul></li>
</ul>
<h3 id="tcg-ir">1.1 TCG IR</h3>
<ul>
<li><p>TCG 定义了一组IR (intermediate representation)，熟悉GCC
的各位对此应该不陌生。</p></li>
<li><p>TCG IR 大致分成以下几类:</p>
<ul>
<li>Move Operation: mov, movi, …</li>
<li>Logic Operation: and, or, xor, shl, shr, …</li>
<li>Arithmetic peration: add, sub, mul, div, …</li>
<li>Branch Operation: jmp, br, brcond</li>
<li>Fuction call: call</li>
<li>Memory Operation: ld, st</li>
<li>QEMU specific Operation: tb_exit, goto_tb, qemu_ld/qemu_st</li>
</ul></li>
<li><p>请见tcg/*，特别是tcg.i，可以看到TCGOpcode。</p></li>
<li><p>tcg/README 也别忘了。</p></li>
<li><p>TCG 在翻译guest binary 的时候是以一个translation block (tb)
为单位，其结尾通常是分支指令。</p></li>
<li><p>target/ARCH/* 定义了如何将ARCH binary 反汇编成TCG IR。</p>
<ul>
<li>target/arm</li>
</ul></li>
<li><p>tcg/ARCH 定义了如何将TCG IR 翻译成ARCH binary。</p>
<ul>
<li>tcg/i386</li>
</ul></li>
</ul>
<h3 id="tcg-flow">1.2 TCG Flow</h3>
<ul>
<li><p>gen_opc_buf 和gen_opparam_buf (translate-all.c) 分别放置TCG
Opcode 和Operand。</p></li>
<li><p>如果使用静态配置的缓冲区，static_code_gen_buffer (exec.c)
即为code cache，放置host binary。</p></li>
<li><p>在跳入/出code cache
执行之前/后，要执行prologue/epilogue，请见code_gen_prologue
(exec.c)。</p></li>
<li><p>这边的prologue/epilogue 就是指function
prologue/epilogue。</p></li>
<li><p>QEMU 将跳至code cache (host binary)
执行的过程看成是函式呼叫，故有此prologue/epilogue。</p></li>
<li><p>以qemu-arm 为例，流程大致如下:</p>
<ul>
<li><p>main() // vl.c</p></li>
<li><p>--&gt;&gt; main_loop() // vl.c</p></li>
<li><p>--&gt;&gt; arm_cpu_realizefn() //
target/arm/cpu.c，实例化虚拟机CPU设备模型 [GUEST]_cpu_realizefn</p></li>
<li><p>--&gt;&gt; qemu_init_vcpu() //
softmmu/cpus.c，KVM没有enable，并且启_cpu_thread_fn用了TCG的情况下，tcg_enabled()</p></li>
<li><p>--&gt;&gt; qemu_tcg_init_vcpu() //
启动VCPU线程，线程处理函数为qemu_tcg_cpu_thread_fn</p></li>
<li><p>--&gt;&gt; qemu_tcg_cpu_thread_fn()</p></li>
<li><p>--&gt;&gt; tcg_exec_all()</p></li>
<li><p>--&gt;&gt; tcg_cpu_exec()</p></li>
<li><p>--&gt;&gt; cpu_exec() //cpu-exee.c</p></li>
<li><p>user mode:</p>
<ul>
<li>main (linux-user/main.c) -&gt; cpu_create -&gt; tcg_prologue_init
(tcg/tcg.c) -&gt; cpu_loop (linux-user/main.c)</li>
</ul></li>
</ul></li>
<li><p>这边只介绍tcg_prologue_init (tcg/tcg.c) -&gt; cpu_loop
(linux-user/arm/cpu_loop.c) 这一段，因为这一段跟TCG 较为相关。</p></li>
<li><p>容我先讲cpu_loop (linux-user/arm/cpu_loop.c)。</p></li>
<li><p>cpu_loop(CPUARMState *env) (linux-user/arm/cpu_loop.c) -&gt;
cpu_exec (accel/tcg/cpu-exec.c)。</p></li>
<li><p>cpu_exec 是主要执行回圈，其结构大致如下: <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* prepare setjmp context for exception handling */</span> </span><br><span class="line"><span class="keyword">if</span> (sigsetjmp(cpu-&gt;jmp_env, <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!cpu_handle_exception(cpu, &amp;ret)) &#123;</span><br><span class="line">    <span class="keyword">while</span> (!cpu_handle_interrupt(cpu, &amp;last_tb)) &#123; </span><br><span class="line">        tb = tb_lookup(cpu, pc, cs_base, flags, cflags); <span class="comment">// 寻找下一个TB</span></span><br><span class="line">        <span class="keyword">if</span> (tb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            tb = tb_gen_code(cpu, pc, cs_base, flags, cflags);</span><br><span class="line">        &#125;</span><br><span class="line">        cpu_loop_exec_tb(cpu, tb, &amp;last_tb, &amp;tb_exit);<span class="comment">// 跳至code cache 执行。</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">cpu_exec_exit(cpu);</span><br></pre></td></tr></table></figure></p></li>
<li><p>tcg_prologue_init (tcg/tcg.c) -&gt; tcg_target_qemu_prologue
(tcg/arm/tcg-target.c.inc)。</p></li>
<li><p>如前所述，QEMU 将跳至code cache (host binary)
执行的过程看成是函式呼叫。</p></li>
<li><p>不同平台的calling convention 各有不同，tcg_prologue_init
将产生prologue/epilogue 的工作转交tcg_target_qemu_prologue。
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tcg_target_qemu_prologue</span><span class="params">(TCGContext *s)</span> &#123; </span><br><span class="line">    <span class="comment">/* Calling convention requires us to save r4-r11 and lr.  */</span></span><br><span class="line">    <span class="comment">/* stmdb sp!, &#123; r4 - r11, lr &#125; */</span></span><br><span class="line">    tcg_out32(s, (COND_AL &lt;&lt; <span class="number">28</span>) | <span class="number">0x092d4ff0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reserve callee argument and tcg temp space.  */</span></span><br><span class="line">    tcg_out_dat_rI(s, COND_AL, ARITH_SUB, TCG_REG_CALL_STACK,</span><br><span class="line">                   TCG_REG_CALL_STACK, STACK_ADDEND, <span class="number">1</span>);</span><br><span class="line">    tcg_set_frame(s, TCG_REG_CALL_STACK, TCG_STATIC_CALL_ARGS_SIZE,</span><br><span class="line">                  CPU_TEMP_BUF_NLONGS * <span class="keyword">sizeof</span>(<span class="type">long</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* QEMU (cpu_exec) -&gt; 入栈*/</span> </span><br><span class="line">    tcg_out_mov(s, TCG_TYPE_PTR, TCG_AREG0, tcg_target_call_iarg_regs[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tcg_target_call_iarg_regs 是函式呼叫负责传递参数的暂存器。</span></span><br><span class="line">    <span class="comment">// 跳至code cache 执行。</span></span><br><span class="line">    tcg_out_bx(s, COND_AL, tcg_target_call_iarg_regs[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 此时，s-&gt;code_ptr 指向code_gen_prologue 中prologue 和jmp to code cache 之后的位址。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Return path for goto_ptr. Set return value to 0, a-la exit_tb,</span></span><br><span class="line"><span class="comment">     * and fall through to the rest of the epilogue.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    tcg_code_gen_epilogue = tcg_splitwx_to_rx(s-&gt;code_ptr);</span><br><span class="line">    tcg_out_movi(s, TCG_TYPE_PTR, TCG_REG_R0, <span class="number">0</span>);</span><br><span class="line">    tcg_out_epilogue(s); <span class="comment">/* 出栈-&gt; 返回QEMU (cpu_exec)，确切的讲是返回tcg_qemu_tb_exec */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>这边小结一下。</p>
<ul>
<li>QEMU -&gt; prologue -&gt; code cache -&gt; epilogue -&gt; QEMU</li>
</ul></li>
<li><p>在介绍cpu_exec 之前，我先介绍几个QEMU
资料结构，请善用SOURCEARCHIVE.com。</p></li>
<li><p>我们要知道所谓仿真或是虚拟化一个CPU
(ISA)，简单来说就是用一个资料结构(struct) 储存该CPU的状态。</p></li>
<li><p>执行该虚拟CPU，就是从内存中读取该虚拟CPU的资料结构，运算后再存回去。</p></li>
<li><p>CPUX86State: 保存x86 register，eflags，eip，cs，…。</p></li>
<li><p>不同ISA 之间通用的资料结构被QEMU #define 成CPU_COMMON。</p></li>
<li><p>一般称此资料结构为CPUState。下文所提env 即为CPUState。</p></li>
<li><p>QEMU 运行虚拟CPU 都会利用env 这个变数。</p></li>
<li><p>TranslationBlock: 之前说过，QEMU 是以一个translation block
为单位进行翻译。</p></li>
<li><p>其中保存此translation block 对应guest binary 的pc, cs_base,
eflags。</p></li>
<li><p>另外，tc_ptr 指向code cache (host
binary)。其它栏位待以后再谈。</p></li>
<li><p>PageDesc: 主要保存guest page 中的第一个tb (TranslationBlock
*)。</p></li>
<li><p>这跟QEMU 内部运作机制有关。某些情况下，guest page (guest binary)
可能被替换或是被写。</p></li>
<li><p>这个时候，QEMU 会以guest page (guest binary)
为单位，清空与它相关联的TB (code cache)。</p></li>
<li><p>这时再回来讲 TranslationBlock。TranslationBlock
有底下两个栏位:</p>
<ul>
<li>page_addr[2]: 存放TranslationBlock 对应guest binary 所在的guest
page。注意! guest binary 有可能跨guest page，故这里有两个栏位。</li>
<li>page_next[2]: 当透过PageDesc-&gt;first_tb 找到该guest page
的第一个tb，tb-&gt;page_next 就被用来找寻该guest page 的下一个tb。</li>
</ul></li>
<li><p>再回来讲PageDesc。QEMU 替PageDesc
维护了一个二级页表l1_map。page_find 这个函式根据输入的address
搜寻l1_map，返回PageDesc。这在以guest page (guest binary)
为单位，清空与它相关联的TB (code cache)
的时候会用到。有一个名字很像的资料结构叫PhysPageDesc，QEMU
也替它维护一个二级页表l1_phys_map。这是在system mode
做地址转换之用，这边不谈。</p></li>
<li><p>TCGContext: 生成TCG IR 时会用到。</p></li>
<li><p>DisasContext: 反汇编guest binary 时会用到</p></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>Arrch64 CPU Structure</title>
    <url>/zyhjy/2023/05/19/Arrch64%20MMU/</url>
    <content><![CDATA[<h1 id="the-memory-management-unit">The Memory Management Unit</h1>
<p>内存管理单元（Memory Management
Unit，MMU）的一个重要功能是使系统能够运行多个任务，这些任务作为独立的程序在它们自己的私有虚拟内存空间中运行。它们不需要知道系统的物理内存映射，也就是硬件实际使用的地址，或者其他可能同时执行的程序。</p>
<p>您可以为每个程序使用相同的虚拟内存地址空间。即使物理内存是碎片化的，您也可以使用连续的虚拟内存映射。这个虚拟地址空间与系统中实际的物理内存映射是分离的。您可以编写、编译和链接应用程序以在虚拟内存空间中运行。</p>
<p><a
href="https://developer.arm.com/documentation/den0024/a/The-Memory-Management-Unit?lang=en#BABBEBII">图12.2</a>展示了一个示例系统，说明了内存的虚拟视图和物理视图。在单个系统中，不同的处理器和设备可能具有不同的虚拟和物理地址映射。操作系统会对MMU进行编程，以在这两个内存视图之间进行转换。</p>
<p>为了实现这一点，在虚拟内存系统中的硬件必须提供地址转换，即将处理器发出的虚拟地址转换为主内存中的物理地址。</p>
<p>虚拟地址是您、编译器和链接器在将代码放入内存时使用的地址。物理地址是实际硬件系统使用的地址。</p>
<p>MMU使用虚拟地址的最高有效位来索引翻译表中的条目，并确定正在访问的块。MMU将代码和数据的虚拟地址转换为实际系统中的物理地址。这种转换是在硬件中自动进行的，并且对应用程序是透明的。除了地址转换之外，MMU还控制每个内存区域的内存访问权限、内存排序和缓存策略。</p>
<h2 id="the-translation-lookaside-buffer">The Translation Lookaside
Buffer</h2>
<p>Translation Lookaside Buffer
(TLB)是MMU中最近访问的页面转换的高速缓存。对于处理器执行的每个内存访问，MMU都会检查TLB中是否缓存了相应的转换。如果请求的地址转换在TLB中命中，地址的转换结果将立即可用。</p>
<p>每个TLB条目通常不仅包含物理地址和虚拟地址，还包括诸如内存类型、缓存策略、访问权限、地址空间ID（ASID）和虚拟机ID（VMID）等属性。如果TLB中没有包含处理器发出的虚拟地址的有效转换，即TLB未命中，就会执行外部的转换表查找或遍历。MMU内的专用硬件使其能够读取内存中的转换表。新加载的转换结果可以被缓存到TLB中，以备后续使用，如果转换表的遍历过程不会导致页面错误。TLB的具体结构在不同的ARM处理器实现之间会有所不同。</p>
<p>如果操作系统修改了可能缓存在TLB中的转换条目，那么操作系统有责任使这些过时的TLB条目失效。</p>
<h2
id="separation-of-kernel-and-application-virtual-address-spaces">Separation
of kernel and application Virtual Address spaces</h2>
<p>操作系统通常会同时运行多个应用程序或任务。每个应用程序都有自己独特的转换表集合，并且内核在切换上下文时会从一个转换表切换到另一个。然而，大部分内存系统只被内核使用，并具有固定的虚拟到物理地址映射，其中转换表条目很少改变。ARMv8架构提供了一些功能来有效地处理这一要求。</p>
<p>转换表的基地址在Translation Table Base Registers
(TTBR0_EL1)和(TTBR1_EL1)中指定。当VA的高位全为0时，选择TTBR0指向的转换表。当VA的高位全部设置为1时，选择TTBR1指向的转换表。您可以启用VA标记以排除检查过程中的前8位。</p>
<p>处理器从指令获取或数据访问的虚拟地址是64位。然而，在48位物理地址内存映射中，您必须同时映射上述两个定义的区域。</p>
<p>EL2和EL3都有一个TTBR0，但没有TTBR1。这意味着：</p>
<p>如果EL2正在使用AArch64，它只能使用范围为0x0至0x0000FFFF_FFFFFFFF的虚拟地址。</p>
<p>如果EL3正在使用AArch64，它只能使用范围为0x0至0x0000FFFF_FFFFFFFF的虚拟地址。</p>
<p><a
href="https://developer.arm.com/documentation/den0024/a/The-Memory-Management-Unit/Separation-of-kernel-and-application-Virtual-Address-spaces?lang=en#CDDFFEJB">图12.4</a>显示了内核空间如何映射到内存的最高有效区域，每个应用程序关联的虚拟地址空间映射到内存的最低有效区域。然而，这两者都映射到一个更小的物理地址空间。</p>
<p>TCR_EL1是转换控制寄存器，它定义了需要进行检查的最高有效位的确切数量。TCR_EL1包含了大小字段T0SZ[5:0]和T1SZ[5:0]。字段中的整数表示必须是全0或全1的最高有效位的数量。这些字段有指定的最小和最大值，这些值随着颗粒大小和起始表级别的不同而变化。因此，在所有系统中，您必须始终使用两个转换表，并且至少需要两个转换表。即使是一个没有操作系统的简单裸机系统，也需要一个包含错误条目的小型上层表。</p>
<h2 id="context-switching-上下文切换">Context switching 上下文切换</h2>
<p>实现ARMv8-A架构的处理器通常用于运行具有许多并发应用程序或任务的复杂操作系统的系统中。每个进程在物理内存中都有自己独特的转换表。当一个应用程序启动时，操作系统会为其分配一组转换表条目，将应用程序使用的代码和数据映射到物理内存。这些表可以随后由内核进行修改，例如映射额外的空间，并在应用程序不再运行时被删除。</p>
<p>因此，内存系统中可能存在多个任务。内核调度程序定期将执行从一个任务转移至另一个任务。这被称为上下文切换，要求内核保存与进程关联的所有执行状态，并恢复要运行的进程的状态。内核还切换转换表条目到下一个要运行的进程的条目。当前未运行的任务的内存完全受到正在运行的任务的保护。</p>
<p>实际上需要保存和恢复的内容因不同操作系统而异，但通常进程上下文切换包括保存或恢复以下一些或全部元素：
- 通用寄存器 X0-X30。 - 高级SIMD和浮点寄存器 V0-V31。 - 一些状态寄存器。
- TTBR0_EL1 和 TTBR0。 - 线程进程ID（TPIDxxx）寄存器。 -
地址空间ID（ASID）。</p>
<p>对于EL0和EL1，有两个转换表。TTBR0_EL1为虚拟地址空间底部（通常是应用程序空间）提供转换，而TTBR1_EL1覆盖虚拟地址空间的顶部（通常是内核空间）。这种分割意味着操作系统映射不必复制到每个任务的转换表中。</p>
<p>转换表条目包含一个非全局（nG）位。如果nG位设置为特定页面，则与特定任务或应用程序相关联。如果该位标记为0，则条目是全局的，适用于所有任务。</p>
<p>对于非全局条目，在更新TLB并将条目标记为非全局时，除了常规转换信息之外，还在TLB条目中存储一个值。该值称为地址空间ID（ASID），由操作系统分配给每个单独的任务。仅当当前ASID与存储在条目中的ASID匹配时，后续的TLB查找才与该条目匹配。这允许多个有效的TLB条目存在于标记为非全局的特定页面中，但具有不同的ASID值。换句话说，我们在上下文切换时不一定需要刷新TLB。</p>
<p>在AArch64中，ASID值可以指定为8位或16位的值，由TCR_EL1.AS位控制。当前ASID值在TTBR0_EL1或TTBR1_EL1中指定。TCR_EL1控制哪个TTBR持有ASID，但通常是TTBR0_EL1，因为它对应应用程序空间。</p>
<p>注意 -
将当前ASID值存储在转换表寄存器中意味着您可以在一条指令中原子地修改转换表和ASID。与ARMv7-A架构相比，这简化了更改表和ASID的过程。</p>
<p>此外，ARMv8-A架构提供了用于操作系统软件的线程ID寄存器。这些寄存器在硬件上没有特殊意义，通常由线程库用作每个线程数据的基指针。这通常称为线程本地存储（TLS）。例如，pthread库使用了这个特性，并包括以下寄存器：
- 用户读写线程ID寄存器（TPIDR_EL0）。 -
用户只读线程ID寄存器（TPIDRRO_EL0）。 -
线程ID寄存器，仅特权访问（TPIDR_EL1）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">uint64_t</span> c14_cntfrq; <span class="comment">/* Counter Frequency register */</span></span><br><span class="line">        <span class="type">uint64_t</span> c14_cntkctl; <span class="comment">/* Timer Control register */</span></span><br><span class="line">        <span class="type">uint32_t</span> cnthctl_el2; <span class="comment">/* Counter/Timer Hyp Control register */</span></span><br><span class="line">        <span class="type">uint64_t</span> cntvoff_el2; <span class="comment">/* Counter Virtual Offset register */</span></span><br><span class="line">        ARMGenericTimer c14_timer[NUM_GTIMERS];</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* Stores the architectural value of the counter *the last time it was</span></span><br><span class="line"><span class="comment">         * updated* by pmccntr_op_start. Accesses should always be surrounded</span></span><br><span class="line"><span class="comment">         * by pmccntr_op_start/pmccntr_op_finish to guarantee the latest</span></span><br><span class="line"><span class="comment">         * architecturally-correct value is being read/set.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">uint64_t</span> c15_ccnt;</span><br><span class="line">        <span class="comment">/* Stores the delta between the architectural value and the underlying</span></span><br><span class="line"><span class="comment">         * cycle count during normal operation. It is used to update c15_ccnt</span></span><br><span class="line"><span class="comment">         * to be the correct architectural value before accesses. During</span></span><br><span class="line"><span class="comment">         * accesses, c15_ccnt_delta contains the underlying count being used</span></span><br><span class="line"><span class="comment">         * for the access, after which it reverts to the delta value in</span></span><br><span class="line"><span class="comment">         * pmccntr_op_finish.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">uint64_t</span> c15_ccnt_delta;</span><br><span class="line">        <span class="type">uint64_t</span> c14_pmevcntr[<span class="number">31</span>];</span><br><span class="line">        <span class="type">uint64_t</span> c14_pmevcntr_delta[<span class="number">31</span>];</span><br><span class="line">        <span class="type">uint64_t</span> c14_pmevtyper[<span class="number">31</span>];</span><br><span class="line">        <span class="type">uint64_t</span> pmccfiltr_el0; <span class="comment">/* Performance Monitor Filter Register */</span></span><br><span class="line">    &#125; cp15;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Qemu</category>
      </categories>
  </entry>
  <entry>
    <title>Arrch64 CPU Structure</title>
    <url>/zyhjy/2023/05/19/Arrch64%20CPU%E6%8C%87%E4%BB%A4%E9%9B%86/</url>
    <content><![CDATA[<h1 id="qemu-arrch64中的常用寄存器">0. Qemu Arrch64中的常用寄存器</h1>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Size</th>
<th>Description</th>
<th>Alias</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>WZR</td>
<td>32 bits</td>
<td>Zero register</td>
<td></td>
</tr>
<tr class="even">
<td>XZR</td>
<td>64 bits</td>
<td>Zero register</td>
<td></td>
</tr>
<tr class="odd">
<td>FP</td>
<td>64 bits</td>
<td>Current stack pointer</td>
<td>X29</td>
</tr>
<tr class="even">
<td>LR</td>
<td>64 bits</td>
<td>Current stack pointer</td>
<td>X30</td>
</tr>
<tr class="odd">
<td>SP</td>
<td>64 bits</td>
<td>Current stack pointer</td>
<td>X31</td>
</tr>
<tr class="even">
<td>PC</td>
<td>64 bits</td>
<td>Program counter</td>
<td></td>
</tr>
</tbody>
</table>
<h1
id="an-introduction-to-the-armv8-instruction-sets-armv8指令集简介">1. An
Introduction to the ARMv8 Instruction Sets / ARMv8指令集简介</h1>
<p>ARMv8架构引入的最重要的变化之一是增加了64位指令集。这个指令集与现有的32位指令集架构相辅相成。这个增加使得可以访问64位宽整数寄存器和数据操作，并且能够使用64位大小的内存指针。这些新指令被称为A64指令，运行在AArch64执行状态下。ARMv8还包括原始的ARM指令集，现在称为A32指令集，以及Thumb
(T32)指令集。A32和T32都在AArch32状态下执行，与ARMv7保持向后兼容。</p>
<p>尽管ARMv8-A与32位ARM体系结构保持向后兼容，但A64指令集与旧的指令集架构是独立的并且编码方式不同。A64添加了一些额外的功能，同时去除了可能限制高性能实现速度或能量效率的其他特性。ARMv8架构还对32位指令集(A32和T32)进行了一些增强。然而，使用这些功能的代码与旧的ARMv7实现不兼容。然而，A64指令集中的指令操作码仍然是32位长，而不是64位。</p>
<p>寻求更详细的A64汇编语言描述的程序员还可以参考ARM编译器armasm参考指南v6.01。</p>
<h2 id="the-armv8-instruction-sets">The ARMv8 instruction sets</h2>
<p>新的A64指令集与现有的A32指令集相似。指令长度为32位，具有类似的语法。</p>
<p>在AArch64状态下，引入了一种新的指令集供内核使用。遵循命名约定，并反映64位操作，该指令集称为：<strong>A64</strong>
A64提供了与AArch32或ARMv7中的A32和T32指令集类似的功能。新的A64指令集的设计带来了几个改进：
#### 一致的编码方案
A32中一些指令的晚期添加导致编码方案的一些不一致性。例如，LDR和STR对半字节的支持在编码上与主流的字节和字传输指令稍有不同。结果是寻址模式稍有不同。</p>
<h4 id="广泛的常量范围">广泛的常量范围</h4>
<p>A64指令提供了广泛的常量选项，每个选项都适用于特定指令类型的要求。 -
算术指令通常接受12位立即数常量。 -
逻辑指令通常接受32位或64位常量，其编码具有一定的限制。 -
MOV指令接受16位立即数，可以移动到任何16位边界。 -
地址生成指令适用于与4KB页面大小对齐的地址。</p>
<p>对于用于位操作指令的常量，存在稍微复杂的规则。然而，位字段操作指令可以在源操作数或目标操作数中处理任何连续的位序列。</p>
<p>A64提供了灵活的常量，但是编码这些常量，甚至确定特定常量是否可以在特定上下文中合法编码，可能并不简单。</p>
<h4 id="数据类型更容易处理">数据类型更容易处理</h4>
<p>A64天然支持64位有符号和无符号数据类型，提供更简洁和高效的操作64位整数的方法。这对于提供64位整数的所有语言，如C或Java，都是有利的。</p>
<h4 id="长偏移量">长偏移量</h4>
<p>A64指令通常提供更长的偏移量，用于<em>PC相对分支和偏移寻址</em>。</p>
<p>增加的分支范围使得管理交叉段跳转更容易。动态生成的代码通常放置在堆上，因此实际上可以位于任何位置。运行时系统通过增加分支范围更容易管理这个过程，并且需要的修复次数更少。</p>
<p>字面池（嵌入在代码流中的字面数据块）的需求一直是ARM指令集的特性。这在A64中仍然存在。然而，更大的PC相对加载偏移量在字面池的管理方面提供了很大帮助，使得每个编译单元可以使用一个字面池。这消除了在长代码序列中为多个池制造位置的需要。</p>
<h4 id="指针">指针</h4>
<p>在AArch64中，指针是64位的，这允许更大的虚拟内存寻址，并提供更大的地址映射自由度。然而，使用64位指针确实会带来一些成本。相同的代码片段在使用64位指针时通常使用更多内存，而不是32位指针。每个指针都存储在内存中，需要8字节而不是4字节。这听起来可能微不足道，但可能累积到显著的性能损失。此外，由于转向64位的内存空间增加使用，可能导致<em>缓存命中的访问次数下降</em>。缓存命中的下降可能会降低性能。</p>
<p>某些语言可以使用压缩指针来解决性能问题，例如Java。</p>
<h4 id="条件构造代替it块">条件构造代替IT块</h4>
<p>IT块是T32的一个有用特性，可以实现避免对未执行指令周围进行短程前向分支的高效序列。然而，它们有时对硬件的高效处理具有一定困难。A64移除了这些块，并用条件指令（如CSEL或条件选择和CINC或条件递增）替换它们。这些条件构造更直观和更容易处理，无需特殊情况。</p>
<h4 id="移位和旋转行为更直观">移位和旋转行为更直观</h4>
<p>A32或T32的移位和旋转行为并不总是与高级语言预期的行为相匹配。</p>
<p>ARMv7提供了一个可用于数据处理指令的位移器。然而，指定移位类型和移位量需要一定数量的操作码位，这些位可以在其他地方使用。</p>
<p>因此，A64指令删除了很少使用的选项，并添加了新的显式指令来执行更复杂的移位操作。</p>
<h4 id="代码生成">代码生成</h4>
<p>在静态和动态生成常见算术函数的代码时，A32和T32通常需要不同的指令或指令序列。这是为了处理不同的数据类型。A64中这些操作更加一致，因此更容易生成在不同大小数据类型上进行简单操作的常见序列。</p>
<p>例如，在T32中，相同的指令可以具有不同的编码，具体取决于使用的寄存器（低寄存器还是高寄存器）。</p>
<p>A64指令集编码更加规则和合理。因此，与T32相比，A64汇编器通常需要更少的代码行数。</p>
<h4 id="固定长度指令">固定长度指令</h4>
<p>所有A64指令的长度都相同，而T32是一种可变长度指令集。这使得管理和跟踪生成的代码序列更容易，特别是对动态代码生成器有影响。</p>
<h4 id="三个操作数更好地映射">三个操作数更好地映射</h4>
<p>A32通常保留了用于数据处理操作的真正的三个操作数结构。而T32则包含大量的双操作数指令格式，这在生成代码时稍微不够灵活。A64坚持使用一致的三个操作数语法，进一步增加了指令集的规则性和统一性，有利于编译器。</p>
<h3 id="cc-inline-assembly">C/C++ inline assembly</h3>
<p>在C和C++中，你可以使用<code>asm</code>关键字来包含内联汇编代码。它允许你直接在C或C++函数中嵌入汇编代码。以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">asm</span> (</span><br><span class="line">    <span class="string">&quot;ADD %w[result], %w[input_i], %w[input_j]&quot;</span></span><br><span class="line">    : [result] <span class="string">&quot;=r&quot;</span> (res)</span><br><span class="line">    : [input_i] <span class="string">&quot;r&quot;</span> (i), [input_j] <span class="string">&quot;r&quot;</span> (j)</span><br><span class="line">  );</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  c = add(a, b);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Result of %d + %d = %d\n&quot;</span>, a, b, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>asm</code>内联汇编语句的一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span>(code [: output_operand_list [: input_operand_list [: clobber_list]]]);</span><br></pre></td></tr></table></figure>
<p>以下是各个组成部分的说明：</p>
<ul>
<li><code>code</code>表示汇编代码本身。在示例中，它是<code>"ADD %[result], %[input_i], %[input_j]"</code>。</li>
<li><code>output_operand_list</code>是一个可选的以逗号分隔的输出操作数列表。每个操作数由方括号中的符号名称、约束字符串和括号中的C表达式组成。</li>
<li><code>input_operand_list</code>是一个可选的以逗号分隔的输入操作数列表。输入操作数使用与输出操作数相同的语法。</li>
<li><code>clobber_list</code>是一个可选的被破坏的寄存器或其他值的列表。</li>
</ul>
<p>当在C/C++和汇编代码之间调用函数时，你必须遵循AAPCS64规则。</p>
<p>更多信息，请参考：<a
href="https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C">https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C</a>。</p>
<h1 id="the-a64-instruction-set">2. The A64 instruction set</h1>
<p>尽管大多数应用级程序员在日常工作中不需要频繁编写汇编代码，但在某些情况下，了解汇编语言仍然具有重要价值。汇编代码在需要高度优化的情况下特别有用，例如编写编译器或使用C等高级语言无法直接访问的低级特性时。</p>
<p>在开发引导代码、设备驱动程序或操作系统时，可能需要使用汇编代码。这些领域通常需要对硬件有精细控制，并要求代码执行效率高。在这些情况下，使用汇编语言编写特定代码部分可以提高性能，并提供对硬件资源的低级访问能力。</p>
<p>此外，在调试C程序时，理解汇编代码变得至关重要。分析汇编指令与相应的C语句之间的映射有助于识别问题并优化代码。能够阅读汇编代码可以增强程序员理解和排查复杂软件行为的能力。</p>
<p>虽然汇编语言对大多数程序员来说不是主要工具，但在性能、低级控制和调试效率至关重要的专门领域中，汇编语言的重要性凸显出来。</p>
<h2 id="instruction-mnemonics-指令助记符">Instruction mnemonics /
指令助记符</h2>
<p>A64汇编语言中使用了指令助记符的重载，根据操作数寄存器名称的不同形式来区分不同的指令。例如，下面的ADD指令具有不同的编码，但您只需要记住一个助记符，汇编器会根据操作数自动选择正确的编码。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD W0, W1, W2             // 添加32位寄存器</span><br><span class="line"></span><br><span class="line">ADD X0, X1, X2             // 添加64位寄存器</span><br><span class="line"></span><br><span class="line">ADD X0, X1, W2, SXTW       // 将符号扩展的32位寄存器添加到64位扩展寄存器</span><br><span class="line"></span><br><span class="line">ADD X0, X1, #42            // 添加立即数到64位寄存器</span><br><span class="line"></span><br><span class="line">ADD V0.8H, V1.8H, V2.8H    // NEON中的16位逐个通道添加，共8个通道</span><br></pre></td></tr></table></figure></p>
<h2 id="data-processing-instructions-数据处理指令">Data processing
instructions / 数据处理指令</h2>
<p>数据处理指令是处理器的基本算术和逻辑操作，操作的对象是通用寄存器中的值，或者一个寄存器和一个立即值。乘法和除法指令可以看作是这些指令的特殊情况。</p>
<p>数据处理指令大多使用一个目标寄存器和两个源操作数。一般格式可以认为是指令，后面是操作数，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Instruction Rd, Rn, Operand2</span><br></pre></td></tr></table></figure>
<p>第二个操作数可以是一个寄存器、一个修改后的寄存器或一个立即值。使用 R
表示它可以是 X 寄存器或 W 寄存器。</p>
<p>数据处理操作包括：</p>
<ul>
<li>算术和逻辑操作。</li>
<li>移动和移位操作。</li>
<li>符号扩展和零扩展指令。</li>
<li>位和位域操作。</li>
<li>有条件的比较和数据处理操作。</li>
</ul>
<h2 id="memory-access-instructions-访存指令">Memory access instructions
/ 访存指令</h2>
<p>和之前的所有ARM处理器一样，ARMv8架构也是一种加载/存储（Load/Store）架构。这意味着没有数据处理指令直接在内存中操作数据。数据首先必须加载到寄存器中，进行修改，然后再存储到内存中。程序必须指定一个地址、要传输的数据大小以及一个源或目标寄存器。还有其他的加载和存储指令提供了进一步的选项，比如非临时的加载/存储、加载/存储互斥和获取/释放。</p>
<p>内存指令可以以非对齐的方式访问普通内存（参见<a
href="https://developer.arm.com/documentation/den0024/a/Memory-Ordering?lang=en">内存排序</a>）。但这在独占访问、加载获取或存储释放变体中是不支持的。如果不希望进行非对齐访问，可以配置为出错。</p>
<h3
id="specifying-the-address-for-a-load-or-store-instruction">Specifying
the address for a Load or Store instruction</h3>
<p>在A64中，用于加载（Load）或存储（Store）指令的地址指定方式与A32和T32类似。虽然存在一些额外的限制和新特性，但对于熟悉A32或T32的人来说，A64提供的地址指定方式应该不会让人感到意外。</p>
<p>在A64中，地址操作数的基础寄存器必须始终是一个X寄存器。然而，有几条指令支持零扩展（zero-extension）或符号扩展（sign-extension），以便可以将32位偏移量作为W寄存器提供。</p>
<h4 id="a.-写回修饰符writeback-modifier">a. 写回修饰符（Writeback
Modifier）（!）</h4>
<p>在ARM汇编语言中，<code>STP</code>（Store
Pair）指令的尾部的感叹号（!）是一个存储修饰符，称为写回修饰符（Writeback
Modifier）。</p>
<p><code>STP</code>指令用于将一对寄存器的数据存储到内存中。写回修饰符（!）用于指示指令是否应该将存储操作后的更新地址写回到基地址寄存器。如果使用了感叹号（!），则表示在存储数据后，将基地址寄存器进行更新，以便指向下一个存储操作的地址。</p>
<p>以下是一个示例，展示了带有写回修饰符（!）的<code>STP</code>指令的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STP X0, X1, [SP, #16]!</span><br></pre></td></tr></table></figure>
<p>上述指令将X0和X1寄存器的数据存储到内存地址为(SP +
16)的位置。同时，由于感叹号（!）的存在，指令执行后，SP寄存器的值会被更新，指向下一个存储操作的地址。</p>
<p>需要注意的是，如果不使用写回修饰符（!），则基地址寄存器的值不会被修改，即不会进行写回操作。这样，下一次的存储操作将使用原始的基地址进行。</p>
<p>写回修饰符（!）的使用可以方便地在一条指令中实现连续的存储操作，同时更新基地址寄存器，而无需额外的指令来更新寄存器的值。</p>
<h4 id="b.-offset-modes">b. Offset modes</h4>
<ol type="1">
<li>有一个64位的基址寄存器（base register）</li>
<li>将一个立即数 / 寄存器值 /
修改后的寄存器值加到64位的基址寄存器上，这个加上的数就是offset</li>
<li>eg: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR X0, [X1, X2, LSL #3] // LSL和#3之间没有逗号</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>load from [X1 + (X2 &lt;&lt; 3)]</li>
<li>lsl : logic shift left</li>
</ul>
<h4 id="c.-index-modes">c. Index modes</h4>
<p>索引模式（Index modes）与偏移模式（Offset
modes）类似，但它们还会更新基础寄存器。其语法与A32和T32相同，但操作的集合更为限制。通常，只能为索引模式提供立即偏移量（immediate
offsets）。</p>
<p>索引模式有两个变体：前索引模式（pre-index
modes）在访问内存之前应用偏移量，而后索引模式（post-index
modes）在访问内存之后应用偏移量。</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Example instruction</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>LDR X0, [X1, #8]!</td>
<td>Pre-index: Update X1 first (to X1 + #8), then load from the new
address</td>
</tr>
<tr class="even">
<td>LDR X0, [X1], #8</td>
<td>Post-index: Load from the unmodified address in X1 first, then
update X1 (to X1 + #8)</td>
</tr>
<tr class="odd">
<td>STP X0, X1, [SP, #-16]!</td>
<td>Push X0 and X1 to the stack. sp is modified</td>
</tr>
<tr class="even">
<td>LDP X0, X1, [SP], #16</td>
<td>Pop X0 and X1 off the stack. sp is modified</td>
</tr>
</tbody>
</table>
<p>These options map cleanly onto some common C operations:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A C example showing accesses that a compiler is likely to generate.</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">example_strcpy</span><span class="params">(<span class="type">char</span> * dst, <span class="type">const</span> <span class="type">char</span> * src)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    c = *(src++);             <span class="comment">// LDRB W2, [X1], #1</span></span><br><span class="line">    *(dst++) = c;             <span class="comment">// STRB W2, [X0], #1</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (c != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="pc-relative-modes-load-literal">PC-relative modes
(load-literal)</h4>
<p>A64引入了另一种专门用于访问<strong>字面池（literal
pools）</strong>的寻址模式，称为PC相对模式（PC-relative
modes）。字面池是嵌入在指令流中的数据块。这些池不会被执行，但可以通过PC相对内存地址从周围的代码中访问它们的数据。字面池通常用于编码无法适应简单的立即数移动指令的常量值。</p>
<p>在A32和T32中，PC可以像通用寄存器一样读取，因此只需将PC指定为基础寄存器即可访问字面池。</p>
<p>在A64中，PC通常是不可访问的，但是有一种特殊的寻址模式（仅适用于加载指令）可以访问PC相对地址。这种专用的寻址模式的范围比A32和T32中的PC相对加载要大得多，因此字面池可以被更稀疏地定位。</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Example instruction</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>LDR W0, &lt;label&gt;</td>
<td>Load 4 bytes from &lt;label&gt; into W0</td>
</tr>
<tr class="even">
<td>LDR X0, &lt;label&gt;</td>
<td>Load 8 bytes from &lt;label&gt; into X0</td>
</tr>
<tr class="odd">
<td>LDRSW X0, &lt;label&gt;</td>
<td>Load 4 bytes from &lt;label&gt; and sign-extend into X0</td>
</tr>
<tr class="even">
<td>LDR S0, &lt;label&gt;</td>
<td>Load 4 bytes from &lt;label&gt; into S0</td>
</tr>
<tr class="odd">
<td>LDR D0, &lt;label&gt;</td>
<td>Load 8 bytes from &lt;label&gt; into D0</td>
</tr>
<tr class="even">
<td>LDR Q0, &lt;label&gt;</td>
<td>Load 16 bytes from &lt;label&gt; into Q0</td>
</tr>
</tbody>
</table>
<p>Note: &lt;label&gt; must be 4-byte-aligned for all variants.</p>
<h3 id="unprivileged-access">Unprivileged access</h3>
<p>A64
LDTR和STTR指令执行非特权的加载（Load）或存储（Store）操作（请参阅ARMv8-A架构参考手册中的LDTR和STTR）：
- 在EL0、EL2或EL3级别下，它们的行为类似于普通的加载或存储指令。 -
当在EL1级别下执行时，它们的行为类似于在EL0特权级别下执行。</p>
<p>这些指令与A32 LDRT和STRT指令是等效的。</p>
<h3
id="non-temporal-load-and-store-pair-非暂态non-temporal加载和存储">Non-temporal
load and store pair / 非暂态（non-temporal）加载和存储</h3>
<p>在ARMv8架构中引入了非暂态（non-temporal）加载和存储的概念。这些概念体现在LDNP和STNP指令中，它们用于读取或写入一对寄存器值。同时，它们向内存系统发出提示，表明对该数据进行缓存是无益的。这个提示并不禁止内存系统的活动，比如地址的缓存、预加载或者聚集。然而，它表明进行缓存不太可能提高性能。一个典型的用例可能是流式数据处理，但需要注意的是，有效地使用这些指令需要针对具体微架构的特定方法。</p>
<p>非暂态加载和存储放宽了内存排序要求。在上述例子中，LDNP指令可能在前面的LDR指令之前执行，这可能导致从不确定的X0地址读取数据。
For example: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR X0, [X3]</span><br><span class="line">LDNP X2, X1, [X0]      // Xo may not be loaded when the instruction executes!</span><br></pre></td></tr></table></figure> 为了纠正上述问题，需要使用显式的加载屏障：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR X0, [X3]</span><br><span class="line">DMB nshld</span><br><span class="line">LDNP X2, X1, [X0]</span><br></pre></td></tr></table></figure>
通过引入加载屏障，可以确保在LDNP指令执行之前先加载X0的值，从而避免了不确定的读取。这样，非暂态加载和存储指令才能够在程序中被正确使用。</p>
<h3 id="memory-access-atomicity">Memory access atomicity</h3>
<p>对齐的内存访问使用单个通用寄存器可以保证原子性。使用对齐的内存地址进行的一对通用寄存器的加载对（load
pair）和存储对（store
pair）指令可以保证作为两个独立的原子访问。非对齐访问不是原子的，因为通常需要进行两次独立的访问。此外，浮点数和SIMD（单指令多数据）内存访问不能保证原子性。</p>
<h3 id="memory-barrier-and-fence-instructions">Memory barrier and fence
instructions</h3>
<p>ARMv7和ARMv8都支持不同类型的内存屏障操作。这些操作在<a
href="https://developer.arm.com/documentation/den0024/a/Memory-Ordering?lang=en">Memory
Ordering</a>中有更详细的描述：</p>
<p>数据内存屏障（Data Memory
Barrier，DMB）：在继续执行后续访问之前，强制使程序顺序中较早的所有内存访问对全局可见。</p>
<p>数据同步屏障（Data Synchronization
Barrier，DSB）：在程序继续执行之前，完成所有待处理的加载和存储、缓存维护指令以及TLB维护指令。DSB的行为类似于DMB，但具有附加属性。</p>
<p>指令同步屏障（Instruction Synchronization
Barrier，ISB）：该指令刷新CPU流水线和预取缓冲区，导致ISB之后的指令从缓存或内存中获取（或重新获取）。</p>
<p>ARMv8引入了单向栅栏（one-sided fences），这与Release
Consistency模型相关。这些栅栏被称为Load-Acquire（LDAR）和Store-Release（STLR），它们是基于地址的同步原语（见<a
href="https://developer.arm.com/documentation/den0024/a/Memory-Ordering?lang=en">One-way
barriers</a>）。这两个操作可以配对形成一个完整的栅栏。这些指令仅支持基址寄存器寻址，不支持偏移量或其他类型的索引寻址。</p>
<h3 id="synchronization-primitives">Synchronization primitives</h3>
<p>ARMv7-A和ARMv8-A架构都支持独占内存访问。在A64中，这是通过Load/Store
exclusive（LDXR/STXR）指令对实现的。</p>
<p>LDXR指令从内存地址加载一个值，并尝试在该地址上默默地获取独占锁。然后，Store-Exclusive指令只有在成功获取并持有锁时才会将新值写入该位置。LDXR/STXR配对用于构建标准的同步原语，例如自旋锁。还提供了一对配对的LDXRP和STXRP指令，以允许原子更新跨越两个寄存器的位置。可用的选项包括字节、半字、字和双字。与Load
Acquire/Store
Release配对一样，只支持基址寄存器寻址，没有任何偏移量。</p>
<p>CLREX指令用于清除监视器，但与ARMv7不同，异常的进入或返回也会清除监视器。监视器也可能被意外地清除，例如由于缓存逐出或与应用程序无直接关联的其他原因。在配对的LDXR和STXR指令之间，软件必须避免任何显式的内存访问、系统控制寄存器更新或缓存维护指令。</p>
<p>此外，还有一对独占的Load Acquire/Store
Release指令，称为LDAXR和STLXR。详见<a
href="https://developer.arm.com/documentation/den0024/a/Multi-core-processors/Multi-processing-systems/Synchronization?lang=en">同步</a>部分。</p>
<h2 id="flow-control">Flow control</h2>
<p>A64指令集提供了多种不同类型的分支指令（参见表<a
href="https://developer.arm.com/documentation/den0024/a/The-A64-instruction-set/Flow-control?lang=en">6.12</a>）。对于简单的相对分支，即从当前地址偏移的分支，使用B指令。<em>无条件的简单相对分支可以向前或向后分支到距离当前程序计数器位置最多128MB的位置</em>。<em>有条件的简单相对分支，在B后附加条件码，其范围较小，为±1MB</em>。</p>
<p>对于需要将返回地址存储在链接寄存器（X30）中的子程序调用，使用BL指令。它没有条件版本。<em>BL的行为类似于B指令，同时额外存储返回地址，即BL指令后一条指令的地址，到寄存器X30中</em>。</p>
<h2 id="system-control-and-other-instructions-系统控制和其他指令">System
control and other instructions / 系统控制和其他指令</h2>
<p>A64指令集包含与以下内容相关的指令： - 异常处理。 - 系统寄存器访问。 -
调试。 - 提示指令，在许多系统中具有电源管理应用。</p>
<h3 id="exception-handling-instructions">Exception handling
instructions</h3>
<p>有三条异常处理指令，其目的是引发异常。这些指令用于调用在操作系统中运行在更高异常级别的代码（EL1），虚拟机监控程序（EL2）或安全监控程序（EL3）：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SVC #imm16   // 监管者调用，允许应用程序调用内核（EL1）。</span><br><span class="line"></span><br><span class="line">HVC #imm16   // 虚拟机监控程序调用，允许操作系统代码调用虚拟机监控程序（EL2）。</span><br><span class="line"></span><br><span class="line">SMC #imm16   // 安全监控程序调用，允许操作系统或虚拟机监控程序调用安全监控程序（EL3）。</span><br></pre></td></tr></table></figure>
立即值将在异常综合寄存器中提供给处理程序。这与ARMv7不同，ARMv7需要通过读取调用指令的操作码来确定立即值。详细信息请参阅<a
href="https://developer.arm.com/documentation/den0024/a/AArch64-Exception-Handling?lang=en">AArch64异常处理</a>。</p>
<p>要从异常返回，请使用ERET指令。此指令通过将SPSR_ELn复制到PSTATE并跳转到ELR_ELn中保存的返回地址来恢复处理器状态。</p>
]]></content>
      <categories>
        <category>Qemu</category>
      </categories>
  </entry>
  <entry>
    <title>C++并发编程</title>
    <url>/zyhjy/2023/06/04/C++%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="基础知识">基础知识</h1>
<h2 id="并发与并行">并发与并行</h2>
<p>并发（Concurrent）与并行（Parallel）都是很常见的术语。 - Concurrent :
two queues one coffee machine - Parallel : two queues one coffee
machines ## 进程与线程 -
进程（英语：process），是指计算机中已运行的程序。进程为曾经是分时系统的基本运作单位。在面向进程设计的系统（如早期的UNIX，Linux
2.4及更早的版本）中，进程是程序的基本执行实体；</p>
<ul>
<li>线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。
## 并发系统的性能 阿姆达尔定律<a
href="https://en.wikipedia.org/wiki/Amdahl%27s_law">Amdahl's
law</a>。简单来说：我们想要预先意识到那些任务是可以并行的，那些是无法并行的。只有明确了任务的性质，才能有的放矢的进行优化。这个定律告诉了我们将系统并行之后性能收益的上限。</li>
</ul>
<span id="more"></span>
<h1 id="c并发编程api">C++并发编程API</h1>
<p><code>thread</code>可以和<code>callable</code>类型一起工作，因此如果你熟悉<code>lambda表达式</code>，你可以直接用它来写线程的逻辑，像这样：
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">thread <span class="title">t</span><span class="params">([] &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">  cout &lt;&lt; <span class="string">&quot;Hello World from lambda thread.&quot;</span> &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">t.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure> or: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Welcome to &quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">  <span class="function">thread <span class="title">t</span><span class="params">(hello, <span class="string">&quot;zyh&quot;</span>)</span></span>;</span><br><span class="line">  t.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure> ## join与detach |API |说明| |-|-| |join
|等待线程完成其执行| |detach |允许线程独立执行|</p>
<p>必须在thread对象销毁之前决定。如果在<code>thread</code>对象销毁的时候我们还没有做决定，则<code>thread</code>对象在析构函数出将调用<code>std::terminate()</code>从而导致我们的进程异常退出。
-
<code>join</code>：调用此接口时，当前线程会一直阻塞，直到目标线程执行完成
-
<code>detach</code>：<code>detach</code>是让目标线程成为守护线程（<code>daemon threads</code>）。<code>detach</code>之后，无法再与之通信。</p>
<p>可以通过<code>joinable()</code>接口查询是否可以对它们进行<code>join</code>或者<code>detach</code>。
## 管理当前线程 |API |说明| |-|-| |yield
|让出处理器，重新调度各执行线程| |get_id |返回当前线程的线程id|
|sleep_for | 使当前线程的执行停止指定的时间段| |sleep_until |
使当前线程的执行停止直到指定的时间点|</p>
<p>上面是一些在线程内部使用的API，它们用来对当前线程做一些控制。</p>
<ul>
<li><p><code>yield</code>
通常用在自己的主要任务已经完成的时候，此时希望让出处理器给其他任务使用。暂时放弃当前线程的执行，并会将线程放入就绪状态，以便其他线程有机会执行。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!condition) &#123;</span><br><span class="line">    <span class="comment">// 执行一些操作</span></span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>get_id</code>
返回当前线程的id，可以以此来标识不同的线程。</p></li>
<li><p><code>sleep_for</code> 是让当前线程停止一段时间。</p></li>
<li><p><code>sleep_until</code>
和<code>sleep_for</code>类似，但是是以具体的时间点为参数。这两个API都以<a
href="https://en.cppreference.com/w/cpp/header/chrono">chrono</a>
API为基础, 见<code>&lt;chrono&gt;</code>。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h2 id="一次调用">一次调用</h2>
<table>
<thead>
<tr class="header">
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>call_once</td>
<td>即便在多线程环境下，也能保证只调用某个函数一次</td>
</tr>
<tr class="even">
<td>once_flag</td>
<td>与call_once配合使用</td>
</tr>
</tbody>
</table>
<p>在一些情况下，我们有些任务需要执行一次，并且我们只希望它执行一次，例如资源的初始化任务。这个时候就可以用到上面的接口。这个接口会保证，即便在多线程的环境下，相应的函数也只会调用一次。</p>
<p>下面就是一个示例：有三个线程都会使用init函数，但是只会有一个线程真正执行它。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Initialing...&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// Do something...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(once_flag* flag)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">call_once</span>(*flag, init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  once_flag flag;</span><br><span class="line"></span><br><span class="line">  <span class="function">thread <span class="title">t1</span><span class="params">(worker, &amp;flag)</span></span>;</span><br><span class="line">  <span class="function">thread <span class="title">t2</span><span class="params">(worker, &amp;flag)</span></span>;</span><br><span class="line">  <span class="function">thread <span class="title">t3</span><span class="params">(worker, &amp;flag)</span></span>;</span><br><span class="line"></span><br><span class="line">  t1.<span class="built_in">join</span>();</span><br><span class="line">  t2.<span class="built_in">join</span>();</span><br><span class="line">  t3.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="threadhardware_concurrency">thread::hardware_concurrency()</h2>
<p>可以获取到当前硬件支持多少个线程并行执行</p>
<h2 id="互斥体与锁">互斥体与锁</h2>
<h3 id="mutex">mutex</h3>
<p>是<strong>mu</strong>tual
<strong>ex</strong>clusion（互斥）的简写。</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>mutex</td>
<td>提供基本互斥设施</td>
</tr>
<tr class="even">
<td>timed_mutex</td>
<td>提供互斥设施，带有超时功能</td>
</tr>
<tr class="odd">
<td>recursive_mutex</td>
<td>提供能被同一线程递归锁定的互斥设施</td>
</tr>
<tr class="even">
<td>recursive_timed_mutex</td>
<td>提供能被同一线程递归锁定的互斥设施，带有超时功能</td>
</tr>
<tr class="odd">
<td>shared_timed_mutex</td>
<td>提供共享互斥设施并带有超时功能</td>
</tr>
<tr class="even">
<td>shared_mutex</td>
<td>提供共享互斥设施</td>
</tr>
</tbody>
</table>
<p>这些类都提供了下面三个方法，并且它们的功能是一样的:</p>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>lock</td>
<td>锁定互斥体，如果不可用，则阻塞</td>
</tr>
<tr class="even">
<td>try_lock</td>
<td>尝试锁定互斥体，如果不可用，直接返回</td>
</tr>
<tr class="odd">
<td>unlock</td>
<td>解锁互斥体</td>
</tr>
</tbody>
</table>
<p>在这些基础功能之上，其他的类分别在下面三个方面进行了扩展： -
超时：<code>timed_mutex</code>，<code>recursive_timed_mutex</code>，<code>shared_timed_mutex</code>的名称都带有<code>timed</code>，这意味着它们都支持超时功能。它们都提供了<code>try_lock_for</code>和<code>try_lock_until</code>方法，这两个方法分别可以指定超时的时间长度和时间点。如果在超时的时间范围内没有能获取到锁，则直接返回，不再继续等待。
-
可重入：<code>recursive_mutex</code>和<code>recursive_timed_mutex</code>的名称都带有<code>recursive</code>。可重入或者叫做可递归，是指在同一个线程中，同一把锁可以锁定多次。这就避免了一些不必要的死锁。
-
共享：<code>shared_timed_mutex</code>和<code>shared_mutex</code>提供了共享功能。对于这类互斥体，实际上是提供了两把锁：一把是共享锁，一把是互斥锁。共享锁通常用在读者写者模型上。</p>
<pre><code>| 方法 | 说明 |
|-|-|
|lock_shared    | 获取互斥体的共享锁，如果无法获取则阻塞|
|try_lock_shared    | 尝试获取共享锁，如果不可用，直接返回|
|unlock_shared  | 解锁共享锁|</code></pre>
<h3 id="通用锁定算法">通用锁定算法</h3>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>lock</td>
<td>锁定指定的互斥体，若任何一个不可用则阻塞</td>
</tr>
<tr class="even">
<td>try_lock</td>
<td>试图通过重复调用 try_lock 获得互斥体的所有权</td>
</tr>
</tbody>
</table>
<p>这两个方法对所有的锁进行排序，每次一定要按照顺序来获取锁，不允许乱序；避免了死锁。</p>
<h3 id="通用互斥管理">通用互斥管理</h3>
<table>
<thead>
<tr class="header">
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>｜ lock_guard ｜ 实现严格基于作用域的互斥体所有权包装器 ｜ ｜
unique_lock ｜ 实现可移动的互斥体所有权包装器 ｜ ｜ shared_lock ｜
实现可移动的共享互斥体所有权封装器 ｜ ｜ scoped_lock ｜
用于多个互斥体的免死锁 RAII 封装器 ｜</p>
<p>这些类都提供了下面三个方法，并且它们的功能是一样的:</p>
<table>
<thead>
<tr class="header">
<th>锁定策略</th>
<th>说明</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>｜defer_lock ｜ 类型为 defer_lock_t，不获得互斥的所有权｜
｜try_to_lock ｜ 类型为try_to_lock_t，尝试获得互斥的所有权而不阻塞｜
｜adopt_lock ｜ 类型为adopt_lock_t，假设调用方已拥有互斥的所有权｜</p>
<p>eg： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lock</span>(*accountA-&gt;<span class="built_in">getLock</span>(), *accountB-&gt;<span class="built_in">getLock</span>());</span><br><span class="line"><span class="function">lock_guard <span class="title">lockA</span><span class="params">(*accountA-&gt;getLock(), adopt_lock)</span></span>;</span><br><span class="line"><span class="function">lock_guard <span class="title">lockB</span><span class="params">(*accountB-&gt;getLock(), adopt_lock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 如果使用unique_lock这三行代码还有一种等价的写法：</span></span><br><span class="line"><span class="function">unique_lock <span class="title">lockA</span><span class="params">(*accountA-&gt;getLock(), defer_lock)</span></span>;</span><br><span class="line"><span class="function">unique_lock <span class="title">lockB</span><span class="params">(*accountB-&gt;getLock(), defer_lock)</span></span>;</span><br><span class="line"><span class="built_in">lock</span>(*accountA-&gt;<span class="built_in">getLock</span>(), *accountB-&gt;<span class="built_in">getLock</span>());</span><br><span class="line"><span class="comment">// 请注意这里lock方法的调用位置。这里先定义unique_lock指定了defer_lock，因此实际没有锁定互斥体，而是到第三行才进行锁定。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 借助scoped_lock，我们可以将三行代码合成一行，这种写法也是等价的。</span></span><br><span class="line"><span class="function">scoped_lock <span class="title">lockAll</span><span class="params">(*accountA-&gt;getLock(), *accountB-&gt;getLock())</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="条件变量">条件变量</h3>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>condition_variable</td>
<td>提供与 std::unique_lock 关联的条件变量</td>
</tr>
<tr class="even">
<td>condition_variable_any</td>
<td>提供与任何锁类型关联的条件变量</td>
</tr>
<tr class="odd">
<td>notify_all_at_thread_exit</td>
<td>安排到在此线程完全结束时对 notify_all 的调用</td>
</tr>
<tr class="even">
<td>cv_status</td>
<td>列出条件变量上定时等待的可能结果</td>
</tr>
</tbody>
</table>
<p>eg: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">changeMoney</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="function">unique_lock <span class="title">lock</span><span class="params">(mMoneyLock)</span></span>; <span class="comment">// ②</span></span><br><span class="line">    mConditionVar.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>, amount] &#123; <span class="comment">// ③</span></span><br><span class="line">      <span class="keyword">return</span> mMoney + amount &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    mMoney += amount;</span><br><span class="line">    mConditionVar.<span class="built_in">notify_all</span>(); <span class="comment">// ④</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="type">double</span> mMoney;</span><br><span class="line">  mutex mMoneyLock;</span><br><span class="line">  condition_variable mConditionVar; <span class="comment">// ①</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 1. 这里声明了一个条件变量，用来在多个线程之间协作。
2.
这里使用的是<code>unique_lock</code>，这是为了与条件变量相配合。因为条件变量会解锁和重新锁定互斥体。
3.
这里是比较重要的一个地方：通过条件变量进行等待。此时：会通过后面的lambda表达式判断条件是否满足。如果满足则继续；如果不满足，则此处会解锁互斥体，并让当前线程等待。
4.
此处也很重要。当金额发生变动之后，我们需要通知所有在条件变量上等待的其他线程。此时所有调用<code>wait</code>线程都会再次唤醒，然后尝试获取锁（当然，只有一个能获取到）并再次判断条件是否满足。除了<code>notify_all</code>还有<code>notify_one</code>，它只通知一个等待的线程。wait和notify就构成了线程间互相协作的工具。</p>
<h2 id="future">future</h2>
<p>都位于<future>头文件中。 |API |说明| |-|-| | async |
异步运行一个函数，并返回保有其结果的std::future | | future |
等待被异步设置的值 | | packaged_task |
打包一个函数，存储其返回值以进行异步获取 | | promise |
存储一个值以进行异步获取 | | shared_future |
等待被异步设置的值（可能为其他 future 所引用） |</p>
<h3 id="async">async</h3>
<ol type="1">
<li>async是启动一个新的线程，还是以同步的方式（不启动新的线程）运行任务，由具体的编译器决定。</li>
<li>如果希望一定要以新的线程来异步执行任务，可以通过launch::async来明确说明。launch中有两个常量：</li>
</ol>
<ul>
<li>async：运行新线程，以异步执行任务。</li>
<li>deferred：调用方线程上第一次请求其结果时才执行任务，即惰性求值。</li>
</ul>
<ol start="3" type="1">
<li>返回一个<code>future</code>对象,用来存储异步任务的执行结果</li>
</ol>
<p>eg: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f2 = <span class="built_in">async</span>(launch::async, [&amp;result]() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= MAX; i++) &#123;</span><br><span class="line">    result += <span class="built_in">sqrt</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">f2.<span class="built_in">wait</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">Worker <span class="title">w</span><span class="params">(<span class="number">0</span>, MAX)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> f3 = <span class="built_in">async</span>(&amp;Worker::work, &amp;w); <span class="comment">// 面向对象</span></span><br><span class="line">f3.<span class="built_in">wait</span>();</span><br></pre></td></tr></table></figure> ### packaged_task
<code>packaged_task</code>绑定到一个函数或者可调用对象上。当它被调用时，它就会调用其绑定的函数或者可调用对象。并且，可以通过与之相关联的<code>future</code>来获取任务的结果。调度程序只需要处理<code>packaged_task</code>，而非各个函数。</p>
<p><code>packaged_task</code>对象是一个可调用对象，它可以被封装成一个<code>std::fucntion</code>，或者作为线程函数传递给<code>std::thread</code>，或者直接调用。</p>
<p>eg: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">concurrent_worker</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> </span>&#123;</span><br><span class="line">  <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;future&lt;<span class="type">double</span>&gt;&gt; results; <span class="comment">// 创建一个集合来存储future对象。我们将用它来获取任务的结果。</span></span><br><span class="line">...</span><br><span class="line"><span class="function">packaged_task&lt;<span class="title">double</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">(concurrent_worker)</span></span>;</span><br><span class="line">results.<span class="built_in">push_back</span>(task.<span class="built_in">get_future</span>());  <span class="comment">// 通过一个新的线程来执行任务，并传入需要的参数。</span></span><br><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(std::move(task), min, range)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>可以借助于packaged_task将任务组装成队列，然后通过线程池的方式进行调度</p>
<h3 id="promise与future">promise与future</h3>
<p>在上面的例子中，<code>concurrent_task</code>的结果是通过<code>return</code>返回的。但在一些时候，我们可能不能这么做：在得到任务结果之后，可能还有一些事情需要继续处理，例如清理工作。</p>
<p>这个时候，就可以将<code>promise</code>与<code>future</code>配对使用。这样就可以将返回结果和任务结束两个事情分开。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">concurrent_task</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max, promise&lt;<span class="type">double</span>&gt;* result)</span> </span>&#123; <span class="comment">// ①</span></span><br><span class="line">  ...</span><br><span class="line">  result-&gt;<span class="built_in">set_value</span>(sum); <span class="comment">// ②</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  promise&lt;<span class="type">double</span>&gt; sum; <span class="comment">// ③</span></span><br><span class="line">  <span class="built_in">concurrent_task</span>(<span class="number">0</span>, MAX, &amp;sum);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; sum.<span class="built_in">get_future</span>().<span class="built_in">get</span>() &lt;&lt; endl; <span class="comment">// ④</span></span><br></pre></td></tr></table></figure>
<ol type="1">
<li><code>concurrent_task</code>不再直接返回计算结果，而是增加了一个<code>promise</code>对象来存放结果。</li>
<li>在任务计算完成之后，将总结过设置到<code>promise</code>对象上。一旦这里调用了<code>set_value</code>，其相关联的<code>future</code>对象就会就绪。</li>
<li>这里创建一个<code>promise</code>来存放结果，并以指针的形式传递进<code>concurrent_task</code>中。</li>
<li>通过<code>sum.get_future().get()</code>来获取结果。</li>
</ol>
<p>需要注意的是，<code>future</code>对象只有被一个线程获取值。并且在调用<code>get()</code>之后，就没有可以获取的值了。如果从多个线程调用<code>get()</code>会出现数据竞争，其结果是未定义的。</p>
<p>如果真的需要在多个线程中获取<code>future</code>的结果，可以使用<code>shared_future</code>。</p>
<h3 id="总结">总结</h3>
<p>这三者分别工作在不同的抽象层次上。</p>
<ol type="1">
<li>async层次最高，你只需要给它提供一个函数，它就会返回一个future对象。接下来就只需等待结果了。</li>
<li>packaged_task次之，你在创建了packaged_task后，还要创建一个thread，并把packaged_task交给它执行。</li>
<li>promise就最低了。在创建了thread之后，你还要把对应的promise作为参数传入。这还没完，别忘了在函数中手动设置promise的值。</li>
</ol>
<h2 id="并行算法">并行算法</h2>
<p>从C++17开始。<algorithm>和<numeric>
头文件的中的很多算法都添加了一个新的参数：<code>sequenced_policy</code>。</p>
<p>借助这个参数，开发者可以直接使用这些算法的并行版本，不用再自己创建并发系统和划分数据来调度这些算法。</p>
<p>sequenced_policy可能的取值有三种，它们的说明如下：</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th>变量</th>
<th>类型</th>
<th>C++版本</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>execution::seq</td>
<td>execution::sequenced_policy</td>
<td>C++17</td>
<td>要求并行算法的执行可以不并行化</td>
</tr>
<tr class="even">
<td>execution::par</td>
<td>execution::parallel_policy</td>
<td>C++17</td>
<td>指示并行算法的执行可以并行化</td>
</tr>
<tr class="odd">
<td>execution::par_unseq</td>
<td>execution::parallel_unsequenced_policy</td>
<td>C++17</td>
<td>指示并行算法的执行可以并行化、向量化</td>
</tr>
</tbody>
</table>
<p>注意：想要编译这部分代码，你需要使用gcc
9.0或更高版本，同时还需要安装Intel Threading Building Blocks。</p>
<p>eg: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(execution::seq, copy1.<span class="built_in">begin</span>(), copy1.<span class="built_in">end</span>()); <span class="comment">// ④</span></span><br><span class="line"><span class="built_in">sort</span>(execution::par, copy2.<span class="built_in">begin</span>(),copy2.<span class="built_in">end</span>()); <span class="comment">// ⑥</span></span><br><span class="line"><span class="built_in">sort</span>(execution::par_unseq, copy2.<span class="built_in">begin</span>(),copy2.<span class="built_in">end</span>()); <span class="comment">// ⑦</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/zyhjy/2023/06/06/gmock/</url>
    <content><![CDATA[<p>DISABLED_可以禁用测试 TEST(StarterTest, DISABLED_TrieNodeInsertTest)
{</p>
]]></content>
  </entry>
  <entry>
    <title>C++并发编程</title>
    <url>/zyhjy/2023/06/04/C++%E4%BE%AF%E6%8D%B7STL%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="section"></h1>
<p>标准库 &gt; STL</p>
<h1 id="section-1"></h1>
<p>STL六大组件</p>
<p>allocator Adapters con it func container Iterator Alogrithms
Functors</p>
<h1 id="pointer-rebind的目的是什么">pointer rebind的目的是什么</h1>
<p>在stl的list中有如下代码： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__list_imp</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">typedef</span> __list_node_base&lt;value_type, __void_pointer&gt;            __node_base;</span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;value_type, __void_pointer&gt;                 __node;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里为什么要在node的类型参数中增加void pointer？</p>
<p>并且在实际使用的时候 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_VoidPtr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_node_pointer_traits</span> &#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __rebind_pointer&lt;_VoidPtr, __list_node&lt;_Tp, _VoidPtr&gt; &gt;::type</span><br><span class="line">        __node_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __rebind_pointer&lt;_VoidPtr, __list_node_base&lt;_Tp, _VoidPtr&gt; &gt;::type</span><br><span class="line">        __base_pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 将void通过rebind转化成了
__list_node&lt;_Tp, _VoidPtr&gt;的指针类型</p>
<p>为何多此一举，不直接使用Nodeptr*呢</p>
<h2 id="section-2"></h2>
<p>The answer to this question comes from allocators, too. Let's take a
look at how _Rebind_pointer_t is defined: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ptr</span>, <span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">using</span> _Rebind_pointer_t = <span class="keyword">typename</span> pointer_traits&lt;_Ptr&gt;::<span class="keyword">template</span> rebind&lt;_Ty&gt;;</span><br></pre></td></tr></table></figure></p>
<p>That is, we have</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Value_type</span>, <span class="keyword">class</span> <span class="title class_">_Voidptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_List_node</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> _Nodeptr = <span class="keyword">typename</span> pointer_traits&lt;_Voidptr&gt;::<span class="keyword">template</span> rebind&lt;_List_node&gt;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_Voidptr也是不可或缺的，因为不知道_List_node的指针是什么类型，未必是简单的*_List_node可以概括的，所以需要一个基础类型的void指针，以此为基准将_Voidptr转化为_Nodeptr</p>
<p>相当于使用_Voidptr的特化了指针萃取的行为，是必须的</p>
<p>Now let's take a look at how _List_node is used: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> _Node = _List_node&lt;_Ty, <span class="keyword">typename</span> _Alty_traits::void_pointer&gt;;</span><br></pre></td></tr></table></figure>
Effectively, we rebind allocator's void_pointer to _List_node pointer.
This trick is needed to support allocators that use fancy pointers
internally.</p>
<p>One such example can be found in Boost.Interprocess library. It has
boost::interprocess::allocator:</p>
<p>An STL compatible allocator that uses a segment manager as memory
source. The internal pointer type will of the same type (raw, smart) as
<code>typename SegmentManager::void_pointer</code> type. This allows
placing the allocator in shared memory, memory mapped-files, etc...</p>
<p>For example, we can write <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> bi = boost::interprocess;</span><br><span class="line"><span class="keyword">using</span> Allocator = bi::allocator&lt;<span class="type">int</span>, bi::managed_shared_memory::segment_manager&gt;;</span><br><span class="line"><span class="function">std::list&lt;<span class="type">int</span>, Allocator&gt; <span class="title">list</span><span class="params">(<span class="comment">/* allocator object */</span>)</span></span>;</span><br></pre></td></tr></table></figure> Now
<code>std::allocator_traits&lt;decltype(list)::allocator_type&gt;::void_pointer</code>
will be not <code>void*</code> as with default allocator, but
<code>boost::interprocess::offset_ptr&lt;void, ...&gt;</code>. As a
result, <code>_Nodeptr</code> will be not <code>_Nodeptr*</code>, but
<code>boost::interprocess::offset_ptr&lt;_Nodeptr, ...&gt;</code>.</p>
<p>https://stackoverflow.com/questions/65262899/what-is-the-purpose-of-pointer-rebind</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>STL学习笔记</title>
    <url>/zyhjy/2023/07/29/STL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="stl">STL</h1>
<p>以下内容基于LLVM8的STL实现</p>
<span id="more"></span>
<h2 id="type_traits">type_traits</h2>
<h3 id="remove_reference">remove_reference</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_reference</span> &#123; <span class="keyword">typedef</span> T type; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_reference</span>&lt;T&amp;&gt; &#123; <span class="keyword">typedef</span> T type; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_reference</span>&lt;T&amp;&amp;&gt; &#123; <span class="keyword">typedef</span> T type; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">remove_reference_t</span> = <span class="keyword">typename</span> remove_reference&lt;T&gt;::type;</span><br></pre></td></tr></table></figure>
<h3 id="move">move</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">typedef</span> <span class="keyword">typename</span> remove_reference&lt;T&gt;::type U;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;U&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="forward">forward</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="built_in">static_assert</span>(!std::is_lvalue_reference&lt;T&gt;::value, <span class="string">&quot;can not forward an rvalue as an lvalue&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="swap">swap</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; x, T&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">T <span class="title">t</span><span class="params">(move(y))</span></span>;</span><br><span class="line">   y = <span class="built_in">move</span>(x);</span><br><span class="line">   x = <span class="built_in">move</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="iterator">iterator</h2>
<h3 id="uml">UML</h3>
<p><img src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230721222137395.png" alt="image-20230721222137395" style="zoom: 80%;" /></p>
<p><img src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230721222231452.png" alt="image-20230721222231452" style="zoom:80%;" /></p>
<h3 id="说明">说明</h3>
<ol type="1">
<li><code>iterator_category</code>一共有五种分类：输入迭代器，输出迭代器，单向迭代器，双向迭代器，随机访问迭代器，继承关系如图所示</li>
<li><code>iterator_traits</code>迭代器萃取可以获取类型的特性，若类型为迭代器(通过模板元编程判断<code>has_iterator_category</code>)，则会获得<code>iterator_traits_impl&lt;Iter, true&gt;</code>的<code>typedef</code>:<code>difference_type</code>,<code>type value_type</code>,<code>pointer</code>,
<code>reference</code>,<code>iterator_category</code>;若不满足条件则不会拥有</li>
<li>指针类型也属于迭代器，迭代器对指针类型做了偏特化且分类为随机访问迭代器</li>
</ol>
<h2 id="allocator">allocator</h2>
<ol type="1">
<li>默认的分配器是无状态的，通常为空类</li>
<li>allocator通过分配内存通过new --&gt;&gt; malloc / delete --&gt;&gt;
free完成</li>
<li>allocator还可以完成构造和析构</li>
</ol>
<h2 id="list">list</h2>
<h3 id="uml-1">UML</h3>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230720213243785.png"
alt="image-20230720213243785" />
<figcaption aria-hidden="true">image-20230720213243785</figcaption>
</figure>
<h3 id="说明-1">说明</h3>
<ol type="1">
<li><p><code>list</code>private inheritance <code>list_imp</code> ;
<code>list_node</code> public inheritance
<code>list_node_base</code></p></li>
<li><p><code>list</code>保存了一个<code>list_node_base</code>对象(该对象保存了两个指向<code>list_node_base</code>的指针),以及一个<code>size_t</code>对象用于记录<code>size</code>，在64bit机器上实际为<code>unsigned long</code>(8B),因此<code>sizeof(list&lt;T&gt;) == 24</code></p></li>
<li><p>list可通过<code>list_node_base</code>转型得到<code>list_node</code>来获取value，类似的，迭代器也通过<code>list_node_base</code>构造生成，迭代器的分类是<code>bidirectional_iterator_tag</code></p></li>
</ol>
<h2 id="vector">vector</h2>
<h3 id="uml-2">UML</h3>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230720205921569.png"
alt="image-20230720205921569" />
<figcaption aria-hidden="true">image-20230720205921569</figcaption>
</figure>
<h3 id="说明-2">说明</h3>
<ol type="1">
<li><p><code>vector</code>private inheritance
<code>__vector_base</code></p></li>
<li><p><code>__vector_base</code>protected inheritance
<code>__vector_base_common</code></p></li>
<li><p>allocator一般为空类(size == 0),
<code>__compressed_pair</code>使用<code>EBCO</code>技术优化存储空间，使得<code>sizeof(__compressed_pair&lt;pointer, allocator_type&gt;) == sizeof(pointer)</code></p>
<ol type="1">
<li>EBCO : <strong>E</strong>mpty <strong>B</strong>ase
<strong>C</strong>lass <strong>O</strong>ptimization,
一般以非空类继承空类的方式优化存储空间;因为C++要求类/空类的大小至少为1，但若空类为基类，此时子类的大小不为0，空基类可以看作子类的一部分，不使用额外空间。</li>
</ol></li>
<li><p>vector的iterator实际上是T*类型，迭代器的分类是<code>random_access_iterator_tag</code></p></li>
<li><p>vector的分配的内存每次满了之后会成倍增长，但不会因为元素少而自动收缩；增长序列为0，1，2，4，8，16...；每次增长都会根据元素的实际情况调用'move构造函数'或'copy构造函数和析构函数'</p></li>
<li><p>可以看出vector一共存了3个iterator，分别为<code>start_</code>,<code>end_</code>,
以及<code>end_cap_</code>(为当前vector分配的内存地址上限),所以在64bit的机器上，<code>sizeof(vector&lt;T&gt;) == 24</code></p></li>
</ol>
<h2 id="array">array</h2>
<h3 id="uml-3">UML</h3>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230729164519559.png"
alt="image-20230729164519559" />
<figcaption aria-hidden="true">image-20230729164519559</figcaption>
</figure>
<h3 id="说明-3">说明</h3>
<ol type="1">
<li>与<code>vector</code>相同，<code>array</code>的<code>iterator</code>实际上是<code>_Tp*</code>类型，迭代器的分类是<code>random_access_iterator_tag</code>;
<code>begin</code>与<code>end</code>迭代器直接通过数组指针计算</li>
</ol>
<h2 id="forward_list">forward_list</h2>
<h3 id="uml-4">UML</h3>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230729172046501.png"
alt="image-20230729172046501" />
<figcaption aria-hidden="true">image-20230729172046501</figcaption>
</figure>
<h3 id="说明-4">说明</h3>
<ol type="1">
<li><code>forward_list</code>通过<code>__compressed_pair</code>持有<code>__forward_begin_node&lt;__forward_list_node*&gt;</code>,
是一个<code>dummy node</code>，该节点指向实际的第一个节点</li>
<li><code>forward_list</code> private inheritance
<code>__forward_list_base</code></li>
<li><code>end()</code>函数通过<code>nullptr</code>构造一个迭代器，即<code>__forward_list_node-&gt;next == nullptr</code>时，对应的迭代器也等于<code>end()</code>函数返回的迭代器</li>
</ol>
<h2
id="unordered_map-unordered_set-unordered_multimap-unordered_multiset">unordered_map,
unordered_set, unordered_multimap, unordered_multiset</h2>
<h3 id="uml-5">UML</h3>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230815170945333.png"
alt="image-20230815170945333" />
<figcaption aria-hidden="true">image-20230815170945333</figcaption>
</figure>
<h3 id="说明-5">说明</h3>
<ol type="1">
<li><code>unordered</code>容器的底层是<code>hash_table</code></li>
<li><code>map</code>将<code>pair&lt;key, value&gt;</code>储存在<code>hash_table_node</code>中，<code>set</code>直接将<code>key</code>储存在<code>hash_table_node</code>中</li>
<li><code>hash_table</code>的方法中，后缀<code>unique</code>表示不允许重复的<code>key</code>，
后缀<code>multi</code>表示允许重复的<code>key</code></li>
</ol>
<h4 id="hash_table"><code>hash_table</code></h4>
<p><code>hash_table</code>的主要结构如下：</p>
<ol type="1">
<li><p><code>__bucket_list</code>：
是一个指向<code>__next_pointer[]</code>数组的<code>unique_ptr</code>,其中<code>__next_pointer</code>可看作<code>hash_node*</code>；即每个<code>bucket</code>是一个<code>hash_node</code>链表。同时<code>unique_ptr</code>还指定了<code>deallocator</code>,<code>deallocator</code>内记录着<code>bucket</code>的数量(<code>bucket_count</code>)。</p></li>
<li><p><code>__p1_</code>， <code>__p2_</code>， <code>__p3_</code>
:</p>
<ul>
<li><p><code>_node_allocator</code>, <code>hasher</code>,
<code>key_equal</code>均为仿函数，即空类，所以使用<code>__compressed_pair</code>压缩空间。</p></li>
<li><p><code>__p1_.first()-&gt;next</code>指向<code>hash_table</code>中的第一个<code>node</code>，<code>begin()</code>也是根据其来构造相应的迭代器。如果一个新的<code>bucket</code>被使用，则将该<code>bucket</code>对添加到迭代器遍历的起始位置，即<code>__p1_.first()-&gt;next</code>指向该<code>bucket</code>。</p></li>
<li><p><code>__p2_.first()</code>记录当前容器有多少元素。</p></li>
<li><p><code>__p3_.first()</code>记录hashtable的<code>max_load_factor</code>，如果当前<span
class="math inline">\(load\_factor(=\frac{size()}{bucket\_count()}) &gt;
max\_load\_factor\)</span>，则需要对<code>hash_table</code>扩容。<code>hash_table</code>每次扩容为当前的两倍大小。</p></li>
</ul></li>
</ol>
<h3 id="hash-functor">hash functor</h3>
<p>C++中有一个模板类<code>hash</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>针对基本类型(所有的整型、指针、<code>std::string</code>、<code>std::vector</code>)，该模板类都做了特化，重载了<code>operate()</code>,可作为默认的<code>hash</code>(仿)函数。</p>
<p>可以针对自定义类型，特化<code>hash template</code>,作为自定义类型的<code>hash</code>(仿)函数。</p>
<h3 id="一个万用的hash-function">一个万用的hash function</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="type">void</span> <span class="title">hash_combine</span><span class="params">(<span class="type">size_t</span>&amp; seed, <span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   seed ^= std::<span class="built_in">hash</span>&lt;T&gt;()(val) + <span class="number">0x9e3779b9</span> + (seed &lt;&lt; <span class="number">6</span>) + (seed &gt;&gt; <span class="number">2</span>); <span class="comment">///  1.9e3779b9 黄金分割比， 1.618</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">hash_val</span><span class="params">(<span class="type">size_t</span>&amp; seed, <span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">hash_combine</span>(seed, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">hash_val</span><span class="params">(<span class="type">size_t</span>&amp; seed, <span class="type">const</span> T&amp; val, <span class="type">const</span> Types&amp; ... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">hash_combine</span>(seed, val);</span><br><span class="line">   <span class="built_in">hash_val</span>(seed, args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">hash_val</span><span class="params">(<span class="type">const</span> Types&amp; ... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">size_t</span> seed = <span class="number">0</span>;</span><br><span class="line">   <span class="built_in">hash_val</span>(seed, args...);</span><br><span class="line">   <span class="keyword">return</span> seed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树</title>
    <url>/zyhjy/2023/07/27/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<h2 id="线段树">线段树</h2>
<h3 id="复杂度">复杂度</h3>
<p>便于维护区间信息，可在<span
class="math inline">\(O(logN)\)</span>的时间复杂度内完成修改/查询。</p>
<span id="more"></span>
<h3 id="说明">说明</h3>
<p>线段树的实现是一个扁平数组<code>tree[]</code>，树上每个节点对应原数组<code>arr</code>上的一段区间，规定数组下标<code>1</code>为根节点(数组下标<code>0</code>不使用)，对应整个原数组区间。</p>
<p>对于树上每个非叶子节点<code>tree[id]</code>,若其对应的区间是<code>[start, end]</code>,存储的值为该区间的特征(根据题目条件确定，一般为区间的和);</p>
<p>则其左孩子为<code>tree[id * 2]</code>,若其对应的区间是<span
class="math inline">\([start , \frac{start + end}{2}]\)</span>;</p>
<p>则其右孩子为<code>tree[id * 2 + 1]</code>,若其对应的区间是<span
class="math inline">\([\frac{start + end}{2} + 1， end]\)</span>.</p>
<p>对于叶子结点，其对应区间为<code>[s,s]</code>，即原数组上的值<code>arr[s]</code>.</p>
<p>易知树的深度为<span class="math inline">\(\lceil logN
\rceil\)</span>，所以数组长度 <span class="math inline">\(&lt; 2^{\lceil
logN \rceil + 1} &lt; 4n\)</span>。</p>
<h3 id="懒惰标记">懒惰标记</h3>
<p>线段树的最大优势就是处理区间修改/查询。</p>
<p>每次修改都从根节点开始，自顶向下找到要求处理的区间（可能由多个区间上连续的节点组成），更新信息，并打上标记，<strong>标记意味着当前节点的子节点并未更新</strong>；此时不需要处理子区间的情况，即延迟处理，直到需要使用子区间时再对子区间更新（标记下放）。</p>
<p>查询同理，从根节点开始，自顶向下找到要求处理的区间（可能由多个区间上连续的节点组成），求和，如果遇到标记需要下放，则完成下放操作。</p>
<p>由此，区间修改/查询的时间复杂度为<span
class="math inline">\(O(logN)\)</span>。</p>
<h3 id="代码示例">代码示例</h3>
<p>注：标记的类型以及<code>modify</code>函数根据题目条件适当修改。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SegTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">explicit</span> <span class="title">SegTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> : n_(arr.size()), tree_(n_ * <span class="number">4</span>, <span class="number">0</span>), tag_(n_ * <span class="number">4</span>, false), arr_(arr)</span></span><br><span class="line"><span class="function">   &#123;</span></span><br><span class="line">      <span class="built_in">build</span>(<span class="number">0</span>, n_ - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">bool</span> tag)</span> </span>&#123;</span><br><span class="line">      <span class="built_in">modify</span>(l, r, tag, <span class="number">0</span>, n_ - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">getsum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">getsum</span>(l, r, <span class="number">0</span>, n_ - <span class="number">1</span>, <span class="number">1</span>);;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="type">int</span> n_;</span><br><span class="line">   vector&lt;<span class="type">int</span>&gt; tree_;</span><br><span class="line">   vector&lt;<span class="type">bool</span>&gt; tag_;</span><br><span class="line">   vector&lt;<span class="type">int</span>&gt;&amp; arr_;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> cur)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">         tree_[cur] = arr_[start];</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">build</span>(start, mid, cur * <span class="number">2</span>);</span><br><span class="line">      <span class="built_in">build</span>(mid + <span class="number">1</span>, end, cur * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">      tree_[cur] = tree_[cur * <span class="number">2</span>] + tree_[cur * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">bool</span> tag, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> cur)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (l &lt;= start &amp;&amp; end &lt;= r) &#123;</span><br><span class="line">         tag_[cur] = tag_[cur] ^ tag;</span><br><span class="line">         tree_[cur] = (end - start + <span class="number">1</span>) - tree_[cur];</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (tag_[cur]) &#123;</span><br><span class="line">         tree_[cur * <span class="number">2</span>] = (mid - start + <span class="number">1</span>) - tree_[cur * <span class="number">2</span>];</span><br><span class="line">         tree_[cur * <span class="number">2</span> + <span class="number">1</span>] = (end - mid) - tree_[cur * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">         tag_[cur * <span class="number">2</span>] = tag_[cur] ^ tag_[cur * <span class="number">2</span>] ;</span><br><span class="line">         tag_[cur * <span class="number">2</span> + <span class="number">1</span>] = tag_[cur] ^ tag_[cur * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">         tag_[cur] = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (l &lt;= mid) &#123;</span><br><span class="line">         <span class="built_in">modify</span>(l, r, tag, start, mid, cur * <span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (r &gt; mid) &#123;</span><br><span class="line">         <span class="built_in">modify</span>(l, r, tag, mid + <span class="number">1</span>, end, cur * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      tree_[cur] = tree_[<span class="number">2</span> * cur] + tree_[<span class="number">2</span> * cur + <span class="number">1</span>];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">getsum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> cur)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (l &lt;= start &amp;&amp; end &lt;= r) &#123;</span><br><span class="line">         <span class="keyword">return</span> tree_[cur];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (tag_[cur]) &#123;</span><br><span class="line">         <span class="comment">// 如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值</span></span><br><span class="line">         tree_[cur * <span class="number">2</span>] = (mid - start + <span class="number">1</span>) - tree_[cur * <span class="number">2</span>];</span><br><span class="line">         tree_[cur * <span class="number">2</span> + <span class="number">1</span>] = (end - mid) - tree_[cur * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">         tag_[cur * <span class="number">2</span>] = tag_[cur] ^ tag_[cur * <span class="number">2</span>] ;</span><br><span class="line">         tag_[cur * <span class="number">2</span> + <span class="number">1</span>] = tag_[cur] ^ tag_[cur * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">         tag_[cur] = <span class="literal">false</span>;                                <span class="comment">// 清空当前节点的标记</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (l &lt;= mid) &#123;</span><br><span class="line">         sum += <span class="built_in">getsum</span>(l, r, start, mid, cur * <span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (r &gt; mid) &#123;</span><br><span class="line">         sum += <span class="built_in">getsum</span>(l, r, mid + <span class="number">1</span>, end, cur * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="相关题目">相关题目</h3>
<ul>
<li><a
href="https://leetcode.cn/problems/handling-sum-queries-after-update/">leetcode[2569]更新数组后处理求和查询</a></li>
</ul>
<h3 id="参考文章">参考文章：</h3>
<ul>
<li><a href="https://oi-wiki.org/ds/seg/">洛谷</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>Topdown论文--ISPASS2014</title>
    <url>/zyhjy/2023/06/04/A%20Top-Down%20method%20for%20performance%20analysis%20and%20counters%20architecture/</url>
    <content><![CDATA[<h1 id="abstract">Abstract</h1>
<p>针对给定的微体系结构优化应用程序的性能变得非常困难。
日益增加的微架构复杂性、工作负载多样性以及性能工具产生的难以管理的数据量增加了优化挑战。
同时，随着最近出现的细分市场的出现，资源和时间限制变得更加严格。
这进一步需要准确和及时的分析方法。
在本文中，开发了一种自上而下的分析——一种快速识别乱序处理器中真正瓶颈的实用方法。
开发的方法在结构化的分层方法中使用指定的性能计数器来快速，更重要的是，正确识别主要性能瓶颈。
开发的方法被包括 VTune 在内的多种生产工具所采用。 来自 VTune
普通用户的反馈表明，由于简化的层次结构避免了与微体系结构细节相关的高学习曲线，分析变得更加容易。
针对 SPEC CPU2006 基准测试和关键企业工作负载报告了此方法的表征结果。
除了针对最新一代英特尔酷睿™
产品的架构探索研究外，还包括该方法指导软件优化的现场案例研究。
这种方法的见解指导了一种新颖的性能计数器架构的提议，该架构可以确定通用乱序处理器的真正瓶颈。
与其他方法不同，我们的分析方法成本低，并且已经在生产系统中得到应用——它只需要将八个简单的新性能事件添加到传统
PMU 中。 它是全面的——对预定义的性能问题集没有限制。
它解决了超标量核心中的粒度瓶颈，这是早期方法遗漏的。</p>
<span id="more"></span>
<h1 id="s1">S1</h1>
<p>性能监控单元 (PMU)
的主要目标是帮助软件开发人员优化其工作负载，以在给定系统上实现最佳性能。现代处理器有数百个性能事件，但可能很难确定哪些事件与特定工作负载的瓶颈有关。这是因为这些表演活动历来是以广告自下而上的方式定义的，PMU设计师试图通过
“专门的失误活动”
来报道关键问题。但是，这种方法可能无法解释设计时未明确预见的性能问题。</p>
<p>为了应对这一挑战，研究人员提出了一种新的性能计数器架构，该架构可以确定一般失序处理器的真正瓶颈。与其他方法不同，他们的分析方法低成本，并且已经在生产系统中使用。只需要向传统
PMU
添加八个简单的新性能事件。它很全面，对预定义的一组性能问题没有限制。它解释了超标量内核中的细粒度瓶颈，而早期方法可能忽略了这些瓶颈。</p>
<p>识别瓶颈有许多用途。计算机架构师可以更好地了解新兴工作负载的资源需求。工作负载特征通常使用原始事件计数数据，但此类未处理的数据不一定指向架构师应解决的正确瓶颈。编译器编写者可以更有效地确定哪种配置文件引导优化
(PGO)
适合工作负载，开销更少。虚拟系统的监视器可以提高资源利用率并最大限度地减少能耗。</p>
<p>突出显示的文本描述了一种名为自上而下分析的方法，该方法是识别失序 CPU
中的关键瓶颈的快速可行方法。该方法涉及以分层方式进行结构化深入分析，将权重分配给树中的节点，以指导用户将分析工作重点放在重要问题上，而忽略微不足道的问题。例如，如果某个应用程序受到指令提取问题的严重影响，则该方法会在树的最上层将其归类为
Frontend Bound，并且用户只能向下钻取层次结构的 Frontend
子树。向下钻取以递归方式执行，直到到达树叶为止，树叶可以指向工作负载的特定停顿状态，也可以表示可能限制应用程序性能的常见微架构症状的一部分问题。</p>
<p>代号为Ivy Bridge的英特尔第三代酷睿™
采用了该方法，并且使用了一小部分自上而下的定向计数器来克服瓶颈识别挑战。多种工具都采用了这种方法，包括VTune和标准Linux性能实用程序的附加包。使用该方法的现场经验揭示了一些以前被传统方法低估的性能问题。该方法的见解用于提出一种新的性能计数器架构，该架构可以通过自上而下的方法确定一般乱序架构的真正瓶颈。</p>
<p>性能监控单元 (PMU)
的主要目标是使软件开发人员能够有效地调整其工作负载，以在给定系统上实现最佳性能。所提出的方法成本低廉，已在生产系统中使用，只需要在传统的PMU中添加八个简单的新性能事件。它很全面，对预定义的一组性能问题没有限制，并且解释了早期方法所遗漏的超标量内核中的细粒度瓶颈。</p>
<p>本文的其余部分组织如下：第 2 节提供了背景信息，并讨论了在失序 CPU
中识别瓶颈所面临的挑战。第 3
节介绍了自上而下的分析方法及其抽象指标。在第 4
节中，提出了一种新的低成本计数器架构来获得这些指标。第 5
节介绍了常见工作负载的结果以及示例用例。第6节讨论了相关工作，最后，第7节总结并概述了未来的工作。</p>
<h1 id="section2-background">Section2 Background</h1>
<p>现代高性能CPU通过采用诸如大窗口乱序执行、预测性猜测和硬件预取等技术，竭尽全力保持其执行流水线的繁忙状态。在广泛的传统工作负载范围内，这些高性能架构在以每个周期指令数（IPC）的高速率执行任意代码方面取得了很大成功。然而，由于这些复杂的超标量乱序机器试图在“边缘”操作，即使是小的性能故障也可能限制工作负载远低于其潜力。不幸的是，在这些CPU中，从众多可以容忍的不重要问题中识别出真正的性能限制因素仍然是一个未解决的问题。</p>
<p>从鸟瞰角度来看，现代乱序CPU的流水线主要由前端和后端两个部分组成。前端负责从内存中获取指令并将其转换为微操作（uops）。这些uops被送到后端部分进行调度、执行和提交（retire），按照原始程序的顺序。为了保持机器的平衡，已经准备好供后端使用的uops通常会被缓存在某个“ready-uops-queue”中。图1显示了Ivy
Bridge微架构的示例块图，包括底层的功能单元。</p>
<p>传统方法<a
href="#section-3">4</a>对停顿进行简单估计。例如，某些缓存的缺失次数乘以预定义的延迟时间：</p>
<p>确实，这种“天真方法”可能适用于按顺序执行的CPU，但对于现代乱序CPU来说，由于多种原因，它显然不太合适：</p>
<ol type="1">
<li><p>停顿重叠：许多单元可以并行工作。例如，当数据缓存缺失时，可以处理一些未来指令缺失指令缓存的情况。</p></li>
<li><p>预测执行：当CPU按照错误的控制路径执行时，来自错误路径的事件比来自正确路径的事件更不重要。</p></li>
<li><p>惩罚因素与工作负载相关：而天真方法假设所有工作负载的惩罚都是固定的。例如，分支之间的距离可能增加错误预测的成本。</p></li>
<li><p>限制于预定义的缺失事件集合：这些复杂的微架构存在许多可能的故障，而只有最常见的子集由专用事件涵盖。</p></li>
<li><p>超标量不准确性：CPU可以在一个周期内发射、执行和退役多个操作。一些（例如客户端）应用程序由于流水线的带宽限制而受到限制，因为通过越来越多的技术来减轻延迟。</p></li>
</ol>
<p>因此，简单地依靠基于缓存缺失和预定义延迟的简单估计，可能无法准确评估现代乱序CPU中的性能限制。需要使用更先进的分析和性能分析技术，以识别和解决这些架构中真正的性能限制因素。</p>
<p>我们通过以下方法解决了这些问题。我们将一个名为“Bad
Speculation”（稍后定义）的主要类别放置在层次结构的顶部。它涵盖了由于错误预测而引起的停顿，以及由于执行错误路径而浪费的资源。这不仅将问题首先引起用户的注意，而且还简化了层次结构中其他地方使用的硬件计数器的要求。我们引入了一打真正的“自上而下”指定的计数器，以便处理其他问题。我们发现，在解决问题（1）和（3）时，确定要查看的流水线阶段和“计数的时机很重要。例如，我们不仅仅检查总内存访问持续时间，而是仅检查由于待定内存访问而导致执行单元利用率不足的子持续时间。通过调用与“专用缺失事件”无关的通用事件，我们可以处理问题（4）。其中一些是占用事件，用于处理问题（5）。</p>
<h1 id="section-3.top-down-analysis">SECTION 3.Top-Down Analysis</h1>
<p>自上而下分析方法的目标是准确且快速地确定性能瓶颈。它引导用户在性能优化阶段关注真正重要的问题。这个阶段通常在整个应用程序开发过程中受到时间和资源的限制，因此迅速确定瓶颈变得更加重要。</p>
<p>这种方法本身很简单：首先对CPU执行时间进行高层次的分类。这一步会标记（报告高分数）一些可能需要调查的领域。接下来，用户可以深入研究这些被标记的领域，并可以安全地忽略所有未被标记的领域。该过程以分层方式重复进行，直到确定特定的性能问题，或者至少确定了一小部分候选问题，可以进行进一步调查。</p>
<p>在本节中，我们首先概述层次结构，然后介绍层次结构上层背后的启发式方法。</p>
<p>该层次结构如图2所示。首先，我们假设用户对分析有预定义的标准。例如，用户可以选择查看至少占总执行时间20%的热点。另一个例子是分析为什么给定的热点在不同硬件代际之间没有显示出预期的加速效果。热点可以是软件模块、函数、循环或基本块之间的一系列指令。</p>
<p>Top-Down分解方法应用于有趣的热点，其中可用的流水线槽被分为四个基本类别：退役（Retiring）、坏预测（Bad
Speculation）、前端受限（Frontend Bound）和后端受限（Backend
Bound）。这些术语在以下子部分中进行了定义。最好通过一个例子来说明这种方法。以一个受数据缓存性能限制的工作负载为例。该方法标记了后端受限（Backend
Bound），而前端受限（Frontend
Bound）不会被标记。这意味着用户需要下一步深入研究后端受限（Backend
Bound）类别，而忽略所有与前端相关的问题。在深入研究后端受限（Backend
Bound）时，如果应用程序被认为对缓存敏感，那么会标记内存受限（Memory
Bound）类别。类似地，在这一点上，用户可以跳过非内存相关的问题。接下来，进行内存受限（Memory
Bound）的深入研究。L1、L2和L3-Bound自然地细分了内存受限（Memory
Bound）类别。每个类别表示工作负载受到该缓存级别限制的部分。L1受限（L1
Bound）应该在那里被标记。最后，由于与先前存储的重叠或缓存行分割加载，加载操作可能成为L1受限（L1
Bound）下面的特定性能问题。该方法最终会建议用户将注意力集中在这个领域上。</p>
<p>请注意，层次结构在查看计数器值时提供了一种自然的安全保障。除非从根节点到特定节点的路径上的所有节点都被标记，否则应该忽略内部节点的值。例如，一个简单的代码在一个内存缓冲区上执行一些除法操作，可能会显示图2中Ext.
Memory
Bound和Divider节点的高值。尽管Divider节点本身可能具有高的分数值，但假设工作负载真正受内存限制，应该忽略它。这是因为Backend.CoreBound不会被标记。我们将此称为层次安全属性（hierarchical-safety
property）。还请注意，只有兄弟节点的权重可以进行比较。这是因为它们在同一流水线阶段计算。不建议比较非兄弟节点的分数值。</p>
<h2 id="top-level-breakdown">3.2. Top Level Breakdown</h2>
<p>在高度复杂的微架构中，首先需要对流水线活动进行一级分类。第一个有趣的问题是如何以及在哪里进行第一级分解？我们选择问题点（在图1中用星号标记）作为自然的边界，将机器的前端和后端部分分割开来。这样可以实现高度准确的最高级别分类。</p>
<p>在问题点上，我们将每个流水线槽分类为四个基本类别：前端受限（Frontend
Bound）、后端受限（Backend Bound）、坏预测（Bad
Speculation）和退役（Retiring），如图3所示。如果在给定的周期内发出了一个微操作（uop），它最终将被退役或取消。因此，它可以分别归属于退役或坏预测类别。</p>
<p>否则，流水线槽可以被分为是否存在后端停顿。后端停顿是后端在资源不可用（例如缺少加载缓冲区条目）时施加的反压机制。在这种情况下，我们将停顿归因于后端，因为即使前端准备好了更多的微操作，它也无法将它们传递到流水线中。如果没有后端停顿，这意味着前端在后端准备接收微操作时应该已经传递了一些微操作；因此，我们将其标记为前端受限。</p>
<p>这种后端停顿的条件是关键的，正如我们在下一节中的FetchBubbles定义中所概述的。</p>
<p>实际上，分类是以流水线槽的粒度进行的，因为超标量CPU能够每个周期发出多个微操作。这使得分解非常准确和稳健，这在层次结构的最高级别上是必要的。这种准确的分类将我们的方法与之前的方法[1]
<a href="#section-3">5</a> [6]区分开来。</p>
<h2 id="frontend-bound-category">3.3. Frontend Bound Category</h2>
<p>回想一下，前端表示流水线的第一部分，其中分支预测器预测下一个要获取的地址，缓存行被获取并解析为指令，然后解码为后端稍后可以执行的微操作。前端受限表示当CPU的前端供应不足时，即后端本来愿意接受微操作。</p>
<p>处理前端问题有一些棘手，因为它们发生在长而缓冲的流水线的最开始部分。这意味着在许多情况下，短暂的问题不会主导实际性能。因此，在仅在最高级别标记为前端受限时才深入研究这个领域非常重要。话虽如此，我们观察到在许多情况下，前端供应带宽可以主导性能，特别是当高IPC适用时。这导致添加了专用单元来隐藏获取流水线的延迟并保持所需的带宽。循环流检测器（Loop
Stream Detector）以及解码指令缓存（即DSB，Sandy
Bridge引入的解码微操作流缓冲区）是英特尔Core系列中的一些例子<a
href="#section-4">7</a>。</p>
<p>Top-Down方法进一步区分延迟和带宽阻塞。指令缓存缺失将被归类为前端延迟受限，而指令解码器的低效将被归类为前端带宽受限。最终，我们希望这些指标只在流水线的其余部分可能受到影响时才计算，正如之前讨论的那样。</p>
<p>请注意，这些度量标准是在Top-Down方法中定义的；前端延迟包括导致无法提供uop的获取饥饿情况（即没有uop传递的症状），无论是由什么原因引起的。熟悉的指令缓存和指令转换后备缓冲（i-TLB）缺失都属于此类。例如，<a
href="#section-2">4</a>已将指令长度解码标记为获取瓶颈。它是特定于CPU的，因此在图2中未显示。分支重建则考虑了由于分支错误预测而导致的流水线刷新延迟等情况。它与错误预测成本密切相关（我们在错误预测成本方面有详细说明）。</p>
<p>该方法还根据将uop插入到uops-ready队列的获取单元对带宽问题进行分类。指令解码器通常用于将主流指令转换为其他部分可以理解的uop
-
这将是一个获取单元。而复杂的指令（如CPUID）通常具有专用单元来提供长的uop流
- 这将是第二个获取单元，依此类推。</p>
<h2 id="bad-speculation-category">3.4. Bad Speculation Category</h2>
<p>"错误推测"是指处理器流水线中由于错误的推测而导致资源浪费的概念。它包括两个主要方面：
1.
用于发出未最终执行的微操作（uops）的时钟周期。这些是被猜测的指令，但实际上没有在正确的程序路径上执行。
2.
由于先前错误的推测而导致发射流水线阻塞的时钟周期。这包括由于错误的预测（例如错误的分支预测）而导致流水线停顿或刷新的情况。</p>
<p>在顶层分析中包含"错误推测"类别是至关重要的，因为它确定了被分析工作负载中受到错误执行路径影响的部分。这对于准确评估其他类别中的观察结果至关重要。此外，它允许较低层级的节点使用传统计数器，因为大多数乱序处理器中的计数器都会对错误推测进行计数。"错误推测"类别的高值将作为一个"红旗"，在查看其他类别之前需要进行调查。减少错误推测不仅提高资源利用率，还增强了层次结构中报告的指标的可信度。</p>
<p>该方法将"错误推测"时钟周期分为"分支错误预测"和"流水线清除"两个子类别。尽管前者比较常见，但后者会导致类似的情况，其中流水线被刷新。例如，错误的数据推测可能会引发"内存序重排"（Memory
Ordering
Nukes）——这是"流水线清除"的一种子集。我们区分这两种情况是因为对它们进行进一步分析的下一步可能完全不同。前者处理如何使程序的控制流对分支预测器更友好，而后者通常指向意外情况。</p>
<h2 id="retiring-category">3.5. Retiring Category</h2>
<p>这个类别反映了被"好的uops"利用的时钟周期——即最终被执行和退役的uops。理想情况下，我们希望将所有时钟周期归属于"退役"类别；也就是说，100%的退役对应于达到给定微架构每个周期最大可退役的uops数。例如，假设一个指令解码成一个uop，50%的退役意味着在一个四路发射机器上实现了IPC为2。因此，最大化退役可以提高IPC。</p>
<p>然而，高退役值并不一定意味着没有提升性能的空间。诸如浮点（FP）辅助之类的微码序列通常会降低性能，可以避免使用<a
href="#section-4">7</a>。它们在微序列度量下被隔离，以引起用户的注意。</p>
<p>对于非矢量化代码，高退役值可能是用户矢量化代码的一个好的提示。这样做实际上使得更多的操作可以由单个指令/uop完成，从而提高性能。有关更多详细信息，请参见第5节中的矩阵乘法用例。由于FP性能在HPC领域具有特殊重要性，我们进一步将基本的退役类别细分为具有标量和矢量操作区别的FP算术。请注意，这是一种信息性的、源自字段的扩展。其他关于已退役操作分布的细分方式也可能适用。</p>
<h2 id="backend-bound-category">3.6. Backend Bound Category</h2>
<p>Backend
Bound（后端受限）反映了由于后端缺乏所需资源而导致无法将uops传送到发射流水线的时钟周期。此类问题的例子包括数据缓存未命中或因除法器过载而导致的停顿。</p>
<p>Backend Bound又被细分为Memory Bound（内存受限）和Core
Bound（核心受限）。这是通过根据执行单元在每个时钟周期中的占用情况来分解后端停顿来实现的。自然地，为了保持最大IPC，必须使执行单元保持忙碌状态。例如，在一个四路发射的机器上，如果在某段代码的稳态下只执行三个或更少的uops，那么它将无法实现最优IPC为4。这些次优的时钟周期被称为Execution
Stalls（执行停顿）。</p>
<p>Memory
Bound对应于与内存子系统相关的执行停顿。这些停顿通常表现为在短时间内执行单元饥饿，例如在加载指令未命中所有缓存的情况下。</p>
<p>而Core
Bound则稍微复杂一些。它的停顿可以表现为短暂的执行饥饿周期，或者是执行端口利用率不佳：长延迟的除法操作可能会导致执行序列化，而对特定类型uops的执行端口的压力可能表现为一个周期中使用的端口数量较少。实际的度量计算在第4节中进行了描述。</p>
<p>通过更好的代码生成通常可以缓解Core
Bound问题。例如，一系列相关的算术操作会被归类为Core
Bound。编译器可以通过更好的指令调度来缓解这个问题。矢量化也可以缓解Core
Bound问题，如第5.5节所示。</p>
<h2 id="memory-bound-breakdown-within-backend">3.7. Memory Bound
Breakdown (within backend)</h2>
<p>现代CPU实现了三级缓存层次结构，以隐藏外部内存的延迟。在英特尔Core处理器中，第一级是数据缓存（L1D）。L2是第二级共享指令和数据缓存，每个核心都有私有的L2缓存。L3是最后一级的缓存，由兄弟核心共享。在这里，我们假设存在一个三级缓存层次结构和统一的外部内存；尽管度量标准足够通用，可以适应其他的缓存和内存组织方式，包括NUMA。</p>
<p>为了处理重叠效应，我们引入了一种新的启发式方法来确定内存访问的实际惩罚。<strong>一个好的乱序调度器应该能够通过使执行单元保持忙碌来隐藏一些内存访问的停顿</strong>，这些执行单元执行的是不依赖于未完成的内存访问的有用uops。因此，内存访问的真正惩罚是当调度器没有准备好的uops可供执行单元使用时发生的。进一步的uops可能正在等待未完成的内存访问，或者依赖于其他尚未准备好的uops。当没有缺失某个缓存层级的需求加载时，如果存在显著的Execution
Stalls，则提示执行很可能受限于该层级本身。图4还说明了如何根据缓存层级来划分Execution
Stalls。</p>
<p>例如，L1D缓存通常具有与ALU停顿相当的短延迟。然而，在某些情况下，比如加载被阻塞以从早期存储器中的重叠地址转发数据，加载操作可能会遭受较高的延迟，尽管最终会由L1D满足。在这种情况下，正在进行中的加载操作将持续很长时间而不会错过L1D。因此，根据图4中的流程图，它被标记为L1
Bound。由于4K别名（4K
Aliasing）而导致的加载阻塞是另一种具有相同症状的场景。某些方法[1] <a
href="#section-3">5</a>无法处理L1命中和近层缓存未命中的这类情况。</p>
<p>请注意，性能中断（如上述的L1
Bound场景）会出现在图2中的叶节点中。由于范围限制，我们没有列出它们。</p>
<p>到目前为止，内存子系统的加载操作已经得到了处理。由于x86体系结构的内存顺序要求，存储操作在乱序CPU中被缓冲并在退休后（完成后）执行。在很大程度上，它们对性能影响较小（如结果部分所示）；但是不能完全忽略。Top-Down定义了Stores
Bound（存储受限）指标，用于表示执行端口利用率较低且缓冲的存储操作数量较多的周期的比例。如果同时存在加载和存储问题，我们将优先处理加载节点，根据前面提到的洞察力进行处理。</p>
<p>数据TLB未命中可以归类为Memory
Bound的子节点。例如，如果TLB翻译由L1D缓存满足，那么它将被标记为L1
Bound。</p>
<p>最后，我们使用了一个简单的启发式方法来区分Ext. Memory Bound下的MEM
Bandwidth（内存带宽）和MEM
Latency（内存延迟）。我们测量了从内存控制器返回的数据待处理请求的占用情况。每当占用度超过一定阈值，例如内存控制器可以同时服务的请求的最大数量的70%，我们将其标记为可能受到内存带宽限制。剩余的部分将归因于内存延迟。</p>
<h1 id="section-4.counters-architecture">SECTION 4.Counters
Architecture</h1>
<p>本节描述了实现所述Top-Down分析所需的硬件支持。我们假设在现代CPU中具备基线PMU（例如x86或ARM），该PMU提供了一小组通用计数器，能够计算性能事件。几乎十几个事件就足以涵盖层次结构的关键节点。事实上，只需要八个指定的新事件即可。其余的事件已经可以在现有的PMU中找到，这些在表1中标有星号。例如，TotalSlots事件可以通过基本的Clockticks事件计算得出。通过层次安全性特性，可以使用其他PMU传统事件来进一步扩展层次结构，这在第3节中进行了描述。</p>
<p>值得注意的是，需要低成本的硬件支持。这八个新事件易于实现。它们依赖于本地设计信号，可能通过延迟指示进行屏蔽。与IBM
POWERS [6]中所需的退休标记不同，也不需要像Accurate CPI Stacks提案[1] <a
href="#section-5">8</a> <a
href="#section-6">9</a>中那样复杂的具有延迟计数器的结构。</p>
<h2 id="top-down-events">4.1. Top-Down Events</h2>
<p>The basic Top-Down generic events are summarized in Table 1. Please
refer to Appendix 1 for the Intel implementation of these events. Notice
there, an implementation can provide simpler events and yet get fairly
good results.</p>
<h2 id="top-down-metrics">4.2. Top-Down Metrics</h2>
<p>The events in Table 1 can be directly used to calculate the metrics
using formulas shown in Table 2. In certain cases, a flavor of the
baseline hardware event is used3. Italic #-prefixed metric denotes an
auxiliary expression.</p>
<p>请注意，ExecutionStall表示在其中没有或很少执行uop的次优周期。在这种情况下，工作负载不太可能达到最大IPC。虽然这些阈值是特定于实现的，但我们的数据表明，在类似Sandy
Bridge核心的情况下，执行0、1或2个uop的周期很好地代表了核心限制的场景。</p>
<h1 id="section-5.results">SECTION 5.Results</h1>
<p>在本节中，我们展示了SPEC
CPU2006基准测试在单线程（1C）和多副本（4C）模式下的Top-Down分析结果，其设置如表3所述。然后，通过对多个CPU进行研究，展示了架构探索的使用案例。由于在CPU2006中，前端限制往往不是瓶颈，因此我们还包括了关键服务器工作负载的结果。最后，我们分享了一些使用Top-Down分析来调优性能问题的案例。</p>
<h2 id="spec-cpu2006-1c">5.1. SPEC CPU2006 1C</h2>
<p>在顶层（Top
Level），图5a显示了基准测试应用程序的多样化分布。从性能角度来看，Retiring类别接近50%，与相同一组运行的聚合IPC约为1.7相符。请记住，100%的Retiring意味着每个周期有四个已退休的uop，而对于SPEC
CPU2006，平均而言，一个指令被解码成略多于一个uop。请注意，Retiring与IPC的相关性良好，这是为了与已建立的指标进行交叉验证。</p>
<p>整体上，Backend
Bound占主导地位。因此，我们在图5中的下一个图表中进行了详细分析。Backend
Level图表指导用户接下来查看核心(Core)或内存(Memory)问题。例如，456.hmmer被标记为Backend
Core
Bound。通过使用VTune查看顶级热点，确实可以看到具有紧密数据相关算术指令的循环。</p>
<p>整数型应用程序对前端限制（Frontend Bound）和错误预测（Bad
Speculation）更为敏感，而浮点型应用程序则相对较不敏感。这与使用专有的逐周期模拟器进行的模拟数据以及Jaleel的先前分析一致。例如，Jaleel的分析报告称gcc、perlbench、xalancbmk、gobmk和sjeng的代码占用空间超过32KB，它们被归类为前端限制最严重的工作负载。请注意，通过这种分类方式，可以更容易地评估多个瓶颈的相对重要性。</p>
<h2 id="spec-cpu2006-4c">5.2. SPEC CPU2006 4C</h2>
<p>在运行4个副本的情况下，这些应用程序的结果如图6所示。顶层显示与单个副本相似，但仔细观察，某些应用程序确实表现出更大的Backend
Bound。根据图6b中更大的Memory
Bound比例，这些是内存敏感型应用程序。这是可以预期的，因为L3缓存在核心之间是“共享”的。由于每个物理核心中都运行着相同的线程，并且给定CPU2006几乎没有i-cache缺失，因此4个副本中的前端限制（Frontend
Bound）和错误预测（Bad Speculation）与单个副本几乎没有变化。</p>
<p>对于不太可扩展的应用程序，将Figure 6c与Figure 5c
4进行比较可以看出，Memory
Bound的细分指向了核外争用。主要差异出现在两类应用程序中，一类是对可用内存带宽敏感的应用程序，另一类是受到线程之间共享缓存竞争影响的应用程序。其中一个例子是470.lbm，它以其高内存带宽需求而闻名<a
href="#section-7">12</a>。在1个和4个副本之间，其大型的MEM
Bound是主要的差异。</p>
<p>另一个重要的例子是482.sphinx3。仔细观察Memory
Bound的细分可以发现，4个副本的L3 Bound减少，而MEM
Bound大幅增加；共享L3缓存中的线程之间的容量竞争导致更多的L3缺失。这个结论可以通过查看此工作负载的工作集进行验证[11]：单个副本在1个副本中需求8MB（与LLC容量相同），而4个副本运行时每个核心的LLC共享为2MB有效。</p>
<p>图7显示了一些FP应用程序中离芯资源的利用情况，分别以1个副本和4个副本并排显示。柱状图的高度表示内存控制器为某些请求提供服务的运行时间的比例。
"MEM
Bandwidth"是许多请求同时被服务的相对部分。注意，我们可以以其本地单位绘制这些指标，这要归功于层次安全属性。不过，我们应该仔细考虑它们。</p>
<p>可用的25GB/s带宽明显满足1份数据的需求。在4份数据中，情况有所不同。435.gromacs、447.dealII、454.calculix和465.tonto由于每千条指令L3缺失次数的增加而花费更多的内存周期，增加了1.3至3.6倍，这是通过一组不同的性能计数器测量得出的结果。然而，需要注意的是，根据图6b显示，它们在内存和核心停顿分数方面与1份数据时相当，这可能是因为乱序执行可以减轻大部分这些内存周期。这与4份数据时测得的IPC在1.7至2.3之间的范围内相吻合。相比之下，410.bwaves、433.milc、437.leslie3d和470.lbm在4份数据中变得更加受内存限制，根据图6c的描述。根据图7所示，这是由于1份数据中的内存延迟转变为4份数据中的内存带宽（4倍的数据需求）。Top-Down正确地将470.lbm分类为受内存带宽限制的应用程序<a
href="#section-7">12</a>。</p>
<h2 id="microarchitectures-comparison">5.3. Microarchitectures
Comparison</h2>
<p>到目前为止，我们已经展示了相同系统的结果。本节将展示Top-Down如何辅助硬件架构师。图8展示了Intel
Core第三代和第四代CPU的顶层视图，以并列方式显示了一部分CPU2006整数基准测试。较新的Intel
Core具有改进的前端，支持具有更好时序的推测性iTLB和i-cache访问，以提高预取的效益<a
href="#section-4">7</a>。这在受益的基准测试中可以明显注意到Frontend
Bound的减少。这个验证结果增加了对早两代发明的基础启发式方法的信心。</p>
<h2 id="server-workloads">5.4. Server Workloads</h2>
<p>图9显示了在Sandy Bridge
EP上的关键服务器工作负载的结果。相较于SPEC工作负载，退休指令较少，这符合较低IPC范围（测得为0.4至1之间）。由于足迹更大，后端和前端限制更为显著。</p>
<p>有趣的是，DBMS工作负载的特征与之前的研究<a
href="#section-2">4</a>一致，该研究报告称这些工作负载主要受限于最后一级数据缓存缺失和一级指令缓存缺失。</p>
<p>在前端方面，延迟问题在所有服务器工作负载中占主导地位。这是由于预期的更多i-cache和i-TLB缺失，与客户端工作负载相比，其前端限制几乎均匀分布在延迟和带宽问题之间（由于论文范围限制，未显示）。</p>
<h2 id="case-study-1-matrix-multiply">5.5. Case Study 1:
Matrix-Multiply</h2>
<p>使用Top-Down对矩阵相乘的经典内核进行了分析。这展示了性能调优的迭代性质。</p>
<p>在multiply()函数的初始代码中，由于大矩阵以不友好的方式遍历，它非常受限于内存。这导致了内存限制。</p>
<p>通过在multiply2()中应用循环交换优化，获得了显著的加速。优化后的代码仍然受限于后端，但从内存限制转变为受核心限制。</p>
<p>接下来，在multiply3()中尝试进行向量化，它通过减少端口利用率和减少净指令数进一步提高了性能。这实现了另一个加速效果。</p>
<h1 id="case-study-2-false-sharing">5.6. Case Study 2: False
Sharing</h1>
<p>一门大学课程通过一个例子来教导学生如何通过并行化串行计算密集型代码来避免多线程陷阱。首次尝试由于伪共享（False
Sharing）而没有加速（甚至速度变慢）。伪共享是多线程中的一个问题，即多个线程争用映射到同一缓存行的不同数据元素。通过添加填充以使线程访问不同的缓存行，可以很容易地避免伪共享。</p>
<p>单线程代码的IPC（每指令周期执行的指令数）适中。Top-Down正确将第一个多线程代码尝试分类为后端内存存储限制（Stores
Bound），因为伪共享必须有一个线程将数据写入内存（即存储操作）。在修复后的多线程版本中，存储限制问题被消除了。</p>
<h2 id="case-study-3-software-prefetch">5.7. Case Study 3: Software
Prefetch</h2>
<p>使用Top-Down对客户专有的物体识别实际应用进行了分析。根据应用程序范围的分类，该工作负载被归类为后端内存扩展内存延迟限制（ExtMemory
LatencyBound）。在最大的热点函数中也是如此，尽管在那里指标的分数更加明显。这表明在其他热点中存在更多非内存瓶颈。</p>
<p>在算法的关键循环中引入了软件预取（Software
Prefetches）[10]，以预取下一次迭代的数据。根据算法得分，实现了35%的加速，这在工作负载范围内相当于1.21倍的速度提升。需要注意的是，优化后的版本显示出更高的内存带宽利用率，并且已经更多地受限于后端核心（Backend
CoreBound）方面。</p>
<h1 id="section-6.related-work">SECTION 6.Related Work</h1>
<p>一些研究（如<a href="#section-2">4</a> <a
href="#section-3">5</a>）采用了广泛使用的天真方法进行命名。尽管这对于顺序执行的CPU可能有效，但对于乱序执行的CPU来说远非准确，原因在于：停顿重叠、推测性缺失和工作负载相关的惩罚，如第2节所详述。</p>
<p>IBM POWER5
[6]具有专用的性能监控单元（PMU）事件，可在退休（提交）阶段辅助计算CPI（每周期指令数）的分解。无退休的停顿周期按照下一条将退休的指令类型进行计数，可能会与缺失事件相关联。同样，这是一组在自下而上方式中选择的固定事件集。虽然这相对于天真方法是一种改进，但它低估了前端缺失的代价，因为它们在调度器队列清空后才被计入。Levinthal
<a href="#section-3">5</a>提出了一种适用于早期Intel
Core实现的周期账户方法。在执行阶段进行平坦的分解，将总周期分解为退休、非退休和停顿组件。然后，分解停顿组件使用了不足的天真方法，正如作者本人在文中所指出的那样。</p>
<p>相比之下，Top-Down在发射阶段进行了更细粒度（槽位）的分解，并避免将所有惩罚简单地汇总到一个平坦的分解中。相反，它以分层的方式深入挖掘停顿，每个层级都会放大到管道的适当部分。此外，使用指定的Top-Down事件；启用对前端发射进行采样（而不是计数），以及在开启超线程时进行分解。<a
href="#section-3">5</a>中没有涉及到这些内容。</p>
<p>一些研究人员试图准确地分类乱序体系结构上的性能影响。Eyerman等人在[1]
<a
href="#section-6">9</a>中使用基于仿真的区间分析模型，提出了一种构建准确CPI堆栈的计数器体系结构。所呈现的结果在与天真方法和IBM
POWER5相比方面都显示出改进，更接近参考的基于仿真的模型。这种方法（及其参考模型）的一个主要缺点是将所有停顿限制在一组固定的八个预定义的缺失事件上。在[1]
<a href="#section-2">4</a> <a
href="#section-3">5</a>中没有考虑（获取）带宽问题以及像L1
Bound这样的低延迟瓶颈。此外，由于跟踪结构相当复杂，<a
href="#section-5">8</a>中的作者自</p>
<p>己后来在文中提到了高硬件成本的问题。尽管<a
href="#section-5">8</a>用较小的FIFO替换了原始结构，但仍需要额外的逻辑来计算惩罚并将其聚合到新的专用计数器中。相比之下，我们的方法采用简单的事件，不需要额外的计数器/逻辑。在前面的部分中，我们已经指出了更多的缺点。</p>
<p>最近，<a href="#section-8">13</a>和<a
href="#section-7">12</a>提出了基于仪器的工具来分析数据局部性和可扩展性瓶颈。在<a
href="#section-8">13</a>中，通过PMU对平均内存延迟进行采样，并结合Pin和缓存模拟器获取的重用距离，以便优先考虑优化工作。离线分析器将这些指标映射回源代码，并允许用户从主函数开始以分层的方式探索数据。<a
href="#section-7">12</a>提出了一种针对特定类型并行程序获得加速堆栈的方法，同时考虑了三个瓶颈：缓存容量、外部内存带宽和同步。</p>
<p>这些可以看作是特定于优化的高级技术，可以在Top-Down中触发，一旦被标记为后端内存限制（Backend
MemoryBound）。此外，我们的MemStalls.
L3Miss事件等更好的指标可以用来代替<a
href="#section-8">13</a>中的原始延迟值，以量化何时可以应用加速。首先在更高的程序范围内检查指标，可以应用于我们的方法，就像VTune的General
Exploration view [2]已经做的那样。尽管<a
href="#section-7">12</a>估计了加速比（我们的方法没有），但它只考虑了一部分可扩展性瓶颈。例如，在5.6的情况下，它没有涵盖它们的三个瓶颈。</p>
<h1 id="section-7.summary-and-future-work">SECTION 7.Summary and Future
Work</h1>
<p>本文介绍了一种名为Top-Down分析方法的综合、系统化的在生产中分析方法，用于识别乱序CPU中的关键性能瓶颈。该方法利用通用多核心中的指定PMU事件，采用分层分类，使用户能够准确定位导致性能不佳的问题。该方法经过演示，能够对各种客户端和服务器工作负载、多个微架构世代以及单线程和多核场景进行关键性能瓶颈分类。</p>
<p>该方法的见解被用于提出一种新颖的低成本性能计数器架构，可以确定一般乱序处理器的真正瓶颈。只需要八个简单的新事件。</p>
<p>所提出的方法在PMU架构和工具方面提出了一些观点。分解几个层级需要同时收集多个事件。某些技术可能可以容忍，例如Sandy
Bridge对最多支持八个通用计数器的支持[10]，或工具中的事件复用[2] <a
href="#section-1">3</a>。然而，仍然希望有更好的硬件支持。此外，将已识别的问题追溯到用户代码可以极大地惠及软件开发人员。虽然PMU的精确机制是一个有希望的方向，但某些微架构领域的覆盖仍然不足。此外，企业级应用程序对平坦的长尾轮廓提出了额外的挑战。</p>
<p>在硬件超线程（HT）的背景下正确地分类瓶颈绝对是一个具有挑战性的前沿领域。虽然超出了本文的范围，但一些Top-Down事件的设计确实考虑了HT，使得顶层在启用HT时起作用；但这只是一个开始。最后，虽然我们的方法的目标是识别关键性能瓶颈，但它并不评估在修复底层问题后可能带来的加速。通常，确定问题修复是否会转化为加速（或是否会产生加速）是棘手的。工作负载通常会转移到下一个关键性能瓶颈上。<a
href="#section-7">12</a>在可扩展性瓶颈的背景下在这方面取得了不错的进展。</p>
<h1 id="appendix-1">10. Appendix 1</h1>
<p>英特尔Core™微架构是一个4-wide的指令发射机制。表7总结了使用Ivy Bridge
PMU事件名称实现的指标。其中一些Top-Down指定的事件在硬件中并不直接可用，而是提供了一个公式来从可用事件中近似计算指标。请注意，表中没有出现的指标对英特尔实现没有特殊要求，可以直接从表2中使用。</p>
<h1 id="pre">PRE</h1>
<h1 id="section">1.</h1>
<p>一种自上而下的性能分析方法和计数器架构</p>
<p>使用top-down分析方法 快速识别乱序处理器中真正瓶颈</p>
<p>计数器架构（Counters Architecture）
是收集和记录特定指标或事件的硬件或软件机制。
用于监测系统性能、资源利用和事件发生。</p>
<p>计数器（Counters）：存储单元。硬/软。可以统计如指令执行次数、缓存命中、中断发生次数等各种系统活动。</p>
<h1 id="动机">2. 动机</h1>
<p>性能优化具有一定的挑战性，原因如下：</p>
<ol type="1">
<li><p>复杂的微体系结构：现代计算机的微体系结构变得越来越复杂，涉及多级缓存、超标量执行、预取等技术。这增加了性能分析和优化的复杂性，需要深入理解硬件特性以找到性能瓶颈。</p></li>
<li><p>应用程序/工作负载多样性：不同的应用程序和工作负载具有不同的性能特征和行为。优化性能需要针对具体应用的特点进行分析和调整，而这种多样性增加了优化的挑战。</p></li>
<li><p>难以管理的数据：在大规模系统中收集和管理性能数据是一项具有挑战性的任务。性能计数器、事件跟踪和日志可能会生成大量数据，分析和提取有用的信息需要合适的工具和技术。</p></li>
<li><p>更严格的约束条件：性能优化通常受到时间、资源和优先级等更严格的约束条件限制。有时，需要在有限的时间内取得显著的性能改进，而同时要考虑可用资源和其他任务的优先级。</p></li>
</ol>
<p>一旦真正的性能瓶颈被确定，就会有机会进行优化，可以采取以下方法：</p>
<ol type="1">
<li><p>软件调优/优化：对应用程序的代码进行调优，消除性能瓶颈和低效操作。这可能涉及算法改进、代码重构、并行化等技术。</p></li>
<li><p>工作负载特性分析：深入分析工作负载的特点和行为，了解其对系统的需求和资源利用模式。这有助于针对性地优化和配置系统以满足特定工作负载的需求。</p></li>
<li><p>基于剖析的优化：使用剖析工具收集应用程序的运行时数据，例如函数调用频率、循环迭代次数等，以指导优化决策。通过剖析数据，可以针对性地优化关键代码路径和热点。</p></li>
<li><p>云中的资源利用：在云计算环境中，性能优化还涉及到合理利用云服务提供的资源。根据工作负载的需求，动态分配和释放资源，以实现更高的性能和效率。</p></li>
</ol>
<p>性能优化是一个迭代的过程，需要持续监测和改进。通过克服上述挑战，利用合适的工具和技术，可以实现系统的性能提升和资源利用的优化。</p>
<h1 id="section-1">3</h1>
<p>顶层分析（Top Down
Analysis）是一种识别真正瓶颈的方法，具有以下特点：</p>
<ul>
<li>简单：采用结构化的层级方法。通过几个步骤即可追溯到最底层的问题点。</li>
<li>快速：能够快速定位到问题的根源。</li>
<li>实用：被生产环境中的工具所采用，例如VTune[2]。</li>
</ul>
<p>这种方法本身很简单：首先对CPU执行时间进行高层次的分类。这一步会标记（报告高分数）一些可能需要调查的领域。接下来，用户可以深入研究这些被标记的领域，并可以安全地忽略所有未被标记的领域。该过程以分层方式重复进行，直到确定特定的性能问题，或者至少确定了一小部分候选问题，可以进行进一步调查。</p>
<p>顶层分析的好处包括：</p>
<ul>
<li>使非专家用户更容易进行分析，简化了微架构的学习曲线。 假设</li>
<li>目标是检测瓶颈，而不是量化加速效果。</li>
<li>分析过程的一个子层级包括系统、应用程序和微架构。</li>
</ul>
<p>通过顶层分析方法，可以更轻松地识别系统中的瓶颈，使分析过程更加简化和实用。</p>
<h1 id="section-2">4</h1>
<p>顶层启发式：
顶层启发式是指在解决问题或做决策时，基于经验或常识的一般原则或指导方针。它们可以帮助人们在面对复杂的情况时快速做出决策或采取行动。</p>
<h1 id="section-3">5</h1>
<p>intel内核微架构</p>
<p>Where and How to start in this Complex microarchitecture?</p>
<p>从鸟瞰角度来看，现代乱序CPU的流水线主要由前端和后端两个部分组成。前端负责从内存中获取指令并将其转换为微操作（uops）。这些uops被送到后端部分进行调度、执行和提交（retire），按照原始程序的顺序。为了保持机器的平衡，已经准备好供后端使用的uops通常会被缓存在某个“ready-uops-queue”中。</p>
<h1 id="挑战">6 挑战</h1>
<p>传统方法： • 傻瓜式方法 - 停顿周期 = Σ 惩罚i * 错误事件i •
不适用于乱序（间隙）情况 1) 停顿重叠 数据cache miss和指令cache
miss同时发生 2) 推测执行
来自错误路径的事件比来自正确路径的事件更不重要。 3) 工作负载相关的惩罚
而天真方法假设所有工作负载的惩罚都是固定的。例如，分支之间的距离可能增加错误预测的成本。
如果目标地址距离过远，预测的目标地址可能不会立即可用，导致预测错误和流水线的清空与填充，从而降低了处理器的性能
4) 预定义的错误事件集合
这些复杂的微架构存在许多可能的故障，而只有最常见的子集由专用事件涵盖。
5) 超标量不准确性
CPU可以在一个周期内发射、执行和退役多个操作。一些（例如客户端）应用程序由于流水线的带宽限制而受到限制，因为通过越来越多的技术来减轻延迟。</p>
<p>自顶向下分析： • 一个层次结构 - 在适当的流水线阶段指定自顶向下事件 -
"层次安全属性" • 解决间隙问题 - 顶部的错误推测 -
通用的自顶向下事件，对计数的时间和位置都有影响 - 占用事件</p>
<p>“Bad Speculation”放置在顶层 涵盖了 错误预测而引起的停顿 以及
执行错误路径而浪费的资源</p>
<p>我们引入了一打真正的“自上而下”指定的计数器，以便处理其他问题。
我们发现，在解决问题（1）和（3）时，确定要查看的流水线阶段和“计数的时机很重要。
例如，我们不仅仅检查总内存访问持续时间，而是仅检查由于待定内存访问而导致执行单元利用率不足的子持续时间。
通过调用与“专用缺失事件”无关的通用事件，我们可以处理问题（4）。
其中一些是占用事件，用于处理问题（5）。</p>
<h1 id="section-4">7</h1>
<p>首先概述层次结构</p>
<p>流水线槽被分为四个基本类别：退役（Retiring）、坏预测（Bad
Speculation）、前端受限（Frontend Bound）和后端受限（Backend
Bound）。</p>
<h1 id="section-5">8</h1>
<p>以一个受 数据缓存性能限制 的工作负载为例。
该方法标记了后端受限（Backend Bound），而前端受限（Frontend
Bound）不会被标记。这意味着用户需要下一步深入研究后端受限（Backend
Bound）类别，而忽略所有与前端相关的问题。 在深入研究后端受限（Backend
Bound）时，如果应用程序被认为对缓存敏感，那么会标记内存受限（Memory
Bound）类别。
类似地，在这一点上，用户可以跳过非内存相关的问题。接下来，进行内存受限（Memory
Bound）的深入研究。 L1、L2和L3-Bound自然地细分了内存受限（Memory
Bound）类别。每个类别表示工作负载受到该缓存级别限制的部分。L1受限（L1
Bound）应该在那里被标记。
该方法最终会建议用户将注意力集中在这个领域上。</p>
<h1 id="section-6">9</h1>
<p>在高度复杂的微架构中，首先需要对流水线活动进行一级分类。第一个有趣的问题是如何以及在哪里进行第一级分解？我们选择问题点（在图1中用星号标记）作为自然的边界，将机器的前端和后端部分分割开来。这样可以实现高度准确的最高级别分类。</p>
<p>在问题点上，我们将每个流水线槽分类为四个基本类别：前端受限（Frontend
Bound）、后端受限（Backend Bound）、坏预测（Bad
Speculation）和退役（Retiring），</p>
<p>如图3所示。如果在给定的周期内发出了一个微操作（uop），它最终将被退役或取消。因此，它可以分别归属于退役或坏预测类别。</p>
<p>否则，流水线槽可以被分为是否存在后端停顿。后端停顿是后端在资源不可用（例如缺少加载缓冲区条目）时施加的反压机制。在这种情况下，我们将停顿归因于后端，因为即使前端准备好了更多的微操作，它也无法将它们传递到流水线中。
如果没有后端停顿，这意味着前端在后端准备接收微操作时应该已经传递了一些微操作；因此，我们将其标记为前端受限。</p>
<p>分类是以流水线槽的粒度进行的</p>
<p>100%的退役对应于达到给定微架构每个周期最大可退役的uops数。例如，假设一个指令解码成一个uop，50%的退役意味着在一个四路发射机器上实现了IPC为2。</p>
<p>然而，高退役值并不一定意味着没有提升性能的空间。诸如浮点（FP）辅助之类的微码序列通常会降低性能，可以避免使用<a
href="#section-4">7</a>。它们在微序列度量下被隔离，以引起用户的注意。</p>
<p>对于非矢量化代码，高退役值可能是用户矢量化代码的一个好的提示。这样做实际上使得更多的操作可以由单个指令/uop完成，从而提高性能。</p>
<h1 id="section-7">12</h1>
<p>计数器架构是指在计算机系统中用于性能监测和分析的计数器的结构和组织方式。</p>
<p>我们假设有一个基线的常见性能监控单元（PMU），它具有有限数量的通用计数器，但这些计数器可以用于计算多个性能事件。我们需要一组性能事件来捕获关键层级节点（以实现对性能层次结构节点的特征化），其中只有8个是新的TopDown事件，其余的已经存在于PMU中。</p>
<p>（PMU是一个硬件组件，负责监测和测量计算机系统的各种与性能相关的指标。它提供计数器，可以编程以计算特定的事件，例如缓存失效、分支指令或内存访问。）</p>
<p>以 Frontend Bound（前端受限）为例，该架构使用了以下指标和事件：</p>
<ul>
<li>TopDown 事件：
<ul>
<li>FetchBubbles：未被利用的发射流水线插槽，且没有后端停顿。</li>
<li>TotalSlots：发射流水线插槽的总数（例如，英特尔处理器中为
4*时钟周期）。</li>
</ul></li>
<li>TopDown 指标：
<ul>
<li>Frontend Bound（前端受限）= FetchBubbles / TotalSlots。</li>
</ul></li>
</ul>
<p>这个指标可以用来衡量前端是否限制了整体性能，即是否有大量未被利用的发射流水线插槽导致性能瓶颈。</p>
<h1 id="section-8">13</h1>
<p>事件名称：总槽位数（TotalSlots） 定义：总的发射流水线槽位数量。
解释：该事件用于统计线程未停顿的时钟周期数，可用于估计处理器的工作负载。</p>
<p>事件名称：发射槽位利用数（SlotsIssued）
定义：用于发射操作的已利用发射流水线槽位数量。
解释：该事件统计发射的微操作数量，包括任何类型的微操作。</p>
<p>事件名称：退休槽位利用数（SlotsRetired）
定义：用于退休（完成）操作的已利用发射流水线槽位数量。
解释：该事件统计已退休（完成）的微操作数量，即已成功执行的操作数量。</p>
<p>事件名称：取指气泡（FetchBubbles）
定义：在没有后端停顿的情况下未利用的发射流水线槽位数量。
解释：该事件用于统计未交付到指令队列的微操作数量，表示未利用的发射槽位数量，当发射流水线上没有后端停顿时。</p>
<p>事件名称：恢复气泡（RecoveryBubbles）
定义：由于从先前的错误预测中恢复而未利用的发射流水线槽位数量</p>
<h1 id="section-9">14</h1>
<p>在顶层（Top Level），图5a显示了基准测试应用程序的多样化分布。
从性能角度来看，Retiring类别接近50%，与相同一组运行的聚合IPC约为1.7相符。请记住，100%的Retiring意味着每个周期有四个已退休的uop，而对于SPEC
CPU2006，平均而言，一个指令被解码成略多于一个uop。请注意，Retiring与IPC的相关性良好，这是为了与已建立的指标进行交叉验证。</p>
<p>整体上，Backend Bound占主导地位。</p>
<p>整数型应用程序对前端限制（Frontend Bound）和错误预测（Bad
Speculation）更为敏感，而浮点型应用程序则相对较不敏感。
这与使用专有的逐周期模拟器进行的模拟数据以及Jaleel的先前分析一致。例如，Jaleel的分析报告称gcc、perlbench、xalancbmk、gobmk和sjeng的代码占用空间超过32KB，它们被归类为前端限制最严重的工作负载。请注意，通过这种分类方式，可以更容易地评估多个瓶颈的相对重要性。</p>
<h1 id="section-10">15</h1>
<p>在微架构的支持方面，Haswell（第四代Core处理器）改进了前端部分。它引入了具有更好时序的预测性iTLB（指令翻译缓冲器）和缓存访问，以提高预取的效益。</p>
<p>这些改进使得受益于此的基准测试清楚地显示了前端受限的减少。这意味着在Haswell处理器上使用Top
Down
Analysis（自顶向下分析）时，可以更好地识别和分析前端部分对性能的影响。</p>
<h1 id="section-11">16</h1>
<p>在运行4个副本的情况下，
顶层显示与单个副本相似，但仔细观察，<strong>某些应用程序确实表现出更大的Backend
Bound</strong>。根据图6b中更大的Memory
Bound比例，这些是内存敏感型应用程序。这是可以预期的，<strong>因为L3缓存在核心之间是“共享”的</strong>。由于每个物理核心中都运行着相同的线程，并且给定CPU2006几乎没有i-cache缺失，因此4个副本中的前端限制（Frontend
Bound）和错误预测（Bad Speculation）与单个副本几乎没有变化。</p>
<p>对于不太可扩展的应用程序，将Figure 6c与Figure 5c
4进行比较可以看出，Memory Bound的细分指向了<strong>核外争用</strong>。
主要差异出现在两类应用程序中，一类是<strong>对可用内存带宽敏感的应用程序</strong>，另一类是受到线程之间共享缓存竞争影响的应用程序。其中一个例子是470.lbm，它以其高内存带宽需求而闻名<a
href="#section-7">12</a>。在1个和4个副本之间，其大型的MEM
Bound是主要的差异。</p>
<p>另一个重要的例子是482.sphinx3。仔细观察Memory
Bound的细分可以发现，4个副本的L3 Bound减少，而MEM
Bound大幅增加；共享L3缓存中的线程之间的容量竞争导致更多的L3缺失。这个结论可以通过查看此工作负载的工作集进行验证[11]：单个副本在1个副本中需求8MB（与LLC容量相同），而4个副本运行时每个核心的LLC共享为2MB有效。</p>
<h1 id="section-12">17</h1>
<p>在这个案例研究中，我们以"Matrix
Multiply"（矩阵乘法）为例进行了迭代的Top-Down分析。下面是具体的分析过程：</p>
<ol type="1">
<li><p>初始情况：矩阵较大，内存访问是性能的瓶颈（MEM
Bound）。这意味着矩阵乘法的执行受限于内存访问速度，而不是处理器的计算能力。</p></li>
<li><p>循环交换（Loop
Interchange）：进行了12倍的循环交换优化。通过重新排列循环，可以更好地利用处理器的执行端口，从而减少了核心受限（CoreBound）的情况。现在，性能瓶颈不再是内存访问，而是处理器核心的利用率。</p></li>
<li><p>向量化（Vectorization）：经过向量化优化后，性能提升了17倍。向量化是利用处理器的向量指令集来并行处理多个数据元素的技术。这进一步减轻了核心受限的情况，提高了矩阵乘法的执行效率。</p></li>
<li><p>结果：通过这些优化步骤，multiply3（第三次优化后的矩阵乘法）成功减轻了核心受限的问题。这意味着处理器核心的利用率得到了更好的改善，从而提高了整体性能。</p></li>
</ol>
<p>这个案例研究说明了如何使用Top-Down分析来识别性能瓶颈并应用优化策略来改进矩阵乘法的执行效率。通过不断迭代分析和优化，我们能够逐步解决不同的性能限制，从而取得更好的性能结果。</p>
<p>使用Top-Down对矩阵相乘的经典内核进行了分析。这展示了性能调优的迭代性质。</p>
<p>在multiply()函数的初始代码中，由于大矩阵以不友好的方式遍历，它非常受限于内存。这导致了内存限制。</p>
<p>通过在multiply2()中应用循环交换优化，获得了显著的加速。优化后的代码仍然受限于后端，但从内存限制转变为受核心限制。</p>
<p>接下来，在multiply3()中尝试进行向量化，它通过减少端口利用率和减少净指令数进一步提高了性能。这实现了另一个加速效果。</p>
<h1 id="section-13">18</h1>
<p>在相关的研究中，有一些与性能分析和优化相关的工作。以下是对这些研究的简要描述：</p>
<ol type="1">
<li><p><a href="#section-3">4</a>
使用了朴素方法：这些研究采用了一种简单的方法来进行性能分析，可能没有考虑到复杂的因素和优化策略。</p></li>
<li><p>[6] IBM POWER5：该研究使用了IBM
POWER5处理器，并在提交阶段对CPI进行了分解，并统计了各种类型的下一条指令的停顿周期。</p></li>
<li><p><a href="#section-3">5</a>
周期计算（x-Intel）：这项研究在执行阶段对周期进行了详细的分解，以提供更详细的性能信息。</p></li>
<li><p>[1][6]<a href="#section-5">8</a>
CPI堆栈：这些研究使用基于模拟的间隔分析，以改进性能分析的准确性，相比于朴素方法有所提高。然而，这些方法可能需要更高的硬件成本，并且在某些情况下需要额外的逻辑用于惩罚计算和聚合。</p></li>
<li><p><a href="#section-8">12</a>
数据局部性和可扩展性瓶颈：这些研究使用基于仪器和模拟的工具，针对数据局部性和可扩展性瓶颈进行分析。一旦发现内存受限情况，可以调用高级的优化特定技术来进行优化。</p></li>
</ol>
<p>这些研究与性能分析和优化相关，提供了不同的方法和技术来理解和改进计算机系统的性能。在使用Top
Down进行性能分析时，可以借鉴这些研究的成果，并结合具体的问题和目标进行相应的分析和优化。</p>
<h1 id="section-14">19</h1>
<p>总结如下：</p>
<ul>
<li><p>Top
Down分析方法：该方法可以识别关键的瓶颈，它简单、结构化且快速。它已经在许多工作负载中得到验证，并在生产环境中使用，例如VTuneTM和perf*。此外，它还具有与Intel核心的向前兼容性。</p></li>
<li><p>计数器架构：为了支持通用的乱序处理器，设计了计数器架构。它使用了8个简单的事件，成本较低，并且在不同平台之间实现了标准化。</p></li>
</ul>
<p>作者鼓励读者查看他们的论文，并提供反馈意见。</p>
]]></content>
      <categories>
        <category>体系结构</category>
        <category>Topdown</category>
      </categories>
      <tags>
        <tag>Paper</tag>
        <tag>Pre</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈</title>
    <url>/zyhjy/2023/08/04/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    <content><![CDATA[<h1 id="单调栈monotone-stack">单调栈(monotone-stack)</h1>
<p>单调栈，即满足单调性的栈，与普通的栈相比，就是在入栈时将不满足要求栈顶的元素弹出。</p>
<p>比如，我们要维护一个从栈底到栈顶单调减少的栈，在某次操作前，栈内有元素：<code>(bottom) 12, 8, 5, 1 (top)</code>;
此时要将7入栈，由于7
大于栈顶元素<code>1,  5</code>,于是需要将其弹出，再将7入栈，此时栈为<code>(bottom) 12, 8, 7 (top)</code>。</p>
<p>单调栈本身很好理解，主要是做题的时候，
如何将题目转化为用单调栈的思路，接下来通过几个例题分析。</p>
<span id="more"></span>
<h2 id="leetcode-402.-移掉-k-位数字">LeetCode 402. 移掉 K 位数字</h2>
<p><a href="https://leetcode.cn/problems/remove-k-digits/">402. 移掉 K
位数字</a></p>
<p>给你一个以字符串表示的非负整数 <code>num</code> 和一个整数
<code>k</code> ，移除这个数中的 <code>k</code>
位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。</p>
<p><strong>示例 1 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = &quot;1432219&quot;, k = 3</span><br><span class="line">输出：&quot;1219&quot;</span><br><span class="line">解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = &quot;10200&quot;, k = 1</span><br><span class="line">输出：&quot;200&quot;</span><br><span class="line">解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = &quot;10&quot;, k = 2</span><br><span class="line">输出：&quot;0&quot;</span><br><span class="line">解释：从原数字移除所有的数字，剩余为空就是 0 。</span><br></pre></td></tr></table></figure>
<h3 id="思路">思路</h3>
<p>首先观察示例1，"1432219"若要去除一个数字，肯定选4，因为3 &lt;
4,所以132XXX &lt; 142XXX,；之后同理，去除3，因为12XXX &lt;
13XXX;一般地，<span
class="math inline">\(L_0...L_{i-1}L_iL_{i+1}...L{n}\)</span>,
<strong>如果<span class="math inline">\(L_{i-1} &gt;
L_i\)</span>，肯定考虑删除<span
class="math inline">\(L_{i-1}\)</span></strong>。</p>
<p>这样就和单调栈联系起来了，因为左边高位的优先级高于右边低位，所以我们从左到右，每次向栈中放入一个数字，如果当前数字小于小于栈顶元素，则将栈顶元素剔除，始终保持单调栈单调递增，再根据题目限制适当修改，栈底到栈顶即为最终答案。</p>
<h2 id="leetcode-316.-去除重复字母">LeetCode 316. 去除重复字母</h2>
<p><a href="https://leetcode.cn/problems/remove-duplicate-letters/">316.
去除重复字母</a></p>
<p>给你一个字符串 <code>s</code>
，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证
<strong>返回结果的字典序最小</strong>（要求不能打乱其他字符的相对位置）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;bcabc&quot;</span><br><span class="line">输出：&quot;abc&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;cbacdcbc&quot;</span><br><span class="line">输出：&quot;acdb&quot;</span><br></pre></td></tr></table></figure>
<h3 id="思路-1">思路</h3>
<p>题目要求每个字母只出现一次，所以只出现过一次的字母肯定是不能删除的，</p>
<p>要求字典序最小，类似上一题要求剩下的数字最小，肯定是<strong>小的字母尽量排在前面</strong>。与上一题思路相同，考虑单调栈，<strong>每次压入字母c时需弹出栈顶字典序大于c的的字母</strong>。</p>
<p>但是，题目要求出现一次，所以开始时先统计每个字母的个数；每次单调栈需要弹出时，如果栈顶字母只剩一个，则不可弹出；否则，弹出且对计数-1；另外记录已经入栈且未被弹出的字母，后续遇到则不需入栈。</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>性能分析工具--Valgrind, perf, pin</title>
    <url>/zyhjy/2023/08/05/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7-Valgrind-perf-pin/</url>
    <content><![CDATA[<h1 id="性能分析工具--valgrind-perf-pin">性能分析工具--Valgrind, perf,
Pin</h1>
<p>对比主流性能分析工具。</p>
<span id="more"></span>
<h2 id="valgrind">Valgrind</h2>
<p><a
href="https://valgrind.org/">Valgrind</a>是一个用于动态分析和调试的开源工具，它的主要功能是在不修改源代码的情况下，监测和分析程序的执行行为、内存使用以及性能瓶颈。Valgrind通过将目标程序解释成自己的中间表示，对程序执行过程中的内存访问和指令执行进行监视和控制。</p>
<p>Valgrind是<strong>开源</strong>的。</p>
<h3 id="原理">原理</h3>
<p>Valgrind的主要原理是<strong>动态二进制翻译</strong>（Dynamic Binary
Translation，DBT）。具体来说，Valgrind会将目标程序的机器码翻译成一种称为"Valgrind
Intermediate
Representation"（VIR）的中间表示。然后，在VIR的基础上，Valgrind会插入额外的代码来监测内存读写、分支执行、函数调用等情况。这样，Valgrind可以捕获程序在运行时的行为，同时检测可能的内存错误、泄漏、未初始化变量等问题。</p>
<p>Valgrind主要包括以下几个部分：</p>
<ol type="1">
<li><p><strong>前端（Front-End）：</strong>
前端负责将目标程序的二进制代码转换成VIR。这个过程中，Valgrind会将插桩代码注入到目标程序中，以便进行监控和分析。</p></li>
<li><p><strong>中间层（VIR）：</strong>
VIR是Valgrind自己定义的一种中间表示。Valgrind在这个中间表示上进行监控和分析，而不是直接在原始机器码上操作。</p></li>
<li><p><strong>后端（Back-End）：</strong>
后端负责执行VIR上的代码，模拟程序的执行过程，并在必要时触发插桩代码。Valgrind会记录执行过程中的内存访问、分支预测等信息。</p></li>
<li><p><strong>工具（Tools）：</strong>
Valgrind提供了不同的工具，用于检测不同类型的问题，如Memcheck用于内存错误检测，Cachegrind用于性能分析等。</p></li>
</ol>
<h3 id="主要工具">主要工具</h3>
<p>Valgrind 主要包括以下几个工具：</p>
<ol type="1">
<li><p><strong>Memcheck：</strong> Memcheck 是 Valgrind
最常用的工具，用于检测内存错误。它会跟踪程序中每个字节的读写情况，检测未初始化的变量、内存越界、内存泄漏等问题。</p></li>
<li><p><strong>Cachegrind：</strong> Cachegrind
用于进行高级的缓存和分支预测分析。它可以估计程序执行时的缓存命中率，帮助你优化程序以减少缓存未命中。</p></li>
<li><p><strong>Callgrind：</strong> Callgrind
用于生成函数调用图和分析函数调用的性能。它可以帮助你了解程序中不同函数之间的调用关系，以及函数调用所花费的时间。</p></li>
<li><p><strong>Helgrind：</strong> Helgrind
用于检测多线程程序中的竞态条件和同步问题。它可以帮助你发现线程之间的竞争条件，以及可能导致死锁和数据竞争的地方。</p></li>
<li><p><strong>Massif：</strong> Massif
用于内存分析，可以帮助你找出程序中内存的使用情况和泄漏情况。</p></li>
</ol>
<hr />
<h2 id="pin">Pin</h2>
<p><a
href="https://www.intel.com/content/www/us/en/developer/articles/tool/pin-a-dynamic-binary-instrumentation-tool.html">Pin</a>是一个动态二进制插桩工具，用于在程序执行期间插入自定义代码，以监视和分析程序的行为。</p>
<p>Intel Pin是<strong>开源</strong>的。</p>
<p><strong>功能和用途：</strong> -
Pin允许开发人员在不修改程序源代码的情况下，通过插入代码来监视和分析程序在执行时的行为。
- 它可以用于性能分析、内存调试、代码覆盖率分析、安全研究等领域。</p>
<p><strong>主要原理：</strong> -
Pin使用了<strong>JIT（Just-In-Time）</strong>编译技术，它将目标程序的二进制代码进行动态重编译，插入自定义的插桩代码，然后执行重编译后的代码。
-
在插桩代码中，开发人员可以实现自己的分析逻辑，如收集统计信息、记录内存访问、检测特定模式等。
-
Pin提供了API供开发人员编写插桩代码，这使得用户能够实现高度定制的程序分析。</p>
<hr />
<h3 id="tips-sbt-dbt-jit">tips : SBT, DBT, JIT</h3>
<p><strong>JIT</strong>（Just-In-Time）编译和<strong>DBT</strong>（Dynamic
Binary
Translation）都是与代码执行优化和分析相关的技术，但它们有一些区别。以下是它们的主要区别：</p>
<ol type="1">
<li><strong>定义：</strong>
<ul>
<li>JIT编译：JIT编译是一种将程序源代码或中间代码（如字节码）即时编译成机器码的技术。在程序执行过程中，JIT编译器会将部分代码编译成机器码，并直接在计算机上执行。这有助于提高代码的执行速度。</li>
<li>DBT：DBT是一种将目标程序的机器码翻译成另一种中间表示，然后在这个中间表示上进行监视、分析和修改的技术。这种翻译是在程序执行之前进行的。</li>
</ul></li>
<li><strong>执行时机：</strong>
<ul>
<li>JIT编译：JIT编译是在程序执行的过程中，动态地将代码从高级源代码或中间代码翻译成机器码。编译发生在程序运行时。</li>
<li>DBT：DBT的翻译阶段是在程序执行之前进行的。目标程序的机器码被翻译成另一种中间表示，然后在这个中间表示上进行分析。</li>
</ul></li>
<li><strong>实时性：</strong>
<ul>
<li>JIT编译：JIT编译可以实现实时性的优化，因为它是在程序执行过程中进行的。程序的执行速度可以因为
JIT 编译而获得即时的提升。</li>
<li>DBT：DBT的翻译是在执行之前进行的，这意味着翻译本身不会在程序运行时对执行速度产生影响。然而，DBT
之后的分析和监视可能会对性能产生一些影响。</li>
</ul></li>
<li><strong>应用领域：</strong>
<ul>
<li>JIT编译：常用于虚拟机环境（如Java虚拟机、.NET等），可以在运行时优化和执行中间代码。</li>
<li>DBT：常用于动态分析、调试和模拟，可以在执行之前对目标程序进行监控和修改。</li>
</ul></li>
</ol>
<p>尽管JIT编译和DBT在某些方面有一些相似之处，但它们的主要应用场景和执行时机有所不同。
JIT更侧重于提高执行速度，而DBT则更侧重于分析和监视程序的行为。</p>
<p>而<strong>静态二进制翻译</strong>（Static Binary
Translation，SBT）用于将一个架构的机器代码翻译成另一个架构的机器代码，而无需运行程序。这与动态二进制翻译（Dynamic
Binary
Translation，DBT）不同，后者是在程序运行时将机器代码翻译成中间表示，然后在中间表示上执行。</p>
<hr />
<h2 id="perf">perf</h2>
<p><code>perf</code>
是一个性能分析工具，用于在Linux系统上进行性能分析和调试。它可以帮助开发人员了解程序的运行时性能，找出瓶颈和优化机会。<code>perf</code>
提供了多种分析功能，包括性能计数器、事件跟踪、函数调用图等，用于收集和分析系统和应用程序的性能数据。</p>
<p><code>perf</code> 是<strong>开源</strong>的，它是 Linux
操作系统自带的一部分，用户可以在终端中直接使用 <code>perf</code>
命令。<code>perf</code>
工具的源代码也是开放的，用户可以查看其实现、贡献改进或自定义特定需求。</p>
<h3 id="主要原理">主要原理：</h3>
<p><code>perf</code> 基于 Linux
内核中的性能计数器子系统和事件跟踪机制。它使用硬件性能计数器来测量程序在
CPU 上的各种操作，如指令执行数、缓存命中率等。此外，<code>perf</code>
还可以使用事件跟踪机制，监视系统中的事件，如系统调用、函数调用、中断等。</p>
<p><code>perf</code> 的主要原理包括以下几个步骤：</p>
<ol type="1">
<li><p><strong>数据收集设置：</strong> 用户使用 <code>perf</code>
工具指定需要分析的事件、计数器等配置信息。</p></li>
<li><p><strong>性能计数器采样：</strong> <code>perf</code>
利用硬件性能计数器定期采样程序的运行时数据，如指令执行次数、缓存命中次数等。</p></li>
<li><p><strong>事件跟踪（可选）：</strong>
除了性能计数器，<code>perf</code>
还可以使用事件跟踪机制收集事件数据，如系统调用、函数调用、中断等。</p></li>
<li><p><strong>数据分析和报告生成：</strong>
采样数据被收集后，<code>perf</code>
将这些数据进行分析，并生成性能报告，包括热点函数、时间分布、缓存命中率等信息。</p></li>
</ol>
]]></content>
      <categories>
        <category>性能分析</category>
        <category>Valgrind</category>
        <category>perf</category>
        <category>pin</category>
      </categories>
  </entry>
  <entry>
    <title>Memory-Efficient Hashed Page Tables</title>
    <url>/zyhjy/2023/07/31/Memory-Efficient-Hashed-Page-Tables/</url>
    <content><![CDATA[<h1 id="memory-efficient-hashed-page-tables">Memory-Efficient Hashed
Page Tables</h1>
<p>该论文工作基于<em>Elastic Cuckoo Page Tables: Rethinking Virtual
Memory Translation for Parallelism</em>展开。</p>
<h3 id="摘要">摘要</h3>
<p>传统的基数树页表在可扩展性方面存在挑战，因为在TLB（转换后备缓冲器）未命中后，地址转换可能需要多次连续的内存访问。另一种选择是哈希页表（HPTs），在这种情况下，概念上地址转换只需要一次内存访问。传统上，由于处理冲突的成本高和其他限制，HPTs一直被回避。尽管最近的进展使得HPTs变得引人注目，HPT设计中的一个主要问题依然是它们对相当连续(
substantial <em>contiguous</em>)的物理内存的需求。</p>
<p>本文解决了这个问题。为了最小化HPTs对连续内存的需求，它引入了<em>逻辑到物理表</em>（<em>Logical
to Physical (L2P)
Table</em>）和<em>动态变化块大小</em>(<em>Dynamically-Changing Chunk
Sizes</em>)的使用。这些技术将HPTs分解成不连续的物理内存块。此外，本文还介绍了两种最小化HPTs总内存需求的技术，间接地降低内存的连续性需求。这些技术是<em>原地页表调整(</em>In-place
Page Table Resizing<em>)和逐路调整(</em>Per-way
Resizing<em>)。我们称这个完整的设计为</em>内存高效*的HPTs（ME-HPTs）。与最先进的HPTs相比，ME-HPTs:
(i) 平均减少了92%的连续内存分配需求，(ii)
平均提高了8.9%的性能。对于两个最要求的工作负载，连续内存需求从64MB减少到1MB。此外，与最先进的基数树页表相比，ME-HPTs
在平均速度上实现了1.23倍的加速（不使用大页面）和1.28倍的加速（使用大页面）。</p>
<span id="more"></span>
<hr />
<h4 id="tips">tips:</h4>
<p><strong>Radix tree</strong>（基数树），也称为 Patricia
tree（前缀树），是一种用于实现动态集合或关联数组的数据结构。它通常用于在计算机科学中高效地存储和查找大量的键-值对。</p>
<p>基数树的特点在于它将键按照前缀进行分割，并将每个前缀存储在树的节点上。这样做可以大幅减少树的高度，从而提高查找效率。基数树的每个节点可以包含一个或多个字符，而不是像二叉查找树那样每个节点只能包含一个键。</p>
<p>由于基数树在每个节点上都存储了部分键，所以在查找时，只需要按照键的前缀逐级搜索树，而无需遍历整个树。这使得基数树在某些情况下比传统的平衡树结构（如红黑树）更加高效。</p>
<p>基数树通常用于处理字符串的搜索和匹配问题，比如在字典中查找单词，路由表中查找IP地址，以及许多其他数据检索的场景。在操作系统中，基数树常用于虚拟内存管理，特别是在页表结构中，用于将虚拟地址映射到物理地址。</p>
<hr />
<h2 id="introduction">1. INTRODUCTION</h2>
<p>目前最先进的页表使用基数树（radix-tree）组织[5]，[42]。在TLB未命中时，地址转换通过遍历一个页面树来进行，该树逐步将搜索导向包含所需转换的叶子节点。这种方法高效地使用内存，并经过几十年的多重缓存结构优化。然而，它的可扩展性很差。原因在于，为了获得正确的转换，系统可能需要<em>依次</em>执行高达四次内存访问。每次访问都使用前一次访问返回的值作为其地址。这个过程可能很慢，并且无法充分利用现代处理器提供的内存级并行性。此外，随着另一层被添加到转换树中以满足新兴应用程序更大的内存需求[40]，[41]，这个过程变得越来越慢。</p>
<p>基数树页表的替代方案是哈希页表（hashed page
tables，简称HPTs）[18]，[24]，[26]，[33]，[36]，[37]，[39]，[44]，[45]，[77]，[83]，[88]。在这里，转换信息被保存在一个表中。在TLB未命中时，地址转换通过哈希虚拟页号，并使用哈希键索引表来获取物理页号。假设没有哈希冲突，这种方法只需要进行一次内存访问即可完成地址转换。</p>
<p>传统上，哈希页表（HPTs）由Barr等人[9]指出至少有三个不受欢迎的原因。首先，访问页表缺乏空间局部性。这是因为哈希散布了相邻虚拟页面的转换。其次，需要将哈希标签（即虚拟页号）与每个HPT条目关联，这会消耗空间。最后，处理哈希冲突是昂贵的：要么需要复杂的硬件，要么操作系统需要遍历冲突的条目[9]，[39]，[88]。</p>
<p>另一个问题是，理论上的一个单一全局HPT来保存机器中所有活动进程的页表条目是行不通的[24]，[83]，[88]。原因在于，为了支持进程之间的页面共享和多种页面大小，需要在转换中添加额外的间接级别。此外，在进程终止时，需要顺序搜索HPT以删除过时的条目和修复冲突。另一种方法是使用每个进程一个HPT，但这种方法很具有挑战性[77]，因为不清楚如何设置每个进程的HPT大小。为每个进程分配大型HPT会导致内存耗尽的风险。</p>
<p>近期的进展使HPTs变得更加引人注目。例如，为了改善HPT的局部性，Yaniv和Tsafrir[88]将多个连续的页表条目放在一个单独的缓存行中。此外，他们使用未使用的位对每个条目编码哈希标签。另外，Skarlatos等人[77]使用Cuckoo哈希来有效处理哈希冲突。此外，他们通过在创建进程时分配小型HPT，并使用弹性Cuckoo哈希相对廉价地动态增长HPTs来支持每个进程的HPTs。</p>
<p>然而，HPT设计的一个重要缺点是它们需要相当数量的<em>连续</em>物理内存。这个需求源于明显需要将HPT（或者更精确地说，每个HPT的分支）放在连续的物理内存中。在我们的测量中，一个HPT分支可以达到64MB。在实践中，在繁忙的计算机中分配一个大块连续内存通常是耗时的，并且在某些情况下可能导致程序失败。相比之下，在基数树页表中，找到连续的内存并不是一个问题，因为内存是一次分配一个页面。</p>
<p>本论文解决了HPT的这个缺陷。为了最小化HPT对连续内存的需求，我们引入了两种技术：<em>逻辑到物理表</em>和<em>动态变化块大小</em>的使用。这些技术将HPT分解成内存高效、不连续的物理内存块。此外，我们还引入了另外两种技术，最小化HPT的总内存需求，并间接地减少了内存的连续性要求。这些技术是<em>原地页表调整</em>和<em>逐路调整</em>。我们将得到的设计称为<em>内存高效</em>的HPTs（ME-HPTs）。</p>
<p>我们通过全系统模拟运行一组内存密集型工作负载来评估ME-HPTs。与最先进的HPT相比，ME-HPTs：(i)
平均减少了92%的连续内存分配需求，(ii)
平均提高了8.9%的性能。对于两个最要求的工作负载，连续内存需求从64MB减少到1MB。此外，与最先进的基数树页表相比，ME-HPTs
在平均速度上实现了1.23倍的加速（不使用大页面）和1.28倍的加速（使用大页面）。</p>
<p>本文的贡献包括：</p>
<ul>
<li>内存高效的HPTs（ME-HPTs），引入了四种新技术，直接或间接地最小化了HPT需要的连续物理内存。</li>
<li>对ME-HPT技术的评估，表明它们解决了HPT的内存连续性限制问题。</li>
</ul>
<h2 id="background">2. BACKGROUND</h2>
<h3 id="a.-limitations-of-radix-tree-page-tables"><em>A. Limitations of
Radix-Tree Page Tables</em></h3>
<p>当前处理器主要使用基数树（radix-tree）页表，这种页表以树的形式进行组织。在TLB未命中时，硬件按顺序遍历树的每个级别。图1显示了x86-64翻译的过程，它在搜索对应于虚拟地址（VA）的物理地址（PA）时，需要访问四个<em>连续</em>的页表：PGD（Page
Global Directory）、PUD（Page Upper Directory）、PMD（Page Middle
Directory）和PTE（Page Table Entry）。</p>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230731142926230.png"
alt="image-20230731142926230" />
<figcaption aria-hidden="true">image-20230731142926230</figcaption>
</figure>
<p>现代处理器使用小的Page Walk Caches (PWCs)
[2]，[9]，[12]，[13]来缓存中间页表条目，以避免在每一步中访问内存。然而，许多新兴应用程序会溢出这些缓存，导致关键路径上出现多次连续的内存访问。此外，制造商正在增加转换树中的级数。例如，新的英特尔Sunny
Cove
[40]，[41]在树中添加了第五级。然而，随着非易失性存储器的出现，非常大的内存可能会出现，这种方法几乎没有可扩展性。</p>
<h3 id="b.-hashed-page-tables"><em>B. Hashed Page Tables</em></h3>
<p>哈希页表（Hashed page
tables，简称HPTs）[18]，[24]，[26]，[33]，[36]，[37]，[39]，[44]，[45]，[77]，[79]，[83]，[88]采用了不同的设计。在TLB未命中时，地址转换通过对虚拟页号（VPN）进行哈希，并使用哈希键索引页表来完成。假设没有哈希冲突，地址转换只需要一次内存访问。HPTs已经在IBM
PowerPC [38]，HP PA-RISC [37]和Intel Itanium [39]架构中实现。</p>
<h4 id="challenges-of-hashed-page-tables.">Challenges of Hashed Page
Tables.</h4>
<p>哈希页表（HPTs）存在一些限制，导致业界不太青睐它们[9]。首先，HPT的访问失去了空间局部性。这是由于哈希散布了相邻虚拟页面的HPT条目。此外，需要将哈希标签与每个页表条目关联，这会消耗内存空间。最重要的是，哈希冲突会导致更多的内存访问，因为系统需要遍历冲突链[9]。诸如冲突链(collision
chaining)[39]和开放地址法(open
addressing)[88]等策略引入了昂贵的内存引用，用于遍历冲突的条目。</p>
<p>除此之外，无法通过简单的设计实现一个包含机器中所有活动进程的页表条目的单一全局HPT
[24]，[88]。原因在于，支持多种页面大小（例如，大页面）或进程之间的页面共享需要额外的复杂性。例如，为了支持这两个特性，IBM
PowerPC架构为每个内存引用使用了一个两级的转换过程[38]。此外，当一个进程被终止时，系统需要对整个HPT进行线性扫描，以找到并删除该进程的条目。不幸的是，删除一个条目的成本很高：可能需要长时间的哈希表查找（对于开放地址法）或者遍历冲突链。此外，在开放地址法中删除一个页表条目可能会影响未来查找中的冲突探测。</p>
<h4 id="making-hashed-page-tables-compelling.">Making Hashed Page Tables
Compelling.</h4>
<p>近期的研究解决了一些HPT的限制。例如，Yaniv和Tsafrir
[88]提出了一种HPT设计，使用了页表条目聚集，将多个连续的页表条目放在一个单独的HPT条目中，其大小等于一个缓存行。此外，他们还提出了页表条目压缩(Page
Table Entry
Compaction)，将多个连续的页表条目的未使用的高位用于存储哈希标签。</p>
<p>为了简化冲突处理，Skarlatos等人[77]，[79]提出在HPT中使用了Cuckoo哈希算法[64]。给定页面大小的HPT采用W路组相联的方式，每个路使用不同的哈希函数。要插入一个元素p，选择一条路，并将p插入其哈希位置。如果选定的条目已经被使用，当前占用者q将被挤出，并在另一条路中重新插入，在q的哈希位置上。如果该位置也被使用，就再次挤出占用者，并重复这个过程。该过程可能会多次重复。通过仔细设置允许的最大HPT占用量，可以选择一个合理的最大重插次数，使最终HPT条目被逐出的概率非常小。在Cuckoo哈希中，元素查找需要检查所有W路（并行进行）。</p>
<p>Skarlatos等人的设计[77]，[79]采用了<em>进程私有</em>的HPT（哈希页表）。与使用可能会在高负载机器上耗尽内存的默认每个进程的HPT大小不同，HPT开始时很小，并且可以<em>动态调整大小</em>。该方案被称为Elastic
Cuckoo Page
Tables（ECPTs）。当HPT占用量达到高阈值时，会触发一个<em>扩容</em>操作；当HPT占用量达到低阈值时，会触发一个<em>缩容</em>操作。这些扩容/缩容操作不会停止程序执行：它们会与程序执行高效地重叠。</p>
<h4 id="mechanics-of-an-hpt-upsize.">Mechanics of an HPT Upsize.</h4>
<p>当一个W路组相联的HPT占用量达到高阈值时，会分配一个新的双倍大小的W路组相联的HPT[77]。从此以后，每当操作系统被调用来将一个元素插入HPT时，操作系统会利用这个机会将一个元素从旧的HPT重新散列（即移动）到新的HPT。为了高效地执行<em>重新散列</em>，每个旧HPT的路i都添加了一个<em>重新散列指针</em>$P_i
<span class="math inline">\(。在每个路中，\)</span>P_i <span
class="math inline">\(最初指向HPT的基址。在从路i重新散列一个元素时，操作系统取\)</span>P_i
<span
class="math inline">\(指向的元素，将其插入到新的HPT的路i中，并将\)</span>P_i
<span class="math inline">\(递增。在任何时候，\)</span>P_i <span
class="math inline">\(将旧HPT的路i划分为两个区域：索引小于\)</span>P_i
<span
class="math inline">\(的条目（*迁移区域*）和索引等于或大于\)</span>P_i
$的条目（<em>存活区域</em>）。随着逐步重新散列的进行，旧HPT中的路的迁移区域不断增长。最终，当迁移区域完全覆盖所有路时，旧HPT将被释放。</p>
<p>在调整大小过程中，将元素p插入W路组相联的HPT的过程如下。系统随机选择旧HPT的一条路，并使用其哈希函数对p进行哈希。如果哈希键落在该路的存活区域内，元素将被插入到旧的HPT中；否则，p将使用新HPT的相同路的哈希函数进行哈希，并将元素插入新HPT中。通过这种设计，在调整大小期间查找元素p只需要W次探测(probes,
探测不等于哈希，探测是指根据hash结果去找对应的entry，涉及一次内存访问)。事实上，p是使用旧HPT的所有哈希函数进行哈希的。对于每条路i，如果哈希键落在存活区域，将对旧HPT的路进行探测；否则，p将使用新HPT中相同路的哈希函数进行哈希，并对新HPT的路进行探测。这样，通过利用已有的旧HPT和新HPT的哈希函数，可以高效地实现元素的插入和查找过程。</p>
<h2 id="motivation-for-improving-hpts">3. MOTIVATION FOR IMPROVING
HPTS</h2>
<p>虽然前面提到的进展使HPTs具有竞争力，但HPTs仍然有一个重要的限制：它们需要分配相当数量的连续物理内存。这在表I中有所体现，该表列出了我们在本研究中分析的一些应用程序的特性。这些应用程序将在第VI节中进行讨论。</p>
<p>在表I中，可能会看到这些应用程序对于HPT的内存需求较大，并且需要大块的连续物理内存来存储它们的页表数据结构。这可能会导致在繁忙的系统中分配这些大块连续内存成为一个耗时的过程，并且在某些情况下可能会导致程序执行失败。因此，HPT设计中如何减少对连续物理内存的需求仍然是一个重要的挑战，值得进一步研究和解决。</p>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230731150538530.png"
alt="image-20230731150538530" />
<figcaption aria-hidden="true">image-20230731150538530</figcaption>
</figure>
<p>表中的第2列显示了应用程序数据的最大内存消耗。第3列和第4列分别显示了使用基数树和ECPT组织的页表分配的最大<em>连续</em>内存。在基数树组织中，连续内存始终为4KB，这是一个页面的大小。在ECPT组织中，所显示的数字是HPT一路（way）的最大大小。<em>直观地说</em>，一个组相联的HPT的每个路都需要在连续的物理内存块中进行分配。ECPT的这些数字对应于没有用于应用程序数据的<strong>透明大页面</strong>（transparent
huge pages
，THP）[85]的环境，这是最不利的情况。从表中可以看出，两个应用程序中的HPT一路使用了64MB的连续内存。</p>
<p>在繁忙的服务器中分配大块连续内存是昂贵的，尤其是当内存高度碎片化时。我们在一个基于Linux的服务器上进行了实验，使用了一个开源的碎片化工具[1]来测试不同碎片化水平下的性能。我们测得，在2
GHz和0.7碎片化（即较高）的FMFI度量[32]，[49]中，分配和清零4KB、8KB、1MB、8MB和64MB内存块分别需要4K、5K、750K、13M和120M个周期。这些数据与先前的测量结果一致[49]。随着块大小的增加，开销增加得更快。<em>更重要的是</em>，当我们将内存碎片化程度提高到0.7以上时，系统无法分配64MB的连续内存，并返回错误。因此，ECPT的运行无法完成。</p>
<p>第5列至第8列显示了使用基数树和ECPT组织的页表在没有和使用THP的情况下的最大内存消耗。可以看出，与没有THP的基数树相比，ECPT的页表内存使用量平均增加了138%；与使用THP的基数树相比，ECPT的页表内存使用量平均增加了128%。与应用程序数据消耗的内存相比，页表消耗的内存更高，但并不显著。然而，正如我们将在后面展示的那样，减少HPT的总内存消耗也有助于减少其对连续内存的需求。</p>
<hr />
<h4 id="tips-1">tips:</h4>
<p>透明大页面（<em>Transparent Huge
Pages</em>，简称THP）是一种内存管理技术，用于优化大内存页面的使用。在传统的页面管理中，内存被分成固定大小的页面，通常是4KB大小。然而，对于一些内存密集型应用程序或工作负载，使用更大的页面（比如2MB或1GB）可能会提高性能，因为更大的页面可以减少页表的大小，减少内存访问的开销。</p>
<p>THP允许操作系统动态地将多个连续的小页面合并成一个大页面，并将这些大页面透明地提供给应用程序。这样，应用程序无需修改代码，也无需知道大页面的存在，操作系统会自动将小页面合并为大页面，并对应用程序透明地提供更大的内存页面。</p>
<p>THP的使用可以提高内存访问效率和系统性能，特别是对于那些需要大量内存的应用程序。它是操作系统在内存管理方面的一项优化技术，可以有效地减少页表的大小，并降低内存访问的开销，从而提高系统的整体性能。</p>
<hr />
<h2 id="designing-memory-efficient-hpts">4. DESIGNING MEMORY-EFFICIENT
HPTS</h2>
<p>为了解决HPT（Hashed Page
Tables）连续性问题，我们提出了四种新的硬件辅助原语来实现内存高效的HPT。其中两种直接减少HPT需要的连续物理内存：(i)
<em>逻辑到物理（L2P）表</em>和(ii)
<em>动态更改块大小</em>。另外两种间接减少HPT需要的连续物理内存，通过减少HPT所需的总物理内存：(i)
<em>原地页表调整</em>(<em>In-place Page Table Resizing</em>)和(ii)
<em>逐路调整</em>(<em>Per-way Resizing</em>)。</p>
<h3 id="a.-logical-to-physical-l2p-table"><em>A. Logical to Physical
(L2P) Table</em></h3>
<p>如图2a所示，传统的HPT（Hashed Page
Table）路需要在一个连续的内存区域中进行分配。这是因为在TLB（Translation
Lookaside
Buffer）缺失时，虚拟页号（VPN）被进行哈希计算，得到的哈希键与HPT的基地址相加，从而得到对应的物理页号（PPN）的入口。这种设计不允许表中出现不连续性，这与基数页表不同。在我们的实验中，我们发现有些应用的HPT每个路需要高达64MB的内存。找到64MB连续内存通常是耗时的。此外，在内存高度碎片化的机器上，我们发现这会导致程序崩溃。</p>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230801181109866.png"
alt="image-20230801181109866" />
<figcaption aria-hidden="true">image-20230801181109866</figcaption>
</figure>
<hr />
<h4 id="tips-2">tips</h4>
<p>hash算出来的是vpn对应的entry的index。</p>
<hr />
<p>为了解决这个问题，我们提出了一种设计，将HPT的每个路（way）分成多个固定大小的<em>块</em>（Chunk），这些块不需要连续。然后，在内存管理单元（MMU）中添加一个小的间接表，称为<em>逻辑到物理（L2P）表</em>，用于将访问重定向到这些块。这种机制对软件透明，而且硬件高度局部化。通过合理选择参数，每个块只需要适量的连续内存，而L2P表足够小，具有可接受的访问时间。</p>
<p>如图2b所示，HPT的路被拆分为大小为<em>ChunkSize</em>（CS）的一组块。在TLB缺失时，VPN的哈希值被除以CS，并添加到L2P表的基地址。该位置的内容（如图2b中的b1）是一个指向包含所需PPN的块的基地址的指针。然后，VPN的哈希值取模CS，并添加到块的基地址，从而得到具有PPN的入口。</p>
<p>在任何时候，MMU只包含当前正在运行的进程的L2P表。在上下文切换时，操作系统保存和恢复L2P表。此操作的开销较低。原因是，正如我们将在后面看到的那样，L2P表不是很大，我们只需要保存和恢复正在使用的L2P表条目，这些条目平均只占所有条目的一小部分。</p>
<p>由于CS是2的幂，图2b中的除法和取模操作实际上是<em>位移和掩码</em>操作。因此，我们估计，在硬件中访问时，一个MMU驻留的L2P表将在基线页面遍历（如图2a所示）中增加约几个周期的开销。这种开销是完全可以接受的，至少对于HPT的Elastic
Cuckoo Page
Table（ECPT）实现来说。这是因为这种开销在大多数情况下可以通过与ECPT的Cuckoo
Walk Cache（CWC）访问的重叠来隐藏。我们将在第五节详细讨论细节。</p>
<h3 id="b.-dynamically-changing-chunk-sizes"><em>B. Dynamically Changing
Chunk Sizes</em></h3>
<p>为了最小化L2P表的访问时间，L2P表必须足够小，最多可以容纳几十个块的指针。因此，我们需要设置CS的值，以便所有这几十个块的组合能够容纳一个HPT路的所有条目。</p>
<p>在实践中，应用程序的行为有很大的差异。一方面，大数据应用程序分配大量内存，可能需要每个HPT路几十兆字节或几百兆字节。另一方面，许多系统服务、功能和微服务所需的内存较少，可能每个HPT路只需要几千字节。对于第一类应用程序，要容纳所有的页面映射，需要将每个块设置在兆字节的范围内。然而，对于第二类应用程序，大块会浪费大量内存。需要注意的是，在所有情况下，一个块由一次性分配的一个或多个连续物理页面组成。</p>
<p>为了解决这个问题，我们提议根据应用程序的行为随时间<em>动态</em>改变分配给应用程序的块大小。我们选择一组从小到大的块大小。当一个应用程序启动时，它使用最小的块大小。随着应用程序增加其HPT路的需求，它可以改变块大小。有了这种支持，小内存和大内存应用程序的HPT都可以<em>高效地</em>使用非连续内存。</p>
<p>第五节列出了我们使用的L2P表大小和不同块大小，并进行了解释。然而，为了理解操作，我们现在展示一个示例，该示例使用64个条目的L2P表，以及8KB和1MB的块大小。图3a显示了一个应用程序，它一开始只需要4KB的HPT路。在这种情况下，操作系统使用小的块大小（8KB），只分配一个块。只使用L2P表的一个条目，HPT路使用了8KB块的一半。如果应用程序的HPT路翻倍，操作系统简单地填满了块的后半部分，同时仍然只使用L2P表的一个条目（图3b）。</p>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230801202605397.png"
alt="image-20230801202605397" />
<figcaption aria-hidden="true">image-20230801202605397</figcaption>
</figure>
<p>如果应用程序进一步将其HPT翻倍至16KB，操作系统会分配第二个小块，并在L2P表中使用第二个条目（图3c）。这个过程重复进行，直到L2P表的所有64个条目都被使用，形成一个总共512KB大小的HPT路（图3d）。如果再次翻倍HPT大小，将触发块大小的转换，这涉及分配一个新的1MB块，将旧块中的条目重新哈希到新块中，并释放旧块。在调整大小后，我们使用L2P表的一个条目，指向1MB块（图3e）。进一步的扩大会分配更多的1MB块，因此会使用更多的L2P表条目。一旦L2P表的所有64个条目都指向完整的1MB块，另一个HPT的扩大将需要分配一个更大尺寸的块。总体上，无论是小尺寸的应用程序还是大尺寸的应用程序都可以高效地使用HPT内存。硬件使用MMU中的一些位来记录HPT当前使用的块大小，以及是否需要改变块大小进行扩大。</p>
<h3 id="c.-in-place-page-table-resizing"><em>C. In-place Page Table
Resizing</em></h3>
<p>这项技术和接下来的一项技术都能减少HPT（Hashed Page
Table）所需的总物理内存；我们稍后会看到，间接地它们也能减少连续物理内存的需求。</p>
<p>为了理解这项技术，回想一下我们的最先进的基准方案（即ECPT），它在程序运行时动态调整HPT的大小，在调整大小期间，旧的和新的HPT共存于内存中。这种方法可能会占用相当大的内存。例如，我们的一些应用程序需要一个由三个64MB组成的HPT，总共192MB。因此，在调整大小为192MB时，新旧HPT表共占用192
+ 96 =
288MB的内存。此外，调整大小操作需要时间，而在大多数程序的执行时间内，会有两个HPT（旧+新）共存于内存中；我们测得平均情况下，总执行时间的87.3％是这种情况。在机器上运行多个进程，每个进程都有一个针对不同页面大小的HPT，可能会导致多个HPT同时调整大小，从而消耗大量内存。</p>
<p>操作系统需要对所有旧的HPT条目进行重新散列。然而，只有在插入新的HPT条目时，才会重新散列单个条目（或一小组条目）。等到有新的条目插入时才重新散列条目的原因是为了重复使用插入触发的操作系统调用。当然，可以为所有重新散列分配另一个操作系统线程，但这会增加开销。</p>
<hr />
<h4 id="tips-3">tips</h4>
<p>重新散列的机制是什么？？？</p>
<hr />
<p>为了减少内存使用量，本文提出了<em>就地</em>HPT调整大小。其思想是让新旧HPT共享同一块内存空间。这确保在任何时候，两个HPT使用的内存等于两者中较大的那个，而不是两者的总和。为了形象化说明，图4显示了如何扩展HPT（a）在原地扩展和（b）非原地扩展。为简单起见，图中仅显示了一个HPT的路。此外，图中将HPT路描述为连续的内存。实际上，根据第IV-A和IV-B节，<em>HPT路（旧的和新的）由一组非连续的块组成</em>。</p>
<p>为了与原始的ECPT论文一致，图4假设地址从图的顶部到底部递增。回忆一下，在进行传统的非原地调整大小的HPT（图4a）时，有三个区域：旧HPT中的Migrated和Live区域以及新HPT。插入操作将条目放入新的HPT或Live区域。重新散列将Migrated区域向下扩展，将Live区域的条目取出并插入到新的HPT中。Migrated区域不放置任何条目。</p>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230801203815590.png"
alt="image-20230801203815590" />
<figcaption aria-hidden="true">image-20230801203815590</figcaption>
</figure>
<p>在我们提出的就地调整大小方案（图4b）中，插入操作和重新散列操作都可能将条目放入Migrated区域，因为它与新的HPT重叠。为了防止这些新条目造成混淆，我们提出了一个简单的技术：新HPT使用与旧HPT相同的散列函数，但是为了索引新的HPT，在散列键的结果中使用了一个额外的位（在上调大小时）或减少了一个位（在下调大小时）。添加的位是散列键的最高有效位（most
significant bit, MSB）之后的一位(The bit added is the one beyond the
most significant bit (MSB) of the hash
key,即更高的一位)；移除的位是散列键的最高有效位（MSB）。此外，我们只将HPT的每个路上调或下调到下一个较高/较低的<em>二次幂大小</em>。</p>
<hr />
<h4 id="tips-4">tips</h4>
<p>散列函数的结果有很多位，比如n bit，旧的HPT只使用m
bit，而新的扩容后的HPT使用m + 1 bit.</p>
<hr />
<h4 id="detailed-rehash-algorithm.">Detailed Rehash Algorithm.</h4>
<p>在HPT调整大小期间，重新散列操作将一个元素从旧HPT的第i个路（Hi）移动到新HPT的相同方式（Hi′）。被移动的元素是位于Hi的Live区域顶部的元素，并由该方式的重新散列指针（Pi）指向（见第二节）。在移动后，Pi被递增。为了描述算法，首先考虑HPT的上调大小，然后再考虑HPT的下调大小。</p>
<p>在HPT上调大小中，假设要重新散列的条目是图5a中的<em>OldEntry</em>。我们使用原始的散列函数对其VPN进行散列，但使用结果散列键的一个额外位。在这一点上，有两种可能的结果：如果额外位为零，该条目将保持原位（图5b中的<em>NewEntry</em>）；如果额外位为一，该条目将移动到新HPT的第二半部分，并在新HPT中与旧HPT相同的偏移位置（图5c中的<em>NewEntry</em>）。</p>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230801205831755.png"
alt="image-20230801205831755" />
<figcaption aria-hidden="true">image-20230801205831755</figcaption>
</figure>
<p>在HPT下调大小中，相反的情况发生：两个来自旧HPT的条目可能被重新散列到新HPT中的相同位置，因此其中一个条目将会被插入到不同的路中。例如，在图5d和图5e中，旧HPT的两个<em>OldEntry</em>条目将被重新散列到新HPT的相同位置，该位置由图5f中的<em>NewEntry</em>给出。</p>
<h4 id="other-operations.">Other Operations.</h4>
<p>在HPT调整大小期间执行的其他操作使用与弹性布谷哈希（Elastic Cuckoo
Hashing）[77]中描述的相同算法。以下我们假设正在进行HPT上调大小。在查找操作中，对于每个路i，使用旧函数创建的哈希键与Rehashing
Pointer（Pi）进行比较。如果哈希键大于或等于Pi，则使用旧哈希键来索引HPT；否则，使用新哈希键来索引HPT。新的哈希键与旧的哈希键相同，只是包含了最高位（MSB）之外的那一位。每个HPT路只需要单个访问。</p>
<p>删除操作遵循查找过程，并在找到元素时清除该条目。最后，插入操作涉及随机选择一个路i，使用旧函数创建一个哈希键，并将哈希键与Pi进行比较。如果哈希键大于或等于Pi，则将元素插入由旧哈希键指向的条目；否则，将元素插入由新哈希键指向的条目。如果出现冲突，则将现有条目替换到另一个方式中。</p>
<h4
id="interaction-between-resizing-and-changing-chunk-sizes.">Interaction
between Resizing and Changing Chunk Sizes.</h4>
<p>所有不涉及更改块大小的上调和下调HPT操作都执行原地HPT调整大小。所有需要更改块大小的上调和下调HPT操作，根据设计要求，都需要进行非原地HPT调整大小。</p>
<h4 id="d.-per-way-resizing"><em>D. Per-way Resizing</em></h4>
<p>在现有的方案中，HPT以集合关联方式组织，以减少冲突，并且在调整大小时，所有W个路由、都进行上调或下调。然而，这种方法在内存使用上可能是不高效的：HPT每次都是倍增/减少大小，而实际上可能只需要稍微多一些/少一些空间。</p>
<p>为了减少HPT内存消耗的浪费，我们提出了<em>逐路调整（Per-Way
Resizing）</em>的方法。该方法的思想是一次只对一个路进行上调或下调。通过这种方法，在上调时，只需分配新HPT中原本需要添加的内存的1/W部分。与前一节一样，这种方法应用于由多个非连续块组成的HPT路。</p>
<p>虽然这种改进节省了内存，但它引入了两个新问题。具体来说，我们需要确定选择哪个路进行上调或下调，同时避免路的不平衡。我们还需要确定在HPT中插入项的算法。接下来我们将讨论这些问题。</p>
<h4 id="deciding-which-way-to-upsize-or-downsize.">Deciding Which Way to
Upsize or Downsize.</h4>
<p>在传统的全路调整大小中，操作系统保持一个包含整个HPT占用率的计数器；当计数器达到阈值时，HPT将被调整大小。而在每路调整大小中，操作系统使用每路计数器来跟踪每个单独路的占用率。当其中一个计数器达到阈值时，对应的路将被调整大小。</p>
<p>需要避免以牺牲其他路为代价，反复对同一路进行上调（或下调）。为了保持不同路的平衡，我们在允许调整某一路之前添加一个额外的条件。具体来说，候选路的大小不能比另一路更大（在上调时），或者比另一路更小（在下调时）。通过这个约束，一条路永远不会比另一条路的大小大两倍（或小于一半）。</p>
<h4 id="deciding-where-to-insert-an-element.">Deciding Where to Insert
an Element.</h4>
<p>在传统的设计中，所有的路都是等大小的，可以在插入时随机选择一条路，并自然地保持路的平衡占用率。然而，在每路调整大小的情况下，随机插入不再合适：调整大小后的路可能无法充分利用其全部容量，而其他路仍然会保持高占用率。这将导致频繁的冲突和重新插入。</p>
<p>为了避免这个问题，我们提出了一种<em>加权</em>随机插入算法。具体来说，由于操作系统知道每个路的占用率和大小，它也知道每个路有多少空闲槽位。因此，我们的算法将将元素插入路i的概率设置为路i中空闲槽位数与所有路空闲槽位数之比。换句话说，我们在0到1之间生成一个随机数，并为每个路i赋予权重<span
class="math inline">\(FREE_i/FREE_{sum}\)</span>。此外，如果某条路比其他路更大，并且其占用率已经达到了预定义的上限，我们将其权重设为零，从效果上阻止在该路中插入。</p>
<p>采用这种算法后，我们可以得到期望的结果。首先，在某条路调整大小后，大多数插入操作会选择该路，从而推迟其他路的调整大小。其次，一旦一条较大的路的占用率达到了阈值，插入操作不会在调整较小的路之前选择该路。</p>
<h3 id="e.-reducing-hpt-size-reduces-memory-contiguity"><em>E. Reducing
HPT Size Reduces Memory Contiguity</em></h3>
<p>最后两种技术是用于减小HPT尺寸的软件策略。然而，它们也可以间接地降低HPT的内存连续性要求。原因在于较小的HPT可能可以使用较小尺寸的内存块，而不需要较大HPT那样的块。例如，我们将在评估部分看到，多亏这些技术，我们的两个应用程序能够使用1MB内存块来构建它们的HPT，而不需要更大尺寸的块。</p>
<h2 id="v.-me-hpt-implementation-aspects">V. ME-HPT IMPLEMENTATION
ASPECTS</h2>
<p>在这一节中，我们将讨论ME-HPT（Memory-Efficient Hashed Page
Tables）的几个方面：L2P表项的“抢占”、选定的块大小、L2P表的可扩展性以及隐藏对L2P表的访问。</p>
<h3 id="a.-l2p-table-entry-stealing"><em>A. L2P Table Entry
Stealing</em></h3>
<p>为了最小化访问时间，我们将每个应用程序的L2P表大小设置为每种页面大小和HPT路的32个条目。回想一下，我们支持三种页面大小（即4KB、2MB和1GB）。假设我们有三个HPT路，则对于一个应用程序，我们将有九个子表格在L2P表中。现在考虑第i个路的三个子表格，分别用于4KB、2MB和1GB的页面大小。很不可能这三个子表格都会被高度利用。最有可能的情况是其中一个或多个子表格的条目较少。因此，如果需要，我们允许某个页面大小的子表格从其他页面大小的子表格中“抢占”条目。这样可以更好地利用L2P表的条目。</p>
<hr />
<h4 id="tips-5">tips</h4>
<p>假设有三种Page Size(4KB，2MB，1GB),则L2P表共3 *
32共96个缓存行，每个缓存行有每一路的entry（多路组相连），下图为3路的情况。</p>
<hr />
<p>图6a展示了我们提出的设计。在MMU中，我们将同一路i的三个子表格连续放置。1GB的子表格放在中间，因为它最不可能被使用。4KB和2MB的L2P子表格在相反方向增长。图6a展示了4KB和2MB子表格各使用两个条目的情况。</p>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230802095758236.png"
alt="image-20230802095758236" />
<figcaption aria-hidden="true">image-20230802095758236</figcaption>
</figure>
<p>现在假设4KB子表格使用了全部32个条目并且需要进行扩容。如果1GB子表格中没有任何条目在使用中，我们允许4KB子表格从1GB子表格中获取所有条目，并扩容到64个条目（图6b）。这时候，内存块大小保持不变。如果之后，4KB子表格想再次进行扩容，它只能通过分配一个更大的内存块并将所有条目重新散列到新内存块中来完成。</p>
<p>如果在4KB子表格从1GB子表格中获取所有条目后，1GB子表格需要一个条目，系统会使用2MB子表格中最重要的一个条目（图6c）。</p>
<h3 id="b.-chosen-chunk-sizes"><em>B. Chosen Chunk Sizes</em></h3>
<p>通过这种支持，我们选择内存块的大小从小到大依次为8KB、1MB、8MB和64MB。尽管对于我们的应用程序，我们只需要8KB和1MB的内存块。具体来说，让我们从最小的8KB内存块大小开始。当使用8KB内存块的子表格达到64个条目（图3d）时，它的HPT
way将扩展到8KB×64 = 512KB。如果HPT
way现在需要扩容，操作系统将内存块大小更改为1MB，分配一个单独的内存块，并在L2P表中使用一个条目（图3e）。</p>
<p>如果应用程序使用1MB内存块填充了所有64个条目，每个way将使用64MB。如果HPT
way现在需要扩容到128MB，操作系统将使用下一个内存块大小。由于这种情况很少发生，并且我们不想分配大的连续内存块，我们将下一个内存块大小设置为8MB。在这种情况下，操作系统分配16个内存块，并在L2P表中使用16个条目。如果应用程序填充了所有64个条目并且HPT
way需要扩容，下一个内存块大小（很少使用）将为64MB。</p>
<p>一个应用程序的L2P表的大小是适度的。考虑使用8KB内存块的最坏情况。对于一个46位的物理地址，8KB内存块的基地址为33位，后面跟着13个零。我们只需要存储这33位。因此，L2P表的总大小为32个条目×
3个way × 3个页面大小 × 33位 = 1.16KB。</p>
<p>请注意，内存块的大小不需要局限于上面列出的大小。相反，操作系统可以根据每个进程和每个系统状态做出决策。为了确定下一个内存块的大小，操作系统可以基于当前的内存碎片化水平和预期的最终HPT
way大小动态使用启发式方法。我们将这个主题视为未来的工作。</p>
<h3 id="c.-scalability-of-l2p-tables-with-changing-chunks"><em>C.
Scalability of L2P Tables with Changing Chunks</em></h3>
<p>ME-HPT提供了一种可扩展的HPT解决方案，通过L2P表和动态改变chunk大小实现。正如前面所述，MMU仅包含正在运行进程的L2P表。对于一个进程，L2P表包括所有页面大小和way，共有288个条目，使用1.16KB的内存。在进行上下文切换时，操作系统只保存和恢复L2P表中的有效条目，这些条目通常聚集在表的两端。应用程序通常只使用L2P表的几个条目。在第VII-E4节中，我们将展示平均来看，它们只使用53个条目。因此，保存和恢复L2P表的开销是适度的。此外，在虚拟化系统中，开销会更小，有两个原因。首先，由于客户机HPT不是连续的，它们分布在主机页面中，因此没有客户机L2P表。其次，在客户机上下文切换时，不会保存或恢复主机L2P表。</p>
<p>对于HPT，最大连续内存需求是一个chunk的大小（在我们的应用程序中为8KB或1MB）。表II显示了不同chunk大小的HPT
way的最大大小，以及生成的总HPT（即所有三个way）在使用4KB页面和大页（2MB）页面时可以映射的最大物理内存空间。我们可以看到，对于8KB的chunks，ME-HPT可以构建一个64x8KB=512KB的HPT
way。如果HPT用于4KB页面，生成的3-way
HPT可以映射768MB的应用程序数据；如果HPT用于2MB页面，则生成的3-way
HPT可以映射384GB的应用程序数据。</p>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230802133353257.png"
alt="image-20230802133353257" />
<figcaption aria-hidden="true">image-20230802133353257</figcaption>
</figure>
<p>使用1MB的chunk，ME-HPT可以构建一个64x1MB=64MB的HPT
way。与之前一样，如果HPT用于4KB页面，则3-way
HPT可以映射96GB的应用程序数据；如果HPT用于大页，则3-way
HPT可以映射48TB的数据。</p>
<p>使用8MB的chunk，ME-HPT可以构建一个64x8MB=512MB的HPT
way。如果HPT用于4KB页面，则3-way
HPT可以映射768GB的应用程序数据；如果HPT用于大页，则生成的HPT可以映射384TB的应用程序数据。</p>
<p>如果应用程序更大，我们可以切换到64MB的chunk。在这种情况下，ME-HPT可以构建一个64x64MB=4GB的HPT
way。如果HPT用于4KB页面，则3-way
HPT可以映射6TB的应用程序数据；如果HPT用于大页，则生成的HPT可以映射3PB的应用程序数据。</p>
<p>当操作系统对HPT
way进行升级时，它会分配一个或多个额外的chunk。这些chunk<em>既不与彼此连续，也不与当前HPT的chunk连续</em>。一个HPT
way始终是由多个非连续的chunk组成的。虽然对于我们的应用程序，chunk大小为8KB或1MB，但更大的应用程序可能需要更大的chunk。为了在高度碎片化的机器上为大chunk找到空间，操作系统可能会执行内存压缩或交换页面，就像通常分配大页一样。升级操作不会失败，除非请求的chunk大小太大，以至于操作系统无法提供如此大的连续内存。</p>
<h3 id="d.-hiding-the-access-to-the-l2p-table"><em>D. Hiding the Access
to the L2P Table</em></h3>
<p>ECPT设计中访问L2P表（第IV-A节）增加的额外延迟并不会明显减慢页面遍历的速度。原因在于这种额外延迟可以与ECPT设计中的Cuckoo
Walk Cache（CWC）硬件结构的访问重叠。</p>
<hr />
<h4 id="tips-6">tips</h4>
<p>CWC的工作原理？？</p>
<hr />
<p>图7显示了设计。在TLB（转换后备缓冲）未命中时，缺失虚拟地址的转换可以存在于任何页面大小的HPT（哈希页表）的任何路中。为了减少需要检查的内存位置数量，ECPT硬件首先访问CWC硬件缓存。根据访问结果确定应该访问哪个页面大小的HPT的哪个路。同时，如果正在进行调整大小操作，则会检查重新哈希指针，以决定是访问旧的HPT还是新的HPT。</p>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230802144500427.png"
alt="image-20230802144500427" />
<figcaption aria-hidden="true">image-20230802144500427</figcaption>
</figure>
<p>同时，我们提出硬件在内存管理单元（MMU）中访问进程的L2P表，并生成潜在的内存地址进行访问。在CWC和重新哈希指针检查完成后，它们选择要执行的内存访问操作。因此，L2P表访问的延迟被隐藏了。</p>
<p>唯一不隐藏L2P表访问延迟的情况是由于HPT冲突而进行的Cuckoo重新插入。在这种情况下，不访问CWC，L2P表访问的延迟位于关键路径上。幸运的是，在这种情况下，几个周期的访问延迟是可以忽略的。原因在于元素插入或Cuckoo重新哈希是由操作系统执行而不是由硬件执行的，而调用操作系统具有更高的开销。</p>
]]></content>
      <categories>
        <category>体系结构</category>
        <category>Virtual memory</category>
        <category>Page tables</category>
        <category>Hashed page tables</category>
      </categories>
      <tags>
        <tag>Paper</tag>
      </tags>
  </entry>
  <entry>
    <title>Elastic Cuckoo Page Tables: Rethinking Virtual Memory Translation for Parallelism</title>
    <url>/zyhjy/2023/08/02/Elastic-Cuckoo-Page-Tables-Rethinking-Virtual-Memory-Translation-for-Parallelism/</url>
    <content><![CDATA[<h1
id="elastic-cuckoo-page-tables-rethinking-virtual-memory-translation-for-parallelism">Elastic
Cuckoo Page Tables: Rethinking Virtual Memory Translation for
Parallelism</h1>
<p><strong>ASPLOS 2020 Best Paper Award.</strong> <a
href="http://iacoma.cs.uiuc.edu/iacoma-papers/PRES/present_asplos20.pdf">slides</a>
<a
href="https://www.youtube.com/watch?v=BIvpGx-znlk&amp;list=PLsLWHLZB96VeVp3IVzvSH58ttVz_Anr7H&amp;index=68&amp;t=0s">video</a></p>
<h3 id="摘要">摘要</h3>
<p>新兴的内存密集型工作负载的内存需求前所未有地增长，这使得虚拟内存转换成为主要的性能瓶颈。为了解决这个问题，本文引入了Elastic
Cuckoo Page
Tables，这是一种新颖的页表设计，将传统的多级基数页表使用的顺序指针追踪操作转化为完全并行的查找。由此产生的设计首次利用内存级并行性进行地址转换。Elastic
cuckoo page tables使用Elastic Cuckoo
Hashing，这是一种支持高效页表调整的cuckoo hashing的新型扩展。Elastic
cuckoo page
tables有效地解决了哈希冲突，提供了进程私有的页表，支持多个页面大小和进程之间的页面共享，并根据应用程序要求动态调整页表大小。</p>
<p>我们通过对一个包含图分析、生物信息学、高性能计算和系统工作负载的8核处理器进行全系统模拟来评估Elastic
cuckoo page tables。相比传统的基数页表，Elastic cuckoo page
tables将地址转换开销平均降低了41%。结果是应用程序执行速度提高了3-18%。</p>
<span id="more"></span>
<h2 id="introduction">1 Introduction</h2>
<p>虚拟内存是现代计算系统的基本抽象，它提供了内存虚拟化和进程隔离功能。虚拟内存的一个核心组成部分是页表，它存储虚拟地址到物理地址的转换。页表的设计对于内存密集型工作负载的性能影响很大，这些工作负载中，工作集远远超过了TLB（Translation
Lookaside
Buffer）的范围。在这些工作负载中，频繁的TLB缺失需要从页表中获取虚拟地址到物理地址的转换，将页表查找放在执行的关键路径上。</p>
<p>目前，页表的<em>事实</em>标准设计称为<em>基数页表</em>，它将转换信息组织成多级树结构。x86-64架构使用四级树，而下一代架构（例如Intel的Sunny
Cove）将增加第五级，Linux已经支持这种设计。基数页表可能会产生高性能开销，因为查找转换涉及一个页表遍历，它从内存系统<em>顺序</em>访问树的所有层级。</p>
<p>尽管人们已经做了大量努力，通过大型和多级TLB、大页支持以及用于页表遍历的内存管理单元（MMU）缓存来提高地址转换效率，但地址转换仍然成为主要的性能瓶颈。它可能占到新型应用程序总体执行时间的20-50%，而页表遍历可能占据主内存访问的20-40%。考虑到TLB的扩展受到访问时间、空间和功耗预算的限制，现代计算平台现在可以提供TB甚至PB级别的主内存，以及不断出现的各种内存密集型工作负载，这样的开销在未来可能会加剧。</p>
<hr />
<h5 id="tips-tlb-mmu-cache">tips: TLB &amp;&amp; MMU Cache</h5>
<p>每个CPU core都有一个独立的TLB（Translation Lookaside
Buffer），用于存储地址转换（虚拟页号+页表项（PTE）），一般来说也采用分层架构，如下图：</p>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230804221009551.png"
alt="image-20230804221009551" />
<figcaption aria-hidden="true">image-20230804221009551</figcaption>
</figure>
<p>作为CPU内部的硬件，为了满足高速的访问速度，TLB的大小很小，通常只有1000个左右的条目。</p>
<p>一旦发生TLB
miss，MMU将会通知内存通过多级页表访问查询对应的物理地址。</p>
<p>例如，×86系统使用四级页表。因此，TLB未命中需要对这些页表进行四次长延迟的内存访问，通常可以在最后一级缓存或主存储器中找到它们。作为回应，一些处理器供应商（例如英特尔和AMD）设计了这样的结构，不仅将多级基数树页表的最后一级中的PTE（在TLB中）进行缓存，还将树的更高级别中的条目缓存在小型每核心的<a
href="https://www.cs.yale.edu/homes/abhishek/abhishek-micro13.pdf">内存管理单元（MMU）缓存</a>中。</p>
<p>MMU缓存在TLB未命中时进行访问；MMU缓存命中可以跳过在页表遍历中的多次内存引用（在最佳情况下，将整个遍历减少到只有一个内存引用）。</p>
<p>TLB在虚拟化环境下表现往往并不好，原因在于进程切换时会带来一定程度上的TLB刷新，导致TLB
miss增加。</p>
<hr />
<p>为了减少地址转换开销，本文探索了一种根本不同的解决方案。具体而言，我们探索了一种新的页表结构，它消除了指针追踪操作，并利用并行性进行转换查找。</p>
<p>一个自然的方法是用<em>哈希页表</em>来替换基数页表，哈希页表将虚拟地址到物理地址的转换存储在一个哈希表中。然而，哈希页表受到一系列问题的困扰。一个主要问题是处理哈希冲突的需求。目前处理页面表中的哈希冲突的解决方案，即冲突链接和开放地址法，需要顺序内存引用来遍历冲突的条目，这需要特殊的操作系统支持。或者，为了避免冲突，哈希页表需要动态调整大小。然而，这样的操作非常昂贵，因此提出的哈希页表解决方案通过使用一个由所有进程共享的大型全局页表来避免它。不幸的是，全局哈希页表无法在不添加额外的转换级别的情况下支持进程之间的页面共享或多个页面大小。</p>
<p>为了解决哈希页表的问题，本文提出了一种称为<em>Elastic Cuckoo Page
Tables</em>的新设计。这些页面表使用<em>Elastic Cuckoo
Hashing</em>进行地址转换，这是对布谷鸟哈希的一种新扩展，用于支持渐进的、动态的调整大小。弹性布谷鸟页表有效地解决了哈希冲突问题，提供了进程私有的页面表，支持多种页面大小和进程之间的页面共享，以及高效地动态调整页面表大小以满足进程需求。因此，弹性布谷鸟页表将传统基数页表的顺序指针追踪操作转变为完全并行的查找，允许地址转换首次利用内存级别的并行性。</p>
<p>我们通过对运行一组图分析、生物信息学、高性能计算和系统工作负载的8核处理器进行全系统模拟来评估弹性布谷鸟页表。相比于基数页表，弹性布谷鸟页表平均减少了41%的地址转换开销。</p>
<h2 id="background">2 Background</h2>
<h3 id="radix-page-tables">2.1 Radix Page Tables</h3>
<p>目前的所有体系结构都实现了Radix页表，其中页表组织为多级Radix树。例如，图1显示了x86-64页表的结构。给定一个48位的虚拟地址（VA），由于标准页面大小为4KB，最低的12位是页偏移量。剩余的36位被分成四个9位字段。每个字段用作页表的四个级别之一的索引。这些级别分别称为PGD（页全局目录）、PUD（页上层目录）、PMD（页中间目录）和PTE（页表项）[19]。翻译从CR3寄存器开始，该寄存器包含PGD表的基址。通过将CR3和位47-39相加，可以得到一个PGD条目，其内容是正确的PUD表的基址。然后，通过添加该内容和位38-30，可以得到一个PUD条目，其内容是正确的PMD表的基址。这个过程一直持续到读取一个PTE条目。它包含物理页号和硬件在TLB中插入的附加标志。物理页号与位11-0连接在一起就是物理地址（PA）。</p>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230803121317873.png"
alt="image-20230803121317873" />
<figcaption aria-hidden="true">image-20230803121317873</figcaption>
</figure>
<p>所描述的过程称为页面表遍历。在TLB未命中时，它在硬件中执行。页面表遍历需要四个<em>顺序</em>的高速缓存层次访问。</p>
<p>为了增加TLB的范围，x86-64体系结构支持两种大页面大小，即2MB和1GB。当使用大页面时，页面表遍历被缩短。具体来说，2MB页面的翻译从PMD表中获得，而1GB页面的翻译从PUD表中获得。</p>
<p>为了减少页面表遍历的开销，x86-64处理器的MMU有一些称为页面遍历缓存（PWC）的小缓存。PWC存储最近访问的PGD、PUD和PMD表项（但不包括PTE表项）[1,
8, 11, 12,
38]。在TLB未命中时，在硬件发出任何对高速缓存层次的请求之前，它会检查PWC。它记录在哪个最低级别的表项命中。然后，它为下一个较低级别的表项生成对高速缓存层次的访问。</p>
<h4 id="struggles-with-emerging-workloads.">2.1.1 Struggles with
Emerging Workloads.</h4>
<p>新兴的工作负载，例如图形处理和生物信息学，通常具有多GB的内存占用，并表现出低局部性内存访问模式。这种行为给地址转换机制带来了压力。最近的研究报告称，地址转换已经成为主要的性能瓶颈[8-10,
12-15, 21, 42,
56]。它可能占据应用程序执行时间的20-50%。此外，页表遍历可能占据主存访问的20-40%
[13]。为了解决这个问题，可以增加PWC的大小以捕获更多的翻译，或者增加翻译树中的级数以增加内存寻址能力。然而，这两种方法都不可扩展。与TLB等靠近核心的其他结构一样，PWC的访问时间需要很短。因此，PWC必须很小。它们很难跟上内存容量的快速增长。增加翻译树中的级数会使翻译速度变慢，因为它可能涉及更多的高速缓存层次访问。在历史上，英特尔逐渐增加了树的深度，从Intel
80386的两级增加到目前处理器中的四级[4, 38]。Intel Sunny
Cove中计划采用五级树 [36,
37]，并已在Linux中实现。这种方法是不可扩展的。</p>
<h3 id="hashed-page-tables">2.2 Hashed Page Tables</h3>
<p>替代基数页表的是<em>哈希页表</em>。在哈希页表中，地址转换涉及将虚拟页号进行哈希，并使用哈希值作为索引访问页表。假设没有哈希冲突，地址转换只需要一次内存系统访问。</p>
<p>哈希页表[22, 33, 39, 40, 68] 已经在IBM PowerPC、HP PA-RISC和Intel
Itanium架构中实现。Itanium架构中对哈希页表的支持被称为长格式虚拟哈希页表（VHPT）[23,
28, 35]。在这个设计中，操作系统处理哈希冲突。当发生哈希冲突时，VHPT
walker会引发一个异常，然后调用操作系统。操作系统处理程序通过搜索冲突链和其他辅助的操作系统定义的数据结构来解决冲突。</p>
<h4 id="challenges-in-hashed-page-tables.">2.2.1 Challenges in Hashed
Page Tables.</h4>
<p>Barr等人[8]总结了哈希页表的三个局限性。第一个是在访问页表时失去空间局部性。这是由哈希引起的，它会将连续虚拟页的页表条目分散开来。第二个局限性是需要将哈希标记（例如虚拟页号）与每个页表条目关联，这导致页表条目占用更多的内存空间。第三个是需要处理哈希冲突，这会导致更多的内存访问，因为系统需要遍历冲突链
[8]。</p>
<p>最近，Yaniv和Tsafrir [73]
表明，前两个限制可以通过精心设计的页表条目来解决。具体来说，他们使用了页表条目聚类技术，将多个连续的页表条目放置在一个大小等于缓存行的哈希表条目中。此外，他们提出了页表条目压缩技术，可以重新利用多个连续的页表条目的未使用的高位来存储哈希标记。</p>
<p>不幸的是，哈希冲突是一个显著的问题，仍然没有解决。现有的策略，如冲突链和开放地址法，都需要昂贵的内存引用来遍历冲突的条目。</p>
<p>为了评估冲突的重要性，我们使用第7节的应用程序模拟了一个全局哈希表。我们评估了以下情景：（1）哈希表的条目数等于所有应用程序所需的所有翻译的总和，（2）哈希函数是计算密集型的BLAKE加密函数
[5]，它最小化了冲突的概率。</p>
<p>图2显示了随机数映射到相同哈希表条目的概率。数据显示为累积分布函数（cumulative
distribution
function，CDF）。图中还显示了超额配置了50％的全局哈希表的CDF。对于基线表，我们可以看到只有35％的哈希表条目没有冲突（即冲突的条目数为1）。另一方面，有些条目存在大量的冲突，需要耗时的冲突解决操作。即使对于超额配置的表，也只有一半的条目没有冲突。</p>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230803121824060.png"
alt="image-20230803121824060" />
<figcaption aria-hidden="true">image-20230803121824060</figcaption>
</figure>
<h4 id="drawbacks-of-a-single-global-hash-table.">2.2.2 Drawbacks of a
Single Global Hash Table.</h4>
<p>一个简单的哈希页表系统设计是拥有一个全局的哈希表，其中包含机器上所有活动进程的页表条目。这个设计很有吸引力，因为：1）哈希表只需要分配一次，2）可以调整表的大小以最小化对动态表调整的需求，这是非常耗时的。</p>
<p>然而，这样的设计有一些实际上的缺点，使其不可取 [22,
73]。首先，它不能支持多种页面大小（例如大页面）和进程之间的页面共享，除非增加额外的复杂性。例如，为了支持这两个功能，IBM
PowerPC架构对每个内存引用使用了两级的转换过程
[34]。其次，当一个进程被终止时，系统需要对整个哈希表进行线性扫描，以找到并删除相关的页表条目。注意，删除一个条目也可能是昂贵的：它可能需要进行长时间的哈希表查找（对于开放寻址法）或冲突链遍历。此外，在开放寻址法中删除一个页表条目可能会影响未来查找中的冲突探测。</p>
<h4 id="resizing-hashed-page-tables.">2.2.3 Resizing Hashed Page
Tables.</h4>
<p>为了减少碰撞，哈希表实现会设置一个占用阈值，当达到该阈值时，会触发对哈希表的重新调整大小。然而，如果一次性完成调整大小，这个过程将会非常昂贵。它需要分配一个更大的新哈希表，并且对旧哈希表中的每个条目，使用新的哈希函数重新计算标签，并将（标签，值）对移动到新哈希表中。在页表的上下文中，正在执行的工作负载需要暂停并等待调整大小过程完成。此外，由于页表条目被移动到新的内存位置，它们在处理器的缓存层次结构中的旧副本将变得无用。正确的副本现在在新的地址中。</p>
<p>另一种方法是逐步移动条目，并在一段时间内保留旧哈希表和新哈希表的内存。插入操作只在新哈希表中插入条目，因此旧哈希表最终将变为空，并且随后被释放。此外，在每次插入之后，系统还会将一个或多个条目从旧哈希表移动到新哈希表中。不幸的是，查找需要从旧哈希表和新哈希表中获取条目，因为所需的条目可能在任一表中存在。</p>
<p>在页表的上下文中，逐步重新哈希有两个限制。首先，保留两个表会近似增加一倍的内存开销。其次，查找必须从两个表中获取条目，这将导致访问缓存层次结构的访问量翻倍。不幸的是，获取的一半条目是无用的，因此缓存可能会被污染。</p>
<h3 id="cuckoo-hashing">2.3 Cuckoo Hashing</h3>
<p>Cuckoo哈希是一种冲突解决算法，允许一个元素具有多个可能的哈希位置
[50]。该元素在一次只能存储在这些位置中的一个，但它可以在这些哈希位置之间移动。假设一个Cuckoo哈希表有两个哈希表或路（ways）<span
class="math inline">\(T_1\)</span>和<span
class="math inline">\(T_2\)</span>，使用哈希函数<span
class="math inline">\(H_1\)</span>和<span
class="math inline">\(H_2\)</span>进行索引。因为有两个表和哈希函数，所以该结构称为2-ary
Cuckoo哈希表。在Cuckoo哈希中，插入操作将元素x放置在两个可能的条目中的一个，即<span
class="math inline">\(T_1\)</span>[<span
class="math inline">\(H_1\)</span>(x)]或<span
class="math inline">\(T_2\)</span>[<span
class="math inline">\(H_2\)</span>(x)]。如果选定的条目被占用，算法将踢出当前的占用者，并重新插入到元素x的另一个哈希位置。如果该条目也被占用，对其占用者执行相同的过程。插入和踢出操作持续进行，直到没有占用者被踢出，或者达到最大位移次数（例如32次）。后一种情况是插入失败。</p>
<p>在Cuckoo哈希中进行查找时，会检查元素的所有可能哈希位置，如果在其中的任何一个位置找到，则查找成功。在上面的例子中，会检查<span
class="math inline">\(T_1\)</span>[<span
class="math inline">\(H_1\)</span>(x)]和<span
class="math inline">\(T_2\)</span>[<span
class="math inline">\(H_2\)</span>(x)]这两个位置。这些位置会并行地进行检查。因此，查找操作的时间是恒定的。删除操作与查找类似，首先进行查找，然后如果找到该元素，则将其删除。</p>
<p>图3展示了将元素x插入2-ary
Cuckoo哈希表的示例。最初，在步骤1中，表中有三个元素：a，b和c。将x插入到<span
class="math inline">\(T_1\)</span>[<span
class="math inline">\(H_1\)</span>(x)]的位置会将先前的占用者b踢出。在步骤2中，算法将b插入到<span
class="math inline">\(T_2\)</span>[<span
class="math inline">\(H_2\)</span>(b)]的位置，并将c踢出。最后，在步骤3中找到了一个空的位置用于c。这个例子可以推广到d-ary
Cuckoo哈希 [24]，它使用d个独立的哈希函数来索引d个哈希表。</p>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230802163229387.png"
alt="image-20230802163229387" />
<figcaption aria-hidden="true">image-20230802163229387</figcaption>
</figure>
<p>和任何哈希表一样，Cuckoo哈希表的性能在高占用率下会恶化。为了获得洞察力，图4描述了d-ary
Cuckoo哈希表（其中d为{2, 3, 4,
8}）的性能与表占用率之间的关系。我们取随机数，并像之前一样使用BLAKE密码哈希函数[5]对它们进行哈希。实际Cuckoo哈希表的大小并不重要，只有哈希表的占用率重要。</p>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230802163344076.png"
alt="image-20230802163344076" />
<figcaption aria-hidden="true">image-20230802163344076</figcaption>
</figure>
<p>图4(a)显示了成功插入元素所需的平均插入尝试次数与表占用率之间的关系。我们可以看到，在低占用率下，要么在第一次尝试中插入键，要么需要单次位移。随着占用率的增加，插入性能恶化
- 例如，在2-ary Cuckoo哈希表中占用率达到50%后，在3、4和8-ary
Cuckoo哈希表中占用率达到⇠70%后。图4(b)显示了经过32次尝试后插入失败的概率。我们可以看到，在2-ary
Cuckoo哈希表中，占用率达到50%后，插入失败的概率不为零，而在3、4和8-ary哈希表中，插入失败的概率仅在占用率达到80%后出现。</p>
<h2 id="rethinking-page-tables">3. Rethinking Page Tables</h2>
<p>如第2.1.1节所示，基数页表不具有可伸缩性。另外，如第2.2.2节所示，单个全局哈希页表也不是一个好的解决方案。我们希望提供<em>进程私有的哈希页表</em>，以便轻松支持进程间的页面共享和多个页面大小。然而，一个默认大小的哈希页表不能太大，否则会在某些进程中浪费太多内存。因此，我们被迫使用适度大小的哈希页表，这将导致碰撞。</p>
<p>解决碰撞的一个有希望的方法是使用Cuckoo哈希（见第2.3节）。不幸的是，任何默认大小的Cuckoo哈希表最终都会由于容量不足而导致插入失败。因此，不可避免地需要调整Cuckoo哈希表的大小。</p>
<p>不幸的是，调整Cuckoo哈希表的大小尤其昂贵。回想第2.2.3节中的内容，在逐步调整大小过程中，查找操作需要两倍的访问次数
-
因为需要访问旧的和新的哈希表。这个要求特别损害Cuckoo哈希，因为在正常操作期间，对d-ary
Cuckoo哈希表的查找已经需要d次访问；因此，在调整大小期间，查找需要执行2 x
d次访问。</p>
<p>为了解决这个问题，在本文中，我们使用一种新的算法扩展了Cuckoo哈希表的逐步调整大小。使用这个算法，在调整d-ary
Cuckoo哈希表的大小期间，查找操作<em>只需要d次访问</em>。此外，该算法不会从旧的哈希表中获取已经移动到新的哈希表的缓存页表项。因此，它最小化了来自这些条目的缓存污染。我们将这个算法命名为<em>Elastic
Cuckoo Hashing</em>。基于这个想法，我们后来建立了每个进程的<em>Elastic
Cuckoo Page Tables</em>作为我们提议用来替换基数页表的解决方案。</p>
<h2 id="elastic-cuckoo-hashing">4. Elastic Cuckoo Hashing</h2>
<h3 id="intuitive-operation">4.1 Intuitive Operation</h3>
<p>Elastic Cuckoo Hashing是一种用于逐渐调整大小的d-ary
cuckoo哈希表的新型算法。它解决了现有逐渐调整大小方案的主要限制。为了理解它的工作原理，首先考虑基线的d-ary
cuckoo哈希表如何进行逐渐调整大小。</p>
<h4 id="cuckoo-hashing-1">Cuckoo Hashing</h4>
<p>回想一下，d-ary
cuckoo哈希表有d个路（way），每个路有自己的哈希函数。我们分别将每个路和哈希函数表示为<span
class="math inline">\(T_i\)</span>和<span
class="math inline">\(H_i\)</span>，其中i取值为1到d。我们将组合的路和函数分别表示为<span
class="math inline">\(T_D\)</span>和HD。当<span
class="math inline">\(T_D\)</span>的占用率达到重新哈希阈值（Rehashing
Threshold）时，会分配一个更大的d-ary
cuckoo哈希表。在这个新的d-ary表中，我们将每个路和哈希函数表示为<span
class="math inline">\(T_i\)</span>和<span
class="math inline">\(H_i\)</span>，其中i取值为1到d，同时将组合的路和函数表示为<span
class="math inline">\(T_D\)</span>和HD。</p>
<p>随着执行的进行，无碰撞插入操作只访问新的d-ary哈希表的一个随机选择的单个路（如果有碰撞，则访问新的d-ary哈希表的多个路）。此外，每次插入之后，系统执行一次重新哈希操作。重新哈希操作包括将一个元素从旧的d-ary哈希表中移除，并将其插入新的d-ary哈希表中。不幸的是，查找操作需要探测旧的和新的d个路（共2d个路），因为一个元素可能位于两个哈希表的d个路中的任何一个路。当旧的d-ary表中的所有元素都被移除时，后者被释放。</p>
<h4 id="elastic-cuckoo-hashing-1">Elastic Cuckoo Hashing</h4>
<p>d-ary弹性cuckoo哈希表的工作方式不同。旧的d-ary哈希表中的每个<span
class="math inline">\(T_i\)</span>路都有一个重新哈希指针<span
class="math inline">\(P_i\)</span>，其中i取值为1到d。<span
class="math inline">\(P_i\)</span>指针的集合被称为<span
class="math inline">\(P_D\)</span>。在每个<span
class="math inline">\(T_i\)</span>中，<span
class="math inline">\(P_i\)</span>最初为零。当系统要从<span
class="math inline">\(T_i\)</span>重新哈希一个元素时，它会移除由<span
class="math inline">\(P_i\)</span>指向的元素，将元素插入新的d-ary表，并递增<span
class="math inline">\(P_i\)</span>。在任何时候，<span
class="math inline">\(P_i\)</span>将其<span
class="math inline">\(T_i\)</span>分为两个区域：低于<span
class="math inline">\(P_i\)</span>索引的条目（迁移区域）和高于或等于<span
class="math inline">\(P_i\)</span>索引的条目（存活区域）。图5显示了一个2-ary弹性cuckoo哈希表的这两个区域。随着逐步重新哈希的进行，<span
class="math inline">\(T_D\)</span>中的迁移区域不断增长。最终，当迁移区域覆盖了<span
class="math inline">\(T_D\)</span>中的所有条目时，旧的d-ary表被释放。</p>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230802163708170.png"
alt="image-20230802163708170" />
<figcaption aria-hidden="true">image-20230802163708170</figcaption>
</figure>
<p>在d-ary弹性Cuckoo哈希表中插入一个元素的过程如下。系统随机选择旧的d-ary表中的一个路，假设为<span
class="math inline">\(T_i\)</span>。将元素使用哈希函数<span
class="math inline">\(H_i\)</span>进行哈希。如果哈希值落在<span
class="math inline">\(T_i\)</span>的存活区域（Live
Region）内，则将元素插入到<span
class="math inline">\(T_i\)</span>；否则，将元素使用相同的路<span
class="math inline">\(T&#39;_i\)</span>的新d-ary表的哈希函数<span
class="math inline">\(H&#39;_i\)</span>进行哈希，并将元素插入到<span
class="math inline">\(T&#39;_i\)</span>。</p>
<p>由于这个算法，查找一个元素的操作只需要d次探测。实际上，元素使用旧的d-ary表中的所有HD个哈希函数进行哈希。对于每个路i，如果哈希值落在<span
class="math inline">\(T_i\)</span>的存活区域内，则对<span
class="math inline">\(T_i\)</span>进行探测；否则，将元素使用<span
class="math inline">\(H&#39;_i\)</span>进行哈希，并对新的d-ary表中的<span
class="math inline">\(T&#39;_i\)</span>进行探测。</p>
<hr />
<h5 id="tips">tips：</h5>
<p>探测是指访问d-ary表中hash结果所对应的条目。</p>
<hr />
<p>Elastic
Cuckoo哈希相对于Cuckoo哈希改进了逐步调整大小的两个方面。首先，它只需要d次探测而不是2
x
d次探测进行查找。其次，它通过不从旧的d-ary表的迁移区域中获取条目来最小化缓存污染；这样的条目是无用的，因为它们已经被移动到新的d-ary表中。</p>
<h3 id="detailed-algorithms">4.2 Detailed Algorithms</h3>
<p>现在我们详细描述弹性Cuckoo哈希算法。 #### Rehash（重新哈希）</p>
<p>重新哈希操作会将旧的d-ary哈希表中路<span
class="math inline">\(T_i\)</span>的重新哈希指针<span
class="math inline">\(P_i\)</span>所指向的元素，使用哈希函数<span
class="math inline">\(H&#39;_i\)</span>插入到新的d-ary哈希表的<em>同</em>一路<span
class="math inline">\(T&#39;_i\)</span>中。然后，<span
class="math inline">\(P_i\)</span>会被递增。</p>
<p>图6展示了一个2-ary弹性Cuckoo哈希表的示例。左侧是重新哈希之前的哈希表，<span
class="math inline">\(P_1\)</span>和<span
class="math inline">\(P_2\)</span>指向最顶部的条目。右侧是第一条<span
class="math inline">\(T_1\)</span>中的条目重新哈希后的旧和新哈希表。系统将元素d从<span
class="math inline">\(T_1\)</span>移动到了<span
class="math inline">\(T&#39;_i\)</span>的位置<span
class="math inline">\(T&#39;_i [H&#39;_i(d)]\)</span>。</p>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230802182039348.png"
alt="image-20230802182039348" />
<figcaption aria-hidden="true">image-20230802182039348</figcaption>
</figure>
<h4 id="look-up.">Look-up.</h4>
<p>元素x的查找涉及计算旧的d-ary哈希表所有路的<span
class="math inline">\(H_i(x)\)</span>值，并对每个路进行比较，判断是否满足条件<span
class="math inline">\(H_i(x)\)</span>≥ <span
class="math inline">\(P_i\)</span>。对于每个路i，如果<span
class="math inline">\(H_i(x)\)</span>属于存活区域（即<span
class="math inline">\(H_i(x)\)</span> ≥ <span
class="math inline">\(P_i\)</span>），则使用<span
class="math inline">\(H_i(x)\)</span>对旧哈希表中的路<span
class="math inline">\(T_i\)</span>进行探测；否则，使用<span
class="math inline">\(H&#39;_i(x)\)</span>对新的哈希表中的路<span
class="math inline">\(T&#39;_i\)</span>进行探测。具体算法如下：</p>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230802182239887.png"
alt="image-20230802182239887" />
<figcaption aria-hidden="true">image-20230802182239887</figcaption>
</figure>
<p>作为示例，考虑2-ary弹性Cuckoo哈希表。对元素x的查找需要两次探测。探测的具体结构取决于<span
class="math inline">\(P_1\)</span>、<span
class="math inline">\(P_2\)</span>、<span
class="math inline">\(H_1(x)\)</span>和<span
class="math inline">\(H_2(x)\)</span>的值。图7展示了四种可能的情况。该图假设<span
class="math inline">\(P_1\)</span>和<span
class="math inline">\(P_2\)</span>当前分别指向<span
class="math inline">\(T_1\)</span>和<span
class="math inline">\(T_2\)</span>的第三个和第二个条目。如果<span
class="math inline">\(H_1\)</span>(x) ≥ <span
class="math inline">\(P_1\)</span>且<span
class="math inline">\(H_2\)</span>(x) ≥ <span
class="math inline">\(P_2\)</span>（情况1），则对条目<span
class="math inline">\(T_1\)</span>[<span
class="math inline">\(H_1\)</span>(x)]和<span
class="math inline">\(T_2\)</span>[<span
class="math inline">\(H_2\)</span>(x)]进行探测。如果<span
class="math inline">\(H_1\)</span>(x) &lt; <span
class="math inline">\(P_1\)</span>且<span
class="math inline">\(H_2\)</span>(x) &lt; <span
class="math inline">\(P_2\)</span>（情况2），则对条目<span
class="math inline">\(T&#39;_1[H&#39;_1(x)]\)</span>和<span
class="math inline">\(T&#39;_2[H&#39;_2(x)]\)</span>进行探测。如果<span
class="math inline">\(H_1\)</span>(x) &lt; <span
class="math inline">\(P_1\)</span>且<span
class="math inline">\(H_2\)</span>(x) ≥ <span
class="math inline">\(P_2\)</span>（情况3），则对条目<span
class="math inline">\(T&#39;_1[H&#39;_1(x)]\)</span>和<span
class="math inline">\(T_2\)</span>[<span
class="math inline">\(H_2\)</span>(x)]进行探测。最后，如果<span
class="math inline">\(H_1\)</span>(x) ≥ <span
class="math inline">\(P_1\)</span>且<span
class="math inline">\(H_2\)</span>(x) &lt; <span
class="math inline">\(P_2\)</span>（情况4），则对条目<span
class="math inline">\(T_1\)</span>[<span
class="math inline">\(H_1\)</span>(x)]和<span
class="math inline">\(T&#39;_2[H&#39;_2(x)]\)</span>进行探测。</p>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230802204719881.png"
alt="image-20230802204719881" />
<figcaption aria-hidden="true">image-20230802204719881</figcaption>
</figure>
<h4 id="observation-1.">Observation 1.</h4>
<p>在查找操作中存在并行性，而在调整大小期间的查找操作需要执行元素的哈希计算、与重新哈希指针中的值进行比较，并且在旧哈希表中的一条路进行探测，或者在新哈希表中的一条路进行第二次哈希计算和探测。</p>
<h4 id="delete.">Delete.</h4>
<p>删除操作遵循查找的过程，在找到元素后清除相应的条目。因此，它的时间与查找相同，并且额外需要对目标路进行写操作。</p>
<h4 id="insert.">Insert.</h4>
<p>元素x的插入操作涉及随机选择旧的d-ary哈希表中的一条路i，并检查<span
class="math inline">\(H_i(x)\)</span> &lt; <span
class="math inline">\(P_i\)</span>是否为真。如果不是，则将元素插入到<span
class="math inline">\(T_i\)</span>[<span
class="math inline">\(H_i(x)\)</span>]；否则，将元素插入到新的d-ary哈希表的同一路<span
class="math inline">\(T&#39;_i[H&#39;_i(x)]\)</span>。在任一情况下，如果插入导致另一个元素的驱逐，则系统随机选择与刚刚更新的路不同的一条路，并对该元素重复相同的过程。该过程可能重复多次，每次选择与前一次不同的路。当插入不导致任何驱逐或达到最大迭代次数时，该过程终止。</p>
<p>下面的算法描述了插入操作。在算法中，<code>RAND_PICK</code>返回一组路中的随机路。我们使用<span
class="math inline">\(x \leftrightarrow
y\)</span>来表示值x和y的交换，并使用<span
class="math inline">\(\perp\)</span>表示空值。</p>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230802202224509.png"
alt="image-20230802202224509" />
<figcaption aria-hidden="true">image-20230802202224509</figcaption>
</figure>
<h4 id="hash-table-resize">Hash Table Resize</h4>
<p>与弹性Cuckoo哈希表调整大小相关的两个参数是<em>Rehashing
Threshold</em>（<span
class="math inline">\(r_t\)</span>）和<em>Multiplicative
Factor</em>（k）。当哈希表的占用比例达到<span
class="math inline">\(r_t\)</span>时，系统触发哈希表的调整大小，并分配一个比旧哈希表大k倍的新哈希表。</p>
<p>我们选择一个适当的<span
class="math inline">\(r_t\)</span>，以保证插入冲突很少，并且插入失败几乎可以忽略不计。如图4所示，对于3-ary哈希表，一个合适的<span
class="math inline">\(r_t\)</span>值为0.6或更小。我们选择一个合适的k，既不会浪费过多内存，也不会导致连续的调整大小操作。如果k太小，在调整大小过程中，当条目被移动到新哈希表时，新哈希表的占用率可能会达到触发新调整大小操作的点。</p>
<p>附录A展示了如何设置k。它表明k &gt; (<span
class="math inline">\(r_t\)</span> + 1)/<span
class="math inline">\(r_t\)</span>。例如，对于<span
class="math inline">\(r_t\)</span> = 0.4，k &gt; 3.5；因此k =
4是合适的。对于<span class="math inline">\(r_t\)</span> = 0.6，k &gt;
2.6；因此k = 3是合适的。然而，为了简化硬件，k取为2的幂次方最为合适。</p>
<p>为了在调整大小期间最小化旧哈希表中的冲突，限制调整大小期间存活区域的占用率是非常重要的。我们的算法跟踪存活区域中已使用条目的比例。只要这个比例不超过触发调整大小的整个表的比例，每次插入操作后只需要单次重新哈希。否则，每次插入操作后都需要重新哈希多个元素，直到存活区域回到所需的已使用条目的比例。</p>
<p>我们选择Rehashing
Threshold为足够低，以确保插入失败的频率可以忽略不计。然而，插入失败仍然可能发生。如果插入失败发生在调整大小之外，我们会启动调整大小。如果插入失败发生在调整大小期间，多个元素将被重新哈希到其他路，并再次尝试插入。实际上，通过选择合理的<em>Rehashing
Threshold</em>，我们完全可以避免插入失败。</p>
<p>弹性Cuckoo哈希表在占用率低于给定阈值时自然支持缩小。我们使用<em>Downsizing
Threshold</em>（<span
class="math inline">\(d_t\)</span>）和<em>Downsizing
Factor</em>（g）来缩小哈希表。对于渐进式缩小，我们使用类似于渐进调整大小的算法。</p>
<h2 id="elastic-cuckoo-page-table-design">5 Elastic Cuckoo Page Table
Design</h2>
<p>Elastic Cuckoo Page
Table是根据进程的内存需求动态缩放的私有哈希页表。它们能够解决哈希冲突，并支持多个页面大小和进程之间的页面共享。在本节中，我们描述它们的组织结构，cuckoo
walk tables和cuckoo walk caches。</p>
<h3 id="elastic-cuckoo-page-table-organization">5.1 Elastic Cuckoo Page
Table Organization</h3>
<p>Elastic Cuckoo Page
Table是一个由d-ary弹性布谷鸟哈希表组成的结构，它通过对虚拟页面号（VPN）标签进行哈希索引。一个核心中的进程拥有与页面大小相对应的Elastic
Cuckoo Page Table。图8显示了一个进程的Elastic Cuckoo Page
Table，适用于x86支持的页面大小：1GB、2MB和4KB。在图中，每个页表使用一个2-ary弹性布谷鸟哈希表。这些表使用了x86的术语命名：PUD、PMD和PTE。每个表项包含多个连续的页面转换条目。在这个示例中，我们假设每个表项有8个页面转换条目。因此，使用受x86启发的实现，这些表由以下VA位索引：PUD使用47-33位，PMD使用47-24位，PTE使用47-15位。所有的哈希函数都是不同的。</p>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230802210930165.png"
alt="image-20230802210930165" />
<figcaption aria-hidden="true">image-20230802210930165</figcaption>
</figure>
<p>通过使用多个独立的页表，这种设计可以支持任意页面大小。这与基数页表形成对比，基数页表由于其执行转换的方式，只能支持一些固定的页面大小。</p>
<p>此外，这种设计可以通过利用两级并行性来实现高性能。第一个级别是不同页面大小的页表之间的并行性。每个Elastic
Cuckoo Page
Table都是独立的，可以并行查找。这与基数页表形成对比，基数页表中每个树级别必须按顺序遍历。第二个级别是在d-ary表的不同d个路径之间的并行性。一个转换可能位于任何d个路径中的一个。因此，所有路径可以并行访问。总的来说，使用Elastic
Cuckoo Page
Table进行虚拟页面转换可以利用现代处理器提供的<strong>内存级并行性</strong>。</p>
<h4 id="page-table-entry">5.1.1 Page Table Entry</h4>
<p>弹性布谷鸟页表中的条目采用了页面表条目聚类和压缩的思想，目的是改善空间局部性并减少VPN标签的开销。具体来说，一个单独的哈希表条目包含一个VPN标签和多个连续的物理页转换条目，它们被紧密地打包在一起。打包在一起的条目数量被称为聚类因子，并且被选择为使标签和条目能够适应一个缓存行。</p>
<p>在64字节缓存行的机器中，我们可以在一个缓存行中聚类8个物理页转换条目和一个标签。这在[73]中提出的压缩方案中是可行的，该方案利用了来自多个连续转换中的一些未使用的位来编码标签
[38, 73]。</p>
<p>举个例子，考虑将8个4KB页面的PTE条目放置在一个缓存行中，这需要最长的VPN标签——即VA的第47-15位所对应的33位。在x86系统中，一个PTE通常使用64位。为了获得这些33位的标签，我们需要从每个PTE中取5位并重新用作标签。我们的实现从每个PTE中取了4位，这些位目前由Linux内核保留以支持实验性用途
[44]，以及1位，目前用于记录页大小——即页面大小是否为4KB或更大。在弹性布谷鸟页表中，后一种信息是不必要的。通过这些选择，我们将8个PTE条目和一个标签放置在一个缓存行中。对于PMD和PUD表，我们可以轻松地做同样的处理，因为我们只需要从这些哈希表中的每个物理页转换条目中取3位和2位，分别用作标签。</p>
<hr />
<h5 id="tips-1">tips</h5>
<p>一个cache line本来有 8 个entry，每个entry 64
bit，共512bit；我们需要标记这8个个entry对应的vpn（33bit），于是每个entry贡献5bit就足够了。</p>
<hr />
<h4 id="cuckoo-walk">5.1.2 Cuckoo Walk</h4>
<p>我们使用“布谷鸟遍历（Cuckoo
Walk）”一词来表示在弹性布谷鸟页表中查找正确转换的过程。布谷鸟遍历与顺序式基数页表遍历根本不同：它是一种<em>并行</em>遍历，可以同时查找多个哈希表。为了执行布谷鸟遍历，硬件页表遍历器取得一个VPN标签，使用不同哈希表的哈希函数对其进行哈希，然后使用得到的键来并行索引多个哈希表。</p>
<p>举个例子，假设我们有一个2-ary
PTE弹性布谷鸟页表。图9说明了从VPN标签开始的转换过程。由于聚类因子是8，VPN标签是VA的第47-15位。这些位被哈希使用两个哈希函数H1和H2。然后，将结果值添加到两个哈希表基地址的物理地址中。这些基地址存储在控制寄存器中。为了遵循x86术语，我们称这些寄存器为<span
class="math inline">\(CR3-PageSize_j-way_i\)</span>。然后访问得到的物理地址，并且如果任何两个标签与VPN标签匹配，则宣布为命中。在命中的情况下，使用PTE
Offset（位14-12）来索引哈希表条目并获取所需的PTE条目。</p>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230803115651534.png"
alt="image-20230803115651534" />
<figcaption aria-hidden="true">image-20230803115651534</figcaption>
</figure>
<p>假设系统支持S种不同的页面大小。在进行转换时，如果请求的页面大小未知，硬件可能需要查找每个S个弹性布谷鸟页表的d个方式。因此，布谷鸟遍历可能需要执行最多S*d个并行查找。在接下来的部分，我们将展示如何显著减少这个数量。</p>
<p>与基数页表条目类似，弹性布谷鸟页表的条目按需被缓存在缓存层次结构中。这样的支持加速了转换过程，因为它减少了发送到主存的请求数量。</p>
<h3 id="cuckoo-walk-tables">5.2 Cuckoo Walk Tables</h3>
<p>我们不希望弹性布谷鸟页表遍历（cuckoo page walk）需要执行S *
d个并行查找来获取一个页面转换项。为了减少所需的查找次数，我们引入了“Cuckoo
Walk
Tables”（CWTs）。这些软件表包含有关应该访问哪个弹性布谷鸟页表的哪个路径（way）以获取所需的页面转换项的信息。当操作系统对弹性布谷鸟页表执行某些类型的更新（详见第5.2.1节）时，CWTs会被操作系统更新。硬件会自动读取CWTs，并有效地减少获取转换的并行查找次数。</p>
<p>使用CWTs导致了图10中显示的四种类型的布谷鸟遍历。该图假设有三种页面大小（1GB、2MB和4KB）和2-ary弹性布谷鸟页表。</p>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230803115758726.png"
alt="image-20230803115758726" />
<figcaption aria-hidden="true">image-20230803115758726</figcaption>
</figure>
<h5 id="complete-walk">Complete Walk:</h5>
<p>在这种情况下，CWTs不提供任何信息，因此硬件访问所有页面大小的弹性布谷鸟页表的所有way。</p>
<h5 id="partial-walk">Partial Walk:</h5>
<p>CWTs指示页面不属于给定的大小。因此，硬件访问可能属于其他弹性布谷鸟页表的所有way。在某些情况下，可以避免搜索其中一些方式。在图中用虚线表示。</p>
<h5 id="size-walk">Size Walk:</h5>
<p>CWTs指示页面属于给定的大小。因此，硬件访问单个弹性布谷鸟页表的所有way。</p>
<h5 id="direct-walk">Direct Walk:</h5>
<p>CWTs指示页面的大小和存储转换的way。在这种情况下，只访问单个弹性布谷鸟页表的一个way。</p>
<p>理想情况下，我们每个弹性布谷鸟页表都有一个关联的CWT。在我们的情况下，这意味着有一个PUD-CWT、一个PMD-CWT和一个PTE-CWT，它们逐渐提供更精确的信息。这些表按顺序访问，并且每个表可能比前一个表提供更精确的信息。</p>
<p>然而，这些软件表位于内存中。为了使它们能够以低延迟访问，它们被缓存在MMU中的特殊缓存中，称为Cuckoo
Walk
Caches（布谷鸟遍历缓存）。这些缓存取代了基数页表的页面遍历缓存。它们在第5.3节中进行了描述。在我们的设计中，我们发现缓存PTE-CWT会提供过少的局部性，以致于没有收益，这一观察与基数页表的当前页面遍历缓存不缓存PTE条目的事实一致。因此，我们只有PUD-CWT和PMD-CWT表，并将它们缓存在布谷鸟遍历缓存中。</p>
<p>PUD-CWT和PMD-CWT由使用锁的操作系统线程进行更新。它们被设计为d-ary的弹性布谷鸟哈希表，就像页面表一样。接下来我们将讨论它们的条目格式。</p>
<h4 id="cuckoo-walk-table-entries.">5.2.1 Cuckoo Walk Table
Entries.</h4>
<p>CWT中的一个条目包含一个VPN标签和若干个连续的段头（<em>Section
Header</em>），使得整个CWT条目占据整个缓存行。一个节头提供有关给定虚拟内存<em>段(section)</em>的信息。一个段是相应弹性布谷鸟页面表中的一个条目所翻译的虚拟内存地址空间范围。节头指定该段中页面的大小以及弹性布谷鸟页面表中哪个路径保存该段的翻译。</p>
<p>为了让这个概念更加具体，我们展示了PMD-CWT中条目的确切格式。图11显示一个条目由一个VPN标签和64个节头组成。每个节头提供有关PMD弹性布谷鸟页面表中一个条目映射的虚拟内存段的信息。例如，图11显示了一个阴影节头，它提供有关PMD弹性布谷鸟页面表中阴影条目所映射的虚拟内存段的信息（在图的底部显示）。
该条目，如第5.1.1节所述，包括一个VPN标签和8个PMD翻译，以填满整个缓存行。</p>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230803115945811.png"
alt="image-20230803115945811" />
<figcaption aria-hidden="true">image-20230803115945811</figcaption>
</figure>
<p>由于PMD页面的大小为2MB，而虚拟内存段（即图11中的PMD弹性布谷鸟页面表的一行或条目）最多可以映射8个PMD页面，所以一个虚拟内存段包含16MB。需要注意的是，这个虚拟内存段的一部分或全部可能由4KB页面（其翻译在PTE弹性布谷鸟页面表中）而不是2MB页面填充。</p>
<p>然后，一个PMD-CWT行或条目为这些虚拟内存段中的64个提供信息，这对应总共1GB的内存空间。因此，PMD-CWT条目的VPN标签包含虚拟地址的47-30位。考虑到64字节的缓存行，这个设计允许在PMD-CWT条目的每个节头中使用至少4位，但我们不能在一行中使用更多的节头。</p>
<p>这4位编码了图11中所示的信息。第一个位（2MB位）指示该内存段是否映射一个或多个2MB页面。第二个位（4KB位）表示该段是否映射一个或多个4KB页面。最后两位（路位）仅在2MB位被设置时有意义。它们指示PMD弹性布谷鸟页面表的路，该表包含了此虚拟内存段中2MB页面的映射翻译。请注意，此编码假定弹性布谷鸟页面表最多有四条路。</p>
<p>表1显示了硬件页行走器在从PMD-CWT中读取目标节头时采取的动作。如果2MB位和4KB位都清除，则该段中没有映射任何2MB或4KB页面。因此，行走器不会访问PMD或PTE弹性布谷鸟页面表。如果设置了2MB位并且4KB位被清除，则行走器在PMD弹性布谷鸟页面表中执行直接查找，使用由路位指示的路。只需要一次访问，因为此段的所有翻译信息都包含在PMD表的单个条目中。</p>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230803120121631.png"
alt="image-20230803120121631" />
<figcaption aria-hidden="true">image-20230803120121631</figcaption>
</figure>
<p>如果2MB位被清除且4KB位被设置，则此段的所有翻译都在PTE弹性布谷鸟页面表中。遗憾的是，PMD-CWT节头中没有关于应访问PTE弹性布谷鸟页面表的哪个路（或路）的信息。因此，行走器在PTE弹性布谷鸟页面表中执行大小遍历。最后，如果2MB位和4KB位都被设置，则目标页面可以是任一大小。因此，行走器执行部分遍历。该遍历由PMD弹性布谷鸟页面表中的直接遍历组成（使用路位指示的路），以及PTE弹性布谷鸟页面表中的大小遍历。</p>
<p>PUD-CWT的组织方式类似。每个节头现在覆盖8GB的虚拟内存段。一个节头有5位：1GB位，2MB位和4KB位，分别指示该段是否映射一个或多个1GB页面，一个或多个2MB页面和/或一个或多个4KB页面；还有两位路位，指示PUD弹性布谷鸟页面表的路，该表包含了此虚拟内存段中1GB页面的映射翻译。如果设置了1GB位，则路位有效。基于这些位的值采取的操作与PMD-CWT相似。为简单起见，我们不详细介绍它们。</p>
<p>总的来说，我们的设计使用CWTs中的少数位对虚拟内存段进行了大量信息编码。</p>
<p>通过对PUD-CWT和PMD-CWT的编码，操作系统很少更新这些表。对弹性布谷鸟页面表的大多数更新都不需要更新CWT。例如，考虑PMD-CWT中的节头。其2MB位和4KB位仅在第一次在该节中分配2MB页面或4KB页面时更新。回想一下，一个节的大小等于4096个4KB页面。同样，当分配或重新散列4KB页面时，PMD-CWT中的节头中的路位不会更新。最后，概念上的设计是，在进行页面遍历时，硬件首先访问PUD-CWT，然后访问PMD-CWT，并根据所获得的信息发出减少的页面表访问。然而，实际设计是，CWT信息被缓存在MMU中的小缓存中，并从关键路径上填充。我们接下来介绍这些缓存。</p>
<h3 id="cuckoo-walk-caches">5.3 Cuckoo Walk Caches</h3>
<p>PUD-CWT和PMD-CWT位于内存中，并且它们的条目可以在缓存层次结构中缓存，就像弹性布谷鸟页面表条目一样。然而，为了在页面遍历时实现非常快的访问，我们的设计按需将它们的一些条目缓存在MMU中的Cuckoo
Walk
Caches（CWCs）中。我们称这些缓存为PUD-CWC和PMD-CWC，并取代基数页表的页面遍历缓存。硬件页面遍历器在访问弹性布谷鸟页面表之前检查CWCs，并根据CWCs中的信息，可以发出较少的并行访问页面表。</p>
<p>PUD-CWC和PMD-CWC与基数页表的页面遍历缓存有一个重要的区别：它们的内容（就像CWTs的内容一样）与页面表的内容是<em>分离</em>的。CWCs存储页面大小和路信息。这与传统的页面遍历缓存不同，后者存储页面表条目。因此，CWCs和CWTs可以独立于弹性布谷鸟页面表进行访问。这一事实有两个含义。</p>
<p>第一个含义是，在CWC<em>缺失</em>的情况下，页面遍历器可以<em>立即</em>访问目标页面表条目
-
尽管可能需要同时发出更多的内存访问请求。在页面遍历完成后，TLB已经填充，并且执行已经重新启动，然后适当的CWT条目被获取并缓存在CWC中，越过（off）了关键路径。而在传统的页面遍历缓存中，页面遍历缓存中的条目必须在访问目标页面表条目和填充TLB之前顺序生成，这会成为关键路径。</p>
<p>第二个含义是CWC条目非常小。它只包括一些页面大小和路位信息。这与传统的页面遍历缓存中的条目不同，后者需要包括下一级页面转换的物理地址，除了页面大小和其他信息。例如，PMD-CWC部分头覆盖16MB区域（4096个4KB页面），仅使用4位，而传统PMD页面遍历缓存中的条目只覆盖2MB区域（512个4KB页面）使用64位。结果是CWC具有较小的大小和非常高的命中率。</p>
<h2 id="implementation">6 Implementation</h2>
<h3 id="steps-of-a-page-translation">6.1 Steps of a Page
Translation</h3>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230803120534242.png"
alt="image-20230803120534242" />
<figcaption aria-hidden="true">image-20230803120534242</figcaption>
</figure>
<p>图12展示了使用Elastic Cuckoo Page Tables
(ECPTs)进行页面转换的步骤。为简单起见，我们假设没有1GB的页面。在TLB缺失时，页面表遍历器硬件首先检查PUD-CWC
1。如果PUD-CWC命中，则检查相应的段头。它可以指示该段只包含4KB页面、只包含2MB页面或同时包含2MB和4KB页面。在只有4KB页面的情况下，页面遍历器在PTE
ECPT中执行大小遍历
5，该遍历将把转换带到TLB或触发页面故障。在只有2MB页面或同时包含2MB和4KB页面的段的情况下，访问PMD-CWC以获取更多信息
8 。</p>
<p>如果PMD-CWC命中，则较小的访问的段可能再次只包含4KB页面、只包含2MB页面或同时包含2MB和4KB页面。在第一种情况下，页面遍历器在PTE
ECPT中执行大小遍历 5；在第二种情况下，它在PMD ECPT中执行直接遍历
6；在第三种情况下，它执行部分遍历 7，其中包括PMD ECPT中的直接遍历和PTE
ECPT中的大小遍历。</p>
<p>如果PMD-CWC未命中，页面遍历器将使用PUD-CWC提供的部分信息。具体来说，如果PUD段只包含2MB页面，则页面遍历器在PMD
ECPT中执行大小遍历 9（因为PMD
ECPT方式没有信息）；如果PUD段既包含2MB页面又包含4KB页面，则它执行部分遍历
11，其中包括PMD ECPT和PTE
ECPT的大小遍历。在这两种情况下，当TLB被填充且执行恢复后，硬件将PMD-CWT条目中缺失的部分加载到PMD-CWC中
10。</p>
<p>最后一种情况是当访问PUD-CWC未命中时。页面遍历器仍然访问PMD-CWC以查看是否可以获取一些信息
2。如果PMD-CWC命中，则访问的段可能只包含4KB页面、只包含2MB页面或同时包含2MB和4KB页面。页面遍历器分别执行操作
5、6和7。如果PMD-CWC未命中，则页面遍历器没有信息，并执行完整遍历将转换带入TLB
3。之后，硬件将缺失的PUD-CWT和PMD-CWT条目分别加载到PUD-CWC和PMD-CWC中
4。</p>
<p>在本讨论中，我们没有考虑1GB页面，因此在PUD-CWC未命中且PMD-CWC命中的情况下，无需获取PUD-CWT条目。如果考虑了1GB页面，则硬件在这种情况下需要获取PUD-CWT条目。</p>
<h3 id="concurrency-issues">6.2 Concurrency Issues</h3>
<p>弹性布谷鸟页表自然地支持多进程和多线程的应用程序，并且与Radix页表一样，遵循Linux的页面表管理并发模型。具体而言，多个MMU页表查找器可以执行页面表查找，而一个OS线程执行页面表更新。</p>
<p>当发现页面表条目的Present位为清零时，会发生页面错误。在处理页面错误时，其他线程仍然可以执行查找操作。我们的方案处理这些情况与当前Linux中的Radix页表类似：当操作系统更新弹性布谷鸟页表或CWT时，会对它们进行锁定。读者可能会从CWC获取过时的信息，但最终会获得正确的状态。</p>
<p>操作系统使用同步和原子指令来插入弹性布谷鸟页表的条目，在页表中的不同路径之间移动元素，在调整大小操作中在不同页表之间移动条目，更新调整阈值，在调整大小操作中更新CWT。</p>
<p>如果CWC是一致的，更新CWT条目将使CWC中的条目无效。在我们的评估中，我们不做这样的假设。在这种情况下，当页面查找器使用在CWC中找到的信息来访问一个翻译并且访问失败时，查找器会重新进行页面查找。但这次，它会访问目标弹性布谷鸟页表的剩余路径，或者如果调整大小正在进行，则访问两个表的剩余路径。这个操作将会找到已经移动到另一个路径的条目。在获得翻译后，CWC中的旧条目将被刷新。对于调整阈值也采取类似的处理过程。</p>
<h2 id="evaluation-methodology">7 Evaluation Methodology</h2>
<h4 id="modeled-architectures.">Modeled Architectures.</h4>
<p>我们使用全系统周期级仿真来模拟一个具有8个核心和64GB主存储器的服务器架构。我们分别对具有4级基于x86-64架构的基准页表和我们提出的弹性布谷鸟页表的系统进行建模。我们分别使用只有4KB页面和启用了Linux内核中的透明超大页面（Transparent
Huge Pages，THP）的多页面大小来建模这些系统。我们将这些系统称为Baseline
4KB、Cuckoo 4KB、Baseline THP和Cuckoo THP。</p>
<p>这些系统的架构参数如下表所示。每个核心都是乱序执行的，并且具有私有的L1和L2缓存，以及一部分共享的L3缓存。每个核心还有私有的L1和L2
TLB和页表查找缓存以进行地址转换。Cuckoo架构使用3-ary弹性布谷鸟哈希用于Elastic
Cuckoo Page
Tables（ECPTs），并使用2-ary弹性布谷鸟哈希用于CWTs。基线架构使用x86-64的4级基于radix的页表。我们将Cuckoo架构中的CWCs的大小调整为比Baseline架构中的PWCs更小，Baseline架构的PWCs是模仿x86-64的。具体而言，两个CWCs共有18个条目，每个条目为32B，总共为576B；三个PWCs共有96个条目，每个条目为8B，总共为768B。</p>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230803214128003.png"
alt="image-20230803214128003" />
<figcaption aria-hidden="true">image-20230803214128003</figcaption>
</figure>
<h4 id="modeling-infrastructure.">Modeling Infrastructure.</h4>
<p>我们将Simics全系统模拟器与SST框架和DRAMSim2内存模拟器集成在一起。我们在Simics上使用Intel
SAE进行操作系统的仪器化。我们使用CACTI对内存结构的能量和访问时间进行评估，并使用Synopsys
Design
Compiler评估哈希函数的RTL实现。Simics为每个内存地址提供实际的内存和页表内容。我们使用SST对弹性布谷鸟页表的硬件组件进行详细建模和评估。</p>
<h4 id="workloads.">Workloads.</h4>
<p>我们评估了不同级别的TLB压力的各种工作负载，这些工作负载属于图分析、生物信息学、高性能计算和系统领域。具体来说，我们使用了来自GraphBIG基准测试套件的八个图应用程序。其中两个是社交图分析算法，分别是Betweenness
Centrality (BC)和Degree Centrality
(DC)；两个是图遍历算法，分别是Breadth-First Search (BFS)和Depth-First
Search
(DFS)；另外四个是用于拓扑分析、图搜索/流和网站相关性的图分析基准测试，分别是Single
Source Shortest Path (SSSP)、Connected Components (CC)、Triangle Count
(TC)和PageRank (PR)。</p>
<p>从生物信息学领域，我们使用了BioBench套件中的MUMmer，它用于基因组级别的比对。从高性能计算领域，我们使用了HPC
Challenge中的GUPS，它是一个随机访问基准测试，用于测量整数随机内存更新的速率。最后，从系统领域，我们选择了SysBench套件中的Memory基准测试，它对内存子系统进行压力测试。我们将其称为SysBench。</p>
<p>这些工作负载的内存占用量为：BC为17.3GB，DC为9.3GB，BFS为9.3GB，DFS为9GB，SSSP为9.3GB，CC为9.3GB，TC为11.9GB，PR为9.3GB，MUMmer为6.9GB，GUPS为32GB，SysBench为32GB。</p>
<p>对于每个单独的工作负载，我们对所有不同的配置进行了全系统模拟。当到达工作负载的感兴趣区域时，详细的模拟开始。我们对每个核心进行50亿条指令的热身，并且然后测量每个核心500亿条指令的执行。</p>
<h2 id="evaluation">8 Evaluation</h2>
<h3 id="elastic-cuckoo-hashing-characterization">8.1 Elastic Cuckoo
Hashing Characterization</h3>
<p>图13描述了弹性布谷鸟哈希的行为特征。左侧显示成功插入一个元素所需的平均插入尝试次数，右侧显示在32次尝试后插入失败的概率，两者都作为表占用率的函数。我们使用3-ary弹性布谷鸟哈希和BLAKE哈希函数[5]。与图4不同，这张图中表的占用率超过了1。原因是当占用率达到重哈希阈值rt
= 0.6时，我们会使用乘法因子k =
4分配一个新的哈希表，并执行渐进式调整大小。回顾一下，在渐进式调整大小中，每次插入都会跟随一个从当前哈希表到新哈希表的重哈希，将一个元素从当前表移动到新表中。</p>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230803214502778.png"
alt="image-20230803214502778" />
<figcaption aria-hidden="true">image-20230803214502778</figcaption>
</figure>
<p>弹性布谷鸟哈希的平均插入尝试次数显示在弹性总插入曲线上。该曲线是弹性插入和弹性重哈希曲线的累加。后者是在调整大小期间从旧表重新散列到新表的元素的重哈希。更详细地说，假设在调整大小期间插入一个元素。该插入以及由于碰撞而导致的任何额外重新插入都计入弹性插入。与之关联的从旧表重新散列到新哈希表的一个元素的重哈希以及由于碰撞而导致的任何额外重新插入都计入弹性重哈希。</p>
<p>我们可以看到，在占用率等于rt时，弹性重哈希曲线跳跃掉。当调整大小进行，元素开始在更大的新表中扩散时，由于重哈希而导致的插入尝试减少。当调整大小在占用率为⇡1.6时终止时，弹性重哈希曲线降为零。弹性插入曲线随着调整大小的进行逐渐减小。因此，弹性总插入曲线在调整大小开始时有一个峰值，但在调整大小完成后降至1。在之后，当新表重新调整大小时，可能会出现另一个峰值。</p>
<p>该图还显示了没有调整大小的普通布谷鸟哈希的插入尝试次数。这条曲线来自图4。总体而言，弹性布谷鸟哈希通过调整大小从未达到大量插入尝试次数。此外，如右图所示，没有插入失败发生。</p>
<h3 id="elastic-cuckoo-page-table-performance">8.2 Elastic Cuckoo Page
Table Performance</h3>
<p>图14评估了弹性布谷鸟页表的性能影响。图14a显示了在Baseline
4KB上运行的应用程序相比于在Baseline 4KB上运行的应用程序的加速比，Cuckoo
4KB和Cuckoo THP。</p>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230803214702366.png"
alt="image-20230803214702366" />
<figcaption aria-hidden="true">image-20230803214702366</figcaption>
</figure>
<p>图表显示，只有4KB页面时，使用弹性布谷鸟页表（Cuckoo
4KB）相比于使用传统的radix页表（Baseline
4KB）可以获得3-28%的应用程序加速。平均加速比为11%。当启用了透明大页面（THP）时，无论是radix页表还是弹性布谷鸟页表，加速效果都显著提高，因为减少了TLB缺失。Cuckoo
THP相比Baseline
THP的加速比为3-18%。平均加速比为10%。这些都是非常显著的应用程序加速。</p>
<p>事实上，在一些应用程序中，Cuckoo 4KB不仅优于Baseline
4KB，还优于Baseline
THP。一些应用程序，如SSSP和TC，并不太受THP的影响。然而，Cuckoo
4KB在使用2MB页面的应用程序，如MUMmer中，也优于Baseline THP。</p>
<p>弹性布谷鸟页表所实现的性能提升有几个原因。首先，弹性布谷鸟页表中的页表遍历直接获取最终的翻译结果，而不需要像radix页表那样按顺序获取中间级别的翻译结果。这种能力加快了翻译过程。其次，CWC的高命中率也提高了性能，这是因为CWC不必存储具有中间级别翻译的条目，并且每个CWC条目很小
-
这与radix页表不同。最后，我们观察到当页表遍历执行大小(Size)和部分(Partial)遍历时，它将翻译结果带入L2和L3缓存中，尽管这些结果尚未加载到TLB中，但它们将在未来使用。实际上，该遍历将翻译结果预取到了缓存中。</p>
<p>图14b显示了所有内存系统请求在MMU中所用的时间，包括访问TLB和进行页表遍历。该时间相对于Baseline
4KB的时间进行了归一化。该图大致遵循图14a的趋势。平均而言，Cuckoo
4KB将Baseline 4KB的MMU开销降低了34％，而Cuckoo THP的开销比Baseline
THP低41％。该图还显示，像GUPS和SysBench这样执行完全随机内存访问的应用程序从THP中获益很多。</p>
<p>我们还评估了一些具有较低的页表遍历开销的应用程序，特别是在使用THP时，例如SPEC2006的MCF和Cactus
[32]，PARSEC的Streamcluster [16]，以及XSBench
[71]。它们的内存占用分别为1.7GB，4.2GB，9.1GB和64GB。在这些应用程序中，虽然弹性布谷鸟页表相比于radix页表降低了MMU开销，但地址翻译并不成为瓶颈。因此，应用程序性能保持不变。</p>
<h3 id="elastic-cuckoo-page-table-characterization">8.3 Elastic Cuckoo
Page Table Characterization</h3>
<h4 id="mmu-and-cache-subsystem">8.3.1 MMU and Cache Subsystem</h4>
<p>图15描述了四个配置的MMU和缓存子系统的性能特征。从上到下，分别显示了每千条指令的MMU请求数（MMU
requests Per Kilo Instruction，PKI）、L2缓存每千条指令的缺失数（L2
Misses Per Kilo Instruction，MPKI）和L3
MPKI。在每个图表中，条形图都相对于Baseline 4KB进行了归一化。</p>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230803215418278.png"
alt="image-20230803215418278" />
<figcaption aria-hidden="true">image-20230803215418278</figcaption>
</figure>
<p>MMU请求是MMU在TLB缺失时向缓存层次结构发出的请求。对于基准系统，它们是获取四个radix树级别的页表翻译的内存请求；对于弹性布谷鸟系统，它们是用于页表翻译和CWT条目的请求。从图中可以看出，Cuckoo
4KB和Cuckoo THP比Baseline 4KB和Baseline
THP分别发出了更多的请求。这有两个原因。第一个，也是最重要的原因是，弹性布谷鸟页表遍历中的许多遍历都不是直接遍历。因此，它们请求了比所需更多的页表条目
-
实际上，由于我们没有PTE-CWT表，没有任何访问PTE弹性布谷鸟页表的访问可以使用直接遍历。第二个原因是对CWT本身的访问。</p>
<p>幸运的是，大多数额外的MMU访问都被L2和L3缓存截获，不会到达主存。事实上，如图15中央和底部的图表所示，Cuckoo系统的L2
MPKI与Baseline系统的相似，而Cuckoo系统的L3
MPKI低于Baseline系统。原因有两个。首先，CWT条目被设计为覆盖大片的内存。因此，所需的条目适合几个缓存行，导致高缓存命中率。第二个原因是由于访问表的多个路数而带来的额外弹性布谷鸟页表条目通常会被另一个访问后再次使用。现在访问它们相当于为将来的访问预取它们。总而言之，尽管弹性布谷鸟页表发出更多的MMU请求，大部分请求在缓存中命中，与radix页表相比，主存的总体流量更低。</p>
<p>为了说明这一点，图16将MUMmer应用程序中的所有MMU访问按完成时间分组。图中显示了Baseline
THP和Cuckoo
THP的数据。在条形图的上方，我们指示了在某些延迟范围内访问的内存层次：缓存命中、第一次DRAM访问、第二次DRAM访问和第三次DRAM访问。Cuckoo
THP永远不会进行多次DRAM访问。从图中可以看出，Cuckoo
THP的MMU访问具有较低的延迟；大多数访问都被缓存截获，最坏情况下需要约200个周期。Baseline
THP的MMU访问通常进行两次或三次DRAM访问，并且有一个达到500多个周期的较长延迟尾部。</p>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230803215503898.png"
alt="image-20230803215503898" />
<figcaption aria-hidden="true">image-20230803215503898</figcaption>
</figure>
<h4 id="types-ofwalks.">8.3.2 Types ofWalks.</h4>
<p>我们现在考虑图12中的弹性布谷鸟页表转换过程，并测量图10中所示的每种类型的布谷鸟遍历的相对频率。我们使用具有2MB大页的弹性布谷鸟页表（Cuckoo
THP）。作为参考，所有应用程序中PUD-CWC和PMD-CWC的平均命中率分别为99.9%和87.7%。</p>
<p>图17展示了每个应用程序的四种布谷鸟遍历类型的分布。从柱状图底部开始，我们可以看到完整遍历（Complete
Walks）的比例非常小。完整遍历仅在PUD-CWC和PMD-CWC都未命中时发生，这种情况非常罕见。部分遍历（Partial
Walks）发生在访问的内存段中包含大页和常规页的情况下。虚拟内存中同时存在两种页面大小的情况在一个段中是不常见的。这种情况在BC应用中有一定程度的发生，在其他应用中很少出现。</p>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230803215536202.png"
alt="image-20230803215536202" />
<figcaption aria-hidden="true">image-20230803215536202</figcaption>
</figure>
<p>幸运的是，大多数遍历都是廉价的类型，即Size Walks和Direct Walks。Size
Walks发生在内存段仅包含常规页的情况下。因此，我们观察到在不使用大页的应用程序中出现了这种行为，比如BFS，CC，DC，DFS，PR，SSSP，TC，以及在BC中也有少量发生。这些遍历是最常见的一种。它们也会在内存区域只有大页，但是PMD-CWC未命中的情况下发生，这种情况较为罕见。</p>
<p>最后，Direct
Walks发生在内存段仅包含大页的情况下。我们观察到它们出现在大量使用大页的应用程序中，比如GUPS，SysBench和MUMmer。总体而言，廉价遍历是最常见的。</p>
<h4 id="memory-consumption">8.3.3 Memory Consumption</h4>
<p>图18显示了不同配置下各种应用程序的页表内存消耗。对于Cuckoo系统，柱状图还包括了CWTs的内存消耗。第一个柱状图（Required）是应用程序使用的PTE数乘以8字节。然后，图中显示了Baseline
4KB，Cuckoo 4KB和Cuckoo
4KB与表缩减的情况。请注意，在本文的其他地方我们没有使用表缩减。平均而言，Required使用了26MB的内存。Baseline
4KB平均消耗27MB的内存，因为它还需要保持三个上级的转换。Cuckoo
4KB平均消耗36MB的内存，因为它需要分配包含2的幂次数条目的哈希表。CWTs增加的内存很少。总体而言，支持Cuckoo
4KB所需的内存绝对增加很小，与现代系统的总内存容量相比。最后，表缩减后的Cuckoo
4KB平均消耗29MB的内存。</p>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230803215929357.png"
alt="image-20230803215929357" />
<figcaption aria-hidden="true">image-20230803215929357</figcaption>
</figure>
<h4 id="comparison-to-2-ary-cuckoo-page-tables.">8.3.4 Comparison to
2-ary Cuckoo Page Tables.</h4>
<p>我们重新评估了弹性杜鹃页表，这次使用的是2-叉弹性杜鹃哈希，而不是我们默认的3-叉设计。我们的结果显示，使用3-叉结构比使用2-叉结构加快了应用程序的速度：在Cuckoo
4KB中，应用程序平均运行速度提高了6.7％，在Cuckoo
THP中提高了3.3％。原因是2-叉结构在较低占用率时容易发生哈希冲突，因此需要更早地调整大小。我们发现，在应用程序执行期间，2-叉表比3-叉表需要更多的重新哈希操作：在我们的所有应用程序中，平均在Cuckoo
4KB中需要63.3％的更多重新哈希，在Cuckoo
THP中需要84％。由3-叉结构引起的额外访问对性能影响相对较小，因为它们通常会命中缓存。</p>
<h2 id="other-related-work">9 Other Related Work</h2>
<p>为了减少TLB（翻译后备缓冲器）缺失，最近的研究提出了通过聚类、合并、连续性优化TLB的组织方式
[14, 18, 21, 42, 54–56, 64, 72]，通过预取 [15, 41, 63]、推测性TLB [9]
和大型部分内存TLB [47, 62]
来实现TLB的扩展。为了增加TLB的覆盖范围，对大页面的支持已经得到广泛研究
[21, 26, 27, 29, 43, 49, 51–53, 57, 60, 67, 69]，并对操作系统进行了改进
[26, 43, 51, 52]。其他研究提出了直接段 [10, 25] 和非虚拟化内存
[31]，并建议应用程序管理虚拟内存 [2]。</p>
<p>许多这些进展都专注于创建翻译连续性：将大连续的虚拟空间映射到大连续的物理空间。这样，需要的翻译次数减少，TLB缺失减少，并且昂贵的多步骤页面查找被最小化。然而，强制连续性会损害内核和其他软件所享受的映射灵活性。而且，强制连续性通常是不可能的，或者在性能上是适得其反的。相反，在我们的工作中，我们专注于通过创建单步翻译过程显著降低页面查找的成本，同时保持内核和其他软件的现有抽象。因此，我们不需要连续性，并保留了当前系统所有的映射灵活性。</p>
<h2 id="conclusion">10 Conclusion</h2>
<p>本论文提出了弹性杜鹃页表，这是一种新颖的页表设计，将基数页表的顺序地址转换变换为完全并行查找，首次利用内存级并行性来进行地址转换。我们的评估结果显示，与传统的基数页表相比，弹性杜鹃页表将地址转换开销平均降低了41％，并且加速了应用程序执行速度，提高了3-18％。我们当前的工作涉及探索在虚拟化环境中应用弹性杜鹃页表的可能性。</p>
]]></content>
      <categories>
        <category>体系结构</category>
        <category>Virtual memory</category>
        <category>Page tables</category>
        <category>Hashed page tables</category>
      </categories>
      <tags>
        <tag>Paper</tag>
      </tags>
  </entry>
  <entry>
    <title>gem5 Full System Simulation</title>
    <url>/zyhjy/2023/08/16/FS-Full-System-Emulation/</url>
    <content><![CDATA[<h1 id="gem5-full-system-simulation">gem5 Full System Simulation</h1>
<p><a
href="https://www.youtube.com/watch?v=dMVrNyYqfMA&amp;list=PL_hVbFs_loVSaSDPr1RJXP5RRFWjBMqq3&amp;index=8&amp;t=2479s">video</a>
<a
href="https://www.youtube.com/redirect?event=video_description&amp;redir_token=QUFFLUhqbG9lcktEWEdOV0xab1RpZzNVUmtHUzVjbXVjd3xBQ3Jtc0trZXpzSVlPV0xlTFVzdkRONW5MMkF3Z1VhRHhZYTdUbjJrNG52SzFtak85UFQyallsaWxmODZTMm5sdHZfVVhwamx0WWFpX0xIREV1RmZXRDNHR3F5enVIR3ZTQ1RsZzRGR3RaaGJGdHhQMEJQWkpKRQ&amp;q=https%3A%2F%2Fucdavis365-my.sharepoint.com%2F%3Ap%3A%2Fg%2Fpersonal%2Fjlowepower_ucdavis_edu%2FEVmWd7NM8HBGtT6MvMkFyJcBvRhUgzjpPD6PAa_-CIHGMA%3Fe%3DKEky0H&amp;v=dMVrNyYqfMA">slide</a></p>
<h2 id="intro.-to-gem5-full-system-mode">Intro. to gem5 Full System
Mode</h2>
<h3 id="what-is-full-system-simulation">What is full-system
simulation?</h3>
<p>Full-system Simulation (FS) encompasses(包含) the entire computer
system:</p>
<span id="more"></span>
<ul>
<li>the processor cores</li>
<li>peripheral(外围的) devices</li>
<li>memories</li>
<li>network connections</li>
<li>the complete software stack
<ul>
<li>device drivers</li>
<li>operating systems</li>
<li>application programs</li>
</ul></li>
</ul>
<h3 id="gem5-in-full-system-mode">gem5 in Full System Mode</h3>
<p>In full system mode, gem5 acts more like an emulator (e.g., QEMU) or
hypervisor (e.g., VMWare ESX and Xen) than a traditional simulator. In
full system mode, gem5 simulates all of the hardware from the CPU to the
I/O devices.</p>
<p>This allows gem5 to execute binaries with no modifications.</p>
<p>Additionally, full system mode allows researchers to investigate the
impacts of the operating system and other low-level details.</p>
<h3 id="what-gem5-needs-for-fs">What gem5 needs for FS?</h3>
<ul>
<li><strong>gem5 Binary</strong> and <strong>Config file</strong>
<ul>
<li>eg: gem5/build/X86/gem5.opt and x86-npb-benchmarks.py</li>
</ul></li>
<li><strong>Kernel Binary</strong>
<ul>
<li>core of an OS</li>
</ul></li>
<li><a href="#disk-image"><strong>Disk Image</strong></a>
<ul>
<li>A descriptive(描写的) file of the hard drive, the non-volatile
memory to store data, app, bootloader and OS, etc</li>
</ul></li>
<li><strong>Workloads Binaries</strong></li>
</ul>
<p>the command :</p>
<p><code>gem5/build/X86/gem5.opt  x86-npb-benchmarks.py  --PATH-TO-KERNEL-BIN  --PATH-TO-DISK-IMG  --PATH-TO-WKL-BIN</code></p>
<h1 id="basics-of-booting-up-a-system">Basics of Booting up a
System</h1>
<h2 id="booting-steps">Booting Steps</h2>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230818180301848.png"
alt="image-20230818180301848" />
<figcaption aria-hidden="true">image-20230818180301848</figcaption>
</figure>
<p>many of these steps take data/code from disk!</p>
<h3 id="bios">1. BIOS</h3>
<p>BIOS (basic input/output system) software is stored on a non-volatile
ROM chip on the motherboard.</p>
<p>BIOS perform hardware initialization during the booting process.</p>
<p>Bios is firmware used to provide runtime services for operating
systems and programs.</p>
<h3 id="bootloader">2. Bootloader</h3>
<p>OS must be loaded into the working memory once the computer is
starting up.</p>
<p>This is the job of a bootloader!</p>
<p>Immediately after a device starts, a bootloader is launched by a
bootable medium like a hard drive.</p>
<p>The bootable medium receives information from the computer’s firmware
(e.g. BIOS) about where the bootloader is.</p>
<h3 id="kernel">3.
<a href="#disk-image"><strong>Kernel</strong></a></h3>
<h4 id="device-tree-binary-dtb">Device Tree Binary (DTB)</h4>
<p>A device tree is a data structure describing the hardware components
of a particular computer so that the operating system's kernel can use
and manage those components, including:</p>
<pre><code>- the CPUs
- the memory
- the buses 
- the integrated peripherals. </code></pre>
<h3 id="systemd">4. systemd</h3>
<p>It’s a system and services manager, the <strong>glue</strong> between
kernel and the application/user</p>
<h3 id="serial-getty-service">5. Serial getty service</h3>
<h3 id="log-in-as-root">6. Log in as root</h3>
<h3 id="bashrc-and-exe">7. bashrc and exe</h3>
<p>The bashrc file is a script file that’s executed when a user logs in.
The file contains a series of configs for the terminal session.</p>
<h3 id="system-is-fully-booted.">8. System is fully booted.</h3>
<h2 id="booting-steps-gem5">Booting Steps: gem5</h2>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230818180330013.png"
alt="image-20230818180330013" />
<figcaption aria-hidden="true">image-20230818180330013</figcaption>
</figure>
<ol type="1">
<li><p>gem5 does not simulate the BIOS/Bootloader. It directly loads
kernel into the memory and continues the booting.</p></li>
<li><p>Running “systemd” is optional, instead other user-defined init
app/services can be used.</p></li>
</ol>
<p>in gem5 we do not simulate Bios/bootloader, rather gem5 directly puts
the kernel in the memory and starts booting (basically bypassing the
first two blocks).</p>
<p>The other things we mostly do, but we have the option to either run
systemd as it is or just use some other (user defined) init
application/service.</p>
<p>Once we are creating a disk image for our FS simulation, we need to
make sure that proper files and programs (in a matching ISA to the
target) are loaded into the disk image, enabling this chart to happen
once you start the simulation.</p>
]]></content>
      <categories>
        <category>体系结构</category>
        <category>gem5</category>
      </categories>
  </entry>
  <entry>
    <title>Kernel and OS</title>
    <url>/zyhjy/2023/08/16/Kernel-and-OS/</url>
    <content><![CDATA[<h2 id="osoperating-system">OS(Operating System)</h2>
<p>An <strong>operating system</strong> (<strong>OS</strong>) is system
software that manages computer hardware and software resources, and
provides common services for computer programs.</p>
<span id="more"></span>
<h3 id="component">component</h3>
<p>除了操作系统的内核外，操作系统通常还包括以下几个重要的组件和层级：</p>
<ol type="1">
<li><strong>Shell（外壳）：</strong>
Shell是用户与操作系统进行交互的接口。它可以是命令行界面（Command Line
Interface，CLI）或图形用户界面（Graphical User
Interface，GUI）。CLI提供了命令行提示符，用户可以输入命令来执行各种操作，而GUI则通过图形元素和窗口来实现用户界面。</li>
<li><strong>系统库（System Libraries）：</strong>
系统库是一组供应用程序使用的预编写的功能和例程。这些库提供了访问操作系统功能的方法，例如文件操作、网络通信等。它们帮助开发人员避免从头开始编写所有必要的代码。</li>
<li><strong>用户界面管理器（User Interface Manager）：</strong>
对于图形用户界面（GUI），用户界面管理器负责显示图形元素，如窗口、菜单和按钮，并接收用户输入，然后将其传递给操作系统。</li>
<li><strong>系统工具和实用程序（System Utilities）：</strong>
这些工具和实用程序为用户提供了执行特定任务的方法，如文件管理、磁盘维护、安全性设置等。常见的系统工具包括文件管理器、磁盘清理工具、任务管理器等。</li>
</ol>
<h2 id="kernel">kernel</h2>
<p>At the core of the operating system is the kernel, which manages and
controls the hardware resources like I/O (networking, storage, graphics
and various user interface devices, etc.), memory and CPU for your
device or computer.</p>
<p>It is one of the first software programs a booting device loads and
runs on the central processing unit (CPU).</p>
<p>It is the part of Operating System which converts user commands into
machine language.</p>
<p>It resides in the main memory.</p>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230818175412579.png"
alt="image-20230818175412579" />
<figcaption aria-hidden="true">image-20230818175412579</figcaption>
</figure>
<h3 id="what-the-kernel-does">What the kernel does</h3>
<ol type="1">
<li><strong>系统资源管理：</strong>
Linux内核负责管理计算机的各种硬件资源，包括内存、处理器、硬盘和其他外部设备。它通过调度算法来分配处理器时间和内存空间，以优化系统性能和资源利用率。</li>
<li><strong>设备驱动程序：</strong>
内核提供了用于与计算机硬件通信的设备驱动程序。这些驱动程序使操作系统能够与各种硬件设备进行交互，如显示器、键盘、鼠标、网络适配器等。</li>
<li><strong>文件系统管理：</strong>
Linux内核支持多种文件系统，如EXT4、Btrfs、XFS等，它负责管理文件和目录的存储、访问和维护。这使得用户能够在不同的存储设备上创建、读取和写入文件。</li>
<li><strong>进程管理：</strong>
内核管理系统中运行的进程（应用程序的执行实例）。它负责进程的创建、调度、终止以及进程间的通信和同步。</li>
<li><strong>系统调用：</strong>
内核提供了一组系统调用，这些调用允许应用程序与内核交互，请求操作系统提供服务，如文件访问、网络通信等。</li>
<li><strong>内存管理：</strong>
内核管理系统的内存分配和释放，确保不同进程之间不会互相干扰。它通过虚拟内存管理来实现更高效的内存使用和保护。</li>
<li><strong>网络通信：</strong>
内核管理计算机的网络通信，包括处理网络协议、数据包的路由和传输，以及网络设备的配置和管理。</li>
<li><strong>安全和权限：</strong>
内核实施访问控制和权限管理，确保不同用户和进程之间的隔离，防止未经授权的访问和操作。</li>
<li><strong>中断处理：</strong>
内核负责处理硬件中断，这些中断可以是来自设备的信号，需要立即处理以响应硬件事件。</li>
<li><strong>能源管理：</strong>
内核支持能源管理功能，如电源管理和CPU频率调整，以降低系统的能耗。</li>
</ol>
<h3 id="load-a-kernel-image">load a kernel image</h3>
<p>To "load" them means copying them from the boot medium (harddisk, CD,
USB stick, ...) to system RAM(Random Access Memory).</p>
<p>The CPU can only receive instructions directly from either the BIOS
or the RAM; in order to run a program stored on the hard disk, there
needs to be a program that is already accessible that will make the
other program accessible.</p>
<p>At system start, there is only the BIOS, which knows how to test the
RAM for defects and read data from the hard disk. The BIOS loads the
bootloader, which is placed so that it can be found easily (either at
the beginning of the disk, or in a special partition).</p>
<p>The bootloader is an intermediate program that basically just
performs the same function as the BIOS -- it loads the next program.
Unlike the BIOS, it is specifically made to load Linux, so it knows how
to read the <a
href="http://en.wikipedia.org/wiki/Executable_and_Linkable_Format">Executable
and Linking Format</a> (which is used for programs under Linux), and it
knows that it should also read the initrd file into memory and pass the
address where its contents can be found to the Linux kernel.</p>
<p>The kernel itself can typically be found in the <code>/boot</code>
directory, with a name of <code>vmlinuz-</code> followed by a version
number, and at the moment you can execute commands, a copy of it is
somewhere in system memory; the exact address is unpredictable.</p>
<h2 id="image">image</h2>
<h3 id="kernel-image">kernel image</h3>
<p>内核镜像（Kernel
Image）是操作系统内核的二进制文件，它包含了操作系统内核的代码和数据，以及启动操作系统所需的信息。内核镜像是操作系统启动时加载到计算机内存中的部分，它负责初始化系统的各个部分，管理硬件资源，以及启动其他系统组件。</p>
<p>在引导过程中，计算机会首先加载内核镜像到内存中，然后将控制权交给内核，使其开始执行。内核镜像负责初始化处理器、内存管理、设备驱动程序加载、文件系统挂载等关键操作，从而建立一个能够运行用户程序的环境。</p>
<h3 id="disk-image">disk image</h3>
<p>磁盘镜像（Disk
Image）是计算机中存储在硬盘或其他存储介质上的完整拷贝或快照。它包含了源磁盘上的所有数据、文件、文件系统结构和分区信息，以及可能的操作系统和应用程序。磁盘镜像可以看作是一个虚拟的磁盘副本，可以在需要时被还原到硬件设备上，恢复原始状态。</p>
<p>磁盘镜像通常用于数据备份、恢复、系统部署和虚拟化等场景。它可以用于创建系统备份，以便在数据丢失或硬件故障时进行恢复。在软件开发和测试中，磁盘镜像可以用于在不同环境中复制相同的系统配置和数据，以确保一致性。虚拟化技术也经常使用磁盘镜像来创建虚拟机，以模拟不同的操作系统环境。</p>
<h3 id="docker-image">docker image</h3>
<p>A Docker image is a lightweight, standalone, and executable software
package that contains all the necessary components to run a piece of
software. It includes the application code, runtime, system tools,
libraries, and settings required for the software to run consistently
across different environments.</p>
<p>Docker images do not include an entire operating system. Instead,
they leverage the host system's operating system, isolating only the
necessary components required for the application to run.</p>
<h2 id="kernel与os的关系">kernel与OS的关系</h2>
<p>At the <strong>core</strong> of operating system is the kernel.</p>
<p>Every operating system has a kernel.</p>
<h3
id="difference-between-operating-system-and-kernel"><strong>Difference
between Operating System and Kernel:</strong></h3>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Operating System</th>
<th style="text-align: center;">Kernel</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Operating System is a <a
href="https://www.geeksforgeeks.org/system-software/">system
software</a>.</td>
<td style="text-align: center;">Kernel is system software which is part
of operating system.</td>
</tr>
<tr class="even">
<td style="text-align: center;">Operating System provides interface
between user and hardware.</td>
<td style="text-align: center;">Kernel provides interface between
applications and hardware.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">It also provides protection and
security.</td>
<td style="text-align: center;">It’s main purpose is memory management,
disk management, process management and task management.</td>
</tr>
<tr class="even">
<td style="text-align: center;">An operating system is a complete
software package that includes a kernel and other system-level
components such as device drivers, system libraries, and utilities.</td>
<td style="text-align: center;">The kernel, on the other hand, is the
core of the operating system that manages system resources, such as the
CPU, memory, and I/O devices.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">the operating system provides a
higher-level interface to the user, such as the GUI, command-line
interface, and file system.</td>
<td style="text-align: center;">The kernel provides low-level services,
such as memory management, process management, and device management, to
other parts of the operating system</td>
</tr>
<tr class="even">
<td style="text-align: center;">the operating system is a more complex
system that includes a large number of components.</td>
<td style="text-align: center;">The kernel is a relatively small and
simple component of the operating system,</td>
</tr>
<tr class="odd">
<td style="text-align: center;">the operating system provides a more
general-purpose interface that can be used on a wide range of hardware
platforms.</td>
<td style="text-align: center;">The kernel is often customized for
specific hardware platforms or applications,</td>
</tr>
<tr class="even">
<td style="text-align: center;">The operating system is designed to be
portable across different hardware platforms,</td>
<td style="text-align: center;">the kernel is often
platform-specific.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">All system needs operating system to
run.</td>
<td style="text-align: center;">All operating systems need kernel to
run.</td>
</tr>
<tr class="even">
<td style="text-align: center;">Type of operating system includes single
and multiuser OS, <a
href="https://www.geeksforgeeks.org/introduction-of-multiprocessor-and-multicomputer/">multiprocessor
OS</a>, <a
href="https://www.geeksforgeeks.org/real-time-operating-system-rtos/">Realtime
OS</a>, <a
href="https://www.geeksforgeeks.org/features-of-distributed-operating-system/">Distributed
OS</a>.</td>
<td style="text-align: center;">Type of kernel includes <a
href="https://www.geeksforgeeks.org/monolithic-architecture/">Monolithic</a>and
<a
href="https://www.geeksforgeeks.org/microkernel-in-operating-systems/">Micro
kernel</a>.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">It is the first program to load when
computer boots up.</td>
<td style="text-align: center;">It is the first program to load when
operating system loads.</td>
</tr>
</tbody>
</table>
<h3 id="linux-kernel与ubuntu的关系">linux kernel与ubuntu的关系</h3>
<p>Linux is a <em>kernel</em>, and Ubuntu is a "<em>Linux
distribution</em>".</p>
<p>Ubuntu
OS，以Linux内核为基础，还包括其他附加软件，如图形用户界面和用户友好的实用工具。</p>
<p>每个ubuntu发行版都有对应的ubuntu kernel版本范围可供选择。ubuntu
kernel是在某个版本的linux kernel上演化更新而来的。</p>
<h4 id="ubuntu-kernel">ubuntu kernel</h4>
<p>The Ubuntu kernel is maintained by Canonical. It's built on the
Debian kernel, which is itself a distribution of the Linux kernel.</p>
<h4 id="mac-kernel">mac kernel</h4>
<p>the <em>Mac OS X</em> kernel - <em>XNU</em> - actually shares a lot
of qualities with Linux, kernel-wise, as Linux is based on
<em>UNIX</em>, and so is <em>XNU</em>.</p>
<h3 id="查看kernel信息">查看kernel信息</h3>
<p>通过<code>uname -v</code>命令，例如macOS下的结果为<code>Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64</code>.</p>
<h2 id="mmu">MMU</h2>
<p><a href="https://en.wikipedia.org/wiki/Memory_management_unit">The
MMU (memory management unit)</a> is a physical component of the computer
system, typically part of the CPU (but not necessarily). It translates
virtual addresses (also known as linear addresses in the x86 world) to
physical addresses; it can also enforce memory access control, cache
control, and bus arbitration. It doesn’t usually have its own memory, it
relies on data in the system’s main memory to operate.</p>
<p>The MMU performs this translation by using information stored in data
structures such as page tables; these specify which physical address
ranges correspond to linear address ranges (if any — a page can be “not
present”). <strong>The page tables are set up by the kernel, and the
kernel determines what the mappings should be — so the ultimate
authority on physical addresses is the kernel, however it always
operates with the help of the MMU.</strong> Put another way, the CPU
always operates on linear addresses, which are translated to physical
addresses by the MMU, but the kernel is aware of the translations and
programs the MMU to perform them.</p>
<p>User-space processes are oblivious to all this and aren’t (normally)
aware of the physical addresses corresponding to the linear addresses
they use, and typically can’t access the mappings either. There are some
cases where physical mappings leak, but those are usually considered to
be security vulnerabilities and quickly addressed. However, in Linux,
processes with sufficient privileges can see their physical map in
<code>/proc/&lt;pid&gt;/pagemap</code>.</p>
<p>For Linux specifically, see <a
href="https://www.kernel.org/doc/html/latest/admin-guide/mm/index.html">the
memory management documentation</a>, and in particular <a
href="https://www.kernel.org/doc/html/latest/admin-guide/mm/pagemap.html">the
section on examining page tables</a>.</p>
]]></content>
      <categories>
        <category>OS</category>
        <category>体系结构</category>
        <category>kernel</category>
      </categories>
  </entry>
  <entry>
    <title>gem5</title>
    <url>/zyhjy/2023/08/18/gem5/</url>
    <content><![CDATA[<h2 id="interaction-of-cpu-model-with-other-parts-of-gem5">Interaction
of CPU model with other parts of gem5</h2>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/image-20230818201426319.png"
alt="image-20230818201426319" />
<figcaption aria-hidden="true">image-20230818201426319</figcaption>
</figure>
]]></content>
      <categories>
        <category>体系结构</category>
        <category>gem5</category>
      </categories>
  </entry>
  <entry>
    <title>Arrch64 CPU Structure</title>
    <url>/zyhjy/2023/05/19/Arrch64%20CPU%20Structure/</url>
    <content><![CDATA[<h1 id="介绍">0. 介绍</h1>
<ul>
<li>ARMv8-A Architecture and Processors描述了以前的 32 位 ARM
架构，介绍了 ARMv8，并描述了 ARMv8 处理器的一些属性。</li>
<li>接下来，ARMv8
基础知识以异常级别和执行状态的形式描述了体系结构的构建块。</li>
<li>ARMv8 寄存器随后介绍了 ARMv8 体系结构中可用的寄存器。</li>
</ul>
<p>ARMv8 架构中引入的最重要的变化之一是添加了 64
位指令集，它补充了现有的 32 位架构。 - ARMv8 指令集简介介绍了 ARMv7
(A32)指令集架构(ISA) 与 A64 指令集之间的差异。A64 指令集更详细地介绍了
Instruction Set 及其使用。除了用于通用操作的新指令集外，ARMv8 还更改了
NEON 和浮点指令集。 - AArch64 浮点数和 NEON描述了 ARMv8 到 ARM 高级 SIMD
(NEON) 和浮点指令的变化。有关 NEON 及其在 ARMv7
中的功能的更详细指南，请参阅ARM NEON 程序员指南。</p>
<ul>
<li>本书的移植到 A64涵盖了将代码从其他体系结构或以前的 ARM
体系结构移植到 ARMv8 时可能遇到的问题。</li>
<li>ARM 64 位架构的 ABI描述了ARM 架构规范的应用程序二进制接口(ABI)。ABI
是针对 ARM 目标的所有编程行为的规范，它管理 64 位代码采用的形式。</li>
<li>AArch64 Exception Handling描述了 ARMv8 在 AArch64
状态下的异常处理行为。</li>
</ul>
<p>在此之后，重点转移到处理器的内部架构。 -
缓存描述了缓存的设计以及缓存的使用如何提高性能。 - 支持 ARMv8 和转向 64
位架构的一个重要推动因素可能是允许访问比仅使用 32
位更大的地址空间。内存管理单元描述了 MMU
如何将虚拟内存地址转换为物理地址。</p>
<ul>
<li><p>内存排序描述了 ARMv8
架构中内存的弱排序模型。通常，这意味着内存访问的顺序不需要与加载和存储操作的程序顺序相同。只有一些程序员必须知道内存排序问题。如果您的代码直接与硬件或在其他内核上执行的代码交互，直接加载或写入要执行的指令，或修改页表，那么您可能必须考虑顺序和障碍。如果您要实现自己的同步功能或无锁算法，这也适用。</p></li>
<li><p>多核处理器描述了 ARMv8-A 架构如何支持多核系统。使用 ARMv8
处理器的系统几乎总是以这种方式实现的。</p></li>
<li><p>电源管理描述了 ARM 内核如何使用其硬件来降低功耗。big.LITTLE
Technology涵盖了应用于多核和多集群系统的电源管理的另一个方面。本章介绍
ARM 的 big.LITTLE
技术如何将高能效LITTLE内核与高性能大内核结合在一起，以提供具有高性能和能效的系统。</p></li>
<li><p>安全性描述了 ARMv8
处理器如何创建一个安全或受信任的系统，以保护密码或信用卡详细信息等资产免遭未经授权的复制或损坏。</p></li>
<li><p>本书的主要部分以调试结束，描述了 Cortex-A53 和 Cortex-A57
处理器中可用的标准调试和跟踪功能。</p></li>
</ul>
<p>https://developer.arm.com/documentation/den0024/a/Introduction</p>
<h1 id="armv8-a-架构">1. ARMv8-A 架构</h1>
<h2 id="以前的arm架构">以前的Arm架构：</h2>
<p>https://developer.arm.com/documentation/den0024/a/ARMv8-A-Architecture-and-Processors
## ARMv8-A 架构 - ARMv8-A 架构是针对应用程序配置的最新一代 ARM 架构。 -
ARMv8 用于描述整体架构，现在包括了 32 位执行和 64 位执行。 -
它引入了使用 64 位宽寄存器执行的能力，同时保持与现有 ARMv7
软件的向后兼容性。</p>
<ul>
<li>ARMv8-A 架构引入了一些改变，可以设计出性能显著提高的处理器实现。
<ul>
<li>大物理地址 / Large physical address
<ul>
<li>这使得处理器能够访问超过 4GB 的物理内存。</li>
</ul></li>
<li>64 位虚拟寻址 / 64-bit virtual addressing
<ul>
<li>这使得虚拟内存能够超过 4GB 的限制。对于使用内存映射文件 I/O
或稀疏寻址的现代桌面和服务器软件来说，这非常重要。</li>
</ul></li>
<li>自动事件信号 / Automatic event signaling
<ul>
<li>这使得能够高效节能地使用高性能自旋锁。</li>
</ul></li>
<li>更大的寄存器文件 / Larger register files -31 个 64
位通用寄存器提高性能并减少堆栈使用。</li>
<li>高效的 64 位立即数生成 / Efficient 64-bit immediate generation
<ul>
<li>对于文字池的需求较少。</li>
</ul></li>
<li>大范围的 PC 相对寻址 / Large PC-relative addressing range
<ul>
<li>为共享库和位置无关可执行文件内的数据寻址提供了一个 +/-4GB
的寻址范围，以提高效率。</li>
</ul></li>
<li>额外的 16KB 和 64KB 翻译粒度 / Additional 16KB and 64KB translation
granules
<ul>
<li>这降低了翻译后备缓冲 (TLB) 的缺失率和页表遍历的深度。</li>
</ul></li>
<li>新的异常模型 / New exception model
-这减少了操作系统和虚拟机监视器软件的复杂性。</li>
<li>高效的缓存管理 / Efficient cache management
<ul>
<li>用户空间缓存操作提高了动态代码生成的效率。使用数据缓存清零指令可以快速清除数据缓存。</li>
</ul></li>
<li>硬件加速的密码学 / Hardware-accelerated cryptography
<ul>
<li>提供了 3 到 10
倍更好的软件加密性能。这对于小颗粒度的解密和加密，以及不能高效地卸载到硬件加速器的情况（例如
HTTPS）非常有用。</li>
</ul></li>
<li>加载-获取、存储-释放指令 / Load-Acquire, Store-Release instructions
<ul>
<li>针对 C++11、C11、Java
内存模型设计。通过消除显式内存屏障指令，提高了线程安全代码的性能。</li>
</ul></li>
<li>NEON 双精度浮点高级 SIMD / NEON double-precision floating-point
advanced SIMD
<ul>
<li>这使得可以将 SIMD
向量化应用于更广泛的算法集，例如科学计算、高性能计算 (HPC)
和超级计算机。</li>
</ul></li>
</ul></li>
</ul>
<h1 id="fundamentals-of-armv8-armv8-基础知识">2. Fundamentals of ARMv8 /
ARMv8 基础知识</h1>
<ul>
<li><p>在ARMv8中，执行发生在四个异常级别之一。</p></li>
<li><p>在AArch64中，异常级别确定特权级别，类似于ARMv7中定义的特权级别。</p></li>
<li><p>异常级别决定特权级别，因此在ELn处执行对应于特权级别PLn。</p></li>
<li><p>类似地，具有较大值n的异常级别比另一个异常级别更高。</p></li>
<li><p>具有较小数字的异常级别被描述为处于较低的异常级别。</p></li>
<li><p>异常级别在ARMv8架构的所有操作状态下提供了软件执行特权的逻辑分离。它类似于并支持计算机科学中常见的分层保护域的概念。</p></li>
<li><p>以下是每个异常级别上典型软件运行的示例：</p>
<ol type="1">
<li><p>EL0（Exception Level 0）：
-也称为用户级别，用于普通应用程序的执行。</p></li>
<li><p>EL1（Exception Level 1）：</p>
<ul>
<li>操作系统内核，也称为特权级别（privileged）。</li>
<li>也称为监管级别，用于特权级别较高的操作系统内核。</li>
<li>大多数操作系统内核代码在此级别上运行，具有更高的特权和对底层硬件的直接访问权限。操作系统内核通常被描述为具有特权的软件。</li>
</ul></li>
<li><p>EL2（Exception Level 2）：</p>
<ul>
<li>也称为虚拟化级别，用于虚拟化和处理器虚拟机监视器（Hypervisor）的执行。</li>
<li>在EL2级别上，可以运行虚拟机监视器软件，用于创建和管理虚拟机。</li>
</ul></li>
<li><p>EL3（Exception Level 3）：</p>
<ul>
<li>低级固件，包括安全监控器（Secure Monitor）。</li>
<li>也称为安全监控级别，用于安全性相关的功能和安全环境的执行。</li>
<li>在EL3级别上，可以运行安全监视器软件，用于实施安全策略和提供安全保护。</li>
</ul></li>
</ol></li>
</ul>
<p>通常情况下，软件的不同部分，比如应用程序、操作系统的内核或虚拟化管理程序，占据一个特定的异常级别。这个规则的一个例外是内核虚拟化管理程序（如KVM），它可以跨EL2和EL1级别运行。<br></p>
<p>ARMv8-A提供了两种安全状态，Secure（安全）和Non-secure（非安全）。Non-secure状态也被称为Normal
World（正常世界）。这使得操作系统（OS）可以与一个可信任的OS并行运行在同一硬件上，并提供对某些软件攻击和硬件攻击的保护。ARM
TrustZone技术使系统能够在Normal World和Secure
World之间进行分区。与ARMv7-A架构一样，安全监控器（Secure
monitor）充当了在Normal World和Secure World之间切换的入口。<br> Secure
World没有EL2.<br>
https://developer.arm.com/documentation/den0024/a/Fundamentals-of-ARMv8
## 执行状态 / Execution states
ARMv8架构定义了两个执行状态，AArch64和AArch32。每个状态用于分别描述使用64位通用寄存器或32位通用寄存器的执行。虽然ARMv8
AArch32保留了ARMv7中特权的定义，但在AArch64中，<strong>特权级别由异常级别确定</strong>。因此，ELn处的执行对应于特权级别PLn。<br>
当处于AArch64状态时，处理器执行A64指令集。当处于AArch32状态时，处理器可以执行A32（在架构早期版本中称为ARM）或T32（Thumb）指令集。<br>
在AArch32状态下，可信任的操作系统软件在Secure
EL3中执行；而在AArch64状态下，主要在Secure EL1中执行。<br>
https://developer.arm.com/documentation/den0024/a/Fundamentals-of-ARMv8/Execution-states</p>
<h2 id="改变异常级别-changing-exception-levels">改变异常级别 / Changing
Exception levels</h2>
<p>··· 改变异常级别（Changing Exception
levels）是通过触发异常或使用异常相关的指令来实现的。ARMv8架构中，处理器可以从当前的执行级别切换到更高或更低的异常级别。</p>
<p>要切换到较高的异常级别，可以触发一个异常，例如使用异常相关的指令或发生特定的事件，导致处理器从当前级别切换到更高的级别。例如，从EL0级别切换到EL1级别，可以通过触发一个系统调用（如SVC指令）来引发一个异常，并将控制权转移到EL1级别的异常处理程序。</p>
<p>要切换到较低的异常级别，通常使用异常返回指令（例如ERET或RFE指令）。这些指令会从当前的异常级别返回到较低的级别，并将控制权交还给较低级别的异常处理程序。</p>
<p>在切换异常级别时，需要保存和恢复相应级别的上下文信息，包括寄存器状态、异常向量表和其他相关的控制状态。这样可以确保在切换后能够正确处理异常和保持系统的正确运行。</p>
<p>通过改变异常级别，系统可以在不同的特权级别之间进行切换，并控制不同软件组件的访问权限和特权级别。这提供了灵活的软件隔离和资源管理机制，以满足不同应用场景和安全要求的需要。</p>
<p>··· 在ARMv7架构中，处理器模式（the processor
mode，异常级别）可以在特权软件控制下或在发生异常时自动切换。当发生异常时，内核会保存当前的执行状态和返回地址，进入所需的模式，并可能禁用硬件中断。<br>
这在下表中进行了总结。应用程序在最低特权级别PL0（先前称为非特权模式）下运行。操作系统在PL1下运行，而在具有虚拟化扩展的系统中，Hypervisor在PL2下运行。安全监控器（Secure
monitor）作为在Secure和Non-secure（Normal）世界之间切换的入口，也在PL1下运行。<br></p>
<h3 id="table-3.1.-armv7-processor-modes">Table 3.1. ARMv7 processor
modes</h3>
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 19%" />
<col style="width: 23%" />
<col style="width: 36%" />
</colgroup>
<thead>
<tr class="header">
<th>Mode</th>
<th>Function</th>
<th>Security state</th>
<th>Privilege Level</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>User (USR) / 用户模式</td>
<td>大多数应用程序运行的非特权模式</td>
<td>Both</td>
<td>PL0</td>
</tr>
<tr class="even">
<td>FIQ / 快速中断模式</td>
<td>在FIQ中断异常发生时进入</td>
<td>Both</td>
<td>PL1</td>
</tr>
<tr class="odd">
<td>IRQ / 中断模式</td>
<td>在IRQ中断异常发生时进入</td>
<td>Both</td>
<td>PL1</td>
</tr>
<tr class="even">
<td>Supervisor(SVC) / 监管模式</td>
<td>在复位时或执行监管调用指令（SVC）时进入</td>
<td>Both</td>
<td>PL1</td>
</tr>
<tr class="odd">
<td>Monitor (MON) / 监控模式</td>
<td>在执行SMC指令（安全监控调用）或处理配置为安全处理的异常时进入。用于支持在安全和非安全状态之间切换。</td>
<td>Secure only</td>
<td>PL1</td>
</tr>
<tr class="even">
<td>Abort (ABT) / 异常模式</td>
<td>在内存访问异常发生时进入</td>
<td>Both</td>
<td>PL1</td>
</tr>
<tr class="odd">
<td>Undef (UND) / 未定义模式</td>
<td>在执行未定义指令时进入</td>
<td>Both</td>
<td>PL1</td>
</tr>
<tr class="even">
<td>System (SYS) / 系统模式</td>
<td>特权模式，与用户模式共享寄存器视图</td>
<td>Both</td>
<td>PL1</td>
</tr>
<tr class="odd">
<td>Hyp (HYP)</td>
<td>通过Hypervisor Call和Hyp Trap异常进入。</td>
<td>Non-secure only</td>
<td>PL2</td>
</tr>
</tbody>
</table>
<p>在AArch64中，处理器模式被映射到异常级别，就像图3.6中所示。与ARMv7（AArch32）类似，当发生异常时，处理器会切换到支持处理异常的异常级别（模式）。<br></p>
<p>异常级别之间的切换遵循一下规则：<br> -
从EL0切换到EL1等较高的异常级别表示增加了软件执行特权。 -
不能将异常发生在较低的异常级别。 / An exception cannot be taken to a
lower Exception level. -
在EL0级别没有异常处理，异常必须在较高的异常级别进行处理。 -
异常引起程序流的改变。异常处理程序的执行从与引发异常相关的定义向量开始，在比EL0更高的异常级别上执行。异常包括：
- 中断，如IRQ和FIQ。 - 内存系统异常。 - 未定义的指令。 -
系统调用。允许非特权软件向操作系统发出系统调用。 -
安全监控器或hypervisor陷阱。 -
结束异常处理并返回到之前的异常级别是通过执行ERET指令完成的。 -
从异常返回时，可以保持在相同的异常级别或进入较低的异常级别。不能进入较高的异常级别。
-
随着异常级别的变化，安全状态也会改变，但从EL3返回到非安全状态时除外。请参阅<a
href="https://developer.arm.com/documentation/den0024/a/Security/Switching-between-Secure-and-Non-secure-state?lang=en">在安全和非安全状态之间切换</a>。
https://developer.arm.com/documentation/den0024/a/Fundamentals-of-ARMv8/Changing-Exception-levels</p>
<h2 id="changing-execution-state-更改执行状态">Changing execution state
/ 更改执行状态</h2>
<p>有时候，你需要改变系统的执行状态。例如，如果你正在运行一个64位操作系统，并且想要在EL0下运行一个32位应用程序，那么系统必须切换到AArch32执行状态。<br></p>
<p>当应用程序完成或执行返回到操作系统时，系统可以切换回AArch64。不能反过来进行切换。AArch32操作系统无法承载64位应用程序。<br></p>
<p>要在相同的异常级别之间切换执行状态，你必须切换到更高的异常级别，然后返回到原始的异常级别。例如，你可能在64位操作系统下运行32位和64位应用程序。在这种情况下，32位应用程序可以执行并生成一个Supervisor
Call（SVC）指令，或者接收一个中断，导致切换到EL1和AArch64。（参见<a
href="https://developer.arm.com/documentation/den0024/a/The-A64-instruction-set/System-control-and-other-instructions/Exception-handling-instructions?lang=en">异常处理指令</a>）然后操作系统可以进行任务切换并返回到AArch64下的EL0。实际上，这意味着你不能同时运行混合的32位和64位应用程序，因为它们之间没有直接的调用方式。<br></p>
<p>你只能通过改变异常级别来改变执行状态。触发异常可能从AArch32切换到AArch64，而从异常返回可能从AArch64切换到AArch32。<br></p>
<p>在EL3下的代码无法触发到更高的异常级别，因此除非通过复位，否则无法改变执行状态。<br></p>
<p>以下是在AArch64和AArch32执行状态之间切换时的一些要点摘要：<br> -
AArch64和AArch32执行状态都具有一般相似的异常级别，但在安全和非安全操作之间存在一些差异。处理异常时处理器所处的执行状态可以限制其他执行状态可用的异常级别。
-
切换到AArch32需要从更高的异常级别转换到更低的异常级别。这是通过执行ERET指令退出异常处理程序的结果。请参阅异常处理指令。
-
切换到AArch64需要从较低的异常级别转换到较高的异常级别。触发异常可以是指令执行或外部信号的结果。
- 如果在触发异常或从异常返回时异常级别保持不变，执行状态将无法改变。</p>
<ul>
<li>当ARMv8处理器在特定的异常级别处于AArch32执行状态时，它使用与ARMv7相同的异常模型来处理到达该异常级别的异常。在AArch64执行状态下，它使用<a
href="https://developer.arm.com/documentation/den0024/a/AArch64-Exception-Handling?lang=en中所描述的异常处理模型">AArch64异常处理</a>。</li>
</ul>
<p>因此，两种状态之间的交互是在安全监视器、虚拟机监控程序或操作系统的级别进行的。在AArch64状态下运行的虚拟机监控程序或操作系统可以支持较低特权级别下的AArch32操作。这意味着在AArch64下运行的操作系统可以承载AArch32和AArch64应用程序。同样，一个AArch64虚拟机监控程序可以承载AArch32和AArch64的客户操作系统。然而，一个32位操作系统不能承载64位应用程序，而一个32位虚拟机监控程序不能承载64位客户操作系统。</p>
<p>对于Cortex-A53和Cortex-A57处理器上实现的最高异常级别（EL3），在触发异常时，每个异常级别要使用的执行状态是固定的。只能通过复位处理器来改变异常级别。对于EL2和EL1，它是由<a
href="https://developer.arm.com/documentation/den0024/a/ARMv8-Registers/System-registers?lang=en控制的">系统寄存器</a>。
https://developer.arm.com/documentation/den0024/a/Fundamentals-of-ARMv8/Changing-execution-state</p>
<h1 id="armv8-registers">3. ARMv8 Registers</h1>
<p>https://developer.arm.com/documentation/den0024/a/ARMv8-Registers The
AArch64 execution state provides 31 × 64-bit general-purpose registers
accessible at all times and in all Exception levels.<br></p>
<p>Each register is 64 bits wide and they are generally referred to as
registers X0-X30.<br> Each AArch64 64-bit general-purpose register
(X0-X30) also has a 32-bit (W0-W30) form.<br></p>
<p>The 32-bit W register forms the lower half of the corresponding
64-bit X register. That is, W0 maps onto the lower word of X0, and W1
maps onto the lower word of X1.<br></p>
<p>Reads from W registers disregard the higher 32 bits of the
corresponding X register and leave them unchanged. <em>Writes to W
registers set the higher 32 bits of the X register to zero.</em> That
is, writing 0xFFFFFFFF into W0 sets X0 to 0x00000000FFFFFFFF.<br></p>
<h2 id="aarch64-special-registers">AArch64 special registers</h2>
<p>除了31个核心寄存器外，还有一些特殊寄存器。<br> Note： -
没有叫做X31或W31的寄存器。许多指令的编码中，数字31表示零寄存器ZR（WZR或XZR）。还有一组受限指令，其中一个或多个参数的编码中数字31表示堆栈指针SP。</p>
<p>当访问零寄存器时，所有的写操作都会被忽略，而所有的读操作都会返回0。请注意，<em>64位形式的堆栈指针寄存器（SP
register）并不使用X前缀</em>。<br></p>
<p>Table 4.1. Special registers in AArch64<br></p>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Size</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>WZR</td>
<td>32 bits</td>
<td>Zero register</td>
</tr>
<tr class="even">
<td>XZR</td>
<td>64 bits</td>
<td>Zero register</td>
</tr>
<tr class="odd">
<td>WSP</td>
<td>32 bits</td>
<td>Current stack pointer</td>
</tr>
<tr class="even">
<td>SP</td>
<td>64 bits</td>
<td>Current stack pointer</td>
</tr>
<tr class="odd">
<td>PC</td>
<td>64 bits</td>
<td>Program counter</td>
</tr>
</tbody>
</table>
<p>在ARMv8架构中，在AArch64执行状态下，每个异常级别都有以下专用寄存器来保存异常返回状态：
- 异常链接寄存器（ELR）。 - 保存的处理器状态寄存器（SPSR）。</p>
<p><em>每个异常级别都有一个专用的堆栈指针寄存器（SP），但它不用于保存返回状态</em>。<br></p>
<p>Table 4.2. Special registers by Exception level<br> | |EL0 |EL1 |EL2
|EL3 | |--- |---- |---- |---- |---- | |Stack Pointer (SP) |SP_EL0
|SP_EL1 |SP_EL2 |SP_EL3 | |Exception Link Register (ELR) | |ELR_EL1
|ELR_EL2 |ELR_EL3 | |Saved Process Status Register (SPSR) | |SPSR_EL1
|SPSR_EL2 |SPSR_EL3 |</p>
<p>https://developer.arm.com/documentation/den0024/a/ARMv8-Registers/AArch64-special-registers</p>
<p>在ARMv8架构中，除了通用寄存器（X0-X30或W0-W30）之外，还有一些特殊寄存器用于特定的功能和控制。以下是其中一些常见的特殊寄存器：</p>
<ol type="1">
<li><p>程序状态寄存器（Program Status
Register，PSR）：用于存储和控制处理器的状态信息，例如条件码（Condition
Flags）和执行状态（Execution State）。</p></li>
<li><p>控制寄存器（Control
Register）：用于控制和配置处理器的行为，例如异常处理、内存访问权限和缓存控制。</p></li>
<li><p>中断/异常向量表寄存器（Interrupt/Exception Vector Table
Register）：用于存储中断和异常处理程序的地址。</p></li>
<li><p>时钟寄存器（Timer Register）：用于计时和定时器功能。</p></li>
<li><p>系统控制寄存器（System Control
Register）：用于配置和控制系统级别的设置，例如内存管理单元（MMU）和缓存。</p></li>
</ol>
<p>这只是一小部分常见的特殊寄存器，实际上还有其他特殊寄存器用于不同的处理器功能和系统配置。具体的特殊寄存器数量和功能可能因处理器型号、架构版本和实现而有所不同。</p>
<h3 id="零寄存器-zero-register">零寄存器 / Zero register</h3>
<p>零寄存器在用作源寄存器时读取为零，并且在用作目标寄存器时丢弃结果。你可以在大多数指令中使用零寄存器，但并不是所有指令都可以使用它。
### Stack pointer / 堆栈指针
在ARMv8架构中，选择使用的堆栈指针在一定程度上与异常级别分离。默认情况下，触发异常会选择目标异常级别的堆栈指针，即SP_ELn。例如，触发到EL1的异常会选择SP_EL1作为堆栈指针。<strong>每个异常级别都有自己的堆栈指针</strong>，包括SP_EL0、SP_EL1、SP_EL2和SP_EL3。在AArch64下，除EL0以外的异常级别，处理器可以使用以下两种方式之一：</p>
<ol type="1">
<li><p><em>与该异常级别关联的专用64位堆栈指针（SP_ELn）</em>。</p></li>
<li><p><em>与EL0关联的堆栈指针（SP_EL0）</em>。</p></li>
</ol>
<p><em>EL0只能访问SP_EL0</em>。<br></p>
<p>Table 4.3. AArch64 Stack pointer options |Exception level| Options |
|--|--| |EL0 |EL0t | |EL1 |EL1t, EL1h | |EL2 |EL2t, EL2h | |EL3 |EL3t,
EL3h |</p>
<p>The t后缀表示选择SP_EL0堆栈指针。h后缀表示选择SP_ELn堆栈指针。</p>
<p>大多数指令不能直接引用堆栈指针（SP）。然而，某些形式的算术指令，比如ADD指令，可以读取和写入当前堆栈指针，以调整函数中的堆栈指针。例如：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD SP, SP, #0x10      // Adjust SP to be 0x10 bytes before its current value</span><br></pre></td></tr></table></figure> ### 程序计数器（Program Counter，PC） 程序计数器（Program
Counter，PC）是ARMv7指令集的一个特性，它将R15作为通用寄存器来使用。PC的使用使得一些巧妙的编程技巧成为可能，但也给编译器和复杂流水线的设计带来了复杂性。在ARMv8中去除了对PC的直接访问，这使得返回预测更加容易，并简化了ABI规范。</p>
<p>PC永远不作为一个命名寄存器进行访问。它在某些指令中的使用是隐式的，例如PC相对加载和地址生成。PC不能作为数据处理指令或加载指令的目的地进行指定。</p>
<h3
id="异常链接寄存器exception-link-registerelr">异常链接寄存器（Exception
Link Register，ELR）</h3>
<p>异常链接寄存器<em>保存异常的返回地址</em>。</p>
<h3 id="链接寄存器link-registerlr">链接寄存器（Link Register，LR）</h3>
<p>在AArch64状态下，链接寄存器（Link
Register，LR）用于存储子程序调用时的返回地址。如果返回地址存储在堆栈上，它也可以用作通用寄存器。LR对应寄存器30。</p>
<h3
id="保存程序状态寄存器saved-program-status-registerspsr">保存程序状态寄存器（Saved
Program Status Register，SPSR</h3>
<p>当发生异常时，处理器状态会存储在相应的保存程序状态寄存器（Saved
Program Status
Register，SPSR）中，类似于ARMv7中的CPSR。<em>SPSR保存在发生异常之前的PSTATE值，并在执行异常返回时用于恢复PSTATE的值</em>。</p>
<p>The individual bits represent the following values for AArch64: ####
N 31 Negative result (N flag). #### Z 30 Zero result (Z) flag. #### C 29
Carry out (C flag). #### V 28 Overflow (V flag). #### SS 21
软件步进（Software Step）标志。指示在发生异常时是否启用了软件步进。 ####
IL 20 非法执行状态位（Illegal Execution State
bit）。显示异常发生前的PSTATE.IL值。 #### D 9 进程状态调试掩码（Process
state Debug
mask）。指示针对异常发生的异常级别的监视点、断点和软件步进调试事件的调试异常是否被屏蔽。
#### A 8 SError (System Error) mask bit. #### I 7 IRQ mask bit. #### F 6
FIQ mask bit. #### M[4] Execution state that the exception was taken
from. A value of 0 indicates AArch64. #### M[3:0] Mode or Exception
level that an exception was taken from.</p>
<p>在ARMv8中，所写入的SPSR取决于异常级别。如果异常发生在EL1级别，则使用SPSR_EL1。如果异常发生在EL2级别，则使用SPSR_EL2。如果异常发生在EL3级别，则使用SPSR_EL3。在发生异常时，内核会填充相应的SPSR寄存器。</p>
<p>注意：
与异常级别相关联的ELR_ELn和SPSR_ELn寄存器对在较低的异常级别执行时保留其状态(retain
their state)。</p>
<h2 id="processor-state">Processor state</h2>
<p>在AArch64架构中，没有直接等效于ARMv7的当前程序状态寄存器（CPSR）。在AArch64中，传统CPSR的各个组成部分被提供为可以独立访问的字段。它们统称为处理器状态。</p>
<p><a
href="https://developer.arm.com/documentation/den0024/a/ARMv8-Registers/AArch64-special-registers/Saved-Process-Status-Register?lang=en">PSTATE每个bit的含义</a></p>
<p>AArch64的处理器状态（PSTATE）字段具有以下定义：<br> Table 4.4. PSTATE
field definitions<br> |Name | Description| |-|-| |N | Negative condition
flag.| |Z | Zero condition flag.| |C | Carry condition flag.| |V |
oVerflow condition flag.| |D | Debug mask bit.| |A | SError mask bit.|
|I | IRQ mask bit.| |F | FIQ mask bit.| |SS | Software Step bit.| | IL |
Illegal execution state bit.| |EL(2) |Exception level.| |nRW |Execution
state; 0 = 64-bit, 1 = 32-bit| |SP |Stack Pointer selector. 0 = SP_EL0,
1 = SP_ELn|</p>
<p>在AArch64中，通过<em>执行ERET指令来从异常返回，并且这会导致将SPSR_ELn复制到PSTATE中</em>。这将恢复ALU标志、执行状态、异常级别和处理器分支。从这里，您将从ELR_ELn中的地址继续执行。</p>
<p>PSTATE.{N, Z, C,
V}字段可以在EL0级别进行访问。所有其他PSTATE字段可以在EL1或更高级别执行，并且在EL0级别未定义。</p>
<h2 id="system-registers">System registers</h2>
<p>在AArch64中，系统配置通过系统寄存器进行控制，并使用MSR和MRS指令进行访问。这与ARMv7-A不同，后者通常通过协处理器15（CP15）操作来访问这些寄存器。寄存器的名称告诉您可以从中访问的最低异常级别。</p>
<p>例如： - TTBR0_EL1可以从EL1、EL2和EL3级别进行访问。 -
TTBR0_EL2可以从EL2和EL3级别进行访问。</p>
<p>具有后缀_ELn的寄存器在某些或所有级别中有一个单独的备份，尽管通常不包括EL0。很少有系统寄存器可以从EL0级别进行访问，尽管Cache
Type Register (CTR_EL0)是一个可以访问的例子。</p>
<p>访问系统寄存器的代码形式如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MRS  x0, TTBR0_EL1          // Move TTBR0_EL1 into x0</span><br><span class="line"></span><br><span class="line">MSR  TTBR0_EL1, x0          // Move x0 into TTBR0_EL1</span><br></pre></td></tr></table></figure>
先前的ARM架构版本使用协处理器进行系统配置。然而，AArch64不支持协处理器。表<a
href="https://developer.arm.com/documentation/den0024/a/ARMv8-Registers/System-registers?lang=en#BABHJIIB">4.5</a>列出了本书提到的系统寄存器。</p>
<p>完整列表请参阅《ARM体系结构参考手册-ARMv8，ARMv8-A架构配置文件》附录J。</p>
<p>该表显示了每个寄存器具有单独副本的异常级别。例如，独立的辅助控制寄存器（ACTLRs）存在于ACTLR_EL1、ACTLR_EL2和ACTLR_EL3中。</p>
<h3 id="the-system-control-register-系统控制寄存器">The system control
register / 系统控制寄存器</h3>
<p><a
href="https://developer.arm.com/documentation/den0024/a/ARMv8-Registers/System-registers/The-system-control-register?lang=en">系统控制寄存器</a>（System
Control
Register，简称SCTLR）是一个寄存器，用于控制标准内存、系统功能，并为内核中实现的功能提供状态信息。</p>
<h2 id="endianness">Endianness</h2>
<p>在内存中查看字节的方式有两种基本方法，即小端序（Little-Endian，LE）和大端序（Big-Endian，BE）。在大端序的计算机上，一个对象在内存中的最高有效字节存储在最低地址，也就是离零地址最近的地址。而在小端序的计算机上，最低有效字节存储在最低地址。字节顺序也可以用字节序来表示，而非字节序。</p>
<p>数据字节序独立地由每个执行级别控制。对于EL3、EL2和EL1，SCTLR_ELn.EE寄存器设置字节序。在EL1级别上，SCTLR_EL1.E0E寄存器控制EL0的数据字节序设置。在AArch64执行状态下，数据访问可以是小端序或大端序，而指令获取始终为小端序。</p>
<p>处理器是否同时支持小端序和大端序取决于处理器的实现。如果仅支持小端序，则EE和E0E位始终为0。同样，如果仅支持大端序，则EE和E0E位的值为静态1。</p>
<p>在使用AArch32时，在EL1、EL2或EL3级别上，CPSR.E位与对应的系统控制寄存器EE位具有不同的值已经被弃用。ARMv7的SETEND指令的使用也已经被弃用。通过设置SCTLR.SED位，可以导致在执行SETEND指令时引发未定义异常。</p>
<h2 id="changing-execution-state-again">Changing execution state
(again)</h2>
<p><a
href="https://developer.arm.com/documentation/den0024/a/ARMv8-Registers/Changing-execution-state--again-?lang=en">Changing
execution state (again)</a>
在从AArch32执行状态进入AArch64执行状态时，从寄存器的角度考虑，以下情况发生变化：</p>
<p>对于在AArch32执行状态下可访问的任何较低异常级别的寄存器的上32位值是未知的。</p>
<p>在AArch32执行状态下不可访问的寄存器将保留它们在AArch32执行之前的状态。</p>
<p>在从使用AArch32的EL2进入EL3的异常入口处，ELR_EL2的上32位值是未知的。</p>
<p>与AArch32执行状态下不可访问的异常级别相关联的AArch64堆栈指针（SPs）和异常链接寄存器（ELRs），在该异常级别中保留它们在AArch32执行之前的状态。这适用于以下寄存器：</p>
<p>SP_EL0</p>
<p>SP_EL1</p>
<p>SP_EL2</p>
<p>ELR_EL1</p>
<p>一般而言，应用程序员编写的应用程序针对AArch32或AArch64中的一种执行状态。只有操作系统需要考虑这两种执行状态以及它们之间的切换。</p>
<h2 id="neon-and-floating-point-registers">NEON and floating-point
registers</h2>
<p>除了通用寄存器外，ARMv8还具有32个128位浮点寄存器，标记为V0-V31。这32个寄存器用于存储标量浮点指令的浮点操作数，以及NEON操作的标量和矢量操作数。浮点寄存器和NEON寄存器也在<a
href="https://developer.arm.com/documentation/den0024/a/AArch64-Floating-point-and-NEON?lang=en">AArch64浮点和NEON</a>中进行了介绍。</p>
<h1
id="an-introduction-to-the-armv8-instruction-sets-armv8指令集简介">4. An
Introduction to the ARMv8 Instruction Sets / ARMv8指令集简介</h1>
<p>ARMv8架构引入的最重要的变化之一是增加了64位指令集。这个指令集与现有的32位指令集架构相辅相成。这个增加使得可以访问64位宽整数寄存器和数据操作，并且能够使用64位大小的内存指针。这些新指令被称为A64指令，运行在AArch64执行状态下。ARMv8还包括原始的ARM指令集，现在称为A32指令集，以及Thumb
(T32)指令集。A32和T32都在AArch32状态下执行，与ARMv7保持向后兼容。</p>
<p>尽管ARMv8-A与32位ARM体系结构保持向后兼容，但A64指令集与旧的指令集架构是独立的并且编码方式不同。A64添加了一些额外的功能，同时去除了可能限制高性能实现速度或能量效率的其他特性。ARMv8架构还对32位指令集(A32和T32)进行了一些增强。然而，使用这些功能的代码与旧的ARMv7实现不兼容。然而，A64指令集中的指令操作码仍然是32位长，而不是64位。</p>
<p>寻求更详细的A64汇编语言描述的程序员还可以参考ARM编译器armasm参考指南v6.01。</p>
<h2 id="the-armv8-instruction-sets">The ARMv8 instruction sets</h2>
<p>新的A64指令集与现有的A32指令集相似。指令长度为32位，具有类似的语法。</p>
<p>在AArch64状态下，引入了一种新的指令集供内核使用。遵循命名约定，并反映64位操作，该指令集称为：<strong>A64</strong>
A64提供了与AArch32或ARMv7中的A32和T32指令集类似的功能。新的A64指令集的设计带来了几个改进：
#### 一致的编码方案
A32中一些指令的晚期添加导致编码方案的一些不一致性。例如，LDR和STR对半字节的支持在编码上与主流的字节和字传输指令稍有不同。结果是寻址模式稍有不同。</p>
<h4 id="广泛的常量范围">广泛的常量范围</h4>
<p>A64指令提供了广泛的常量选项，每个选项都适用于特定指令类型的要求。 -
算术指令通常接受12位立即数常量。 -
逻辑指令通常接受32位或64位常量，其编码具有一定的限制。 -
MOV指令接受16位立即数，可以移动到任何16位边界。 -
地址生成指令适用于与4KB页面大小对齐的地址。</p>
<p>对于用于位操作指令的常量，存在稍微复杂的规则。然而，位字段操作指令可以在源操作数或目标操作数中处理任何连续的位序列。</p>
<p>A64提供了灵活的常量，但是编码这些常量，甚至确定特定常量是否可以在特定上下文中合法编码，可能并不简单。</p>
<h4 id="数据类型更容易处理">数据类型更容易处理</h4>
<p>A64天然支持64位有符号和无符号数据类型，提供更简洁和高效的操作64位整数的方法。这对于提供64位整数的所有语言，如C或Java，都是有利的。</p>
<h4 id="长偏移量">长偏移量</h4>
<p>A64指令通常提供更长的偏移量，用于<em>PC相对分支和偏移寻址</em>。</p>
<p>增加的分支范围使得管理交叉段跳转更容易。动态生成的代码通常放置在堆上，因此实际上可以位于任何位置。运行时系统通过增加分支范围更容易管理这个过程，并且需要的修复次数更少。</p>
<p>字面池（嵌入在代码流中的字面数据块）的需求一直是ARM指令集的特性。这在A64中仍然存在。然而，更大的PC相对加载偏移量在字面池的管理方面提供了很大帮助，使得每个编译单元可以使用一个字面池。这消除了在长代码序列中为多个池制造位置的需要。</p>
<h4 id="指针">指针</h4>
<p>在AArch64中，指针是64位的，这允许更大的虚拟内存寻址，并提供更大的地址映射自由度。然而，使用64位指针确实会带来一些成本。相同的代码片段在使用64位指针时通常使用更多内存，而不是32位指针。每个指针都存储在内存中，需要8字节而不是4字节。这听起来可能微不足道，但可能累积到显著的性能损失。此外，由于转向64位的内存空间增加使用，可能导致<em>缓存命中的访问次数下降</em>。缓存命中的下降可能会降低性能。</p>
<p>某些语言可以使用压缩指针来解决性能问题，例如Java。</p>
<h4 id="条件构造代替it块">条件构造代替IT块</h4>
<p>IT块是T32的一个有用特性，可以实现避免对未执行指令周围进行短程前向分支的高效序列。然而，它们有时对硬件的高效处理具有一定困难。A64移除了这些块，并用条件指令（如CSEL或条件选择和CINC或条件递增）替换它们。这些条件构造更直观和更容易处理，无需特殊情况。</p>
<h4 id="移位和旋转行为更直观">移位和旋转行为更直观</h4>
<p>A32或T32的移位和旋转行为并不总是与高级语言预期的行为相匹配。</p>
<p>ARMv7提供了一个可用于数据处理指令的位移器。然而，指定移位类型和移位量需要一定数量的操作码位，这些位可以在其他地方使用。</p>
<p>因此，A64指令删除了很少使用的选项，并添加了新的显式指令来执行更复杂的移位操作。</p>
<h4 id="代码生成">代码生成</h4>
<p>在静态和动态生成常见算术函数的代码时，A32和T32通常需要不同的指令或指令序列。这是为了处理不同的数据类型。A64中这些操作更加一致，因此更容易生成在不同大小数据类型上进行简单操作的常见序列。</p>
<p>例如，在T32中，相同的指令可以具有不同的编码，具体取决于使用的寄存器（低寄存器还是高寄存器）。</p>
<p>A64指令集编码更加规则和合理。因此，与T32相比，A64汇编器通常需要更少的代码行数。</p>
<h4 id="固定长度指令">固定长度指令</h4>
<p>所有A64指令的长度都相同，而T32是一种可变长度指令集。这使得管理和跟踪生成的代码序列更容易，特别是对动态代码生成器有影响。</p>
<h4 id="三个操作数更好地映射">三个操作数更好地映射</h4>
<p>A32通常保留了用于数据处理操作的真正的三个操作数结构。而T32则包含大量的双操作数指令格式，这在生成代码时稍微不够灵活。A64坚持使用一致的三个操作数语法，进一步增加了指令集的规则性和统一性，有利于编译器。</p>
<h3 id="cc-inline-assembly">C/C++ inline assembly</h3>
<p>在C和C++中，你可以使用<code>asm</code>关键字来包含内联汇编代码。它允许你直接在C或C++函数中嵌入汇编代码。以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">asm</span> (</span><br><span class="line">    <span class="string">&quot;ADD %w[result], %w[input_i], %w[input_j]&quot;</span></span><br><span class="line">    : [result] <span class="string">&quot;=r&quot;</span> (res)</span><br><span class="line">    : [input_i] <span class="string">&quot;r&quot;</span> (i), [input_j] <span class="string">&quot;r&quot;</span> (j)</span><br><span class="line">  );</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  c = add(a, b);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Result of %d + %d = %d\n&quot;</span>, a, b, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>asm</code>内联汇编语句的一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span>(code [: output_operand_list [: input_operand_list [: clobber_list]]]);</span><br></pre></td></tr></table></figure>
<p>以下是各个组成部分的说明：</p>
<ul>
<li><code>code</code>表示汇编代码本身。在示例中，它是<code>"ADD %[result], %[input_i], %[input_j]"</code>。</li>
<li><code>output_operand_list</code>是一个可选的以逗号分隔的输出操作数列表。每个操作数由方括号中的符号名称、约束字符串和括号中的C表达式组成。</li>
<li><code>input_operand_list</code>是一个可选的以逗号分隔的输入操作数列表。输入操作数使用与输出操作数相同的语法。</li>
<li><code>clobber_list</code>是一个可选的被破坏的寄存器或其他值的列表。</li>
</ul>
<p>当在C/C++和汇编代码之间调用函数时，你必须遵循AAPCS64规则。</p>
<p>更多信息，请参考：<a
href="https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C">https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C</a>。</p>
<h1 id="the-a64-instruction-set">The A64 instruction set</h1>
<p>尽管大多数应用级程序员在日常工作中不需要频繁编写汇编代码，但在某些情况下，了解汇编语言仍然具有重要价值。汇编代码在需要高度优化的情况下特别有用，例如编写编译器或使用C等高级语言无法直接访问的低级特性时。</p>
<p>在开发引导代码、设备驱动程序或操作系统时，可能需要使用汇编代码。这些领域通常需要对硬件有精细控制，并要求代码执行效率高。在这些情况下，使用汇编语言编写特定代码部分可以提高性能，并提供对硬件资源的低级访问能力。</p>
<p>此外，在调试C程序时，理解汇编代码变得至关重要。分析汇编指令与相应的C语句之间的映射有助于识别问题并优化代码。能够阅读汇编代码可以增强程序员理解和排查复杂软件行为的能力。</p>
<p>虽然汇编语言对大多数程序员来说不是主要工具，但在性能、低级控制和调试效率至关重要的专门领域中，汇编语言的重要性凸显出来。</p>
<h2 id="instruction-mnemonics-指令助记符">Instruction mnemonics /
指令助记符</h2>
<p>A64汇编语言中使用了指令助记符的重载，根据操作数寄存器名称的不同形式来区分不同的指令。例如，下面的ADD指令具有不同的编码，但您只需要记住一个助记符，汇编器会根据操作数自动选择正确的编码。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD W0, W1, W2             // 添加32位寄存器</span><br><span class="line"></span><br><span class="line">ADD X0, X1, X2             // 添加64位寄存器</span><br><span class="line"></span><br><span class="line">ADD X0, X1, W2, SXTW       // 将符号扩展的32位寄存器添加到64位扩展寄存器</span><br><span class="line"></span><br><span class="line">ADD X0, X1, #42            // 添加立即数到64位寄存器</span><br><span class="line"></span><br><span class="line">ADD V0.8H, V1.8H, V2.8H    // NEON中的16位逐个通道添加，共8个通道</span><br></pre></td></tr></table></figure></p>
<h2 id="data-processing-instructions-数据处理指令">Data processing
instructions / 数据处理指令</h2>
<p>数据处理指令是处理器的基本算术和逻辑操作，操作的对象是通用寄存器中的值，或者一个寄存器和一个立即值。乘法和除法指令可以看作是这些指令的特殊情况。</p>
<p>数据处理指令大多使用一个目标寄存器和两个源操作数。一般格式可以认为是指令，后面是操作数，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Instruction Rd, Rn, Operand2</span><br></pre></td></tr></table></figure>
<p>第二个操作数可以是一个寄存器、一个修改后的寄存器或一个立即值。使用 R
表示它可以是 X 寄存器或 W 寄存器。</p>
<p>数据处理操作包括：</p>
<ul>
<li>算术和逻辑操作。</li>
<li>移动和移位操作。</li>
<li>符号扩展和零扩展指令。</li>
<li>位和位域操作。</li>
<li>有条件的比较和数据处理操作。</li>
</ul>
<h2 id="memory-access-instructions-访存指令">Memory access instructions
/ 访存指令</h2>
<p>和之前的所有ARM处理器一样，ARMv8架构也是一种加载/存储（Load/Store）架构。这意味着没有数据处理指令直接在内存中操作数据。数据首先必须加载到寄存器中，进行修改，然后再存储到内存中。程序必须指定一个地址、要传输的数据大小以及一个源或目标寄存器。还有其他的加载和存储指令提供了进一步的选项，比如非临时的加载/存储、加载/存储互斥和获取/释放。</p>
<p>内存指令可以以非对齐的方式访问普通内存（参见<a
href="https://developer.arm.com/documentation/den0024/a/Memory-Ordering?lang=en">内存排序</a>）。但这在独占访问、加载获取或存储释放变体中是不支持的。如果不希望进行非对齐访问，可以配置为出错。</p>
<h3
id="specifying-the-address-for-a-load-or-store-instruction">Specifying
the address for a Load or Store instruction</h3>
<p>在A64中，用于加载（Load）或存储（Store）指令的地址指定方式与A32和T32类似。虽然存在一些额外的限制和新特性，但对于熟悉A32或T32的人来说，A64提供的地址指定方式应该不会让人感到意外。</p>
<p>在A64中，地址操作数的基础寄存器必须始终是一个X寄存器。然而，有几条指令支持零扩展（zero-extension）或符号扩展（sign-extension），以便可以将32位偏移量作为W寄存器提供。</p>
<h4 id="offset-modes">Offset modes</h4>
<p>https://developer.arm.com/documentation/den0024/a/The-A64-instruction-set/Memory-access-instructions/Specifying-the-address-for-a-Load-or-Store-instruction?lang=en
#### Index modes 索引模式（Index modes）与偏移模式（Offset
modes）类似，但它们还会更新基础寄存器。其语法与A32和T32相同，但操作的集合更为限制。通常，只能为索引模式提供立即偏移量（immediate
offsets）。</p>
<p>索引模式有两个变体：前索引模式（pre-index
modes）在访问内存之前应用偏移量，而后索引模式（post-index
modes）在访问内存之后应用偏移量。</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Example instruction</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>LDR X0, [X1, #8]!</td>
<td>Pre-index: Update X1 first (to X1 + #8), then load from the new
address</td>
</tr>
<tr class="even">
<td>LDR X0, [X1], #8</td>
<td>Post-index: Load from the unmodified address in X1 first, then
update X1 (to X1 + #8)</td>
</tr>
<tr class="odd">
<td>STP X0, X1, [SP, #-16]!</td>
<td>Push X0 and X1 to the stack.</td>
</tr>
<tr class="even">
<td>LDP X0, X1, [SP], #16</td>
<td>Pop X0 and X1 off the stack.</td>
</tr>
</tbody>
</table>
<p>These options map cleanly onto some common C operations:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A C example showing accesses that a compiler is likely to generate.</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">example_strcpy</span><span class="params">(<span class="type">char</span> * dst, <span class="type">const</span> <span class="type">char</span> * src)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    c = *(src++);             <span class="comment">// LDRB W2, [X1], #1</span></span><br><span class="line">    *(dst++) = c;             <span class="comment">// STRB W2, [X0], #1</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (c != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="pc-relative-modes-load-literal">PC-relative modes
(load-literal)</h4>
<p>A64引入了另一种专门用于访问<strong>字面池（literal
pools）</strong>的寻址模式，称为PC相对模式（PC-relative
modes）。字面池是嵌入在指令流中的数据块。这些池不会被执行，但可以通过PC相对内存地址从周围的代码中访问它们的数据。字面池通常用于编码无法适应简单的立即数移动指令的常量值。</p>
<p>在A32和T32中，PC可以像通用寄存器一样读取，因此只需将PC指定为基础寄存器即可访问字面池。</p>
<p>在A64中，PC通常是不可访问的，但是有一种特殊的寻址模式（仅适用于加载指令）可以访问PC相对地址。这种专用的寻址模式的范围比A32和T32中的PC相对加载要大得多，因此字面池可以被更稀疏地定位。</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Example instruction</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>LDR W0, &lt;label&gt;</td>
<td>Load 4 bytes from &lt;label&gt; into W0</td>
</tr>
<tr class="even">
<td>LDR X0, &lt;label&gt;</td>
<td>Load 8 bytes from &lt;label&gt; into X0</td>
</tr>
<tr class="odd">
<td>LDRSW X0, &lt;label&gt;</td>
<td>Load 4 bytes from &lt;label&gt; and sign-extend into X0</td>
</tr>
<tr class="even">
<td>LDR S0, &lt;label&gt;</td>
<td>Load 4 bytes from &lt;label&gt; into S0</td>
</tr>
<tr class="odd">
<td>LDR D0, &lt;label&gt;</td>
<td>Load 8 bytes from &lt;label&gt; into D0</td>
</tr>
<tr class="even">
<td>LDR Q0, &lt;label&gt;</td>
<td>Load 16 bytes from &lt;label&gt; into Q0</td>
</tr>
</tbody>
</table>
<p>Note: &lt;label&gt; must be 4-byte-aligned for all variants.</p>
<h3 id="unprivileged-access">Unprivileged access</h3>
<p>A64
LDTR和STTR指令执行非特权的加载（Load）或存储（Store）操作（请参阅ARMv8-A架构参考手册中的LDTR和STTR）：
- 在EL0、EL2或EL3级别下，它们的行为类似于普通的加载或存储指令。 -
当在EL1级别下执行时，它们的行为类似于在EL0特权级别下执行。</p>
<p>这些指令与A32 LDRT和STRT指令是等效的。</p>
<h3
id="non-temporal-load-and-store-pair-非暂态non-temporal加载和存储">Non-temporal
load and store pair / 非暂态（non-temporal）加载和存储</h3>
<p>在ARMv8架构中引入了非暂态（non-temporal）加载和存储的概念。这些概念体现在LDNP和STNP指令中，它们用于读取或写入一对寄存器值。同时，它们向内存系统发出提示，表明对该数据进行缓存是无益的。这个提示并不禁止内存系统的活动，比如地址的缓存、预加载或者聚集。然而，它表明进行缓存不太可能提高性能。一个典型的用例可能是流式数据处理，但需要注意的是，有效地使用这些指令需要针对具体微架构的特定方法。</p>
<p>非暂态加载和存储放宽了内存排序要求。在上述例子中，LDNP指令可能在前面的LDR指令之前执行，这可能导致从不确定的X0地址读取数据。
For example: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR X0, [X3]</span><br><span class="line">LDNP X2, X1, [X0]      // Xo may not be loaded when the instruction executes!</span><br></pre></td></tr></table></figure> 为了纠正上述问题，需要使用显式的加载屏障：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR X0, [X3]</span><br><span class="line">DMB nshld</span><br><span class="line">LDNP X2, X1, [X0]</span><br></pre></td></tr></table></figure>
通过引入加载屏障，可以确保在LDNP指令执行之前先加载X0的值，从而避免了不确定的读取。这样，非暂态加载和存储指令才能够在程序中被正确使用。</p>
<h3 id="memory-access-atomicity">Memory access atomicity</h3>
<p>对齐的内存访问使用单个通用寄存器可以保证原子性。使用对齐的内存地址进行的一对通用寄存器的加载对（load
pair）和存储对（store
pair）指令可以保证作为两个独立的原子访问。非对齐访问不是原子的，因为通常需要进行两次独立的访问。此外，浮点数和SIMD（单指令多数据）内存访问不能保证原子性。</p>
<h3 id="memory-barrier-and-fence-instructions">Memory barrier and fence
instructions</h3>
<p>ARMv7和ARMv8都支持不同类型的内存屏障操作。这些操作在<a
href="https://developer.arm.com/documentation/den0024/a/Memory-Ordering?lang=en">Memory
Ordering</a>中有更详细的描述：</p>
<p>数据内存屏障（Data Memory
Barrier，DMB）：在继续执行后续访问之前，强制使程序顺序中较早的所有内存访问对全局可见。</p>
<p>数据同步屏障（Data Synchronization
Barrier，DSB）：在程序继续执行之前，完成所有待处理的加载和存储、缓存维护指令以及TLB维护指令。DSB的行为类似于DMB，但具有附加属性。</p>
<p>指令同步屏障（Instruction Synchronization
Barrier，ISB）：该指令刷新CPU流水线和预取缓冲区，导致ISB之后的指令从缓存或内存中获取（或重新获取）。</p>
<p>ARMv8引入了单向栅栏（one-sided fences），这与Release
Consistency模型相关。这些栅栏被称为Load-Acquire（LDAR）和Store-Release（STLR），它们是基于地址的同步原语（见<a
href="https://developer.arm.com/documentation/den0024/a/Memory-Ordering?lang=en">One-way
barriers</a>）。这两个操作可以配对形成一个完整的栅栏。这些指令仅支持基址寄存器寻址，不支持偏移量或其他类型的索引寻址。</p>
<h3 id="synchronization-primitives">Synchronization primitives</h3>
<p>ARMv7-A和ARMv8-A架构都支持独占内存访问。在A64中，这是通过Load/Store
exclusive（LDXR/STXR）指令对实现的。</p>
<p>LDXR指令从内存地址加载一个值，并尝试在该地址上默默地获取独占锁。然后，Store-Exclusive指令只有在成功获取并持有锁时才会将新值写入该位置。LDXR/STXR配对用于构建标准的同步原语，例如自旋锁。还提供了一对配对的LDXRP和STXRP指令，以允许原子更新跨越两个寄存器的位置。可用的选项包括字节、半字、字和双字。与Load
Acquire/Store
Release配对一样，只支持基址寄存器寻址，没有任何偏移量。</p>
<p>CLREX指令用于清除监视器，但与ARMv7不同，异常的进入或返回也会清除监视器。监视器也可能被意外地清除，例如由于缓存逐出或与应用程序无直接关联的其他原因。在配对的LDXR和STXR指令之间，软件必须避免任何显式的内存访问、系统控制寄存器更新或缓存维护指令。</p>
<p>此外，还有一对独占的Load Acquire/Store
Release指令，称为LDAXR和STLXR。详见<a
href="https://developer.arm.com/documentation/den0024/a/Multi-core-processors/Multi-processing-systems/Synchronization?lang=en">同步</a>部分。</p>
<h2 id="flow-control">Flow control</h2>
<p>A64指令集提供了多种不同类型的分支指令（参见表<a
href="https://developer.arm.com/documentation/den0024/a/The-A64-instruction-set/Flow-control?lang=en">6.12</a>）。对于简单的相对分支，即从当前地址偏移的分支，使用B指令。<em>无条件的简单相对分支可以向前或向后分支到距离当前程序计数器位置最多128MB的位置</em>。<em>有条件的简单相对分支，在B后附加条件码，其范围较小，为±1MB</em>。</p>
<p>对于需要将返回地址存储在链接寄存器（X30）中的子程序调用，使用BL指令。它没有条件版本。<em>BL的行为类似于B指令，同时额外存储返回地址，即BL指令后一条指令的地址，到寄存器X30中</em>。</p>
<h2 id="system-control-and-other-instructions-系统控制和其他指令">System
control and other instructions / 系统控制和其他指令</h2>
<p>A64指令集包含与以下内容相关的指令： - 异常处理。 - 系统寄存器访问。 -
调试。 - 提示指令，在许多系统中具有电源管理应用。</p>
<h3 id="exception-handling-instructions">Exception handling
instructions</h3>
<p>有三条异常处理指令，其目的是引发异常。这些指令用于调用在操作系统中运行在更高异常级别的代码（EL1），虚拟机监控程序（EL2）或安全监控程序（EL3）：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SVC #imm16   // 监管者调用，允许应用程序调用内核（EL1）。</span><br><span class="line"></span><br><span class="line">HVC #imm16   // 虚拟机监控程序调用，允许操作系统代码调用虚拟机监控程序（EL2）。</span><br><span class="line"></span><br><span class="line">SMC #imm16   // 安全监控程序调用，允许操作系统或虚拟机监控程序调用安全监控程序（EL3）。</span><br></pre></td></tr></table></figure>
立即值将在异常综合寄存器中提供给处理程序。这与ARMv7不同，ARMv7需要通过读取调用指令的操作码来确定立即值。详细信息请参阅<a
href="https://developer.arm.com/documentation/den0024/a/AArch64-Exception-Handling?lang=en">AArch64异常处理</a>。</p>
<p>要从异常返回，请使用ERET指令。此指令通过将SPSR_ELn复制到PSTATE并跳转到ELR_ELn中保存的返回地址来恢复处理器状态。</p>
<h1 id="arm-64位架构的abi">ARM 64位架构的ABI</h1>
<p>ARM体系结构的应用二进制接口（ABI）规定了所有可执行的本机代码模块必须遵循的基本规则，以便它们可以正确地协同工作。这些基本规则还可以通过特定编程语言（例如C++）的附加规则进行补充。各个操作系统或执行环境（例如Linux）可能会指定额外的规则以满足其自身特定的要求，超出了ARM
ABI规定的规则。</p>
<h2
id="aarch64过程调用标准中的寄存器使用">AArch64过程调用标准中的寄存器使用</h2>
<h3 id="通用寄存器中的参数">通用寄存器中的参数</h3>
<p>为了函数调用的目的，通用寄存器被分为四组： #### 参数寄存器（X0-X7）
这些寄存器用于将参数传递给函数并返回结果。它们可以用作临时寄存器或调用者保存的寄存器变量，在函数内部和调用其他函数之间保存中间值。提供了8个寄存器用于传递参数，相比于AArch32，减少了将参数保存到堆栈的需要。
#### 调用者保存的临时寄存器（X9-X15）
如果调用者需要在调用其他函数之后保留这些寄存器中的值，调用者必须在自己的堆栈帧中保存受影响的寄存器。被调用的子程序可以修改这些寄存器，而无需在返回给调用者之前保存和恢复它们。
#### 被调用者保存的寄存器（X19-X29）
这些寄存器在被调用者的帧中保存。被调用的子程序可以修改这些寄存器，只要在返回之前保存和恢复它们。
#### 具有特殊用途的寄存器（X8，X16-X18，X29，X30） - <a
href="https://developer.arm.com/documentation/den0024/a/The-ABI-for-ARM-64-bit-Architecture/Register-use-in-the-AArch64-Procedure-Call-Standard/Indirect-result-location?lang=en">X8</a>是间接结果寄存器。它用于传递间接结果的地址位置，例如函数返回大型结构体的情况。
-
X16和X17是IP0和IP1，函数内部调用的临时寄存器。这些寄存器可以由调用细节和类似代码使用，或者作为子例程调用之间的临时寄存器用于中间值。在函数中可以更改它们，但在返回给调用者之前需要保存和恢复。
-
X18是平台寄存器，保留用于平台ABI的使用。对于不分配特殊含义的平台来说，这是一个额外的临时寄存器。
- <strong>X29是帧指针寄存器（FP）</strong>。
X29寄存器是ARM64（AArch64）体系结构中的一个特殊寄存器，也被称为Frame
Pointer（FP，帧指针）。在函数调用和栈操作中，X29寄存器用于指向当前函数的栈帧（stack
frame）的起始位置。</p>
<p>栈帧是用于管理函数调用和局部变量的内存区域。当一个函数被调用时，当前函数的栈帧会被创建，并且X29寄存器会被设置为指向栈帧的起始位置。栈帧通常包括函数的参数、局部变量、返回地址和其他与函数执行相关的数据。</p>
<p>X29寄存器在函数执行过程中保持不变，直到函数返回。在函数返回时，栈帧会被销毁，X29寄存器会被恢复为之前的值，以便返回到调用函数的位置。</p>
<p>除了作为帧指针的功能外，X29寄存器也可以用作通用寄存器，存储其他临时数据。</p>
<p>需要注意的是，X29寄存器在ARM64体系结构中具有固定的寄存器编号。在编程中，可以使用X29寄存器来访问和修改栈帧中的数据。
- <strong>X30是链接寄存器（LR）</strong>。</p>
<h1 id="aarch64-exception-handling">AArch64 Exception Handling</h1>
<p>严格来说，中断是指中断软件执行流程的事件。然而，在ARM术语中，这实际上被称为异常（Exception）。异常是指需要特权软件（异常处理程序）采取某些操作以确保系统正常运行的条件或系统事件。每种异常类型都有一个关联的异常处理程序。一旦异常被处理，特权软件会准备内核继续执行之前发生异常的操作。</p>
<p>以下是存在的异常类型： #### Interrupts / 中断
有两种类型的中断，称为IRQ和FIQ。</p>
<p>FIQ比IRQ具有更高的优先级。这两种异常类型通常与内核上的输入引脚相关联。外部硬件会断言一个中断请求线，当当前指令执行完成时（尽管一些指令，例如可以加载多个值的指令，可以被中断），相应的异常类型会被触发，前提是中断未被禁用。</p>
<p>Both FIQ and IRQ are physical signals to the core, and when asserted,
如果当前该中断启用，则内核会执行相应的异常处理。在几乎所有系统上，各种中断源使用中断控制器连接。中断控制器进行仲裁和优先级排序，并提供一个串行的单一信号，然后将其连接到内核的FIQ或IRQ信号。有关更多信息，请参阅通用中断控制器。</p>
<p>由于IRQ和FIQ中断的发生与内核在任何给定时间执行的软件没有直接关系，因此它们被归类为异步异常。</p>
<h4 id="reset">Reset</h4>
<p>重置（Reset）被视为最高实现的异常等级的特殊向量。这是ARM处理器在引发异常时跳转到的指令位置。该向量使用实现定义的地址。RVBAR_ELn包含此复位向量地址，其中n是最高实现的异常等级的编号。</p>
<p>所有内核都有一个复位输入，并在复位后立即执行复位异常。它是最高优先级的异常，无法屏蔽。此异常用于在上电后对内核进行初始化的代码执行。</p>
<h4 id="生成异常的指令">生成异常的指令</h4>
<p>执行某些指令可能会生成异常。这些指令通常用于请求在更高特权级别下运行的软件提供服务：
- 监控模式调用（Supervisor
Call，SVC）指令使用户模式程序能够请求操作系统服务。 -
Hypervisor调用（Hypervisor
Call，HVC）指令使客户操作系统能够请求hypervisor服务。 -
安全监控调用（Secure monitor
Call，SMC）指令使正常世界能够请求安全世界服务。</p>
<p>如果由于EL0处的指令获取而生成的异常，则将其视为对EL1的异常，除非在非安全状态下设置了HCR_EL2.TGE位，否则将其视为对EL2的异常。</p>
<p>如果异常是由于在其他任何异常等级处的指令获取而生成的，则异常等级保持不变。</p>
<h2 id="exception-handling-registers">Exception handling registers</h2>
<p>如果发生异常，PSTATE信息将保存在Saved Program Status
Register（SPSR_ELn）中，其中SPSR_ELn存在于SPSR_EL3、SPSR_EL2和SPSR_EL1。</p>
<p>如果发生异常，处理器会将当前的处理状态信息保存到相应的SPSR_ELn寄存器中。SPSR_EL3用于保存EL3的状态信息，SPSR_EL2用于保存EL2的状态信息，SPSR_EL1用于保存EL1的状态信息。</p>
<p>这些寄存器保存了执行异常之前的处理器状态，包括程序状态寄存器（PSTATE）的值，如处理器模式、中断使能状态、条件标志等。通过保存当前状态，处理器可以在处理完异常后恢复到发生异常之前的状态，以便顺利继续执行。</p>
<p>SPSel字段选择当前异常等级的堆栈指针（Stack
Pointer）或SP_EL0是否应该被使用。除EL0之外的任何异常等级都可以进行此选择。这将在本章后面进行讨论。</p>
<p>在发生引发异常的事件时，处理器硬件会自动执行某些操作。SPSR_ELn（其中n是发生异常的异常等级）将被更新，用于存储在异常结束时正确返回所需的PSTATE信息。PSTATE会更新以反映新的处理器状态（这可能意味着提升异常等级，也可能保持不变）。要在异常结束时使用的返回地址将存储在ELR_ELn中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> flow in EL0                           flow in EL1</span><br><span class="line"></span><br><span class="line">Exception occurs</span><br><span class="line">            PC -&gt;ELR_EL1</span><br><span class="line">            PSTATE -&gt;SPSR_EL1</span><br><span class="line">                                    ExceptionHandler</span><br><span class="line">            SPSR_EL1 -&gt; PSTATE</span><br><span class="line">            ELR_EL1 -&gt; PC</span><br></pre></td></tr></table></figure>
<p>请记住，寄存器名称中的_ELn后缀表示在不同的异常等级存在多个副本。例如，SPSR_EL1是与SPSR_EL2不同的物理寄存器。此外，在同步或SError异常的情况下，ESR_ELn还会更新为指示异常原因的值。</p>
<p>处理器需要通过软件告知何时从异常返回。这是通过执行ERET指令来完成的。该指令从SPSR_ELn中恢复先前的异常前PSTATE，并通过从ELR_ELn中恢复PC将程序执行返回到原始位置。</p>
<p>我们已经了解了SPSR如何记录异常返回所需的状态信息。现在我们来看一下用于存储程序地址信息的链接寄存器。架构为函数调用和异常返回提供了单独的链接寄存器。</p>
<p>正如我们在A64指令集中看到的那样，寄存器X30与RET指令一起用于从子程序返回。每当执行带链接的分支指令（BL或BLR）时，其值都会更新为要返回的指令的地址。</p>
<p>ELR_ELn寄存器用于存储异常的返回地址。该寄存器中的值（实际上是多个寄存器，正如我们所见）在进入异常时会自动写入，并作为执行ERET指令返回异常的效果之一写入PC。</p>
<p>注意：
当从异常返回时，如果SPSR中的值与系统寄存器的设置发生冲突，您将会看到错误。</p>
<p>ELR_ELn包含首选用于特定异常类型的返回地址。对于某些异常，这是生成异常的指令之后的下一条指令的地址。例如，当执行SVC（系统调用）指令时，我们只希望返回到应用程序中的下一条指令。在其他情况下，我们可能希望重新执行生成异常的指令。</p>
<p>对于异步异常，ELR_ELn指向由于接收中断而尚未执行或完全执行的第一条指令的地址。处理器代码可以修改ELR_En，例如，如果需要在中止同步异常后返回到指令之后。ARMv8-A模型比ARMv7-A中使用的模型要简单得多，因为出于向后兼容的原因，在从某些类型的异常返回时，需要从链接寄存器值中减去4或8。</p>
<p>除了SPSR和ELR寄存器之外，每个异常等级都有自己专用的堆栈指针寄存器。它们被命名为SP_EL0、SP_EL1、SP_EL2和SP_EL3。这些寄存器用于指向专用堆栈，例如，可用于存储由异常处理程序破坏的寄存器，以便在返回到原始代码之前将它们恢复到原始值。</p>
<p>处理器代码可以从使用SP_ELn切换到SP_EL0。例如，可能是SP_EL1指向保存了内核始终保证有效的小型堆栈的内存区域。而SP_EL0可能指向一个更大的内核任务堆栈，但不能保证免受溢出的影响。通过写入[SPSel]位来控制此切换，如下面的代码所示：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MSR SPSel, #0  // 切换到SP_EL0</span><br><span class="line">MSR SPSel, #1  // 切换到SP_ELn</span><br></pre></td></tr></table></figure></p>
<h2
id="synchronous-and-asynchronous-exceptions-同步和异步异常">Synchronous
and asynchronous exceptions / 同步和异步异常</h2>
<p>在AArch64架构中，异常可以是同步的或异步的。如果异常是由执行或尝试执行指令流而产生的，并且返回地址提供了引发异常的指令的详细信息，那么该异常被称为同步异常。而异步异常不是通过执行指令而生成的，返回地址可能并不总是提供引发异常的详细信息。</p>
<p>异步异常的来源包括IRQ（普通优先级中断）、FIQ（快速中断）或SError（系统错误）。系统错误有多种可能的原因，其中最常见的是异步数据中止（例如，由缓存行向外部内存写回脏数据而触发的中止）。</p>
<p>同步异常有多种来源： - 来自MMU的指令中止。例如，通过从标记为"Execute
Never"的内存位置读取指令。 -
来自MMU的数据中止。例如，权限失败或对齐检查。 - SP和PC对齐检查。 -
同步外部中止。例如，在读取转换表时发生中止。 - 未分配的指令。 -
调试异常。</p>
<h3 id="synchronous-aborts-同步中止">Synchronous aborts / 同步中止</h3>
<p>同步异常可能由多种原因引起： -
来自MMU的中止。例如，权限失败或被标记为访问标志错误的内存区域。 -
SP和PC对齐检查。 - 未分配的指令。 - 服务调用（SVC、SMC和HVC）。</p>
<p>这些异常可能是操作系统正常运行的一部分。例如，在Linux中，当一个任务希望请求分配一个新的内存页面时，通过MMU中止机制(abort
mechanism)来处理这个请求。</p>
<h3 id="handling-synchronous-exceptions">Handling synchronous
exceptions</h3>
<p>为了向异常处理程序提供有关同步异常原因的信息，提供了一些寄存器。异常综合症寄存器(Exception
Syndrome Register) (ESR_ELn)
提供有关异常原因的信息。故障地址寄存器（FAR_ELn）保存了所有同步指令和数据中止以及对齐错误的故障虚拟地址。</p>
<p>异常链接寄存器（ELR_ELn）保存导致数据访问中止的指令地址（对于数据中止）。这通常在发生内存故障后更新，但在其他情况下也可能被设置，例如通过跳转到一个不对齐的地址。</p>
<p>对于实现EL2（虚拟化监控器）或EL3（安全内核）的系统，同步异常通常在当前或更高的异常级别中进行处理。异步异常（如果需要）可以被路由到更高的异常级别，由虚拟化监控器或安全内核处理。SCR_EL3寄存器指定了应将哪些异常路由到EL3，类似地，HCR_EL2指定了应将哪些异常路由到EL2。有单独的位允许对IRQ、FIQ和SError的路由进行个别控制。</p>
<h3 id="system-calls-系统调用">System calls / 系统调用</h3>
<p>某些指令或系统功能只能在特定的异常级别下执行。如果在较低的异常级别下运行的代码需要执行特权操作，例如应用程序代码请求内核功能。一种方法是使用SVC指令。这允许应用程序生成一个异常。参数可以通过寄存器传递，也可以在系统调用中进行编码。</p>
<h3 id="unallocated-instructions-未分配的指令">Unallocated instructions
/ 未分配的指令</h3>
<p>在AArch64中，未分配的指令会引发同步中止异常。当处理器执行以下情况之一时，会生成此异常类型：
- 未分配的指令操作码。 - 要求比当前异常级别更高特权级别的指令。 -
已禁用的指令。 - 当设置了PSTATE.IL字段时的任何指令。</p>
<h3 id="the-exception-syndrome-register">The Exception Syndrome
Register</h3>
<p>异常综合症寄存器（ESR_ELn）包含的信息可以帮助异常处理程序确定异常的原因。它仅针对同步异常和SError进行更新。对于IRQ或FIQ，它不会更新，因为这些中断处理程序通常从通用中断控制器（GIC）的寄存器中获取状态信息。（参见<a
href="https://developer.arm.com/documentation/den0024/a/AArch64-Exception-Handling/The-Generic-Interrupt-Controller?lang=en">通用中断控制器</a>。）该寄存器的位编码如下：
-
ESR_ELn的位[31:26]指示异常类别，使处理程序能够区分各种可能的异常原因（例如，未分配的指令、来自MCR/MRC到CP15的异常、浮点操作异常、执行的SVC、HVC或SMC、数据中止和对齐异常，见<a
href="https://developer.arm.com/documentation/ddi0595/2021-03/AArch64-Registers/ESR-EL3--Exception-Syndrome-Register--EL3-">EC</a>。
- 0b100100 ==&gt;&gt; Data Abort - 0b100100 ==&gt;&gt; Instruction Abort
(Used for MMU faults generated by instruction accesses)</p>
<p>Used for MMU faults generated by data accesses, alignment faults
other than those caused by Stack Pointer misalignment, and synchronous
External aborts, including synchronous parity or ECC errors. Not used
for debug-related exceptions. -
位[25]指示被捕获指令的长度（对于16位指令为0，对于32位指令为1），并且对某些异常类别也会设置。
-
位[24:0]形成指令特定综合症（ISS）字段，其中包含特定于该异常类型的信息。例如，当执行系统调用指令（SVC、HVC或SMC）时，该字段包含与操作码相关联的立即数值，如对于<code>SVC 0x123456</code>，该字段包含0x123456。</p>
<h2 id="aarch64异常向量表">AArch64异常向量表</h2>
<p><a
href="https://developer.arm.com/documentation/den0024/a/AArch64-Exception-Handling/AArch64-exception-table?lang=en">AArch64异常向量表</a>是存储异常处理程序代码的内存位置，用于处理发生的异常。在ARM架构中，异常向量表被存储在一个称为异常向量表的表中。每个异常级别都有自己的向量表，即EL3、EL2和EL1各有一个。该表包含要执行的指令，而不是一组地址。各个异常的向量位于距离表开始处的固定偏移量位置。每个表基地址的虚拟地址由向量基地址寄存器VBAR_EL3、VBAR_EL2和VBAR_EL1设置。</p>
<p>向量表中的每个条目长度为16条指令。与ARMv7相比，这本身就代表了一个重要的变化，因为ARMv7的每个条目长度为4字节。ARMv7向量表的这种间隔意味着每个条目几乎总是某种形式的分支，指向内存中实际的异常处理程序。在AArch64中，向量之间的间隔更大，因此顶级处理程序可以直接编写在向量表中。</p>
<h2 id="interrupt-handling">Interrupt handling</h2>
<p>在ARM中，通常使用"interrupt"来表示中断信号。在ARM
A-profile和R-profile处理器上，这意味着外部的IRQ或FIQ中断信号。架构没有规定这些信号如何使用。FIQ通常用于保留安全中断源。在早期的架构版本中，FIQ和IRQ用于表示高优先级和标准优先级的中断，但在ARMv8-A中不再适用这种情况。</p>
<p>当处理器执行到AArch64执行状态时，所有的PSTATE中断屏蔽位都会自动设置。这意味着进一步的异常被禁用。如果软件需要支持嵌套异常，例如允许更高优先级的中断打断低优先级源的处理，那么软件需要显式地重新启用中断。</p>
<h2 id="gic">GIC</h2>
<p><a
href="https://developer.arm.com/documentation/den0024/a/AArch64-Exception-Handling/The-Generic-Interrupt-Controller?lang=en">GIC</a>架构提供了寄存器，用于管理中断源和行为，并在多核系统中将中断路由到各个内核。它使软件能够屏蔽、使能和禁用来自各个源的中断，对各个源进行硬件优先级排序，并生成软件中断。GIC接受在系统级别被触发的中断，并将其传递给每个连接的内核，可能导致触发IRQ或FIQ异常。</p>
<p>从软件的角度来看，GIC具有两个主要的功能块：</p>
<p>分配器（Distributor）
连接系统中的所有中断源。分配器具有用于控制单个中断属性的寄存器，例如优先级、状态、安全性、路由信息和使能状态。分配器通过连接的CPU接口确定要转发给内核的中断。</p>
<p>CPU接口（CPU Interface）
内核接收中断的接口。CPU接口包含用于屏蔽、识别和控制转发到该内核的中断状态的寄存器。系统中的每个内核都有一个独立的CPU接口。</p>
<p>中断在软件中通过一个称为中断ID的编号来进行标识。中断ID唯一对应一个中断源。软件可以使用中断ID来识别中断源，并调用相应的处理程序来处理中断。实际呈现给软件的确切中断ID由系统设计确定，</p>
<h3 id="initialization">Initialization</h3>
<p>在分配器中，软件必须配置每个中断的优先级、目标、安全性和使能状态。然后，通过控制寄存器（GICD_CTLR）启用分配器。对于每个CPU接口，软件必须设置优先级掩码和抢占设置。</p>
<p>每个CPU接口模块本身也必须通过其控制寄存器（GICD_CTLR）进行启用。这样可以准备GIC将中断传递给内核</p>
<h3 id="interrupt-handling-1">Interrupt handling</h3>
<p>当内核接收到中断时，它会跳转到从向量表获取的顶级中断向量，并开始执行。</p>
<p>顶级中断处理程序从CPU接口模块读取中断确认寄存器以获取中断ID。</p>
<p>除了返回中断ID外，读取操作还会将中断标记为在分配器中处于活动状态。一旦知道中断ID（标识中断源），顶级处理程序现在可以调度一个特定于设备的处理程序来处理中断。</p>
<p>当设备特定的处理程序执行完成后，顶级处理程序将相同的中断ID写入CPU接口模块中的结束中断（EoI）寄存器，表示中断处理结束。</p>
<p>除了取消活动状态，使最终中断状态变为非活动状态或挂起状态（如果状态既是活动又是挂起），这还使得CPU接口能够将更多待处理的中断转发给内核。这完成了单个中断的处理过程。</p>
<p>在同一个内核上可能有多个等待处理的中断，但CPU接口一次只能发送一个中断。顶级中断处理程序可以重复上述序列，直到读取到特殊的中断ID值1023，表示在该内核上没有更多待处理的中断。这个特殊的中断ID称为虚假中断ID。</p>
<p>虚假中断ID是一个保留值，不能分配给系统中的任何设备。当顶级处理程序读取到虚假中断ID时，它可以完成执行，并准备内核继续执行中断之前的任务。</p>
<p>通用中断控制器（GIC）通常管理来自多个中断源的输入，并将它们分发给IRQ或FIQ请求。</p>
<h1 id="multi-core-processors">Multi-core processors</h1>
<h2 id="multi-core-processors-system">Multi-core processors system</h2>
<h3 id="timers">Timers</h3>
<p>Symmetric Multi-Processing (SMP) 一个支持SMP(Symmetric
Multi-Processing)操作的操作系统内核通常具有任务调度器，该调度器负责在多个任务之间对内核上的可用周期进行时间切片。它动态确定各个任务的优先级，并决定在每个内核上下一个要运行的任务。通常需要一个定时器，以便可以周期性地中断每个内核上的活动任务的执行，使调度器有机会选择不同的任务进行进展。</p>
<p>当所有内核都竞争同一个关键资源时可能会出现问题。每个内核运行调度器以决定它应该执行哪个任务，这发生在固定的时间间隔内。内核调度器代码需要使用一些共享数据，例如任务列表，可以通过互斥锁进行并发访问保护。互斥锁一次只允许一个内核有用地运行调度器。</p>
<p>系统定时器架构描述了一个常见的系统计数器，每个内核提供多达四个定时器通道。该系统计数器应具有固定的时钟频率。有安全和非安全的物理定时器以及两个用于虚拟化目的的定时器。每个通道都有一个比较器，该比较器与一个系统范围的64位计数进行比较，该计数从零开始递增。您可以配置定时器，使得当计数大于或等于编程的比较器值时生成中断。</p>
<p>尽管系统定时器必须具有固定的频率（通常以MHz为单位），但允许变化的更新粒度。这意味着您可以在每个时钟节拍上将计数增加1，也可以以较大的增量（例如10或100）进行增加，对应地以每10或100个周期的较低速率进行增加。这会产生相同的有效频率，但更新粒度较小。这对于实现较低的功耗状态非常有用。</p>
<p><code>CNTFRQ_EL0</code>寄存器报告了系统定时器的频率。</p>
<p>一个常见的误解是CNTFRQ_EL0由所有内核共享。它只是寄存器按内核独立，但仅从固件的角度来看：所有其他软件应在所有内核上看到该寄存器已初始化为正确的共享值。然而，计数器频率是全局的，对所有内核而言是固定的。CNTFRQ_EL0为引导ROM或固件提供了一种方便的方式来告知其他软件全局计数器频率是多少，但不控制任何硬件行为的方面。</p>
<p>CNTPCT_EL0寄存器报告当前的计数值。<code>CNTKCTL_EL1</code>控制EL0是否可以访问系统定时器。</p>
<p>要配置定时器，请完成以下步骤： 1.
将比较器值写入CNTP_CVAL_EL0，一个64位寄存器。 2.
在CNTP_CTL_EL0中启用计数器和中断生成。 3.
轮询CTP_CTL_EL0以报告EL0定时器中断的原始状态。</p>
<p>您可以将系统定时器用作倒计时定时器。在这种情况下，所需的计数将写入32位的CNTP_TVAL_EL0寄存器。硬件将为您计算正确的CNTP_CVAL_EL0值。</p>
]]></content>
      <categories>
        <category>Qemu</category>
      </categories>
  </entry>
  <entry>
    <title>解决打家劫舍系列问题</title>
    <url>/zyhjy/2023/08/18/%E8%A7%A3%E5%86%B3%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="解决打家劫舍系列问题">解决打家劫舍系列问题</h1>
<p>打家劫舍（House
Robber）问题的模式，就是在一个数组中挑出若干不相邻的数字，使得挑出的数字的和最大。</p>
<p>其演化形式可以将数组改变为环形数组或树等数据结构，或者限制挑出的数字的个数。</p>
<span id="more"></span>
<h2 id="leetcode-198.打家劫舍">LeetCode 198.打家劫舍</h2>
<p><a href="https://leetcode.cn/problems/house-robber/">198.
打家劫舍</a></p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你
<strong>不触动警报装置的情况下</strong>
，一夜之内能够偷窃到的最高金额。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure>
<h3 id="思路">思路</h3>
<p>动态规划，设<code>dp[i]</code>是从下标区间<code>[0, i]</code>选出的房屋金额之和的最大值，则递推公式为<code>dp[i] = max&#123;dp[i - 2] + nums[i], dp[i - 1]&#125;</code>.</p>
<h2 id="leetcode-213.-打家劫舍-ii">LeetCode 213. 打家劫舍 II</h2>
<p><a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍
II</a></p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都
<strong>围成一圈</strong>
，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>
。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你
<strong>在不触动警报装置的情况下</strong>
，今晚能够偷窃到的最高金额。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,3,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<h3 id="思路-1">思路</h3>
<p>可以发现数组变成了环形数组，分析可知，与上题的不同之处在于，<strong>首尾不可同时打劫</strong>。</p>
<p>于是依然使用动态规划，设<code>dp[i]</code>是从下标区间<code>[0, i]</code>选出的房屋金额之和的最大值，则递推公式为<code>dp[i] = max&#123;dp[i - 2] + nums[i], dp[i - 1]&#125;</code>；但是需要做两次dp，相应的数组范围分别为<code>[0, n - 2]</code>和<code>[1, n - 1]</code>.</p>
<h2 id="leetcode-1388.-3n-块披萨">LeetCode 1388. 3n 块披萨</h2>
<p><a href="https://leetcode.cn/problems/pizza-with-3n-slices/">1388. 3n
块披萨</a></p>
<p>给你一个披萨，它由 3n
块不同大小的部分组成，现在你和你的朋友们需要按照如下规则来分披萨：</p>
<ul>
<li>你挑选 <strong>任意</strong> 一块披萨。</li>
<li>Alice 将会挑选你所选择的披萨逆时针方向的下一块披萨。</li>
<li>Bob 将会挑选你所选择的披萨顺时针方向的下一块披萨。</li>
<li>重复上述过程直到没有披萨剩下。</li>
</ul>
<p>每一块披萨的大小按顺时针方向由循环数组 <code>slices</code> 表示。</p>
<p>请你返回你可以获得的披萨大小总和的最大值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：slices = [1,2,3,4,5,6]</span><br><span class="line">输出：10</span><br><span class="line">解释：选择大小为 4 的披萨，Alice 和 Bob 分别挑选大小为 3 和 5 的披萨。然后你选择大小为 6 的披萨，Alice 和 Bob 分别挑选大小为 2 和 1 的披萨。你获得的披萨总大小为 4 + 6 = 10 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：slices = [8,9,8,6,1,1]</span><br><span class="line">输出：16</span><br><span class="line">解释：两轮都选大小为 8 的披萨。如果你选择大小为 9 的披萨，你的朋友们就会选择大小为 8 的披萨，这种情况下你的总和不是最大的。</span><br></pre></td></tr></table></figure>
<h3 id="思路-2">思路</h3>
<p>在挑选披萨之后，旁边的两块披萨会被选走，即<strong>不可能选两块连续的披萨</strong>。题目转化为上一题的环形数组打家劫舍。</p>
<p>但是此题同时要求，一共选取n(= slices.size() / 3)块披萨。</p>
<p>考虑二维动态规划的情况，设<code>dp[i][j]</code>是从下标区间<code>[0, i]</code>选出j个披萨的大小总合最大的情况，则递推公式为<code>dp[i][j] = max&#123;dp[i - 2][j - 1] + slices[i], dp[i - 1][j]&#125;</code>；同样的，由于是环形数组，需要做两次dp，相应的数组范围分别为<code>[0, 3 * n - 2]</code>和<code>[1, 3 * n - 1]</code>.</p>
]]></content>
      <categories>
        <category>DP</category>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>offer</tag>
      </tags>
  </entry>
</search>
