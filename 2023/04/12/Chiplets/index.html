<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
<meta name="referrer" content="no-referrer">
  <link rel="apple-touch-icon" sizes="180x180" href="/zyhjy/images/relativity128.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/zyhjy/images/relativity32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/zyhjy/images/relativity16.png">
  <link rel="mask-icon" href="/zyhjy/images/logo.svg" color="#222">

<link rel="stylesheet" href="/zyhjy/css/main.css">

<link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css?family=Comic Sans MS:300,300italic,400,400italic,700,700italic|Noto Serif SC:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/zyhjy/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zyh-eric.gitee.io","root":"/zyhjy/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="该论文讨论了系统级芯片（SoC）的复杂性和硅成本的增加促使将SoC分解为更小的“芯片块”。基于芯片块的SoC设计过程有望通过使用先进的封装技术将多个不同的芯片（例如CPU、GPU、内存、FPGA）紧密集成到一起来实现快速的SoC构建。然而，当将芯片块组装成单个SoC时，由于芯片块之间路由的复杂性增加，会出现正确性和性能问题。该论文提出了一种模块化但无死锁的路由方法，用于具有各种拓扑结构的基于芯片块">
<meta property="og:type" content="article">
<meta property="og:title" content="ZYHJY">
<meta property="og:url" content="https://zyh-eric.gitee.io/zyhjy/2023/04/12/Chiplets/">
<meta property="og:site_name" content="ZYHJY">
<meta property="og:description" content="该论文讨论了系统级芯片（SoC）的复杂性和硅成本的增加促使将SoC分解为更小的“芯片块”。基于芯片块的SoC设计过程有望通过使用先进的封装技术将多个不同的芯片（例如CPU、GPU、内存、FPGA）紧密集成到一起来实现快速的SoC构建。然而，当将芯片块组装成单个SoC时，由于芯片块之间路由的复杂性增加，会出现正确性和性能问题。该论文提出了一种模块化但无死锁的路由方法，用于具有各种拓扑结构的基于芯片块">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-04-11T16:00:00.000Z">
<meta property="article:modified_time" content="2023-07-30T10:15:18.574Z">
<meta property="article:author" content="Yuhang Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zyh-eric.gitee.io/zyhjy/2023/04/12/Chiplets/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title> | ZYHJY</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-J17VP3T2B4"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-J17VP3T2B4');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/zyhjy/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ZYHJY</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/zyhjy/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/zyhjy/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/zyhjy/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/zyhjy/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/zyhjy/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2023/04/12/Chiplets/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-12 00:00:00" itemprop="dateCreated datePublished" datetime="2023-04-12T00:00:00+08:00">2023-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:18" itemprop="dateModified" datetime="2023-07-30T18:15:18+08:00">2023-07-30</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>34 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>该论文讨论了系统级芯片（SoC）的复杂性和硅成本的增加促使将SoC分解为更小的“芯片块”。基于芯片块的SoC设计过程有望通过使用先进的封装技术将多个不同的芯片（例如CPU、GPU、内存、FPGA）紧密集成到一起来实现快速的SoC构建。然而，当将芯片块组装成单个SoC时，由于芯片块之间路由的复杂性增加，会出现正确性和性能问题。该论文提出了一种模块化但无死锁的路由方法，用于具有各种拓扑结构的基于芯片块的系统。</p>
<h1 id="introduction">INTRODUCTION</h1>
<p>在越来越复杂的工艺技术中，大型片上系统（SoC）的成本不断上升，这促使了基于“芯片”设计的SoC的出现。这个概念将传统的单片式SoC分解成几个更小的芯片，每个芯片都可以更便宜地开发，更容易在多个产品中重复使用，并使用最合适的工艺技术进行实现。芯片方法正在学术界[1]-[4]、工业界[5]-[11]和政府机构[12]中得到积极的研究
基于芯片的体系结构存在许多研究和工程挑战；我们关注其中一个具体但关键的问题。遵循模块化设计方法，每个单独的芯片都应该在不了解整个系统的情况下进行设计和验证。当从多个芯片构建SoC时，即使每个单独的组件都经过了正确的验证，完全集成的系统仍然可能存在正确性问题。互连网络特别容易受到这种影响。每个单独的芯片可能包含其自己的本地网络芯片（NoC），该NoC对于芯片内部流量是本地死锁自由且正常运行的。但是，连接多个NoC在一起可能会引入新的资源周期，从而导致跨芯片的循环依赖关系。”
虽然已经宣布了相对简单的基于芯片的体系结构[13]，或者甚至已经可用[14]，但这项工作进一步展望了基于在活动硅中间层上堆叠多个芯片的新兴体系结构（尽管我们也解释了如何将我们的方法应用于更接近的集成方法，例如被动中间层）。我们首先提供一些有关芯片的背景，并描述现有多芯片体系结构所涉及的模块化挑战。然后，我们介绍了一种新的基于芯片的路由方法，使每个芯片都可以独立设计，而不需要了解其他芯片或中间层的NoC细节，这是先前技术不支持的关键属性。我们的可组合路由方法利用了一个简单而强大的见解：从单个芯片的角度来看，整个系统可以抽象为单个虚拟节点。转向限制仅应用于连接芯片与虚拟节点之间的边界路由器，从而实现了以单个芯片为粒度的可处理分析和优化。
# II. CHIPLET-BASED SYSTEMS
“摩尔定律”和“丹纳德缩放定律”的减速使得先进工艺技术变得越来越复杂和昂贵。为了抵消缩放的减速，许多芯片变得更大，以继续在功能和性能上进行世代改进；最近的例子是使用了815平方毫米芯片的NVidia“Volta”GPU
[15]。最近，行业和政府正在追求和倡导基于“芯片组”的SoC设计概念，其中一个大型昂贵的SoC可以分解成多个较小、产量更高、成本更低的芯片组，然后使用先进的封装技术重新组装起来。这些技术包括AMD的超级计算APU愿景[6]，[10]，NVidia的MCM-GPU
[11]，TSMC的CoWoS（芯片-在-晶片-在-基板）服务，Marvell的MoChiTM（模块化芯片）架构[7]，[8]和DARPA的CHIPS项目[12]。芯片组方法还使得SoC可以结合来自不同公司的硅，例如最近宣布的Intel
Core处理器与AMD Radeon
Graphics技术[13]。计算机体系结构研究文献也反映了这些趋势，涉及使用被动硅中间层[16]、带微流控冷却的被动中间层[17]、有源硅中间层[2]、[18]和光子芯片组[3]、[4]等芯片组类似体系结构的研究。
## A. Active-interposer Chiplet SoCs
尽管当前的多芯片架构采用硅中间层[6]和多芯片模块[11]，[14]等被动集成技术，但本文展望了基于新兴活性硅中间层的芯片组SoC设计，如图1所示（我们在第VI节中探讨了其他封装技术）。尽管被动基板（仅有线而没有逻辑）[19]-[21]是近期商业关注的焦点，但越来越多的学术界[2]，[4]，[22]，工业界和政府研究机构[23]-[28]正在关注活性中间层。已经展示了一种带有3D
NoC的工作活性中间层原型[29]。
多常见的SoC功能可以移动到有源中间层，例如外部存储器接口、芯片间连接（即NoC）、外部IO和系统管理和调试（例如复位、JTAG）。这使得单个芯片可以更简单（减少设计时间）和更小（提高产量/成本）。如果芯片在更昂贵的技术节点（例如14nm）上实现，而中间层在更成熟和更便宜的工艺（例如28nm、20nm）上实现，则从更昂贵的芯片中移动逻辑到中间层可以获得额外的成本效益[2]。最近的分析得出结论，与被动硅中间层相比，有源中间层对于大型SoC来说也可以具有成本效益[30]。
## B. Baseline Assumptions
虽然我们提出的方法适用于各种可能的基于芯片的SoC，但我们专注于特定的架构作为工作示例。我们考虑了一个多芯片异构计算系统（“APU”），由CPU和GPU组件组成。图2显示了针对GPU计算进行优化的基线系统。有四个GPU芯片，每个芯片提供16个GPU
SIMD计算单元（CUs），以及一个中央CPU芯片，用于支持GPGPU工作负载的CPU阶段。这五个芯片堆叠在一个实现自己的NoC以相互连接芯片和其他常见系统功能的活动中间层上。
我们的基线配置使用网格拓扑结构来连接芯片和互连器的NoC子网络。每个GPU芯片的16个CU排列成4×4网格，互连器层也有一个4×4网格连接芯片。所有NoC组件都使用静态路由，采用路由表实现，这是当前商业系统（例如HyperTransport
[31]或QuickPath
Interconnect（QPI）[32]）的典型特征。每个芯片的本地网格和互连器网格使用X-Y路由。有关其他详细信息，例如NoC路由器配置（例如缓冲区大小，管道深度），请参见第V-A节。我们的基线提供了一个APU，其中包含64个GPU计算单元，4个CPU核心和8个外部内存通道，同时保持相对简单的结构以帮助我们的解释、评估和分析。
# 3. MOTIVATION ## A -
NoC提供了一种统一的接口，用于连接不同系统组件。与强制系统设计者在每对通信块之间实现特定接口并(更糟糕的是)验证每个接口的正确行为相比,NoC方法使得更模块化和可扩展的设计方法成为可能，这是将不同芯片连接在一起的自然选择。
- 路由可以显著影响网络性能、可靠性和功能性
。设计不良的路由算法可能会导致网络中的资源依赖关系，从而导致死锁，这可能对系统产生致命影响。我们在基于芯片片的系统中开发了一种模块化但无死锁的路由方法，该方法具有各种拓扑结构。
## B. Chiplet Composability Challenges -
对于多芯片SoC，小芯片可能来自不同的供应商[13]，即使由单个供应商提供，也可能由不同的团队独立设计。小芯片可能部署在多个产品中，包括在小芯片设计时甚至没有定义的未来产品，全局SoC路由信息可能不可用。因此，设计用于可扩展SoC或拓扑的小芯片变得极具挑战性，因为尽管每个小芯片的NoC可能是无死锁的，但它们仍然可以以在最终SoC中引入死锁的方式连接在一起。图3a显示了一个例子，其中两个4×4网状小芯片通过额外的链路连接。尽管每个单独的小芯片使用无死锁的X-Y路由，但仍然存在可能导致死锁的信道依赖性。图3b显示了一个基于两个小芯片插入器的系统，其中突出显示了一些潜在的依赖循环
-
大多数现有的无死锁路由算法都假设有完整的系统级信息可用，而这在基于小芯片的系统中并不一定有效。因此，这些方法不适用于路由可在多种SoC设计和拓扑中重复使用的模块化、独立设计的小芯片。我们解决了这个问题，并为未来SoC的模块化设计提出了一种可组合的路由算法。
## C. Deadlock Avoidance -
死锁是通过防止NoC的资源依赖关系图中的循环来避免的。有两种主要技术可以避免循环依赖：（1）<code>虚拟通道</code>（<code>VC</code>）方法[34]，以及（2）转弯模型[35]，[36]。转向模型不依赖于额外的虚拟通道来防止死锁。相反，它们对某些路径施加转向限制，以防止循环形成。在这项工作中，我们利用转弯限制来确保多芯片、基于插入器的NoC的死锁自由度，但我们引入了一种路由方法，该方法只需要在小芯片和插入器之间的“边界”处选择一些转弯限制。我们现在讨论相关工作，并在基于可重复使用的模块化小芯片的SoC的背景下解释其限制。
### VC-based Approaches -
基于VC的方法以<em>时间复用</em>的方式将物理信道划分为多个虚拟信道。每个VC都是独立管理的，并且在每个NoC路由器中都有专用的（每个VC）微片缓冲区。通过将不同的网络流分配给不相交的VC来消除循环依赖。请注意，除了避免协议级死锁所需的虚拟网络之外，还有路由死锁自由的VC。因此，对于需要复杂一致性协议的异构系统，所需的VC数量可能相当大（影响NoC路由器面积、功率等）。对于可组合的基于小芯片的系统，<em>必须预先配置VC数量，以支持最大的系统</em>，系统中的所有个体都必须为最大数量的VC实现这一点，导致小型系统的过度供应和单个小芯片的更高成本。
-
增加VC的数量会直接影响NoC路由器的面积和功率，因为每个VC都有自己的输入缓冲器，并且仲裁逻辑会随着VC的数量而扩展。从基于小芯片的系统的角度来看，单个小芯片的NoC可以设计成具有不同数量的VC，以保证死锁自由，这取决于本地拓扑和路由方案；这使得在集成多个这样的网络时设计和验证VC分配/仲裁逻辑极其复杂。为了使用VC消除死锁，设计人员需要提前了解完整的系统细节，过度配置VC，和/或限制每个小芯片和/或插入器的允许NoC。出于这些原因，我们寻求基于VC的方法的替代方案，以解决多芯片、基于插入器的SoC中的死锁。
### Flat Networks -
将整个系统作为一个平面网络，并应用统一的全局路由算法。在这种背景下，已经提出了许多拓扑不可知的路由算法。第一个这样的算法是up<em>/down</em>[37]，它使用由根节点形成的广度优先搜索（BFS）生成树。指向根的链接是上行链路，而其余的是下行链路。通过禁止消息从下行链路切换到上行链路来避免信道依赖性。上行*/下行路由需要以全局方式分析和编程所有路由表，这<strong>不允许单个芯片使用（更好的）本地路由决策。这也严重降低了系统的模块性和可组合性</strong>。我们还发现，上下路由会导致<strong>流量不平衡</strong>，因为<strong>根节点附近的链路往往比叶节点附近的更拥塞</strong>。
-
基于分段的路由将网络划分为子网，将子网划分为分段，并在每个分段内设置双向切换限制[38]。对于形成循环的起始段，除了起始路由器外，任何路由器都可以设置转弯限制；对于常规段，通过在任何路由器上设置双向转向限制来打破循环；对于仅由一条链路组成的一个路段，不允许任何流量穿过该链路（因此，在链路的一侧，必须在该链路和其他相邻链路之间设置双向转弯限制）。优化是可能的，因为转弯限制可以在一个路段内自由设置，而不依赖于其他路段。
-
Nue[39]是InfiniBand的一种基于目的地的遗忘路由实现。在网络的完全信道依赖图（CDG）的基础上，Nue构建了一个生成树，保证了死锁的自由性和连通性。然后，它使用Dijkstra算法计算从一个源节点到完整CDG中所有其他节点的最短路径，同时保持无循环约束。Nue不依赖VC来提供死锁自由，尽管额外的VC确实提高了负载平衡和性能
### ALL -
所有这些平面路由方法都需要目标SoC的全局信息来构建CDG，在CDG上可以实现死锁自由。对CDG进行全面分析的成本可能高得令人望而却步[40]。如前所述，完整的SoC配置和拓扑信息预计不可用于基于小芯片的系统（例如，小芯片可能用于未来尚未指定的SoC）。虽然我们提供了与其中几种方法的实验比较，但我们强调，这些现有方法都不能满足实现真正模块化和可重复使用的小芯片与独立优化的小芯片本地NoC的目标。
### Hierarchical Approaches: -
另一种方法是将NoC拓扑分解为几个层次结构层。在内部路由中，设计者可以自由地为单个级别选择任何现有的路由算法；并且每个节点只知道其级别内的本地节点。目的地为另一个级别的消息首先转发到连接到另一个层次结构级别的富时路由器。消息从源边界路由器指向其目的地通过其他边界路由器。分层路由的一个优点是独立分析本地网络的每一级，并且可以应用局部最优路由算法。然而，正如我们前面所讨论的，当<strong>将单个网络组合在一起时，全局网络仍然可能出现死锁</strong>。因此，必须小心避免全局死锁，这通常会导致对所有可能的全局路由路径进行逐案分析[41]，[42]。先前的工作提出了基于规则拓扑（如总线、环形、网格和树）的分层NoC[42]-[44]。然而，<strong>来自不同制造商的小芯片可能没有使用规则NoC进行设计，并且集成SoC系统可能不是对称的</strong>。因此，系统级的死锁避免仍然需要付出很大的努力，而且很容易出错。
## D. Comparison of Modularity -
虽然“模块化”可能有很多可能的定义，但我们将重点放在表I中列出的关键属性上。
- Table I: Comparison of deadlock avoidance approaches</p>
<table style="width:100%;">
<colgroup>
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>Independently Designed Chiplets</th>
<th>Enables Local Op-timization</th>
<th>Global CDG</th>
<th>Not Required Future-proof Chiplets</th>
<th>HW Cost</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>VC-based</td>
<td>-</td>
<td>++</td>
<td>+</td>
<td>-</td>
<td>High</td>
</tr>
<tr class="even">
<td>Flat NoCs</td>
<td>--</td>
<td>-</td>
<td>--</td>
<td>-</td>
<td>Low</td>
</tr>
<tr class="odd">
<td>Hierarchical</td>
<td>-</td>
<td>+</td>
<td>-</td>
<td>--</td>
<td>Low</td>
</tr>
<tr class="even">
<td>Composable(this work)</td>
<td>+</td>
<td>++</td>
<td>++</td>
<td>++</td>
<td>Low</td>
</tr>
</tbody>
</table>
<h3 id="independently-designed-chiplets">Independently Designed
Chiplets:</h3>
<ul>
<li>单个芯片的架构师应该能够设计和优化他们的本地NoC，而对整个SoC的其余部分知之甚少。基于VC的方法要求小芯片架构要么拥有整个SoC组织的信息（小芯片设计不再独立），要么过度提供VC的数量，以支持所有可能使用小芯片的SoC。扁平和分层的NoC通常也需要完整的SoC信息来分析和确保锁定自由
### Enables Local Optimization</li>
<li>模块化设计方法应允许小芯片架构师在独立于最终SoC组织的情况下局部优化一个chiplet的NoC。扁平化方法需要全局SoC信息，因此影响本地拓扑、路由算法、负载平衡等的芯片内优化，不能孤立地进行。分层NoC确实实现了一定程度的局部小芯片级优化，尽管这可能仍然受到完整CDG的全局分析的限制，以消除死锁。基于VC的方法以及本文提出的可组合方案有效地允许任意小芯片级别的NoC组织和优化
### Global CDG Not Required</li>
<li>平面和分层的NoC不是模块化的，因为构建依赖图需要所有通道的连接，并且在所有小芯片网络最终确定之前无法执行路由分配。在不影响全局路由决策的情况下优化本地NoC也是极其困难的，因为修改本地网络会改变全局CDG。基于VC的方法在局部优化方面提供了更大的灵活性，并且不需要全局CDG；他们需要一些全局信息来分配VC。我们的可组合方法要求与SoC集成商共享关于小芯片的一些有限信息（但远低于全套信道依赖性），并要求在独立的小芯片设计之间共享节点依赖性信息。
### Future-proof Chiplets</li>
<li>一个小芯片可能会集成到未来尚未设计的SoC中。由于扁平化和分层NoC方法需要全局CDG，小芯片将很难重复使用，因为本地NoC设计和优化可能已经固定。基于风险投资的方法可能会更好，但为尚未考虑的SoC过度提供风险投资可能会很昂贵。我们的可组合方法将与到/从中介器到SoC设计时间的流量相关的NoC决策延迟绑定（与设计小芯片时相反），从而在新的SoC组织中部署小芯片所需的效率和返工最少
### Hardware Cost:</li>
<li>除了基于VC的设计外，其他方法修改不同NoC组件的路由表，因此硬件开销很小。对于基于VC的方法，特别是如果需要为未来的系统进行超额配置，则支持更多VC的区域影响可能会相对昂贵。</li>
</ul>
<h1 id="iv.-multi-chiplet-routing">IV. MULTI-CHIPLET ROUTING</h1>
<p>在本节中，我们为芯片组系统提出了一种可组合、拓扑无关、无死锁的路由方法。关键的洞察力是简单而强大的：从任何单个芯片的角度来看，整个系统（与其他芯片的总数或中间层复杂性无关）都可以抽象成一个单一的虚拟节点，这使得在芯片粒度上进行可处理性分析、优化和正确性成为可能。我们详细介绍了一种基于芯片的路由具体方法，但这只是我们的关键洞察力所能实现的一种可能解决方案。
## A. Overview - Before describing our methodology, we define some
terms. ### 定义1： -
芯片组的边界路由器通过边界链路将芯片组连接到中间层。从中间层到芯片组的流量称为入站流量；从芯片组到中间层的流量称为出站流量。
### 定义2： -
边界路由器b的入站可达性InR(b)是从中间层通过路由器b可以到达的芯片上路由器的比例；0
&lt; <em>InR(b)</em> ≤ 1。 ### 定义3： -
边界路由器b的出站可达性OutR(b)是可以通过路由器b到达中间层的芯片上路由器的比例；0
&lt; <em>OutR(b)</em> ≤ 1。 ### 定义4： -
<em>InD(r)</em>是芯片路由器r的入站距离，是从最近的可以到达r的边界路由器到路由器r的拓扑距离。
### 定义5： -
芯片上路由器r的出站距离<em>OutD(r)</em>是从r到其最近可达边界路由器的拓扑距离。</p>
<p>这段话是在讨论可组合路由方法的目标。该方法的目标是尽可能地隔离单个芯片和中间层的设计，允许对每个芯片和中间层进行独立的负载平衡优化，同时为整个系统提供无死锁路由。</p>
<p>具体来说，我们在每个芯片上的边界路由器上放置单向转向限制。当应用转向限制时，系统的其余部分被抽象为一个与所有边界路由器相连的单个节点。转向限制确定了每个边界路由器的入站和出站可达性，并保证每个芯片内不存在循环通道依赖关系。然后，可达性信息传播到中间层，中间层负责将消息从一个边界路由器路由到另一个边界路由器。有了边界路由器可达性的知识，消息就会被转发到正确的目标芯片。一旦消息到达目标边界路由器，本地芯片NoC将把消息路由到其最终目的地。这种分层方法使用两组路由表来为每个芯片提供服务。第一组表用于在同一芯片内本地路由消息（这是常规的芯片内部路由），而第二组表则将出站消息引导到适当的边界路由器。本节末提供了更多实现细节。与第一条路由表（芯片内部）相对应的路由决策可以完全独立于系统的其余部分进行，这可能甚至尚未定义。
## B. Chiplet Design Guidelines
在设计芯片级NoC时，边界路由器的数量和位置是两个关键的设计参数，它们可以影响整个系统的性能。这些与芯片和中介器之间的垂直（微颗粒）链接数量有关
### Number of Boundary Routers: -
边界路由器的数量决定了芯片可以维持发送/接收离片流量的吞吐量；边界路由器越多，离片流量带宽就越高。一个极端情况是将芯片上的每个路由器都连接到中介器上，使每个路由器都成为边界路由器，这是先前其他人考虑过的[2]，[22]。然而，这样的设计可能会超额配置预期的离片流量，并可能受到可用微颗粒密度的限制。
-
在确定每个芯片的边界路由器数量时，一个关键观察是，虽然可能的边界路由器最大数量是芯片面积的函数，但最大有用带宽是其周长的函数。对于一个n×n网格的芯片，我们已经分析确定，在本文考虑的中介器拓扑结构下，n个边界路由器就足够了（为简洁起见，完整分析被省略）。对于我们大多数实验中假定的4×4芯片，我们每个芯片使用四个边界路由器。虽然我们专注于网格，但我们的方法适用于其他拓扑结构（请参见第VI节）。
### Turn Restrictions at Boundary Routers -
图3中的简单示例表明，通过中介器、其他芯片等，可能存在大量潜在的依赖循环，导致需要分析的可能路径数量爆炸。为了使单个芯片级别的路由决策成为可能，并使芯片间依赖分析可行，我们将系统的其余部分抽象为单个节点，并将所有边界路由器连接到抽象节点上（图4）。与之前的工作不同，这种新颖的抽象步骤是实现芯片独立设计的关键，而不需要全局CDG信息。
-
我们使用转向限制来打破包含抽象节点和一对边界路由器的循环。抽象节点代表单个芯片设计者不需要了解的系统的其余部分，因此<strong>转向限制不适用于抽象节点</strong>。在为边界路由器选择禁止转向时，必须保持连通性（即，每个芯片路由器到抽象节点之间必须存在路径，反之亦然），因此<strong>禁止导致断开NoC的转向限制</strong>。
-
在保持连通性的同时打破所有循环足以确保与该芯片相关的操作的正确性。但是，为了性能原因，仍然需要仔细选择转向限制和路由。可以采用不同的启发式方法；我们描述了一种在实践中表现良好的可能方法。我们考虑负载平衡的入站和出站可达性。不平衡的入站或出站可达性可能会导致芯片和/或中介器拥塞。同时，所有芯片路由器的入站和出站距离的平均值应该最小化，因为当路由到芯片外时，如果消息有多个边界路由器候选，则首选最近的边界路由器。总体而言，在选择禁止转向时，我们的目标是最小化平均距离/平均可达性，其中距离和可达性在第IV-A节中定义，并且平均值是在所有芯片上计算的。具体而言，平均距离是芯片上所有路由器的入站和出站距离的平均值。平均可达性类似地计算每个边界路由器的入站和出站可达性。我们的启发式方法选择具有较低平均距离和较高平均可达性的组合。
-
为了可视化指标，图4给出了一个4×4网格的示例，其中有3个边界路由器a、b和c；其余的系统用x表示。假设本地芯片NoC采用X-Y路由，禁止转弯的箭头在边界路由器处被划掉。包含x和任意一对边界路由器的循环通过禁止某些转弯来打破。
在此示例中，a 的入站可达性 (InR(a)) 为
1/2，因为其入站转向限制与小芯片的本地 X-Y
路由相结合，使得小芯片的左半部分无法从节点 x 通过 a 到达。
由于a没有出站转向限制，其出站可达性OutR(a)为1，即每台路由器都可以通过a到达x。
x → a → c → x 的环路在 c 处因出站转弯限制而中断，导致 OutR(c) = 1/2。
或者，不是在路由器 c 处断开环路，而是可以在路由器 a 处放置入站转弯限制 x
→ a → (3, 3) 以断开相同的环路，为此 InR(a) 变为 1/4（仅列 编号 2
可通过路由器 a
到达，因为两个单独的入站转弯限制用于打破两个不同的环路），并且 OutR©
变为 1。 路由器 m 的入站距离为 3，从边界路由器 b 测量； 出站距离为 3，到
a 或 b。 同样，从路由器c测得的路由器InD(n)=1； OutD(n) = 2 到路由器 a。
虽然此示例出于说明目的有些特别，但我们提供了一个具体的算法来确定下面的所有这些。
### Boundary Router Placement -
给定一个内部芯片级路由算法，边界路由器的选择会影响它们的入站和出站可达性以及芯片上的流量分布。我们提出了以下选择边界路由器的准则。
首先，避免将边界路由器聚集在一起，以减少创建网络热点的机会。
其次，应该以一种使所有边界路由器的入站/出站可达性保持平衡的方式放置边界路由器。
第三，更喜欢具有较低基数的路由器。
前两个准则旨在优化网络性能和吞吐量。第三个准则旨在最小化电路复杂性。例如，在图4中，芯片中间的四个路由器每个都有五个端口（四个连接到相邻路由器，第五个连接到它连接的网络端点，例如GPU
CU）。向其中一个“内部”路由器添加垂直链接将强制该路由器实现六个端口，这会增加面积并可能影响电路时序。但是，向芯片边缘上的任何一个路由器添加垂直链接都可以使所有路由器继续具有五个或更少的端口。
### Boundary Router Placement and Turn Restriction Algorithm - 算法1
确定每个芯片的边界路由器位置和转向限制。
PlaceBoundaryRouter通过调用SetTurns迭代所有边界路由器位置，以查找更好的位置和转向限制。
对于每个放置，函数identifyAllBoundaryTurns枚举所有可能的边界转弯并将它们存储在列表bturn
[]中。另一个列表pturn
[]存储禁止的边界转弯，这在SetTurns中递归更新。变量max是消除所有死锁所需的最大禁止边界转弯数。
- 过程 SetTurns
使用启发式方法检查所有边界转弯组合，如果当前限制改进了用户指定的目标函数，则更新迄今为止找到的最佳位置。
我们使用 CDG [39]、[45] 的矩阵表示。 最初，允许所有边界转弯。
更新函数（第 16 行）使用 Floyd Warshall 全对最短路径算法 [46]
传播到整个图的通道连接的禁止边界转弯列表 pt[] 更新 CDG。
这提供了来自更新的 CDG 的连接信息、边界路由器可达性和跳数。
下一步检查用户指定的目标函数是否得到改进（第 17 行）。 在第 19
行，connected 函数检查 CDG
是否仍然连接，因为任何导致网络断开的转向限制都应该被丢弃。
如果图是连通的，hasLoop
会检测入站通道（从抽象节点到边界路由器）是否连接到出站通道（从边界路由器到抽象节点）。
如果没有找到循环，则在第 22 行更新最佳位置，递归终止。 第 24
行控制递归的深度，因为只需要一定数量的边界限制就可以消除死锁。 如果 CDG
已连接但循环仍然存在，则第 27-29 行调用对 SetTurns
的递归调用以根据需要添加更多转弯限制。 ## C. Interposer NoC
Configuration -
确定了芯片的进出转向限制后，我们现在解释如何编程中继器的路由表。请注意，当单独考虑中继器网络（不包括芯片）时，中继器网络本身也应该是无死锁的。中继器负责将消息从一个边界路由器路由到另一个边界路由器。为此，必须向中继器提供某些芯片级别的信息。
首先，我们需要知道每个单独边界路由器可达的芯片节点（终端节点）。我们使用这个来确保消息从可以到达目的地的芯片边界路由器路由。其次，我们可以选择使用每个边界路由器和其可达芯片节点之间的拓扑距离来优化路由距离和负载平衡。请注意，这些信息可以简单地以“列表”格式列出（例如，节点x可以从边界节点y到达）；不需要芯片的本地NoC的完整细节（例如，网络的拓扑和请求如何从y到x的路由决策），并且这些信息独立于interposer和任何其他芯片。
我们现在描述我们的互连路由方案。对于每个目标路由器的消息，以下算法决定将该消息发送到目标芯片的哪个边界路由器。如果目标只能通过单个边界路由器到达，则中间件必须将消息路由到该特定边界路由器。否则，我们选择边界路由器以在边界路由器之间平衡网络负载（平均利用芯片-中间件带宽），同时最小化路径长度（避免发送消息在高度迂回的情况下只是为了负载平衡）。下面，我们正式指定算法。
- 对于给定的边界路由器i，仅由i可到达的节点集合称为Ai。 -
对于可以被多个边界路由器到达的其余节点，列表Ci包含所有节点，这些节点在拓扑上比任何其他边界路由器更接近i。对于不同的边界路由器j和k，Cj∩Ck=∅。
-
剩余的节点与至少两个边界路由器等距。设Ei，j是同时等距于边界路由器i和j的节点列表。虽然可能等距于两个以上的边界路由器，但为简单起见，我们仅考虑两个路由器的情况。
• 执行以下步骤将芯片上的节点分配给边界路由器。 -
第1步。在所有边界路由器中，选择具有Ai中最小项目数的路由器i。 -
第2步。逐个将Ci中的节点分配给Ai，直到Ai中的项目数不再是最小值。将项目分配给Ai时，从Ci中删除该项。如果Ai仍然具有最小数量的项目，则逐个从Ei，j中分配节点到Ai。将项目分配给Ai后，从Ei，j和Ej，i中删除该项。
-
第3步。如果无法进行进一步分配，则完成对边界路由器i的节点分配。重复步骤1-3，直到Ci
= ∅且Ei，j = ∅对于所有边界路由器i和j。
完成后，每个边界路由器的节点分配信息都存储在Ai中。通过参考这些信息，配置相应的中间层路由表。系统集成商可以自由选择任何对于中间层网络来说是死锁自由的底层路由算法。
- 考虑图4中的示例。对于边界路由器a、b和c，Aa = {(2, 0),(2, 1),(2, 2),
a}，Ab = {(0, 0),(0, 1), m,(0, 3), b,(1, 1),(1, 2),(1, 3)}，Ac = ∅；Ca =
{(3, 3)}，Cb = ∅，Cc = {(3, 0), c,
n}。在这个网络中没有等距集。节点分配从边界路由器c开始，因为Ac为空。Cc中的所有元素都分配给Ac，Ac
= {(3, 0), c,
n}。对于c，不能进行进一步的分配，因此算法选择下一个路由器a。Ca中唯一的元素被分配给Aa，Aa
= {(2, 0),(2, 1),(2, 2), a,(3,
3)}。到目前为止，每个芯片上的节点都被分配给了一个边界路由器；这些分配存储在Aa、Ab和Ac中。有了上述信息，互连器就能将消息路由到正确的边界路由器（a、b或c），如果消息是发送到该芯片的话。
## D. Deadlock Freedom and Connectivity -
现在我们展示可组合路由方案是无死锁且连通的。假设存在一个循环r1，l1，r2，l2，…，rn，ln，其中r表示路由器，l是连接到r的链接。如果所有路由器和链接都属于同一个芯片，则与基本假设芯片级网络无死锁相矛盾。否则，如果循环的子集属于插板和其他芯片，则可以用单个节点x来抽象这个子集。因此，该循环转换为r1，l1，…，rj，x，rk，lk，…，rn，ln。因为删除了包含x的循环中的所有循环依赖项，所以新循环是无死锁的。因此，可组合路由方案是无死锁的。
-
单个芯片内的任何网络都是连接的，因为边界路由器转向限制不影响内部芯片网络。芯片上的任何节点都能通过至少一个边界路由器到达中间层。中间层网络是通过构造连接的（即，每个中间层路由器都可以到达其他中间层路由器）。对于任何一对芯片节点，都存在一条路径。因此，该系统是连接的。
## E. Microarchitectural Issues -
每个芯片需要实现两个不同的路由表。第一个处理从不到达互连器的芯片内部流量。这个路由表可以以芯片设计者认为合适的任何方式填充。第二个路由表将出站流量定向到适当的边界路由器。这种组织方式假定整个系统中所有路由器端点都有全局ID空间。类似于用于检测系统中所有内存和计算资源（特别是在多插槽SMP系统中）的引导序列，可组合的基于互连器的SoC需要一个类似的系统配置协议。这个过程的一部分将是检测可用的NoC端点，为每个端点分配唯一ID，并计算和填充次级路由表。与系统引导不同，这个过程只会由SoC集成器在物理组装SoC后执行一次（尽管也可以提供钩子以在以后的某个时间点更新表，例如处理失败的链接[32]）
-
在我们的设计中，每个网络接口（NI）都有一个查找表，将出站数据包的目标ID映射到边界路由器ID。然后将边界路由器ID嵌入标题flit中，并用于芯片内路由，直到数据包离开芯片。关于面积/功率开销，每个NI中的查找表需要针对给定产品的最大系统大小进行配置。路由表通常比其他路由器组件（如缓冲区和交叉点）小得多。此外，每个芯片中第二个路由表的大小仅与边界路由器的数量成比例；因此，它比第一个路由表小得多。有几种实现互连路由器的方法：1）为最大系统大小提供路由表，导致相对较大的互连路由表；或2）添加另一层目标映射以将目标ID转换为目标边界路由器ID，导致更小的路由表但更复杂的边界路由器。总体而言，与规范的两级路由器相比，我们的设计不应产生显着的额外功率/面积/时间影响。
# V. EVALUATION ## A. Experimental Methodology -
为了评估网络性能，我们使用由 gem5 [47] 和 GPU 模型 [48] 的修改版本组成的
APU 模拟平台进行周期级执行驱动模拟。 我们使用 Garnet [49]
来模拟使用每通道 4-flit 缓冲区的 2 级路由器的网络。 我们的初始实验使用图
2 所示的多芯片 APU 配置，包括四个 GPU 芯片、一个 CPU
芯片和一个有源中介层。 CPU chiplet 由 CPU 内核、专用 CPU L1 和 L2
缓存以及末级缓存组成。 每个 GPU 小芯片由 16 个计算单元 (CU) 和 8 个 GPU
L2 缓存组组成。 我们的内存模型使用内置的 gem5 模型
[50]，每个通道有八个内存通道和八个存储体。 图 2 还显示了由我们的算法从第
IV 节确定的边界节点的位置。 -
我们同时使用合成流量和基于应用程序的模拟。对于合成流量，每个数据包宽度为8个flits，并且网络模拟了200万个周期。对于系统级（非合成）模拟，我们使用AMD
SDK [51]、Rodinia [52]和Pannotia
[53]套件中的APU应用程序，其中芯片外通信包括GPU
CUs之间的缓存一致性和到主存储器的流量。 ## B. Comparison Points -
即使从定性上看，基于VC的方法是昂贵且不太吸引人的，但为了完整性，我们提供了一个比较。使用与EbDa
[40]类似的方法，我们实现了一个支持最小路径自适应路由的VC-based死锁避免机制：对于单个2D网格，需要两个VC来避免死锁；通过在芯片和interposer之间引入垂直连接，需要两个更多的VC来隔离入站和出站流量。我们还实现了第III-C节中描述的三种全局路由算法：up<em>/down</em>
[37]、基于段[38]和Nue路由[39]。请注意，所有三种算法都需要完整的CDG知识，并且不支持独立设计和芯片复用。我们将其与之进行比较作为我们所知道的最相关的工作，但它们无法满足我们的关键芯片模块化标准。
-
在应用转向限制之前，通过找到与所有其他节点的平均距离最小的节点来选择上<em>/下</em>路由中的根节点。基于段的路由中的起始段是从系统的左上角（左上GPU芯片的左上路由器）形成的。在我们的可组合路由方案中，本地芯片算法和互连器算法都使用维度排序路由。为了与基于VC的方法进行公平比较，我们为每个基于转向的方案提供了四个VC。
-
我们还将我们的结果与理想化系统（表示为最短路径）进行比较，该系统使用不切实际的大量虚拟通道来避免死锁。
路由表是使用全对最短路径 (APSP)
算法配置的（与现有技术和我们自己提出的一些路由可能不是最短的方案形成对比）。
请注意，这个理想化的系统不一定能提供真正的最佳性能，因为 APSP
仍然会导致某些链路中的拥塞程度高于其他链路。
然而在实践中，我们发现这种最短路径配置通常优于实际的替代方案，因此它提供了一个乐观的性能目标来进行比较。</p>
<h2
id="c.-basic-throughput-evaluations-with-synthetic-traffic-使用合成流量进行基本吞吐量评估">C.
Basic Throughput Evaluations with Synthetic Traffic
使用合成流量进行基本吞吐量评估</h2>
<ul>
<li>在本节中，我们评估了一个由四个芯片组成的64-CU系统，每个芯片组由16个CU组成，组织为4×4网格。每个芯片组通过四个边界路由器连接到中间层。中间层网络是4×4网格。</li>
<li>图5a和图5b显示了均匀随机和位补码流量下的负载延迟曲线。我们观察到，许多异构多芯片工作负载与均匀随机流量相似：实际系统具有混合的芯片内、芯片间、芯片到互连器和芯片到内存的流量，涵盖了一致性和主存储器请求和响应；这些在总体上“平均”，使得均匀随机流量的高级性能趋势与我们的几项应用驱动研究大致相符。位补码流量模式强制所有数据包离开芯片，因此进一步加重了互连器的压力并创建了网络热点。我们运行了其他合成流量模式，但总体趋势非常相似，因此没有显示。</li>
<li>我们的可组合方案优于up<em>/down</em>、基于段的和VC-based方法。在相同数量的虚拟通道下，可组合方案的性能优于VC-based方法，主要是因为额外的虚拟通道减少了头阻塞。典型的一致性协议需要3-5个虚拟网络，每个虚拟网络都需要四个VC以实现死锁自由。异构架构的一致性协议可能需要更多的虚拟网络，使得VC-based方法变得更加昂贵。虽然VC-based方法需要每个虚拟网络四个VC以实现正确性，但是由于VC-based和可组合方案之间的性能差距，需要更多的VC以实现更好的性能。</li>
<li>基于段的路由在零负载延迟方面存在问题，并且具有最低的饱和吞吐量。这主要是因为它是为2D网格状网络设计和优化的。虽然评估系统由多个网格网络组成，但全局拓扑结构仍然不规则，因此基于段的路由无法有效处理它。基线基于段的算法并不总是形成最优段；从边界路由器向中间件开始的段可能会绕到同一芯片上的路由器上结束，或者通过另一个芯片跨越多个跳跃，直到到达属于现有段的路由器。这样的链式段在较大的系统中可能非常长，并且在段内断开任何双向转弯将导致更多的非最小路径（对于基线APU，我们观察到平均路由距离近11个跳跃，而其他方法则为∼8个跳跃）。虽然拓扑感知优化可能会改善基于段的路由性能，但这超出了本文的范围。¹</li>
<li>上行<em>/下行</em>
路由具有低零负载延迟，这表明消息可能会在评估系统中采用最少的路由。
然而，与其他方法相比，它相对较早地饱和。
根节点附近的链路本质上比叶节点附近的链路更拥塞。
当注入率增加时，这些环节会饱和并成为瓶颈。 Nue
路由优于我们的可组合方法，但这只是因为它具有利用完整 CDG
知识优化其路由的优势，从而导致与理想的最短路径算法类似的行为。
有了足够的
VC（我们为其提供），它会找到优化的路径来平衡网络工作负载。</li>
<li>我们的组合方案优于up<em>/down和基于段的路由，因为芯片和互连网络更加负载平衡，芯片和互连器之间的垂直链接也是如此。Nue提供更好的负载平衡，因此表现接近理想的最短路径路由，但与其他先前的工作一样，它不适用于独立设计和重用芯片以进行模块化SoC构建。与理想的最短路径路由相比，我们的方案覆盖了从up/down</em>到理想化最短路径路由的吞吐量差距的大部分，但仍然存在一些余地。这是因为1）由于转向限制而仍然存在一些负载不平衡，以及2）理想化网络具有更多的虚拟通道以改善头部阻塞。总体而言，尽管我们提出的方法没有实现全局负载平衡优化的全部性能，但我们的结果表明，我们的方案确保了正确性，并提供了高性能的多芯片SoC，它独特地实现了一种模块化芯片设计方法论，不需要对整个系统的CDG有先验知识。
## D. Application-level Impact ### Network Latency:
我们使用执行驱动模拟对非合成工作负载评估了我们的可组合路由方案。图6a显示了平均网络延迟，归一化为理想的最短路径方法。基于段的路由未显示，因为在给定的系统大小下，它始终表现出色并且明显优于其余方法。我们省略了基于VC的方案，因为评估的异构系统需要大量的VC才能避免路由和协议级死锁，同时保持性能。总体而言，我们的可组合方法实现的网络延迟几乎与最短路径相同。在一些情况下（bfs、nw、srad），可组合路由比最短路径表现略好；正如前面所讨论的，最短路径并不是真正的最优解，有时会出现局部流量突发（这种情况在GPU工作负载中比传统CPU应用程序更常见），会导致最短路径配置中的拥塞/负载不平衡。
由于根节点在高负载下成为瓶颈，因此上下行方法的大多数基准测试的平均网络延迟增加了50%以上，如第V-C节所讨论的。这种瓶颈限制了系统的有效带宽，并导致了显着的网络缓冲延迟。
### Application Performance:
图6b显示了程序执行时间，归一化为理想的最短路径方法。总体而言，可组合路由与最短路径相比实现了类似（在1%以内）的系统性能。虽然APU/GPGPU应用程序会生成大量的NoC/内存流量（这对于压力网络来说非常好），但对应用程序执行时间的总体影响却很小，因为大多数GPU应用程序本质上对延迟不太敏感（即，丰富的SIMD并行性可以更容易地容忍增加的延迟）。虽然有流量突发，但应用程序的大部分部分不会使NoC接近饱和，因此对总执行时间的影响较小。尽管如此，我们仍然观察到一些工作负载使用up<em>/down</em>路由时性能下降了5-10%，而我们的方法在大约与最短路径方法相同的水平上执行。
### Case Study – HotSpot:
图7显示了执行HotSpot时最常用的链接的最大链接利用率。仅显示了互连网络和GPU芯片上的边界路由器，因为其余部分利用率较低。对于每个10000个周期，我们对每个链接的利用率进行了采样。链接的最大利用率是整个程序执行过程中观察到的最大采样结果。最大链接利用率向我们展示了在突发流量行为下最糟糕的链接拥塞发生在哪里，从而使我们能够可视化全局网络流量并定位任何NoC瓶颈。一般来说，可组合路由比最短路径具有更少的拥塞链接。但是，前者在互连器上具有略微不平衡的流量分布，这表明最大链接利用率更大。这是由于转向限制偏向边界路由器的可达性（即，某些边界路由器接收更多流量）。对于上<em>/下</em>路由，根节点位于互连器上。如预期所示，靠近根节点的链接比其他链接更加利用。
# VI. BROADER APPLICABILITY 更广泛的适用性
前一节展示了我们方法在一个特定的芯片组SoC上的有效性。在本节中，我们提供了额外的实验结果，因为各种系统假设被修改，然后我们还讨论了如何将该提议应用于没有活动互连器的芯片组系统。
## A. Design Guideline Justification 设计指南的证明
在第IV-B节中，我们描述了如何确定边界路由器的数量、选择转向限制的目标函数以及边界路由器的放置。为了证明所提出的指南的有效性，我们使用均匀随机流量评估了其他设计方案。图8a显示了从2个边界路由器增加到8个路由器时吞吐量的提高。在所有情况下，互连网络保持相同的大小；当有8个边界路由器时，2个边界路由器集中到一个互连路由器上，这增加了路由器的复杂性和面积。从4个边界路由器到8个边界路由器的改进要比从2个边界路由器到4个边界路由器的改进小得多。不足的边界路由器可能会影响系统吞吐量。通过提供更多的边界路由器，可以增加芯片外带宽，从而减少与芯片内通信的干扰。在16个边界路由器的极端情况下，每个芯片路由器都有一个垂直连接，与芯片外通信不会影响芯片内通信/拥塞。然而，这样的设计是不切实际的，因为需要大量垂直线。总体而言，在性能和硬件成本方面，4个边界路由器是一个合理的设计选择。
图8b比较了不同目标函数的系统吞吐量，包括最小化平均距离、最大化平均可达性和我们提出的度量（即最小化平均距离/平均可达性）。结果表明，我们提出的目标函数是有效的，并且与其他度量相比提供了最佳性能。仅考虑平均距离或平均可达性往往会创建不平衡的芯片内流量。
在某些情况下，设计者可能没有自由选择边界路由器放置位置的自由（例如，布局限制，物理设计约束）。图8c考虑了边界路由器位置已移动到较不理想的位置（例如，聚集在一起），分散到角落，位于同一行（即与我们的方法分配给它们的位置不同）。我们重新运行了确定转向限制的算法。结果表明，边界路由器的随机放置最终导致某些链接被使用得比其他链接更多，从而影响了系统吞吐量，但死锁自由仍然得以保持。
## B. Sensitivity Studies 我们考虑了以下基线的变体：
系统规模：基线具有4个GPU芯片，每个芯片有16个CU，总计算能力为64个CU。我们还考虑了两种128-CU配置（CPU数量保持不变），分别由（1）每个芯片32个CU的4个芯片和（2）每个芯片16个CU的8个芯片组成。在这两种情况下，每个芯片仍然有四个边界路由器。
Interposer
NoC拓扑结构：为了支持这一论点，即中介器的NoC可以独立于芯片设计，我们评估了基线系统，但将中介器的网状NoC替换为“双蝴蝶”拓扑结构[22]
不规则芯片拓扑结构：为了支持芯片的NoC拓扑结构可以独立设计的类似主张，我们评估了一个系统，其中每个GPU芯片都实现了一个不同的本地NoC拓扑结构，包括网格、环、蝴蝶和树形拓扑结构
结果：本节中的分析仅呈现了均匀随机流量的负载延迟曲线。我们也进行了应用程序级别的实验，但总体趋势非常一致，因此我们由于空间原因和重复性而省略了这些附加图形。这些实验的主要目的是证明我们的提议是一种在广泛的基于芯片组的系统可能性范围内实现高性能并确保死锁自由的强大方法。
图9a和b显示了更大的128-CU配置的结果，我们的组合方法轻松地优于上/下路由。这两个配置之间的主要区别是芯片内和芯片间流量的比例。与最短路径相比，我们的组合方法对流量分布不太敏感，因为具有更好的芯片级和互连器级负载平衡。”
的中文翻译是：“图9a和b显示了更大的128-CU配置的结果，我们的组合方法轻松地优于上/下路由。这两个配置之间的主要区别是芯片内和芯片间流量的比例。与最短路径相比，我们的组合方法对流量分布不太敏感，因为具有更好的芯片级和互连器级负载平衡。
图9c显示了当插层NoC具有蝴蝶式拓扑结构时的结果。结果与网格的基准系统类似，总体上这有助于证明可以轻松地独立设计单个芯片，而不受插层NoC拓扑结构的影响。
图9d显示了当每个GPU芯片组具有不同的本地NoC拓扑时的结果。这里的结果更有趣，因为我们的提议导致的饱和吞吐量比具有丰富虚拟通道和最短路径路由的“理想”情况更高。这是因为在处理芯片间通信时，最短路径会偏向于靠近互连器中心的边界路由器，而我们的提议方法实现了更好的互连器流量分布。”
的中文翻译是
“图9d显示了当每个GPU芯片组具有不同的本地NoC拓扑时的结果。这里的结果更有趣，因为我们的提议导致的饱和吞吐量比具有丰富虚拟通道和最短路径路由的“理想”情况更高。这是因为在处理芯片间通信时，最短路径会偏向于靠近互连器中心的边界路由器，而我们的提议方法实现了更好的互连器流量分布。
## C. Other Chiplet Packaging Options
到目前为止，我们的研究集中在基于新兴活性硅中间层技术构建的芯片组系统上。虽然活性硅中间层可能是实用的，特别是如果可以将用于逻辑的总中间层面积最小化[2]，[30]，但近期芯片组系统可能会受到被动基板的限制。无论是使用被动硅中间层[19]-[21]还是更传统的封装基板[7]，[11]，[14]，[54]，一个可能的担忧是芯片组下方缺乏活性层可能会限制我们方法的适用性。
图10a显示了一个在被动基板上具有芯片的示例系统。此布局假定提供了常见功能的中央芯片（否则将放置在活动互连器上，例如内存控制器、NoC、系统管理），计算芯片以星形拓扑结构从中央芯片向外扩展。使用这种类型的布局，我们的建议方法可以直接应用于此系统，无需进行任何修改，方法是将中央芯片与我们之前的工作示例中的活动互连器相同对待。选择最佳边界节点放置的过程可以更有效，因为芯片上可供选择的合理节点较少（即最靠近中央芯片的节点）。
## D. Other Chiplet Topologies
即使对于非星型拓扑的芯片，他们的方法也可以进行适应。图10b显示了一个基于芯片的系统，其中两个CPU芯片具有额外的点对点链接（例如，用于低延迟高速缓存一致性），这些链接不通过中央芯片进行路由。为了支持这一点，这两个CPU芯片被有效地视为单个虚拟芯片，以应用他们的方法来确定路由限制。仍然需要CPU芯片设计人员确保两个CPU芯片之间的直接路由是正确的（即无死锁），但设计人员无需担心从/到中央芯片进入/离开任一芯片的流量，因为他们的方法确定适当的转向限制以确保整个SoC的正常运行。
同样，图10c显示了一个没有单个“中央”芯片的系统，而是有两个芯片连接到其他芯片。在这里，我们应用了类似的技术，其中两个芯片被视为单个虚拟芯片，以便于此方法。与上面的两个CPU芯片示例类似，SoC设计人员必须确保一对芯片是相互/本地死锁自由的，但是任何剩余的与其他芯片的连接都将得到正确处理。大多数合理的芯片拓扑都可以迭代地合并，直到将拓扑转换为类似星形的组织为止，此时我们的方法可以直接应用。
# VII. RELATED WORK
平面网络：在第III-C节中，我们介绍了一种避免死锁的平面网络方法。对up<em>/down</em>路由的进一步优化已被提出：Koibuchi等人基于BFS生成树构建了一个从左到右的有向图，并在根节点周围分配流量[55]；Sancho等人使用深度优先搜索（DFS）生成树[56]；他们通过在每个周期中单独删除每个方向上的通道依赖关系来改善流量平衡[57]。
分层网络：HiRA
[41]是一种用于分层NoC中无死锁路由的方法。在HiRA中，网络被划分为子网（具有独立无死锁路由算法的网络）和外部链接（子网之间的链接）。通过在每个子网中选择安全边界节点并在边界节点上应用转向限制来避免死锁。当连接到其他子网时，如果边界节点不会发生死锁并且可以保证连通性而不修改子网的内部路由算法，则边界节点是安全的。在应用边界节点上的转向限制时，使用包含所有边界节点的CDG。虽然HiRA可应用于具有被动互连器的芯片组系统，但对于两个主要原因，它不适用于主动互连器SoC。首先，仍需要系统级CDG，并且转向限制在很大程度上取决于子网路由算法。其次，HiRA缺乏中央网络（即主动互连器）的路由算法，该网络连接到所有芯片组。
“3D NoC中的路由：常规3D
NoC的死锁避免技术包括DoR和基于转向的路由[35]，[58] -
[60]和基于VC的方法[61] -
[63]。其中许多技术不直接适用，因为它们的基于转向的算法要求每个路由器在堆栈中具有垂直连接（我们不做出这种假设），这会增加每个芯片TSV区域开销。其他3D
VC技术创建与芯片在堆叠中的垂直位置相关联的单调VC排序；芯片在中间层上的物理拓扑结构使得很难强制实施总排序。我们不提供这些作品的实验评估，因为不明显如何将它们适应不仅由单个垂直3D芯片堆栈组成的拓扑结构。”
# VIII. CONCLUSIONS
基于芯片组的复杂SoCs的构建非常令人兴奋，因为它可以实现各种类型的系统，但这些系统必须易于设计和组装。当使用来自第三方硅IP供应商的黑盒芯片构建系统时，确保正确性变得更加具有挑战性和重要性。本文对基于芯片组的SoC设计方法论做出了重大贡献，重点是互连；然而，仍有其他有益的研究领域。如果系统中的不同芯片要具有高速缓存一致性，则必须设计一个正确运行并跨不同物理芯片扩展（以性能为准）的高速缓存一致性协议。虽然不是严格的正确性问题，但可能需要设计服务质量机制，以确保不同的芯片集成在一起“友好地协作”，特别是在实时组件（例如图形和音频）或更高级别的性能目标（例如数据中心服务级别协议）方面。</li>
</ul>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Yuhang Zhang
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://zyh-eric.gitee.io/zyhjy/2023/04/12/Chiplets/" title="">https://zyh-eric.gitee.io/zyhjy/2023/04/12/Chiplets/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/zyhjy/2023/03/22/Clion%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" rel="prev" title="Clion使用指南!">
      <i class="fa fa-chevron-left"></i> Clion使用指南!
    </a></div>
      <div class="post-nav-item">
    <a href="/zyhjy/2023/05/18/Qemu%20icount/" rel="next" title="Qemu icount">
      Qemu icount <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81ODg3Ni8zNTMzOA=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#introduction"><span class="nav-number">1.</span> <span class="nav-text">INTRODUCTION</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#independently-designed-chiplets"><span class="nav-number">1.0.1.</span> <span class="nav-text">Independently Designed
Chiplets:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#iv.-multi-chiplet-routing"><span class="nav-number">2.</span> <span class="nav-text">IV. MULTI-CHIPLET ROUTING</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#c.-basic-throughput-evaluations-with-synthetic-traffic-%E4%BD%BF%E7%94%A8%E5%90%88%E6%88%90%E6%B5%81%E9%87%8F%E8%BF%9B%E8%A1%8C%E5%9F%BA%E6%9C%AC%E5%90%9E%E5%90%90%E9%87%8F%E8%AF%84%E4%BC%B0"><span class="nav-number">2.1.</span> <span class="nav-text">C.
Basic Throughput Evaluations with Synthetic Traffic
使用合成流量进行基本吞吐量评估</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yuhang Zhang"
      src="/zyhjy/images/zyhjy.png">
  <p class="site-author-name" itemprop="name">Yuhang Zhang</p>
  <div class="site-description" itemprop="description">爱小雅，爱生活，爱物理!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/zyhjy/archives/">
        
          <span class="site-state-item-count">75</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/zyhjy/categories/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/zyhjy/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/zyhjy/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuhang Zhang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">407k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">11:19</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/zyhjy/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>

<script src="/zyhjy/js/utils.js"></script>


<script src="/zyhjy/js/schemes/pisces.js"></script>


<script src="/zyhjy/js/next-boot.js"></script>




  




  
<script src="/zyhjy/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
