<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
<meta name="referrer" content="no-referrer">
  <link rel="apple-touch-icon" sizes="180x180" href="/zyhjy/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/zyhjy/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/zyhjy/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/zyhjy/images/logo.svg" color="#222">

<link rel="stylesheet" href="/zyhjy/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/zyhjy/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zyh-eric.gitee.io","root":"/zyhjy/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="0. Qemu Arrch64中的常用寄存器   Name Size Description Alias    WZR 32 bits Zero register    XZR 64 bits Zero register    FP 64 bits Current stack pointer X29   LR 64 bits Current stack pointer X30   SP 64 bi">
<meta property="og:type" content="article">
<meta property="og:title" content="Arrch64 CPU Structure">
<meta property="og:url" content="https://zyh-eric.gitee.io/zyhjy/2023/05/19/Arrch64%20CPU%E6%8C%87%E4%BB%A4%E9%9B%86/">
<meta property="og:site_name" content="ZYHJY">
<meta property="og:description" content="0. Qemu Arrch64中的常用寄存器   Name Size Description Alias    WZR 32 bits Zero register    XZR 64 bits Zero register    FP 64 bits Current stack pointer X29   LR 64 bits Current stack pointer X30   SP 64 bi">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-05-19T13:03:50.000Z">
<meta property="article:modified_time" content="2023-07-30T10:15:50.931Z">
<meta property="article:author" content="Yuhang Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zyh-eric.gitee.io/zyhjy/2023/05/19/Arrch64%20CPU%E6%8C%87%E4%BB%A4%E9%9B%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Arrch64 CPU Structure | ZYHJY</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/zyhjy/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ZYHJY</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/zyhjy/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/zyhjy/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/zyhjy/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/zyhjy/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/zyhjy/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2023/05/19/Arrch64%20CPU%E6%8C%87%E4%BB%A4%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Arrch64 CPU Structure
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-19 21:03:50" itemprop="dateCreated datePublished" datetime="2023-05-19T21:03:50+08:00">2023-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:50" itemprop="dateModified" datetime="2023-07-30T18:15:50+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/Qemu/" itemprop="url" rel="index"><span itemprop="name">Qemu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="0-Qemu-Arrch64中的常用寄存器"><a href="#0-Qemu-Arrch64中的常用寄存器" class="headerlink" title="0. Qemu Arrch64中的常用寄存器"></a>0. Qemu Arrch64中的常用寄存器</h1><table>
<thead>
<tr>
<th>Name</th>
<th>Size</th>
<th>Description</th>
<th>Alias</th>
</tr>
</thead>
<tbody><tr>
<td>WZR</td>
<td>32 bits</td>
<td>Zero register</td>
<td></td>
</tr>
<tr>
<td>XZR</td>
<td>64 bits</td>
<td>Zero register</td>
<td></td>
</tr>
<tr>
<td>FP</td>
<td>64 bits</td>
<td>Current stack pointer</td>
<td>X29</td>
</tr>
<tr>
<td>LR</td>
<td>64 bits</td>
<td>Current stack pointer</td>
<td>X30</td>
</tr>
<tr>
<td>SP</td>
<td>64 bits</td>
<td>Current stack pointer</td>
<td>X31</td>
</tr>
<tr>
<td>PC</td>
<td>64 bits</td>
<td>Program counter</td>
<td></td>
</tr>
</tbody></table>
<h1 id="1-An-Introduction-to-the-ARMv8-Instruction-Sets-ARMv8指令集简介"><a href="#1-An-Introduction-to-the-ARMv8-Instruction-Sets-ARMv8指令集简介" class="headerlink" title="1. An Introduction to the ARMv8 Instruction Sets &#x2F; ARMv8指令集简介"></a>1. An Introduction to the ARMv8 Instruction Sets &#x2F; ARMv8指令集简介</h1><p>ARMv8架构引入的最重要的变化之一是增加了64位指令集。这个指令集与现有的32位指令集架构相辅相成。这个增加使得可以访问64位宽整数寄存器和数据操作，并且能够使用64位大小的内存指针。这些新指令被称为A64指令，运行在AArch64执行状态下。ARMv8还包括原始的ARM指令集，现在称为A32指令集，以及Thumb (T32)指令集。A32和T32都在AArch32状态下执行，与ARMv7保持向后兼容。</p>
<p>尽管ARMv8-A与32位ARM体系结构保持向后兼容，但A64指令集与旧的指令集架构是独立的并且编码方式不同。A64添加了一些额外的功能，同时去除了可能限制高性能实现速度或能量效率的其他特性。ARMv8架构还对32位指令集(A32和T32)进行了一些增强。然而，使用这些功能的代码与旧的ARMv7实现不兼容。然而，A64指令集中的指令操作码仍然是32位长，而不是64位。</p>
<p>寻求更详细的A64汇编语言描述的程序员还可以参考ARM编译器armasm参考指南v6.01。</p>
<h2 id="The-ARMv8-instruction-sets"><a href="#The-ARMv8-instruction-sets" class="headerlink" title="The ARMv8 instruction sets"></a>The ARMv8 instruction sets</h2><p>新的A64指令集与现有的A32指令集相似。指令长度为32位，具有类似的语法。</p>
<p>在AArch64状态下，引入了一种新的指令集供内核使用。遵循命名约定，并反映64位操作，该指令集称为：<strong>A64</strong><br>A64提供了与AArch32或ARMv7中的A32和T32指令集类似的功能。新的A64指令集的设计带来了几个改进：</p>
<h4 id="一致的编码方案"><a href="#一致的编码方案" class="headerlink" title="一致的编码方案"></a>一致的编码方案</h4><p>A32中一些指令的晚期添加导致编码方案的一些不一致性。例如，LDR和STR对半字节的支持在编码上与主流的字节和字传输指令稍有不同。结果是寻址模式稍有不同。</p>
<h4 id="广泛的常量范围"><a href="#广泛的常量范围" class="headerlink" title="广泛的常量范围"></a>广泛的常量范围</h4><p>A64指令提供了广泛的常量选项，每个选项都适用于特定指令类型的要求。</p>
<ul>
<li>算术指令通常接受12位立即数常量。</li>
<li>逻辑指令通常接受32位或64位常量，其编码具有一定的限制。</li>
<li>MOV指令接受16位立即数，可以移动到任何16位边界。</li>
<li>地址生成指令适用于与4KB页面大小对齐的地址。</li>
</ul>
<p>对于用于位操作指令的常量，存在稍微复杂的规则。然而，位字段操作指令可以在源操作数或目标操作数中处理任何连续的位序列。</p>
<p>A64提供了灵活的常量，但是编码这些常量，甚至确定特定常量是否可以在特定上下文中合法编码，可能并不简单。</p>
<h4 id="数据类型更容易处理"><a href="#数据类型更容易处理" class="headerlink" title="数据类型更容易处理"></a>数据类型更容易处理</h4><p>A64天然支持64位有符号和无符号数据类型，提供更简洁和高效的操作64位整数的方法。这对于提供64位整数的所有语言，如C或Java，都是有利的。</p>
<h4 id="长偏移量"><a href="#长偏移量" class="headerlink" title="长偏移量"></a>长偏移量</h4><p>A64指令通常提供更长的偏移量，用于<em>PC相对分支和偏移寻址</em>。</p>
<p>增加的分支范围使得管理交叉段跳转更容易。动态生成的代码通常放置在堆上，因此实际上可以位于任何位置。运行时系统通过增加分支范围更容易管理这个过程，并且需要的修复次数更少。</p>
<p>字面池（嵌入在代码流中的字面数据块）的需求一直是ARM指令集的特性。这在A64中仍然存在。然而，更大的PC相对加载偏移量在字面池的管理方面提供了很大帮助，使得每个编译单元可以使用一个字面池。这消除了在长代码序列中为多个池制造位置的需要。</p>
<h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>在AArch64中，指针是64位的，这允许更大的虚拟内存寻址，并提供更大的地址映射自由度。然而，使用64位指针确实会带来一些成本。相同的代码片段在使用64位指针时通常使用更多内存，而不是32位指针。每个指针都存储在内存中，需要8字节而不是4字节。这听起来可能微不足道，但可能累积到显著的性能损失。此外，由于转向64位的内存空间增加使用，可能导致<em>缓存命中的访问次数下降</em>。缓存命中的下降可能会降低性能。</p>
<p>某些语言可以使用压缩指针来解决性能问题，例如Java。</p>
<h4 id="条件构造代替IT块"><a href="#条件构造代替IT块" class="headerlink" title="条件构造代替IT块"></a>条件构造代替IT块</h4><p>IT块是T32的一个有用特性，可以实现避免对未执行指令周围进行短程前向分支的高效序列。然而，它们有时对硬件的高效处理具有一定困难。A64移除了这些块，并用条件指令（如CSEL或条件选择和CINC或条件递增）替换它们。这些条件构造更直观和更容易处理，无需特殊情况。</p>
<h4 id="移位和旋转行为更直观"><a href="#移位和旋转行为更直观" class="headerlink" title="移位和旋转行为更直观"></a>移位和旋转行为更直观</h4><p>A32或T32的移位和旋转行为并不总是与高级语言预期的行为相匹配。</p>
<p>ARMv7提供了一个可用于数据处理指令的位移器。然而，指定移位类型和移位量需要一定数量的操作码位，这些位可以在其他地方使用。</p>
<p>因此，A64指令删除了很少使用的选项，并添加了新的显式指令来执行更复杂的移位操作。</p>
<h4 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h4><p>在静态和动态生成常见算术函数的代码时，A32和T32通常需要不同的指令或指令序列。这是为了处理不同的数据类型。A64中这些操作更加一致，因此更容易生成在不同大小数据类型上进行简单操作的常见序列。</p>
<p>例如，在T32中，相同的指令可以具有不同的编码，具体取决于使用的寄存器（低寄存器还是高寄存器）。</p>
<p>A64指令集编码更加规则和合理。因此，与T32相比，A64汇编器通常需要更少的代码行数。</p>
<h4 id="固定长度指令"><a href="#固定长度指令" class="headerlink" title="固定长度指令"></a>固定长度指令</h4><p>所有A64指令的长度都相同，而T32是一种可变长度指令集。这使得管理和跟踪生成的代码序列更容易，特别是对动态代码生成器有影响。</p>
<h4 id="三个操作数更好地映射"><a href="#三个操作数更好地映射" class="headerlink" title="三个操作数更好地映射"></a>三个操作数更好地映射</h4><p>A32通常保留了用于数据处理操作的真正的三个操作数结构。而T32则包含大量的双操作数指令格式，这在生成代码时稍微不够灵活。A64坚持使用一致的三个操作数语法，进一步增加了指令集的规则性和统一性，有利于编译器。</p>
<h3 id="C-C-inline-assembly"><a href="#C-C-inline-assembly" class="headerlink" title="C&#x2F;C++ inline assembly"></a>C&#x2F;C++ inline assembly</h3><p>在C和C++中，你可以使用<code>asm</code>关键字来包含内联汇编代码。它允许你直接在C或C++函数中嵌入汇编代码。以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">asm</span> (</span><br><span class="line">    <span class="string">&quot;ADD %w[result], %w[input_i], %w[input_j]&quot;</span></span><br><span class="line">    : [result] <span class="string">&quot;=r&quot;</span> (res)</span><br><span class="line">    : [input_i] <span class="string">&quot;r&quot;</span> (i), [input_j] <span class="string">&quot;r&quot;</span> (j)</span><br><span class="line">  );</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  c = add(a, b);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Result of %d + %d = %d\n&quot;</span>, a, b, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>asm</code>内联汇编语句的一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>(code [: output_operand_list [: input_operand_list [: clobber_list]]]);</span><br></pre></td></tr></table></figure>

<p>以下是各个组成部分的说明：</p>
<ul>
<li><code>code</code>表示汇编代码本身。在示例中，它是<code>&quot;ADD %[result], %[input_i], %[input_j]&quot;</code>。</li>
<li><code>output_operand_list</code>是一个可选的以逗号分隔的输出操作数列表。每个操作数由方括号中的符号名称、约束字符串和括号中的C表达式组成。</li>
<li><code>input_operand_list</code>是一个可选的以逗号分隔的输入操作数列表。输入操作数使用与输出操作数相同的语法。</li>
<li><code>clobber_list</code>是一个可选的被破坏的寄存器或其他值的列表。</li>
</ul>
<p>当在C&#x2F;C++和汇编代码之间调用函数时，你必须遵循AAPCS64规则。</p>
<p>更多信息，请参考：<a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C">https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C</a>。</p>
<h1 id="2-The-A64-instruction-set"><a href="#2-The-A64-instruction-set" class="headerlink" title="2. The A64 instruction set"></a>2. The A64 instruction set</h1><p>尽管大多数应用级程序员在日常工作中不需要频繁编写汇编代码，但在某些情况下，了解汇编语言仍然具有重要价值。汇编代码在需要高度优化的情况下特别有用，例如编写编译器或使用C等高级语言无法直接访问的低级特性时。</p>
<p>在开发引导代码、设备驱动程序或操作系统时，可能需要使用汇编代码。这些领域通常需要对硬件有精细控制，并要求代码执行效率高。在这些情况下，使用汇编语言编写特定代码部分可以提高性能，并提供对硬件资源的低级访问能力。</p>
<p>此外，在调试C程序时，理解汇编代码变得至关重要。分析汇编指令与相应的C语句之间的映射有助于识别问题并优化代码。能够阅读汇编代码可以增强程序员理解和排查复杂软件行为的能力。</p>
<p>虽然汇编语言对大多数程序员来说不是主要工具，但在性能、低级控制和调试效率至关重要的专门领域中，汇编语言的重要性凸显出来。</p>
<h2 id="Instruction-mnemonics-指令助记符"><a href="#Instruction-mnemonics-指令助记符" class="headerlink" title="Instruction mnemonics &#x2F; 指令助记符"></a>Instruction mnemonics &#x2F; 指令助记符</h2><p>A64汇编语言中使用了指令助记符的重载，根据操作数寄存器名称的不同形式来区分不同的指令。例如，下面的ADD指令具有不同的编码，但您只需要记住一个助记符，汇编器会根据操作数自动选择正确的编码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ADD W0, W1, W2             // 添加32位寄存器</span><br><span class="line"></span><br><span class="line">ADD X0, X1, X2             // 添加64位寄存器</span><br><span class="line"></span><br><span class="line">ADD X0, X1, W2, SXTW       // 将符号扩展的32位寄存器添加到64位扩展寄存器</span><br><span class="line"></span><br><span class="line">ADD X0, X1, #42            // 添加立即数到64位寄存器</span><br><span class="line"></span><br><span class="line">ADD V0.8H, V1.8H, V2.8H    // NEON中的16位逐个通道添加，共8个通道</span><br></pre></td></tr></table></figure>

<h2 id="Data-processing-instructions-数据处理指令"><a href="#Data-processing-instructions-数据处理指令" class="headerlink" title="Data processing instructions &#x2F; 数据处理指令"></a>Data processing instructions &#x2F; 数据处理指令</h2><p>数据处理指令是处理器的基本算术和逻辑操作，操作的对象是通用寄存器中的值，或者一个寄存器和一个立即值。乘法和除法指令可以看作是这些指令的特殊情况。</p>
<p>数据处理指令大多使用一个目标寄存器和两个源操作数。一般格式可以认为是指令，后面是操作数，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Instruction Rd, Rn, Operand2</span><br></pre></td></tr></table></figure>

<p>第二个操作数可以是一个寄存器、一个修改后的寄存器或一个立即值。使用 R 表示它可以是 X 寄存器或 W 寄存器。</p>
<p>数据处理操作包括：</p>
<ul>
<li>算术和逻辑操作。</li>
<li>移动和移位操作。</li>
<li>符号扩展和零扩展指令。</li>
<li>位和位域操作。</li>
<li>有条件的比较和数据处理操作。</li>
</ul>
<h2 id="Memory-access-instructions-访存指令"><a href="#Memory-access-instructions-访存指令" class="headerlink" title="Memory access instructions &#x2F; 访存指令"></a>Memory access instructions &#x2F; 访存指令</h2><p>和之前的所有ARM处理器一样，ARMv8架构也是一种加载&#x2F;存储（Load&#x2F;Store）架构。这意味着没有数据处理指令直接在内存中操作数据。数据首先必须加载到寄存器中，进行修改，然后再存储到内存中。程序必须指定一个地址、要传输的数据大小以及一个源或目标寄存器。还有其他的加载和存储指令提供了进一步的选项，比如非临时的加载&#x2F;存储、加载&#x2F;存储互斥和获取&#x2F;释放。</p>
<p>内存指令可以以非对齐的方式访问普通内存（参见<a target="_blank" rel="noopener" href="https://developer.arm.com/documentation/den0024/a/Memory-Ordering?lang=en">内存排序</a>）。但这在独占访问、加载获取或存储释放变体中是不支持的。如果不希望进行非对齐访问，可以配置为出错。</p>
<h3 id="Specifying-the-address-for-a-Load-or-Store-instruction"><a href="#Specifying-the-address-for-a-Load-or-Store-instruction" class="headerlink" title="Specifying the address for a Load or Store instruction"></a>Specifying the address for a Load or Store instruction</h3><p>在A64中，用于加载（Load）或存储（Store）指令的地址指定方式与A32和T32类似。虽然存在一些额外的限制和新特性，但对于熟悉A32或T32的人来说，A64提供的地址指定方式应该不会让人感到意外。</p>
<p>在A64中，地址操作数的基础寄存器必须始终是一个X寄存器。然而，有几条指令支持零扩展（zero-extension）或符号扩展（sign-extension），以便可以将32位偏移量作为W寄存器提供。</p>
<h4 id="a-写回修饰符（Writeback-Modifier）（-）"><a href="#a-写回修饰符（Writeback-Modifier）（-）" class="headerlink" title="a. 写回修饰符（Writeback Modifier）（!）"></a>a. 写回修饰符（Writeback Modifier）（!）</h4><p>在ARM汇编语言中，<code>STP</code>（Store Pair）指令的尾部的感叹号（!）是一个存储修饰符，称为写回修饰符（Writeback Modifier）。</p>
<p><code>STP</code>指令用于将一对寄存器的数据存储到内存中。写回修饰符（!）用于指示指令是否应该将存储操作后的更新地址写回到基地址寄存器。如果使用了感叹号（!），则表示在存储数据后，将基地址寄存器进行更新，以便指向下一个存储操作的地址。</p>
<p>以下是一个示例，展示了带有写回修饰符（!）的<code>STP</code>指令的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STP X0, X1, [SP, #16]!</span><br></pre></td></tr></table></figure>

<p>上述指令将X0和X1寄存器的数据存储到内存地址为(SP + 16)的位置。同时，由于感叹号（!）的存在，指令执行后，SP寄存器的值会被更新，指向下一个存储操作的地址。</p>
<p>需要注意的是，如果不使用写回修饰符（!），则基地址寄存器的值不会被修改，即不会进行写回操作。这样，下一次的存储操作将使用原始的基地址进行。</p>
<p>写回修饰符（!）的使用可以方便地在一条指令中实现连续的存储操作，同时更新基地址寄存器，而无需额外的指令来更新寄存器的值。</p>
<h4 id="b-Offset-modes"><a href="#b-Offset-modes" class="headerlink" title="b. Offset modes"></a>b. Offset modes</h4><ol>
<li>有一个64位的基址寄存器（base register）</li>
<li>将一个立即数 &#x2F; 寄存器值 &#x2F; 修改后的寄存器值加到64位的基址寄存器上，这个加上的数就是offset</li>
<li>eg:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR X0, [X1, X2, LSL #3] // LSL和#3之间没有逗号</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>load from [X1 + (X2 &lt;&lt; 3)]</li>
<li>lsl : logic shift left</li>
</ul>
<h4 id="c-Index-modes"><a href="#c-Index-modes" class="headerlink" title="c. Index modes"></a>c. Index modes</h4><p>索引模式（Index modes）与偏移模式（Offset modes）类似，但它们还会更新基础寄存器。其语法与A32和T32相同，但操作的集合更为限制。通常，只能为索引模式提供立即偏移量（immediate offsets）。</p>
<p>索引模式有两个变体：前索引模式（pre-index modes）在访问内存之前应用偏移量，而后索引模式（post-index modes）在访问内存之后应用偏移量。</p>
<table>
<thead>
<tr>
<th>Example instruction</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>LDR X0, [X1, #8]!</td>
<td>Pre-index: Update X1 first (to X1 + #8), then load from the new address</td>
</tr>
<tr>
<td>LDR X0, [X1], #8</td>
<td>Post-index: Load from the unmodified address in X1 first, then update X1 (to X1 + #8)</td>
</tr>
<tr>
<td>STP X0, X1, [SP, #-16]!</td>
<td>Push X0 and X1 to the stack. sp is modified</td>
</tr>
<tr>
<td>LDP X0, X1, [SP], #16</td>
<td>Pop X0 and X1 off the stack. sp is modified</td>
</tr>
</tbody></table>
<p>These options map cleanly onto some common C operations:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A C example showing accesses that a compiler is likely to generate.</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">example_strcpy</span><span class="params">(<span class="type">char</span> * dst, <span class="type">const</span> <span class="type">char</span> * src)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    c = *(src++);             <span class="comment">// LDRB W2, [X1], #1</span></span><br><span class="line">    *(dst++) = c;             <span class="comment">// STRB W2, [X0], #1</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (c != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="PC-relative-modes-load-literal"><a href="#PC-relative-modes-load-literal" class="headerlink" title="PC-relative modes (load-literal)"></a>PC-relative modes (load-literal)</h4><p>A64引入了另一种专门用于访问<strong>字面池（literal pools）</strong>的寻址模式，称为PC相对模式（PC-relative modes）。字面池是嵌入在指令流中的数据块。这些池不会被执行，但可以通过PC相对内存地址从周围的代码中访问它们的数据。字面池通常用于编码无法适应简单的立即数移动指令的常量值。</p>
<p>在A32和T32中，PC可以像通用寄存器一样读取，因此只需将PC指定为基础寄存器即可访问字面池。</p>
<p>在A64中，PC通常是不可访问的，但是有一种特殊的寻址模式（仅适用于加载指令）可以访问PC相对地址。这种专用的寻址模式的范围比A32和T32中的PC相对加载要大得多，因此字面池可以被更稀疏地定位。</p>
<table>
<thead>
<tr>
<th>Example instruction</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>LDR W0, &lt;label&gt;</td>
<td>Load 4 bytes from &lt;label&gt; into W0</td>
</tr>
<tr>
<td>LDR X0, &lt;label&gt;</td>
<td>Load 8 bytes from &lt;label&gt; into X0</td>
</tr>
<tr>
<td>LDRSW X0, &lt;label&gt;</td>
<td>Load 4 bytes from &lt;label&gt; and sign-extend into X0</td>
</tr>
<tr>
<td>LDR S0, &lt;label&gt;</td>
<td>Load 4 bytes from &lt;label&gt; into S0</td>
</tr>
<tr>
<td>LDR D0, &lt;label&gt;</td>
<td>Load 8 bytes from &lt;label&gt; into D0</td>
</tr>
<tr>
<td>LDR Q0, &lt;label&gt;</td>
<td>Load 16 bytes from &lt;label&gt; into Q0</td>
</tr>
<tr>
<td>Note:</td>
<td></td>
</tr>
<tr>
<td>&lt;label&gt; must be 4-byte-aligned for all variants.</td>
<td></td>
</tr>
</tbody></table>
<h3 id="Unprivileged-access"><a href="#Unprivileged-access" class="headerlink" title="Unprivileged access"></a>Unprivileged access</h3><p>A64 LDTR和STTR指令执行非特权的加载（Load）或存储（Store）操作（请参阅ARMv8-A架构参考手册中的LDTR和STTR）：</p>
<ul>
<li>在EL0、EL2或EL3级别下，它们的行为类似于普通的加载或存储指令。</li>
<li>当在EL1级别下执行时，它们的行为类似于在EL0特权级别下执行。</li>
</ul>
<p>这些指令与A32 LDRT和STRT指令是等效的。</p>
<h3 id="Non-temporal-load-and-store-pair-非暂态（non-temporal）加载和存储"><a href="#Non-temporal-load-and-store-pair-非暂态（non-temporal）加载和存储" class="headerlink" title="Non-temporal load and store pair &#x2F; 非暂态（non-temporal）加载和存储"></a>Non-temporal load and store pair &#x2F; 非暂态（non-temporal）加载和存储</h3><p>在ARMv8架构中引入了非暂态（non-temporal）加载和存储的概念。这些概念体现在LDNP和STNP指令中，它们用于读取或写入一对寄存器值。同时，它们向内存系统发出提示，表明对该数据进行缓存是无益的。这个提示并不禁止内存系统的活动，比如地址的缓存、预加载或者聚集。然而，它表明进行缓存不太可能提高性能。一个典型的用例可能是流式数据处理，但需要注意的是，有效地使用这些指令需要针对具体微架构的特定方法。</p>
<p>非暂态加载和存储放宽了内存排序要求。在上述例子中，LDNP指令可能在前面的LDR指令之前执行，这可能导致从不确定的X0地址读取数据。<br>For example:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDR X0, [X3]</span><br><span class="line">LDNP X2, X1, [X0]      // Xo may not be loaded when the instruction executes!</span><br></pre></td></tr></table></figure>
<p>为了纠正上述问题，需要使用显式的加载屏障：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LDR X0, [X3]</span><br><span class="line">DMB nshld</span><br><span class="line">LDNP X2, X1, [X0]</span><br></pre></td></tr></table></figure>
<p>通过引入加载屏障，可以确保在LDNP指令执行之前先加载X0的值，从而避免了不确定的读取。这样，非暂态加载和存储指令才能够在程序中被正确使用。</p>
<h3 id="Memory-access-atomicity"><a href="#Memory-access-atomicity" class="headerlink" title="Memory access atomicity"></a>Memory access atomicity</h3><p>对齐的内存访问使用单个通用寄存器可以保证原子性。使用对齐的内存地址进行的一对通用寄存器的加载对（load pair）和存储对（store pair）指令可以保证作为两个独立的原子访问。非对齐访问不是原子的，因为通常需要进行两次独立的访问。此外，浮点数和SIMD（单指令多数据）内存访问不能保证原子性。</p>
<h3 id="Memory-barrier-and-fence-instructions"><a href="#Memory-barrier-and-fence-instructions" class="headerlink" title="Memory barrier and fence instructions"></a>Memory barrier and fence instructions</h3><p>ARMv7和ARMv8都支持不同类型的内存屏障操作。这些操作在<a target="_blank" rel="noopener" href="https://developer.arm.com/documentation/den0024/a/Memory-Ordering?lang=en">Memory Ordering</a>中有更详细的描述：</p>
<p>数据内存屏障（Data Memory Barrier，DMB）：在继续执行后续访问之前，强制使程序顺序中较早的所有内存访问对全局可见。</p>
<p>数据同步屏障（Data Synchronization Barrier，DSB）：在程序继续执行之前，完成所有待处理的加载和存储、缓存维护指令以及TLB维护指令。DSB的行为类似于DMB，但具有附加属性。</p>
<p>指令同步屏障（Instruction Synchronization Barrier，ISB）：该指令刷新CPU流水线和预取缓冲区，导致ISB之后的指令从缓存或内存中获取（或重新获取）。</p>
<p>ARMv8引入了单向栅栏（one-sided fences），这与Release Consistency模型相关。这些栅栏被称为Load-Acquire（LDAR）和Store-Release（STLR），它们是基于地址的同步原语（见<a target="_blank" rel="noopener" href="https://developer.arm.com/documentation/den0024/a/Memory-Ordering?lang=en">One-way barriers</a>）。这两个操作可以配对形成一个完整的栅栏。这些指令仅支持基址寄存器寻址，不支持偏移量或其他类型的索引寻址。</p>
<h3 id="Synchronization-primitives"><a href="#Synchronization-primitives" class="headerlink" title="Synchronization primitives"></a>Synchronization primitives</h3><p>ARMv7-A和ARMv8-A架构都支持独占内存访问。在A64中，这是通过Load&#x2F;Store exclusive（LDXR&#x2F;STXR）指令对实现的。</p>
<p>LDXR指令从内存地址加载一个值，并尝试在该地址上默默地获取独占锁。然后，Store-Exclusive指令只有在成功获取并持有锁时才会将新值写入该位置。LDXR&#x2F;STXR配对用于构建标准的同步原语，例如自旋锁。还提供了一对配对的LDXRP和STXRP指令，以允许原子更新跨越两个寄存器的位置。可用的选项包括字节、半字、字和双字。与Load Acquire&#x2F;Store Release配对一样，只支持基址寄存器寻址，没有任何偏移量。</p>
<p>CLREX指令用于清除监视器，但与ARMv7不同，异常的进入或返回也会清除监视器。监视器也可能被意外地清除，例如由于缓存逐出或与应用程序无直接关联的其他原因。在配对的LDXR和STXR指令之间，软件必须避免任何显式的内存访问、系统控制寄存器更新或缓存维护指令。</p>
<p>此外，还有一对独占的Load Acquire&#x2F;Store Release指令，称为LDAXR和STLXR。详见<a target="_blank" rel="noopener" href="https://developer.arm.com/documentation/den0024/a/Multi-core-processors/Multi-processing-systems/Synchronization?lang=en">同步</a>部分。</p>
<h2 id="Flow-control"><a href="#Flow-control" class="headerlink" title="Flow control"></a>Flow control</h2><p>A64指令集提供了多种不同类型的分支指令（参见表<a target="_blank" rel="noopener" href="https://developer.arm.com/documentation/den0024/a/The-A64-instruction-set/Flow-control?lang=en">6.12</a>）。对于简单的相对分支，即从当前地址偏移的分支，使用B指令。<em>无条件的简单相对分支可以向前或向后分支到距离当前程序计数器位置最多128MB的位置</em>。<em>有条件的简单相对分支，在B后附加条件码，其范围较小，为±1MB</em>。</p>
<p>对于需要将返回地址存储在链接寄存器（X30）中的子程序调用，使用BL指令。它没有条件版本。<em>BL的行为类似于B指令，同时额外存储返回地址，即BL指令后一条指令的地址，到寄存器X30中</em>。</p>
<h2 id="System-control-and-other-instructions-系统控制和其他指令"><a href="#System-control-and-other-instructions-系统控制和其他指令" class="headerlink" title="System control and other instructions &#x2F; 系统控制和其他指令"></a>System control and other instructions &#x2F; 系统控制和其他指令</h2><p>A64指令集包含与以下内容相关的指令：</p>
<ul>
<li>异常处理。</li>
<li>系统寄存器访问。</li>
<li>调试。</li>
<li>提示指令，在许多系统中具有电源管理应用。</li>
</ul>
<h3 id="Exception-handling-instructions"><a href="#Exception-handling-instructions" class="headerlink" title="Exception handling instructions"></a>Exception handling instructions</h3><p>有三条异常处理指令，其目的是引发异常。这些指令用于调用在操作系统中运行在更高异常级别的代码（EL1），虚拟机监控程序（EL2）或安全监控程序（EL3）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SVC #imm16   // 监管者调用，允许应用程序调用内核（EL1）。</span><br><span class="line"></span><br><span class="line">HVC #imm16   // 虚拟机监控程序调用，允许操作系统代码调用虚拟机监控程序（EL2）。</span><br><span class="line"></span><br><span class="line">SMC #imm16   // 安全监控程序调用，允许操作系统或虚拟机监控程序调用安全监控程序（EL3）。</span><br></pre></td></tr></table></figure>
<p>立即值将在异常综合寄存器中提供给处理程序。这与ARMv7不同，ARMv7需要通过读取调用指令的操作码来确定立即值。详细信息请参阅<a target="_blank" rel="noopener" href="https://developer.arm.com/documentation/den0024/a/AArch64-Exception-Handling?lang=en">AArch64异常处理</a>。</p>
<p>要从异常返回，请使用ERET指令。此指令通过将SPSR_ELn复制到PSTATE并跳转到ELR_ELn中保存的返回地址来恢复处理器状态。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/zyhjy/2023/05/19/Arrch64%20CPU%20Structure/" rel="prev" title="Arrch64 CPU Structure">
      <i class="fa fa-chevron-left"></i> Arrch64 CPU Structure
    </a></div>
      <div class="post-nav-item">
    <a href="/zyhjy/2023/05/19/Qemu%E4%BB%8B%E7%BB%8D/" rel="next" title="Qemu介绍">
      Qemu介绍 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#0-Qemu-Arrch64%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">1.</span> <span class="nav-text">0. Qemu Arrch64中的常用寄存器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-An-Introduction-to-the-ARMv8-Instruction-Sets-ARMv8%E6%8C%87%E4%BB%A4%E9%9B%86%E7%AE%80%E4%BB%8B"><span class="nav-number">2.</span> <span class="nav-text">1. An Introduction to the ARMv8 Instruction Sets &#x2F; ARMv8指令集简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#The-ARMv8-instruction-sets"><span class="nav-number">2.1.</span> <span class="nav-text">The ARMv8 instruction sets</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E6%A1%88"><span class="nav-number">2.1.0.1.</span> <span class="nav-text">一致的编码方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%BF%E6%B3%9B%E7%9A%84%E5%B8%B8%E9%87%8F%E8%8C%83%E5%9B%B4"><span class="nav-number">2.1.0.2.</span> <span class="nav-text">广泛的常量范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9B%B4%E5%AE%B9%E6%98%93%E5%A4%84%E7%90%86"><span class="nav-number">2.1.0.3.</span> <span class="nav-text">数据类型更容易处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%95%BF%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="nav-number">2.1.0.4.</span> <span class="nav-text">长偏移量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88"><span class="nav-number">2.1.0.5.</span> <span class="nav-text">指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E4%BB%A3%E6%9B%BFIT%E5%9D%97"><span class="nav-number">2.1.0.6.</span> <span class="nav-text">条件构造代替IT块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E4%BD%8D%E5%92%8C%E6%97%8B%E8%BD%AC%E8%A1%8C%E4%B8%BA%E6%9B%B4%E7%9B%B4%E8%A7%82"><span class="nav-number">2.1.0.7.</span> <span class="nav-text">移位和旋转行为更直观</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="nav-number">2.1.0.8.</span> <span class="nav-text">代码生成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E6%8C%87%E4%BB%A4"><span class="nav-number">2.1.0.9.</span> <span class="nav-text">固定长度指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0%E6%9B%B4%E5%A5%BD%E5%9C%B0%E6%98%A0%E5%B0%84"><span class="nav-number">2.1.0.10.</span> <span class="nav-text">三个操作数更好地映射</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-C-inline-assembly"><span class="nav-number">2.1.1.</span> <span class="nav-text">C&#x2F;C++ inline assembly</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-The-A64-instruction-set"><span class="nav-number">3.</span> <span class="nav-text">2. The A64 instruction set</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Instruction-mnemonics-%E6%8C%87%E4%BB%A4%E5%8A%A9%E8%AE%B0%E7%AC%A6"><span class="nav-number">3.1.</span> <span class="nav-text">Instruction mnemonics &#x2F; 指令助记符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Data-processing-instructions-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><span class="nav-number">3.2.</span> <span class="nav-text">Data processing instructions &#x2F; 数据处理指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Memory-access-instructions-%E8%AE%BF%E5%AD%98%E6%8C%87%E4%BB%A4"><span class="nav-number">3.3.</span> <span class="nav-text">Memory access instructions &#x2F; 访存指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Specifying-the-address-for-a-Load-or-Store-instruction"><span class="nav-number">3.3.1.</span> <span class="nav-text">Specifying the address for a Load or Store instruction</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a-%E5%86%99%E5%9B%9E%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%88Writeback-Modifier%EF%BC%89%EF%BC%88-%EF%BC%89"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">a. 写回修饰符（Writeback Modifier）（!）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-Offset-modes"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">b. Offset modes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c-Index-modes"><span class="nav-number">3.3.1.3.</span> <span class="nav-text">c. Index modes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PC-relative-modes-load-literal"><span class="nav-number">3.3.1.4.</span> <span class="nav-text">PC-relative modes (load-literal)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unprivileged-access"><span class="nav-number">3.3.2.</span> <span class="nav-text">Unprivileged access</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Non-temporal-load-and-store-pair-%E9%9D%9E%E6%9A%82%E6%80%81%EF%BC%88non-temporal%EF%BC%89%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%AD%98%E5%82%A8"><span class="nav-number">3.3.3.</span> <span class="nav-text">Non-temporal load and store pair &#x2F; 非暂态（non-temporal）加载和存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Memory-access-atomicity"><span class="nav-number">3.3.4.</span> <span class="nav-text">Memory access atomicity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Memory-barrier-and-fence-instructions"><span class="nav-number">3.3.5.</span> <span class="nav-text">Memory barrier and fence instructions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Synchronization-primitives"><span class="nav-number">3.3.6.</span> <span class="nav-text">Synchronization primitives</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flow-control"><span class="nav-number">3.4.</span> <span class="nav-text">Flow control</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#System-control-and-other-instructions-%E7%B3%BB%E7%BB%9F%E6%8E%A7%E5%88%B6%E5%92%8C%E5%85%B6%E4%BB%96%E6%8C%87%E4%BB%A4"><span class="nav-number">3.5.</span> <span class="nav-text">System control and other instructions &#x2F; 系统控制和其他指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Exception-handling-instructions"><span class="nav-number">3.5.1.</span> <span class="nav-text">Exception handling instructions</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yuhang Zhang"
      src="/zyhjy/images/zyhjy.png">
  <p class="site-author-name" itemprop="name">Yuhang Zhang</p>
  <div class="site-description" itemprop="description">爱小雅，爱生活，爱物理!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/zyhjy/archives/">
        
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/zyhjy/categories/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/zyhjy/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuhang Zhang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/zyhjy/lib/anime.min.js"></script>

<script src="/zyhjy/js/utils.js"></script>


<script src="/zyhjy/js/schemes/pisces.js"></script>


<script src="/zyhjy/js/next-boot.js"></script>




  















  

  

</body>
</html>
