<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
<meta name="referrer" content="no-referrer">
  <link rel="apple-touch-icon" sizes="180x180" href="/zyhjy/images/relativity128.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/zyhjy/images/relativity32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/zyhjy/images/relativity16.png">
  <link rel="mask-icon" href="/zyhjy/images/logo.svg" color="#222">

<link rel="stylesheet" href="/zyhjy/css/main.css">

<link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css?family=Comic Sans MS:300,300italic,400,400italic,700,700italic|Noto Serif SC:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/zyhjy/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/zyhjy/lib/pace/pace-theme-minimal.min.css">
  <script src="/zyhjy/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zyh-eric.gitee.io","root":"/zyhjy/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="第一章 并发与并行 并发（Concurrent）与并行（Parallel） 并发：多个程序按照时间片轮转轮流执行，通常是指在一个core上。 并行：多个core同时执行多个程序。 为什么要使用并发  分离独立模块之间的逻辑：每个线程负责独立事物，不用实现切换逻辑（利用CPU调度自动切换）  例：DVD播放界面和用户操作界面  利用现代CPU的多核架构带来的并行性">
<meta property="og:type" content="article">
<meta property="og:title" content="笔记：C++ Concurrency in Action 2ed">
<meta property="og:url" content="https://zyh-eric.gitee.io/zyhjy/2023/06/04/C++%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">
<meta property="og:site_name" content="ZYHJY">
<meta property="og:description" content="第一章 并发与并行 并发（Concurrent）与并行（Parallel） 并发：多个程序按照时间片轮转轮流执行，通常是指在一个core上。 并行：多个core同时执行多个程序。 为什么要使用并发  分离独立模块之间的逻辑：每个线程负责独立事物，不用实现切换逻辑（利用CPU调度自动切换）  例：DVD播放界面和用户操作界面  利用现代CPU的多核架构带来的并行性">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-06-04T03:06:00.000Z">
<meta property="article:modified_time" content="2023-11-11T13:45:25.791Z">
<meta property="article:author" content="Yuhang Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zyh-eric.gitee.io/zyhjy/2023/06/04/C++%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>笔记：C++ Concurrency in Action 2ed | ZYHJY</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-J17VP3T2B4"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-J17VP3T2B4');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/zyhjy/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ZYHJY</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/zyhjy/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/zyhjy/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/zyhjy/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/zyhjy/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/zyhjy/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-solutions">

    <a href="/zyhjy/solutions/" rel="section"><i class="fa fa-code fa-fw"></i>算法题解</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2023/06/04/C++%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          笔记：C++ Concurrency in Action 2ed
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-04 11:06:00" itemprop="dateCreated datePublished" datetime="2023-06-04T11:06:00+08:00">2023-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-11 21:45:25" itemprop="dateModified" datetime="2023-11-11T21:45:25+08:00">2023-11-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/Concurrent/" itemprop="url" rel="index"><span itemprop="name">Concurrent</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>34k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>57 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="第一章-并发与并行">第一章 并发与并行</h1>
<h2
id="并发concurrent与并行parallel">并发（Concurrent）与并行（Parallel）</h2>
<p>并发：多个程序按照时间片轮转轮流执行，通常是指在一个core上。</p>
<p>并行：多个core同时执行多个程序。</p>
<h2 id="为什么要使用并发">为什么要使用并发</h2>
<ol type="1">
<li>分离独立模块之间的逻辑：每个线程负责独立事物，不用实现切换逻辑（利用CPU调度自动切换）
<ul>
<li>例：DVD播放界面和用户操作界面</li>
</ul></li>
<li>利用现代CPU的多核架构带来的并行性</li>
</ol>
<span id="more"></span>
<h1 id="第二章-线程管理">第二章 线程管理</h1>
<h2 id="线程的基本操作">线程的基本操作</h2>
<h3
id="启动线程stdthread构造">启动线程（<code>std::thread</code>构造）</h3>
<p>简单来说，使用C++线程库启动线程，就是构造<code>std::thread</code>对象，<code>std::thread</code>可以用可调用对象进行构造，构造完成后线程将会直接启动：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_some_work</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">my_thread</span><span class="params">(do_some_work)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">background_task</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">do_something</span>();</span><br><span class="line">    <span class="built_in">do_something_else</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">background_task f;</span><br><span class="line"><span class="function">std::thread <span class="title">my_thread</span><span class="params">(f)</span></span>;</span><br></pre></td></tr></table></figure>
<p>有一点需要注意的是，不要像下面这样使用临时函数对象构造；编译器的理解与你的理解不同：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">my_thread</span><span class="params">(background_task())</span></span>;</span><br></pre></td></tr></table></figure>
<p>这相当于声明了一个名为my_thread的函数，这个函数带有一个参数(函数指针，指向没有参数并返回background_task对象的函数)，返回一个<code>std::thread</code>对象的函数。</p>
<p>使用在前面命名函数对象的方式，或使用多组括号①，或使用统一的初始化语法②，以及Lambda表达式，都可以避免这个问题；如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">my_thread1</span><span class="params">((background_task()))</span></span>;  <span class="comment">// 1</span></span><br><span class="line">std::thread my_thread2&#123;<span class="built_in">background_task</span>()&#125;;    <span class="comment">// 2</span></span><br><span class="line"><span class="function">std::thread <span class="title">my_thread3</span><span class="params">([]&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">  do_something();</span></span></span><br><span class="line"><span class="params"><span class="function">  do_something_else();</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="传递参数">传递参数</h4>
<p>向可调用对象或函数传递参数很简单，只需要将这些参数作为
<code>std::thread</code>构造函数的附加参数即可。需要注意的是，这些参数会<strong>拷贝至新线程的内存空间中</strong>(同临时变量一样)。即使函数中的参数是引用的形式，拷贝操作也会执行。来看一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i, std::string <span class="type">const</span>&amp; s)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(f, <span class="number">3</span>, <span class="string">&quot;hello&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>代码创建了一个调用f(3,
"hello")的线程。这里函数f需要一个<code>std::string</code>的常量引用作为第二个参数，但这里使用的是字符串的字面值，也就是<code>char const *</code>类型，新线程的上下文会完成字面值向<code>std::string</code>的转化，之后再通过常量引用的形式传给函数f。</p>
<p>如果函数期望传递一个非常量引用，并在传参时没有使用将参数转换成引用的形式，则会出现编译错误。比如，尝试使用线程更新引用传递的数据结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_data_for_widget</span><span class="params">(widget_id w,widget_data&amp; data)</span></span>; <span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">oops_again</span><span class="params">(widget_id w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  widget_data data;</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(update_data_for_widget,w,data)</span></span>; <span class="comment">// 2</span></span><br><span class="line">  <span class="built_in">display_status</span>();</span><br><span class="line">  t.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">process_widget_data</span>(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然update_data_for_widget①的第二个参数期待传入一个引用，但<code>std::thread</code>的构造函数②并不知晓，构造函数无视函数参数类型，盲目地拷贝已提供的变量。</p>
<p><code>std::thread</code>
的构造函数会在新线程中执行，而不是在旧线程中执行。</p>
<p><strong>构造函数</strong>的内部代码会将拷贝的参数以<strong>右值</strong>的方式进行传递，这是为了那些只支持移动的类型，而后会尝试以右值为实参调用update_data_for_widget。</p>
<p>但因为函数期望的是一个非常量引用作为参数(而非右值)，所以会在编译时出错。</p>
<hr />
<p>问：都是转发参数，为什么<code>std::thread</code>的实现并不使用完美转发，而<code>std::make_shared</code>的实现却使用了完美转发？</p>
<p>答：因为<code>std::make_shared</code>会立即调用并直接将参数转发给构造函数。而在创建了<code>std::thread</code>对象之后，并不知道何时会将参数转发给可调用对象；也就是说，可能在转发参数给可调用对象的时候，构造<code>std::thread</code>对象的<strong>上下文</strong>（如堆栈）可能已经<strong>失效</strong>；为了避免上下文失效的严重后果，<code>std::thread</code>的构造函数会拷贝所有的参数；并以右值的形式传参给可调用对象（为了那些只支持移动的类型）。因此，当需要转发引用参数给可调用对象时，请使用<code>std::ref</code>将参数转换成引用的形式。（<code>std::bind</code>与<code>std::thread</code>的情况相同）</p>
<hr />
<p>对于熟悉<code>std::bind</code>的开发者来说，问题的解决办法很简单：可以使用<code>std::ref</code>将参数转换成引用的形式。因此可将线程的调用改为以下形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(update_data_for_widget,w,std::ref(data))</span></span>;</span><br></pre></td></tr></table></figure>
<p>这样update_data_for_widget就会收到data的引用，而非data的拷贝副本，这样代码就能顺利的通过编译了。</p>
<p>此外，也可以传递一个成员函数指针作为线程函数，并提供一个合适的对象指针作为第一个参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">do_lengthy_work</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">X my_x;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(&amp;X::do_lengthy_work, &amp;my_x)</span></span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>这段代码中，新线程将会调用my_x.do_lengthy_work()，其中my_x的地址①作为对象指针提供给函数。也可以为成员函数提供参数：<code>std::thread</code>构造函数的第三个参数就是成员函数的第一个参数，以此类推，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">do_lengthy_work</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">X my_x;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(&amp;X::do_lengthy_work, &amp;my_x, num)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="stdthread析构"><code>std::thread</code>析构</h3>
<p>当<code>std::thread</code>对象销毁之前还没有<code>join</code> 或者
<code>detach</code>
，程序就会终止(<code>std::thread</code>的析构函数会调用<code>std::terminate()</code>)。</p>
<h3 id="join-or-detach"><code>join</code> or <code>detach</code></h3>
<p>因此线程启动后，需要确保线程能够<em>汇入</em>(joined)或<em>分离</em>(detached),以避免<code>std::thread</code>对象析构而引外线程终止。</p>
<h4 id="join"><code>join</code></h4>
<p>如果想要分离线程，可以在线程启动后，直接使用detach()进行分离。</p>
<p>如果等待线程，则需要细心挑选使用join()的位置。避免主程序被抛出的异常所终止，导致跳过<code>join()</code>。</p>
<p>一种方式是使用了<code>try/catch</code>块确保线程退出后函数才结束。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span>; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> some_local_state=<span class="number">0</span>;</span><br><span class="line">  <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">do_something_in_current_thread</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span>(...)</span><br><span class="line">  &#123;</span><br><span class="line">    t.<span class="built_in">join</span>();  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t.<span class="built_in">join</span>();  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种方式是使用“资源获取即初始化方式”(RAII，Resource Acquisition Is
Initialization)，提供一个类，在析构函数中使用join()。如同下面代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">thread_guard</span></span><br><span class="line">&#123;</span><br><span class="line">  std::thread&amp; t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">thread_guard</span><span class="params">(std::thread&amp; t_)</span>:</span></span><br><span class="line"><span class="function">    t(t_)</span></span><br><span class="line"><span class="function">  &#123;</span>&#125;</span><br><span class="line">  ~<span class="built_in">thread_guard</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(t.<span class="built_in">joinable</span>()) <span class="comment">// 1</span></span><br><span class="line">    &#123;</span><br><span class="line">      t.<span class="built_in">join</span>();      <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">thread_guard</span>(thread_guard <span class="type">const</span>&amp;)=<span class="keyword">delete</span>;   <span class="comment">// 3</span></span><br><span class="line">  thread_guard&amp; <span class="keyword">operator</span>=(thread_guard <span class="type">const</span>&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> some_local_state=<span class="number">0</span>;</span><br><span class="line">  <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">  <span class="function">thread_guard <span class="title">g</span><span class="params">(t)</span></span>;</span><br><span class="line">  <span class="built_in">do_something_in_current_thread</span>();</span><br><span class="line">&#125;    <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>主线程执行到④处时，局部对象就要被逆序销毁了。因此，thread_guard对象g是第一个被销毁的，这时线程在析构函数中被加入②到原始线程中。即使do_something_in_current_thread抛出一个异常，这个销毁依旧会发生。</p>
<p>在thread_guard析构函数中，首先判断线程是否可汇入①。如果可汇入，会调用<code>join()</code>②进行汇入。</p>
<hr />
<h6
id="问如果在主线程①执行之后②执行之前从线程执行结束了会怎样">问：如果在主线程①执行之后，②执行之前，从线程执行结束了，会怎样？</h6>
<p>答：线程执行结束，线程对象仍然是<code>joinable</code>的;<code>joinable</code>
并不意味着still_running，它只是表示当前<code>std::thread</code>对象有执行线程，可以安全调用<code>join()</code>。</p>
<hr />
<h4 id="detach"><code>detach</code></h4>
<p>使用detach()会让线程在后台运行，这就意味着与主线程不能直接交互。C++运行库保证，当线程退出时，相关资源的能够正确回收。</p>
<p>分离线程通常称为<em>守护线程</em>(daemon threads)。</p>
<p>为了从<code>std::thread</code>对象中分离线程，不能对没有执行线程的<code>std::thread</code>对象使用detach()，并且要用同样的方式进行检查——当<code>std::thread</code>对象使用t.joinable()返回的是true，就可以使用t.detach()。当然，一般来说刚刚创建的<code>std::thread</code>，都是可以直接<code>detch()</code>的。</p>
<h3 id="转移所有权">转移所有权</h3>
<p>C++标准库中有很多<em>资源占有</em>(resource-owning)类型，比如<code>std::ifstream</code>，<code>std::unique_ptr</code>还有<code>std::thread</code>都是可移动，但不可复制。这说明执行线程的所有权可以在<code>std::thread</code>实例中移动，下面将展示一个例子。例子中，创建了两个执行线程，并在<code>std::thread</code>实例之间(t1，t2和t3)转移所有权：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_function</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_other_function</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(some_function)</span></span>;            <span class="comment">// 1</span></span><br><span class="line">std::thread t2=std::<span class="built_in">move</span>(t1);            <span class="comment">// 2</span></span><br><span class="line">t1=std::<span class="built_in">thread</span>(some_other_function);    <span class="comment">// 3</span></span><br><span class="line">t1=std::<span class="built_in">move</span>(t3);                        <span class="comment">// 6 赋值操作将使程序崩溃</span></span><br></pre></td></tr></table></figure>
<p>首先，新线程与t1相关联①。当显式使用<code>std::move()</code>创建t2后②，t1的所有权就转移给了t2。之后，t1和执行线程已经没有关联了，执行some_function的函数线程与t2关联。</p>
<p>然后，临时<code>std::thread</code>对象相关的线程启动了③。为什么不显式调用<code>std::move()</code>转移所有权呢？因为，所有者是一个临时对象——移动操作将会隐式的调用。</p>
<p>最后一个移动操作，将some_function线程的所有权转移⑥给t1。不过，t1已经有了一个关联的线程(执行some_other_function的线程)，所以这里系统直接调用<code>std::terminate()</code>终止程序继续运行。这样做(不抛出异常，<code>std::terminate()</code>是<a
target="_blank" rel="noopener" href="http://www.baidu.com/link?url=5JjyAaqAzTTXfKVx1iXU2L1aR__8o4wfW4iotLW1BiUCTzDHjbGcX7Qx42FOcd0K4xe2MDFgL5r7BCiVClXCDq"><em>noexcept</em></a>函数)是为了保证与<code>std::thread</code>的析构函数的行为一致。之前提到，需要在线程对象析构前，显式的等待线程完成，或者分离它；进行赋值时也需要满足这些条件(说明：不能通过赋新值给<code>std::thread</code>对象的方式来"丢弃"一个线程)。</p>
<h3 id="确定线程数量">确定线程数量</h3>
<p><code>std::thread::hardware_concurrency()</code>在新版C++中非常有用，其会返回并发线程的数量。例如，多核系统中，返回值可以是CPU核芯的数量。返回值也仅仅是一个标识，当无法获取时，函数返回0。</p>
<h3 id="线程标识">线程标识</h3>
<p>线程标识为<code>std::thread::id</code>类型，可以通过两种方式进行检索。第一种，可以通过调用<code>std::thread</code>对象的成员函数<code>get_id()</code>来直接获取。如果<code>std::thread</code>对象没有与任何执行线程相关联，<code>get_id()</code>将返回<code>std::thread::type</code>默认构造值，这个值表示“无线程”。第二种，当前线程中调用<code>std::this_thread::get_id()</code>(这个函数定义在<code>&lt;thread&gt;</code>头文件中)也可以获得线程标识。</p>
<p>开发者可以将其当做为容器的键值做排序，或做其他比较。按默认顺序比较不同的<code>std::thread::id</code>：当<code>a&lt;b</code>，<code>b&lt;c</code>时，得<code>a&lt;c</code>，等等。标准库也提供<code>std::hash&lt;std::thread::id&gt;</code>容器，<code>std::thread::id</code>也可以作为无序容器的键值。</p>
<h1 id="第三章-共享数据">第三章 共享数据</h1>
<h2 id="互斥量">互斥量</h2>
<h3 id="mutex-lock_guard">mutex &amp;&amp; lock_guard</h3>
<p>是<strong>mu</strong>tual
<strong>ex</strong>clusion（互斥）的简写。</p>
<p>通过实例化<code>std::mutex</code>创建互斥量实例，成员函数lock()可对互斥量上锁，unlock()为解锁。不过，不推荐直接去调用成员函数，调用成员函数就意味着，必须在每个函数出口都要去调用unlock()(包括异常的情况)。C++标准库为互斥量提供了RAII模板类<code>std::lock_guard</code>，在构造时就能提供已锁的互斥量，并在析构时进行解锁，从而保证了互斥量能被正确解锁。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::list&lt;<span class="type">int</span>&gt; some_list;    <span class="comment">// 1</span></span><br><span class="line">std::mutex some_mutex;    <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_list</span><span class="params">(<span class="type">int</span> new_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(some_mutex)</span></span>;    <span class="comment">// 3</span></span><br><span class="line">  some_list.<span class="built_in">push_back</span>(new_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++17中添加了一个新特性，称为模板类参数推导，类似<code>std::lock_guard</code>这样简单的模板类型，其模板参数列表可以省略。③和④的代码可以简化成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::lock_guard <span class="title">guard</span><span class="params">(some_mutex)</span></span>;</span><br></pre></td></tr></table></figure>
<p>具体的模板参数类型推导则交给C++17的编译器完成。</p>
<h3 id="stdlock-stdscope_lock"><code>std::lock</code> &amp;&amp;
<code>std::scope_lock</code></h3>
<p><code>std::lock</code>——可以一次性锁住多个(两个以上)的互斥量，并且没有死锁风险。下面的程序代码中，就来看一下怎么在一个简单的交换操作中使用<code>std::lock</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">some_big_object</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(some_big_object&amp; lhs,some_big_object&amp; rhs)</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  some_big_object some_detail;</span><br><span class="line">  std::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">X</span>(some_big_object <span class="type">const</span>&amp; sd):<span class="built_in">some_detail</span>(sd)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;lhs==&amp;rhs)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    std::<span class="built_in">lock</span>(lhs.m,rhs.m); <span class="comment">// 1</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_a</span><span class="params">(lhs.m,std::adopt_lock)</span></span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_b</span><span class="params">(rhs.m,std::adopt_lock)</span></span>; <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">swap</span>(lhs.some_detail,rhs.some_detail);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先检查参数，避免同时多次获取同一把锁。然后，调用<code>std::lock()</code>①锁住两个互斥量，并且创建两个<code>std:lock_guard</code>实例②③。提供<code>std::adopt_lock</code>参数默认当前线程已经获得锁，将锁交由<code>std::lock_guard</code>管理；这样，就能保证在大多数情况下，函数退出时mutex能解锁。</p>
<p>。当使用<code>std::lock</code>去锁lhs.m或rhs.m时，可能会抛出异常，异常会传播到<code>std::lock</code>之外。当<code>std::lock</code>获取互斥锁时，并尝试从另一个互斥量上再获取锁时，就会有异常抛出，第一个锁也会随着异常而自动释放，所以<code>std::lock</code>要么将两个锁都锁住，要不一个都不锁。</p>
<p>C++17对这种情况提供了支持，<code>std::scoped_lock&lt;&gt;</code>是一种新的RAII模板类型，与<code>std::lock_guard&lt;&gt;</code>的功能相同，这个新类型能接受不定数量的互斥量类型作为模板参数，以及相应的互斥量(数量和类型)作为构造参数。互斥量支持构造时上锁，与<code>std::lock</code>的用法相同，解锁在析构中进行。因此上述swap()操作可以重写如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(&amp;lhs==&amp;rhs)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="function">std::scoped_lock <span class="title">guard</span><span class="params">(lhs.m,rhs.m)</span></span>; <span class="comment">// 1 C++17自动推导模板参数</span></span><br><span class="line">  <span class="built_in">swap</span>(lhs.some_detail,rhs.some_detail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3
id="避免死锁的设计层次锁hierarchical_mutex">避免死锁的设计：层次锁<code>hierarchical_mutex</code></h3>
<h4 id="设计思想">设计思想</h4>
<p>层次锁有三个成员变量，<code>std::mutex</code>，该层次锁的层级值以及上锁之前线程的层级值。</p>
<p>使用thread_local变量保存当前线程的层级值。</p>
<p>当线程的层级值大于锁的层级值时，可以上锁。上锁成功后，更新线程的层级值，并将旧的线程层级值保存在锁中。每次解锁时，需要检查线程的层级值是否与锁的层级值相等，必须相等才能解锁；这样保证了解锁的有序性；同时，解锁成功后，恢复线程的层级值为获取该锁之前的线程层级值。</p>
<p>实现三个成员函数：lock(), unlock() 和
try_lock()。这样层次锁<code>hierarchical_mutex</code>就可以和<code>std::lock_guard&lt;&gt;</code>模板一起使用。（符合模板的萃取要求即可）</p>
<h4 id="代码实现">代码实现</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hierarchical_mutex</span></span><br><span class="line">&#123;</span><br><span class="line">  std::mutex internal_mutex;</span><br><span class="line">  </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> hierarchy_value;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> previous_hierarchy_value;</span><br><span class="line">  </span><br><span class="line">  <span class="type">static</span> <span class="keyword">thread_local</span> <span class="type">unsigned</span> <span class="type">long</span> this_thread_hierarchy_value;  <span class="comment">// 1</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">check_for_hierarchy_violation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(this_thread_hierarchy_value &lt;= hierarchy_value)  <span class="comment">// 2</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(“mutex hierarchy violated”);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">update_hierarchy_value</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    previous_hierarchy_value=this_thread_hierarchy_value;  <span class="comment">// 3</span></span><br><span class="line">    this_thread_hierarchy_value=hierarchy_value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">hierarchical_mutex</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> value)</span>:</span></span><br><span class="line"><span class="function">      hierarchy_value(value),</span></span><br><span class="line"><span class="function">      previous_hierarchy_value(<span class="number">0</span>)</span></span><br><span class="line"><span class="function">  &#123;</span>&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">check_for_hierarchy_violation</span>();</span><br><span class="line">    internal_mutex.<span class="built_in">lock</span>();  <span class="comment">// 4</span></span><br><span class="line">    <span class="built_in">update_hierarchy_value</span>();  <span class="comment">// 5</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(this_thread_hierarchy_value!=hierarchy_value)</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(“mutex hierarchy violated”);  <span class="comment">// 9</span></span><br><span class="line">    this_thread_hierarchy_value=previous_hierarchy_value;  <span class="comment">// 6</span></span><br><span class="line">    internal_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">try_lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">check_for_hierarchy_violation</span>();</span><br><span class="line">    <span class="keyword">if</span>(!internal_mutex.<span class="built_in">try_lock</span>())  <span class="comment">// 7</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">update_hierarchy_value</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">thread_local</span> <span class="type">unsigned</span> <span class="type">long</span></span></span><br><span class="line"><span class="function">     <span class="title">hierarchical_mutex::this_thread_hierarchy_value</span><span class="params">(ULONG_MAX)</span></span>;  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<h3
id="stdunique_lock灵活的锁"><code>std::unique_lock</code>——灵活的锁</h3>
<p><code>std::unique_lock</code>实例的体积通常要比<code>std::lock_guard</code>实例大，当使用<code>std::unique_lock</code>替代<code>std::lock_guard</code>，会对标志进行更新或检查，就会有一些轻微的性能惩罚。当<code>std::lock_guard</code>已经能够满足需求时，建议继续使用。</p>
<p>当需要更加灵活的锁时，最好选择<code>std::unique_lock</code>，因为它更适合于你的任务。首先，可将<code>std::adopt_lock</code>作为第二个参数传入构造函数，对互斥量进行管理。也可以将<code>std::defer_lock</code>作为第二个参数传递进去，表明互斥量应保持解锁状态。这样就可以让<code>std::unique_lock</code>对象(不是互斥量)的lock()所获取，或传递<code>std::unique_lock</code>对象到<code>std::lock()</code>中。示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">some_big_object</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(some_big_object&amp; lhs,some_big_object&amp; rhs)</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  some_big_object some_detail;</span><br><span class="line">  std::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">X</span>(some_big_object <span class="type">const</span>&amp; sd):<span class="built_in">some_detail</span>(sd)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;lhs==&amp;rhs)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock_a</span><span class="params">(lhs.m,std::defer_lock)</span></span>; <span class="comment">// 1 </span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock_b</span><span class="params">(rhs.m,std::defer_lock)</span></span>; <span class="comment">// 1 std::defer_lock 留下未上锁的互斥量</span></span><br><span class="line">    std::<span class="built_in">lock</span>(lock_a,lock_b); <span class="comment">// 2 互斥量在这里上锁</span></span><br><span class="line">    <span class="built_in">swap</span>(lhs.some_detail,rhs.some_detail);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>std::unique_lock</code>是可移动，但不可赋值的类型。</p>
<p>另一种使用可能是允许函数去锁住一个互斥量，并且将所有权移到调用者上，所以调用者可以在这个锁保护的范围内执行额外的动作。</p>
<p>下面的程序片段展示了：函数get_lock()锁住了互斥量，然后准备数据，返回锁的调用函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">get_lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">extern</span> std::mutex some_mutex;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(some_mutex)</span></span>;</span><br><span class="line">  <span class="built_in">prepare_data</span>();</span><br><span class="line">  <span class="keyword">return</span> lk;  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(get_lock())</span></span>;  <span class="comment">// 2</span></span><br><span class="line">  <span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lk在函数中被声明为自动变量，它不需要调用<code>std::move()</code>，可以直接返回①(编译器负责调用移动构造函数)。process_data()函数直接转移<code>std::unique_lock</code>实例的所有权②，调用do_something()可使用的正确数据(数据没有受到其他线程的修改)。</p>
<p><code>std::unique_lock</code>的灵活性同样也允许实例在销毁之前放弃拥有的锁。可以使用unlock()来做这件事.</p>
<h2 id="保护共享数据">保护共享数据</h2>
<h3 id="保护共享数据的初始化过程">保护共享数据的初始化过程</h3>
<p>假设有一个共享源，构建代价很昂贵，它可能会打开一个数据库连接或分配出很多的内存。</p>
<p>延迟初始化(Lazy
initialization)在单线程代码很常见——每一个操作都需要先对源进行检查，为了了解数据是否被初始化，然后在其使用前决定，数据是否需要初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;some_resource&gt; resource_ptr;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!resource_ptr)</span><br><span class="line">  &#123;</span><br><span class="line">    resource_ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> some_resource);  <span class="comment">// 1</span></span><br><span class="line">  &#125;</span><br><span class="line">  resource_ptr-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转为多线程代码时，只有①处需要保护，这样共享数据对于并发访问就是安全的。</p>
<h4 id="方案一-naive">方案一 ： naive</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;some_resource&gt; resource_ptr;</span><br><span class="line">std::mutex resource_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(resource_mutex)</span></span>;  <span class="comment">// 所有线程在此序列化 </span></span><br><span class="line">  <span class="keyword">if</span>(!resource_ptr)</span><br><span class="line">  &#123;</span><br><span class="line">    resource_ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> some_resource);  <span class="comment">// 只有初始化过程需要保护 </span></span><br><span class="line">  &#125;</span><br><span class="line">  lk.<span class="built_in">unlock</span>();</span><br><span class="line">  resource_ptr-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会导致没必要的序列化，影响性能。</p>
<h4 id="方案二双重检查锁">方案二：双重检查锁</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">undefined_behaviour_with_double_checked_locking</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!resource_ptr)  <span class="comment">// 1</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(resource_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!resource_ptr)  <span class="comment">// 2</span></span><br><span class="line">    &#123;</span><br><span class="line">      resource_ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> some_resource);  <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  resource_ptr-&gt;<span class="built_in">do_something</span>();  <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个模式为什么声名狼藉呢？因为有潜在的条件竞争。未被锁保护的读取操作①没有与其他线程里被锁保护的写入操作③进行同步，因此就会产生条件竞争，这个条件竞争不仅覆盖指针本身，还会影响到其指向的对象；即使一个线程知道另一个线程完成对指针进行写入，它可能没有看到新创建的some_resource实例，然后调用do_something()④后，得到不正确的结果。</p>
<h4
id="方案三推荐stdcall_once">方案三（推荐）：<code>std::call_once</code></h4>
<p>C++标准库提供了<code>std::once_flag</code>和<code>std::call_once</code>来处理这种情况。比起锁住互斥量并显式的检查指针，每个线程只需要使用<code>std::call_once</code>就可以，在<code>std::call_once</code>的结束时，就能安全的知晓指针已经被其他的线程初始化了。使用<code>std::call_once</code>比显式使用互斥量消耗的资源更少，特别是当初始化完成后。下面的例子展示了与代码3.11中的同样的操作，这里使用了<code>std::call_once</code>。这种情况下，初始化通过调用函数完成，这样的操作使用类中的函数操作符来实现同样很简单。如同大多数在标准库中的函数一样，或作为函数被调用，或作为参数被传递，<code>std::call_once</code>可以和任何函数或可调用对象一起使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;some_resource&gt; resource_ptr;</span><br><span class="line">std::once_flag resource_flag;  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_resource</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  resource_ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> some_resource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::<span class="built_in">call_once</span>(resource_flag,init_resource);  <span class="comment">// 可以完整的进行一次初始化</span></span><br><span class="line">  resource_ptr-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中，<code>std::once_flag</code>①和初始化好的数据都是命名空间区域的对象.</p>
<p>值得注意的是，<code>std::mutex</code>和<code>std::once_flag</code>的实例不能拷贝和移动，需要通过显式定义相应的成员函数，对这些类成员进行操作。</p>
<h4 id="方案四推荐static局部变量">方案四（推荐）：static局部变量</h4>
<p>在C++11标准中：初始化及定义完全在一个线程中发生，并且没有其他线程可在初始化完成前对其进行处理，条件竞争终止于初始化阶段。在只需要一个全局实例情况下，这里提供一个<code>std::call_once</code>的替代方案</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">my_class</span>;</span><br><span class="line"><span class="function">my_class&amp; <span class="title">get_my_class_instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">static</span> my_class instance;  <span class="comment">// 线程安全的初始化过程</span></span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多线程可以安全的调用get_my_class_instance()①函数，不用为数据竞争而担心。</p>
<h2 id="保护不常更新的数据结构----读写锁">保护不常更新的数据结构 --
读写锁</h2>
<p>C++17标准库提供了两种非常好的互斥量——<code>std::shared_mutex</code>和<code>std::shared_timed_mutex</code>。</p>
<p>C++14只提供了<code>std::shared_timed_mutex</code>，并且在C++11中并未提供任何互斥量类型</p>
<p><code>std::shared_mutex</code>和<code>std::shared_timed_mutex</code>的不同点在于，<code>std::shared_timed_mutex</code>支持更多的操作方式，<code>std::shared_mutex</code>有更高的性能优势，但支持的操作较少。</p>
<p>可以使用<code>std::lock_guard&lt;std::shared_mutex&gt;</code>和<code>std::unique_lock&lt;std::shared_mutex&gt;</code>上锁。作为<code>std::mutex</code>的替代方案，与<code>std::mutex</code>所做的一样，这就能保证更新线程的独占访问。那些无需修改数据结构的线程，可以使用<code>std::shared_lock&lt;std::shared_mutex&gt;</code>获取访问权。</p>
<h3 id="stdrecursive_mutex"><code>std::recursive_mutex</code></h3>
<p>C++标准库提供了<code>std::recursive_mutex</code>类。除了可以在同一线程的单个实例上多次上锁，其他功能与<code>std::mutex</code>相同。其他线程对互斥量上锁前，当前线程必须释放拥有的所有锁，所以如果你调用lock()三次，也必须调用unlock()三次。正确使用<code>std::lock_guard&lt;std::recursive_mutex&gt;</code>和<code>std::unique_lock&lt;std::recursive_mutex&gt;</code>可以帮你处理这些问题。</p>
<p>使用嵌套锁时，要对代码设计进行改动。嵌套锁一般用在可并发访问的类上，所以使用互斥量保护其成员数据。每个公共成员函数都会对互斥量上锁，然后完成对应的操作后再解锁互斥量。不过，有时成员函数会调用另一个成员函数，这种情况下，第二个成员函数也会试图锁住互斥量，这就会导致未定义行为的发生。“变通的”解决方案会将互斥量转为嵌套锁，第二个成员函数就能成功的进行上锁，并且函数能继续执行。</p>
<p>但是这种方式过于草率和不合理，所以<strong>不推荐</strong>这样的使用方式。特别是，对应类的不变量通常会被破坏。这意味着，当不变量被破坏时，第二个成员函数还需要继续执行。一个比较好的方式是，从中提取出一个函数作为类的私有成员，这个私有成员函数不会对互斥量进行上锁(调用前必须获得锁)。然后，需要仔细考虑一下，这种情况调用新函数时数据的状态。</p>
<h1 id="第四章-同步操作">第四章 同步操作</h1>
<h2 id="条件变量">条件变量</h2>
<p>C++标准库对条件变量有两套实现：<code>std::condition_variable</code>和<code>std::condition_variable_any</code>，这两个实现都包含在<code>&lt;condition_variable&gt;</code>头文件的声明中。两者都需要与互斥量一起才能工作(互斥量是为了同步)，前者仅能与<code>std::mutex</code>一起工作，而后者可以和合适的互斥量一起工作，从而加上了<code>_any</code>的后缀。因为<code>std::condition_variable_any</code>更加通用，不过在性能和系统资源的使用方面会有更多的开销，所以通常会将<code>std::condition_variable</code>作为首选类型。当对灵活性有要求时，才会考虑<code>std::condition_variable_any</code>。</p>
<p>以下代码展示了使用条件变量唤醒线程的方式。</p>
<p>代码4.1 使用<code>std::condition_variable</code>处理数据等待</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mut;</span><br><span class="line">std::queue&lt;data_chunk&gt; data_queue;  <span class="comment">// 1</span></span><br><span class="line">std::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">data_preparation_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">more_data_to_prepare</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    data_chunk <span class="type">const</span> data=<span class="built_in">prepare_data</span>();</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    data_queue.<span class="built_in">push</span>(data);  <span class="comment">// 2</span></span><br><span class="line">    data_cond.<span class="built_in">notify_one</span>();  <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">data_processing_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;  <span class="comment">// 4</span></span><br><span class="line">    data_cond.<span class="built_in">wait</span>(</span><br><span class="line">         lk,[]&#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);  <span class="comment">// 5</span></span><br><span class="line">    data_chunk data=data_queue.<span class="built_in">front</span>();</span><br><span class="line">    data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    lk.<span class="built_in">unlock</span>();  <span class="comment">// 6</span></span><br><span class="line">    <span class="built_in">process</span>(data);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">is_last_chunk</span>(data))</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，队列中中有两个线程，两个线程之间会对数据进行传递①。数据准备好时，使用<code>std::lock_guard</code>锁定队列，将准备好的数据压入队列②之后，线程会对队列中的数据上锁，并调用<code>std::condition_variable</code>的notify_one()成员函数，对等待的线程(如果有等待线程)进行通知③。</p>
<p>另外的一个线程正在处理数据，线程首先对互斥量上锁(这里使用<code>std::unique_lock</code>要比<code>std::lock_guard</code>④更加合适)。之后会调用<code>std::condition_variable</code>的成员函数wait()，传递一个锁和一个Lambda表达式(作为等待的条件⑤)。</p>
<p>wait()会去检查这些条件(通过Lambda函数)，当条件满足(Lambda函数返回true)时返回。如果条件不满足(Lambda函数返回false)，wait()将解锁互斥量，并且将线程(处理数据的线程)置于阻塞或等待状态。当准备数据的线程调用notify_one()通知条件变量时，处理数据的线程从睡眠中苏醒，重新获取互斥锁，并且再次进行条件检查。在条件满足的情况下，从wait()返回并继续持有锁。当条件不满足时，线程将对互斥量解锁，并重新等待。这就是为什么用<code>std::unique_lock</code>而不使用<code>std::lock_guard</code>的原因——等待中的线程必须在等待期间解锁互斥量，并对互斥量再次上锁，而<code>std::lock_guard</code>没有这么灵活。</p>
<p>调用wait()的过程中，在互斥量锁定时，可能会去检查条件变量若干次，当提供测试条件的函数返回true就会立即返回。当等待线程重新获取互斥量并检查条件变量时，并非直接响应另一个线程的通知，就是所谓的<em>伪唤醒</em>(spurious
wakeup)。</p>
<p>本质上，<code>std::condition_variable::wait</code>是“忙碌-等待”的优化。下面用简单的循环实现了一个“忙碌-等待”：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Predicate&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">minimal_wait</span><span class="params">(std::unique_lock&lt;std::mutex&gt;&amp; lk, Predicate pred)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!<span class="built_in">pred</span>())&#123;</span><br><span class="line">    lk.<span class="built_in">unlock</span>();</span><br><span class="line">    lk.<span class="built_in">lock</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为wait()准备一个最小化实现，只需要notify_one()或notify_all()。</p>
<p><code>std::unique_lock</code>的灵活性，不仅适用于对wait()的调用，还可以用于待处理的数据⑥。处理数据可能是耗时的操作，并且长时间持有锁是个糟糕的主意。</p>
<hr />
<h2 id="future"><code>future</code></h2>
<p>假设你要乘飞机去国外度假，当到达机场办理完各种登机手续后，还需要等待机场广播通知登机。这段时间内，你可能会在候机室里面找一些事情来打发时间，比如：读书，上网，或者来一杯咖啡。不过，你就在等待一件事情：机场广播通知登机。</p>
<p>C++标准库将这种事件称为future。当线程需要等待特定事件时，某种程度上来说就需要知道期望的结果。之后，线程会周期性(较短的周期)的等待或检查事件是否触发(检查信息板)，检查期间也会执行其他任务(品尝昂贵的咖啡)。另外，等待任务期间也可以先执行另外的任务，直到对应的任务触发，而后等待future的状态会变为就绪状态。future可能是和数据相关(比如，登机口编号)，也可能不是。当事件发生时(状态为就绪)，这个future就不能重置了。</p>
<p>C++标准库中有两种future，声明在<code>&lt;future&gt;</code>头文件中:
unique future(<code>std::future&lt;&gt;</code>)和shared
futures(<code>std::shared_future&lt;&gt;</code>)，与了<code>std::unique_ptr</code>和<code>std::shared_ptr</code>非常类似。<code>std::future</code>只能与指定事件相关联，而<code>std::shared_future</code>就能关联多个事件。后者的实现中，所有实例会在同时变为就绪状态，并且可以访问与事件相关的数据。这种关联与模板有关，比如<code>std::unique_ptr</code>
和<code>std::shared_ptr</code>的模板参数就是相关的数据类型。与数据无关处的，可以使用<code>std::future&lt;void&gt;</code>与<code>std::shared_future&lt;void&gt;</code>的特化模板。虽然，我倾向于线程通讯，但future对象本身并不提供同步访问。当多个线程需要访问一个独立future对象时，必须使用互斥量或类似同步机制进行保护。不过，当多个线程对一个<code>std::shared_future&lt;&gt;</code>副本进行访问，即使同一个异步结果，也不需要同步future。</p>
<h3 id="后台任务的返回值">后台任务的返回值</h3>
<p>假设有一个需要长时间的运算，需要计算出一个有效值，但并不迫切需要这个值。你可以启动新线程来执行这个计算，你需要计算的结果，而<code>std::thread</code>并不提供直接接收返回值的机制。这里就需要<code>std::async</code>函数模板(也是在头文件<code>&lt;future&gt;</code>)。</p>
<p>当不着急让任务结果时，可以使用<code>std::async</code>启动一个异步任务。与<code>std::thread</code>对象等待的方式不同，<code>std::async</code>会返回一个<code>std::future</code>对象，这个对象持有最终计算出来的结果。当需要这个值时，只需要调用这个对象的get()成员函数，就会阻塞线程直到future为就绪为止，并返回计算结果。</p>
<p>代码4.6 <code>std::future</code>从异步任务中获取返回值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_the_answer_to_ltuae</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_other_stuff</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::future&lt;<span class="type">int</span>&gt; the_answer=std::<span class="built_in">async</span>(find_the_answer_to_ltuae);</span><br><span class="line">  <span class="built_in">do_other_stuff</span>();</span><br><span class="line">  std::cout&lt;&lt;<span class="string">&quot;The answer is &quot;</span>&lt;&lt;the_answer.<span class="built_in">get</span>()&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与<code>std::thread</code>方式一样，<code>std::async</code>允许通过添加额外的调用参数，向函数传递额外的参数。第一个参数是指向成员函数的指针，第二个参数提供这个函数成员类的具体对象(是通过指针，也可以包装在<code>std::ref</code>中)，剩余的参数可作为函数的参数传入。否则，第二个和随后的参数将作为函数的参数，或作为指定可调用对象的第一个参数。和<code>std::thread</code>一样，当参数为右值时，拷贝操作将使用移动的方式转移原始数据，就可以使用“只移动”类型作为函数对象和参数。</p>
<p>代码4.7 使用<code>std::async</code>向函数传递参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>,std::string <span class="type">const</span>&amp;)</span></span>;</span><br><span class="line">  <span class="function">std::string <span class="title">bar</span><span class="params">(std::string <span class="type">const</span>&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">X x;</span><br><span class="line"><span class="keyword">auto</span> f1=std::<span class="built_in">async</span>(&amp;X::foo,&amp;x,<span class="number">42</span>,<span class="string">&quot;hello&quot;</span>);  <span class="comment">// 调用p-&gt;foo(42, &quot;hello&quot;)，p是指向x的指针</span></span><br><span class="line"><span class="keyword">auto</span> f2=std::<span class="built_in">async</span>(&amp;X::bar,x,<span class="string">&quot;goodbye&quot;</span>);  <span class="comment">// 调用tmpx.bar(&quot;goodbye&quot;)， tmpx是x的拷贝副本</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Y</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Y y;</span><br><span class="line"><span class="keyword">auto</span> f3=std::<span class="built_in">async</span>(<span class="built_in">Y</span>(),<span class="number">3.141</span>);  <span class="comment">// 调用tmpy(3.141)，tmpy通过Y的移动构造函数得到</span></span><br><span class="line"><span class="keyword">auto</span> f4=std::<span class="built_in">async</span>(std::<span class="built_in">ref</span>(y),<span class="number">2.718</span>);  <span class="comment">// 调用y(2.718)</span></span><br><span class="line"><span class="function">X <span class="title">baz</span><span class="params">(X&amp;)</span></span>;</span><br><span class="line">std::<span class="built_in">async</span>(baz,std::<span class="built_in">ref</span>(x));  <span class="comment">// 调用baz(x)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">move_only</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">move_only</span>();</span><br><span class="line">  <span class="built_in">move_only</span>(move_only&amp;&amp;)</span><br><span class="line">  <span class="built_in">move_only</span>(move_only <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  move_only&amp; <span class="keyword">operator</span>=(move_only&amp;&amp;);</span><br><span class="line">  move_only&amp; <span class="keyword">operator</span>=(move_only <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> f5=std::<span class="built_in">async</span>(<span class="built_in">move_only</span>());  <span class="comment">// 调用tmp()，tmp是通过std::move(move_only())构造得到</span></span><br></pre></td></tr></table></figure>
<p>future的等待取决于<code>std::async</code>是否启动一个线程，或是否有任务在进行同步。大多数情况下，也可以在函数调用之前向<code>std::async</code>传递一个额外参数，这个参数的类型是<code>std::launch</code>，还可以是<code>std::launch::defered</code>，表明函数调用延迟到wait()或get()函数调用时才执行，<code>std::launch::async</code>表明函数必须在其所在的独立线程上执行，<code>std::launch::deferred | std::launch::async</code>表明实现可以选择这两种方式的一种。最后一个选项是默认的，当函数调用延迟，就可能不会再运行了。如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f6=std::<span class="built_in">async</span>(std::launch::async,<span class="built_in">Y</span>(),<span class="number">1.2</span>);  <span class="comment">// 在新线程上执行</span></span><br><span class="line"><span class="keyword">auto</span> f7=std::<span class="built_in">async</span>(std::launch::deferred,baz,std::<span class="built_in">ref</span>(x));  <span class="comment">// 在wait()或get()调用时执行</span></span><br><span class="line"><span class="keyword">auto</span> f8=std::<span class="built_in">async</span>(</span><br><span class="line">              std::launch::deferred | std::launch::async,</span><br><span class="line">              baz,std::<span class="built_in">ref</span>(x));  <span class="comment">// 实现选择执行方式</span></span><br><span class="line"><span class="keyword">auto</span> f9=std::<span class="built_in">async</span>(baz,std::<span class="built_in">ref</span>(x));</span><br><span class="line">f7.<span class="built_in">wait</span>();  <span class="comment">//  调用延迟函数</span></span><br></pre></td></tr></table></figure>
<h3 id="future与任务关联">4.2.2 future与任务关联</h3>
<p><code>std::packaged_task&lt;&gt;</code>会将future与函数或可调用对象进行绑定。当调用<code>std::packaged_task&lt;&gt;</code>对象时，就会调用相关函数或可调用对象，当future状态为就绪时，会存储返回值。这可以用在构建线程池(可见第9章)或其他任务的管理中，比如：在任务所在线程上运行其他任务，或将它们串行运行在一个特殊的后台线程上。当粒度较大的操作被分解为独立的子任务时，每个子任务都可以包含在<code>std::packaged_task&lt;&gt;</code>实例中，之后将实例传递到任务调度器或线程池中。对任务细节进行抽象，调度器仅处理<code>std::packaged_task&lt;&gt;</code>实例，而非处理单独的函数。</p>
<p><code>std::packaged_task&lt;&gt;</code>的模板参数是一个函数签名。构造<code>std::packaged_task&lt;&gt;</code>实例时，就必须传入函数或可调用对象。</p>
<p>函数签名的返回类型可以用来标识从get_future()返回的<code>std::future&lt;&gt;</code>的类型，而函数签名的参数列表，可用来指定packaged_task的函数调用操作符。例如，模板偏特化<code>std::packaged_task&lt;std::string(std::vector&lt;char&gt;*,int)&gt;</code>会在下面的代码中使用到。</p>
<p>代码4.8 <code>std::packaged_task&lt;&gt;</code>的偏特化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">packaged_task</span>&lt;std::<span class="built_in">string</span>(std::vector&lt;<span class="type">char</span>&gt;*,<span class="type">int</span>)&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Callable&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">explicit</span> <span class="title">packaged_task</span><span class="params">(Callable&amp;&amp; f)</span></span>;</span><br><span class="line">  <span class="function">std::future&lt;std::string&gt; <span class="title">get_future</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(std::vector&lt;<span class="type">char</span>&gt;*,<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>std::packaged_task</code>是个可调用对象，可以封装在<code>std::function</code>对象中，从而作为线程函数传递到<code>std::thread</code>对象中，或作为可调用对象传递到另一个函数中或直接调用。当<code>std::packaged_task</code>作为函数调用时，实参将由函数调用操作符传递至底层函数，并且返回值作为异步结果存储在<code>std::future</code>中，并且可通过get_future()获取。因此可以用<code>std::packaged_task</code>对任务进行打包，并适时的取回future。当异步任务需要返回值时，可以等待future状态变为“就绪”。</p>
<p><strong>线程间传递任务</strong></p>
<p>很多图形架构需要特定的线程去更新界面，所以当线程对界面更新时，需要发出一条信息给正确的线程，让相应的线程来做界面更新。<code>std::packaged_task</code>提供了这种功能，且不需要发送一条自定义信息给图形界面线程。</p>
<p>代码4.9 使用<code>std::packaged_task</code>执行一个图形界面线程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex m;</span><br><span class="line">std::deque&lt;std::packaged_task&lt;<span class="type">void</span>()&gt; &gt; tasks;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">gui_shutdown_message_received</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_and_process_gui_message</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gui_thread</span><span class="params">()</span>  <span class="comment">// 1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!<span class="built_in">gui_shutdown_message_received</span>())  <span class="comment">// 2</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">get_and_process_gui_message</span>();  <span class="comment">// 3</span></span><br><span class="line">    std::packaged_task&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">      <span class="keyword">if</span>(tasks.<span class="built_in">empty</span>())  <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      task=std::<span class="built_in">move</span>(tasks.<span class="built_in">front</span>());  <span class="comment">// 5</span></span><br><span class="line">      tasks.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">task</span>();  <span class="comment">// 6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">gui_bg_thread</span><span class="params">(gui_thread)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func&gt;</span></span><br><span class="line"><span class="function">std::future&lt;<span class="type">void</span>&gt; <span class="title">post_task_for_gui_thread</span><span class="params">(Func f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::packaged_task&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(f)</span></span>;  <span class="comment">// 7</span></span><br><span class="line">  std::future&lt;<span class="type">void</span>&gt; res=task.<span class="built_in">get_future</span>();  <span class="comment">// 8</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">  tasks.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(task));  <span class="comment">// 9</span></span><br><span class="line">  <span class="keyword">return</span> res; <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码十分简单：图形界面线程①循环直到收到一条关闭图形界面的信息后关闭界面②。关闭界面前，进行轮询界面消息处理③，例如：用户点击和执行在队列中的任务。当队列中没有任务④时，循环将继续。除非能在队列中提取出一个任务⑤，释放队列上的锁，并且执行任务⑥。这里future与任务相关，当任务执行完时，其状态会置为“就绪”。</p>
<p>将任务传入队列：提供的函数⑦可以提供一个打包好的任务，通过这个任务⑧调用get_future()成员函数获取future对象，并且在任务推入列表⑨之前，future将返回调用函数⑩。</p>
<p>例子中使用<code>std::packaged_task&lt;void()&gt;</code>创建任务，其中包含了一个无参数无返回值的函数或可调用对象(如果当这个调用有返回值时，返回值会被丢弃)。这可能是最简单的任务，<code>std::packaged_task</code>也可以用于复杂的情况——通过指定不同的函数签名作为模板参数，不仅可以改变其返回类型(因此该类型的数据会存在期望相关的状态中)，也可以改变函数操作符的参数类型。这个例子可以简单的扩展成允许任务运行在图形界面线程上，并且接受传参，还可以通过<code>std::future</code>获取返回值。</p>
<p>这些任务能作为简单的函数调用来表达吗？还有，任务的结果能从很多地方得到吗？这些问题可以使用第三种方法创建future来解决：使用<code>std::promise</code>对值进行显示设置。</p>
<h3 id="使用stdpromises">4.2.3 使用<code>std::promises</code></h3>
<p>当需要处理很多网络连接时，会使用不同线程尝试连接每个接口，能使网络尽早联通。不幸的是，随着连接数量的增长，这种方式变的越来越不合适。因为大量的线程会消耗大量的系统资源，还有可能造成线程上下文频繁切换(当线程数量超出硬件可接受的并发数时)，这都会对性能有影响。最极端的例子：线程会将系统资源消耗殆尽，系统连接网络的能力会变的极差。因此通过少数线程处理网络连接，每个线程同时处理多个连接，对需要处理大量网络连接的应用而言，这是一种比较普遍的做法。</p>
<p>当线程处理多个连接事件，来自不同的端口连接的数据包基本上以乱序方式进行处理。同样的，数据包也将以乱序的方式进入队列。很多情况下，一些应用不是等待数据成功的发送，就是等待(新的)指定网络接口数据的接收成功。</p>
<p><code>std::promise&lt;T&gt;</code>提供设定值的方式(类型为T)，这个类型会和后面看到的<code>std::future&lt;T&gt;</code>对象相关联。<code>std::promise/std::future</code>对提供一种机制：future可以阻塞等待线程，提供数据的线程可以使用promise对相关值进行设置，并将future的状态置为“就绪”。</p>
<p>可以通过给定的<code>std::promise</code>的get_future()成员函数来获取与之相关的<code>std::future</code>对象，与<code>std::packaged_task</code>的用法类似。当promise设置完毕(使用set_value()成员函数)时，对应的future状态就变为“就绪”，并且可用于检索已存储的值。当设置值之前销毁<code>std::promise</code>，将会存储一个异常。在4.2.4节中，会详细描述异常是如何传送到线程的。</p>
<p>代码4.10中是单线程处理多接口的实现，这个例子中，可以使用一对<code>std::promise&lt;bool&gt;/std::future&lt;bool&gt;</code>找出传出成功的数据块，与future相关的只是简单的“成功/失败”标识。对于传入包，与future相关的数据就是数据包的有效负载。</p>
<p>代码4.10 使用promise解决单线程多连接问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_connections</span><span class="params">(connection_set&amp; connections)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!<span class="built_in">done</span>(connections))  <span class="comment">// 1</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(connection_iterator  <span class="comment">// 2</span></span><br><span class="line">            connection=connections.<span class="built_in">begin</span>(),end=connections.<span class="built_in">end</span>();</span><br><span class="line">          connection!=end;</span><br><span class="line">          ++connection)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(connection-&gt;<span class="built_in">has_incoming_data</span>())  <span class="comment">// 3</span></span><br><span class="line">      &#123;</span><br><span class="line">        data_packet data=connection-&gt;<span class="built_in">incoming</span>();</span><br><span class="line">        std::promise&lt;payload_type&gt;&amp; p=</span><br><span class="line">            connection-&gt;<span class="built_in">get_promise</span>(data.id);  <span class="comment">// 4</span></span><br><span class="line">        p.<span class="built_in">set_value</span>(data.payload);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(connection-&gt;<span class="built_in">has_outgoing_data</span>())  <span class="comment">// 5</span></span><br><span class="line">      &#123;</span><br><span class="line">        outgoing_packet data=</span><br><span class="line">            connection-&gt;<span class="built_in">top_of_outgoing_queue</span>();</span><br><span class="line">        connection-&gt;<span class="built_in">send</span>(data.payload);</span><br><span class="line">        data.promise.<span class="built_in">set_value</span>(<span class="literal">true</span>);  <span class="comment">// 6</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>process_connections()中(直到done()返回true①为止)每一次循环，都会依次的检查每个连接②，检索是否有数据③或正在发送已入队的传出数据⑤。假设输入数据包是具有ID和有效负载的(有实际的数在其中)，一个ID映射到一个<code>std::promise</code>(可能是在相关容器中进行的依次查找)④，并且值是在包的有效负载中。传出包是在传出队列中检索，从接口直接发送出去。当发送完成，传出数据相关的promise将置为true，来表明传输成功⑥。是否能映射到实际网络协议上，取决于所用协议。</p>
<p>上面的代码不理会异常，一切工作都会很好的执行，但有悖常理。有时候磁盘满载，有时候会找不到东西，有时候网络会断，还有时候数据库会崩溃。当需要某个操作的结果时，就需要在对应的线程上执行这个操作，因为代码可以通过异常来报告错误。不过，这会对使用<code>std::packaged_task</code>或<code>std::promise</code>带来一些不必要的限制。因此，C++标准库提供了一种在以上情况下清理异常的方法，并且允许将异常存储为相关结果的一部分。</p>
<h3 id="将异常存与future中">4.2.4 将异常存与future中</h3>
<p>看完下面的代码段，思考一下：当你传递-1到square_root()中时，它将抛出一个异常，并且你想让调用者看到这个异常：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">square_root</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(“x&lt;<span class="number">0</span>”);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设调用square_root()函数不是当前线程，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> y=<span class="built_in">square_root</span>(<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
<p>将调用改为异步调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::future&lt;<span class="type">double</span>&gt; f=std::<span class="built_in">async</span>(square_root,<span class="number">-1</span>);</span><br><span class="line"><span class="type">double</span> y=f.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure>
<p>当y获得函数调用的结果，线程调用f.get()时，就能再看到异常了。</p>
<p>函数作为<code>std::async</code>的一部分时，当调用抛出一个异常时，这个异常就会存储到future中，之后future的状态置为“就绪”，之后调用get()会抛出已存储的异常(注意：标准级别没有指定重新抛出的这个异常是原始的异常对象，还是一个拷贝。不同的编译器和库将会在这方面做出不同的选择)。将函数打包入<code>std::packaged_task</code>任务包后，当任务调用时，同样的事情也会发生。打包函数抛出一个异常，这个异常将存储在future中，在get()调用时会再次抛出。</p>
<p>当然，通过函数的显式调用，<code>std::promise</code>也能提供同样的功能。当存入的是异常而非数值时，就需要调用set_exception()成员函数，而非set_value()。这通常是用在一个catch块中，并作为算法的一部分。为了捕获异常，这里使用异常填充promise：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> std::promise&lt;<span class="type">double</span>&gt; some_promise;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">  some_promise.<span class="built_in">set_value</span>(<span class="built_in">calculate_value</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(...)</span><br><span class="line">&#123;</span><br><span class="line">  some_promise.<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用<code>std::current_exception()</code>来检索抛出的异常，可用<code>std::copy_exception()</code>作为替代方案，<code>std::copy_exception()</code>会直接存储新的异常而不抛出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">some_promise.<span class="built_in">set_exception</span>(std::<span class="built_in">copy_exception</span>(std::<span class="built_in">logic_error</span>(<span class="string">&quot;foo &quot;</span>)));</span><br></pre></td></tr></table></figure>
<p>这比使用try/catch块更加清晰，当异常类型已知，就应该优先使用。不是因为代码实现简单，而是给编译器提供了极大的优化空间。</p>
<p>另一种向future中存储异常的方式，在没有调用promise上的任何设置函数前，或正在调用包装好的任务时，销毁与<code>std::promise</code>或<code>std::packaged_task</code>相关的future对象。任何情况下，当future的状态还不是“就绪”时，调用<code>std::promise</code>或<code>std::packaged_task</code>的析构函数，将会存储一个与<code>std::future_errc::broken_promise</code>错误状态相关的<code>std::future_error</code>异常。通过创建一个future，可以构造一个promise为其提供值或异常，也可以通过销毁值和异常源，去违背promise。这种情况下，编译器没有在future中存储任何东西，线程可能会永远的等下去。</p>
<p>现在，例子中都在用<code>std::future</code>，不过<code>std::future</code>也有局限性。很多线程在等待的时候，只有一个线程能获取结果。当多个线程等待相同事件的结果时，就需要使用<code>std::shared_future</code>来替代<code>std::future</code>了。</p>
<h3 id="多个线程的等待">4.2.5 多个线程的等待</h3>
<p>虽然<code>std::future</code>可以处理所有在线程间数据转移的同步，但是调用某一特殊<code>std::future</code>对象的成员函数，就会让这个线程的数据和其他线程的数据不同步。多线程在没有额外同步的情况下，访问独立<code>std::future</code>对象时，就会有数据竞争和未定义行为。因为<code>std::future</code>独享同步结果，并且通过调用get()函数，一次性的获取数据，这就让并发访问变的毫无意义。</p>
<p>如果并行代码没办法让多个线程等待同一个事件，<code>std::shared_future</code>可以帮你解决这个问题。因为<code>std::future</code>是只移动的，所以其所有权可以在不同的实例中互相传递，但只有一个实例可以获得特定的同步结果，而<code>std::shared_future</code>实例是可拷贝的，所以多个对象可以引用同一关联期望值的结果。</p>
<p>每一个<code>std::shared_future</code>的独立对象上，成员函数调用返回的结果还是不同步的，所以为了在多个线程访问一个独立对象时避免数据竞争，必须使用锁来对访问进行保护。优先使用的办法：为了替代只有一个拷贝对象的情况，可以让每个线程都拥有自己对应的拷贝对象。这样，当每个线程都通过自己拥有的<code>std::shared_future</code>对象获取结果，那么多个线程访问共享同步结果就是安全的。可见图4.1。</p>
<p><img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/4-1-1.png" /></p>
<p><img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/4-1-2.png" /></p>
<p>图4.1 使用多个<code>std::shared_future</code>对象来避免数据竞争</p>
<p>可能会使用<code>std::shared_future</code>的场景，例如：实现类似于复杂的电子表格的并行执行，每一个单元格有唯一终值，这个终值可能由其他单元格中的数据通过公式计算得到。公式计算得到的结果依赖于其他单元格，然后可以使用<code>std::shared_future</code>对象引用第一个单元格的数据。当每个单元格内的所有公式并行执行后，任务会以期望的方式完成工作。不过，当其中有计算需要依赖其他单元格的值时就会阻塞，直到依赖单元格的数据准备就绪。这可以让系统在最大程度上使用硬件并发。</p>
<p><code>std::shared_future</code>的实例同步<code>std::future</code>实例的状态。当<code>std::future</code>对象没有与其他对象共享同步状态所有权，那么所有权必须使用<code>std::move</code>将所有权传递到<code>std::shared_future</code>，其默认构造函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;<span class="type">int</span>&gt; p;</span><br><span class="line"><span class="function">std::future&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(p.get_future())</span></span>;</span><br><span class="line"><span class="built_in">assert</span>(f.<span class="built_in">valid</span>());  <span class="comment">// 1 期望值 f 是合法的</span></span><br><span class="line"><span class="function">std::shared_future&lt;<span class="type">int</span>&gt; <span class="title">sf</span><span class="params">(std::move(f))</span></span>;</span><br><span class="line"><span class="built_in">assert</span>(!f.<span class="built_in">valid</span>());  <span class="comment">// 2 期望值 f 现在是不合法的</span></span><br><span class="line"><span class="built_in">assert</span>(sf.<span class="built_in">valid</span>());  <span class="comment">// 3 sf 现在是合法的</span></span><br></pre></td></tr></table></figure>
<p>期望值f开始是合法的①，因为引用的是promise
p的同步状态，但是在转移sf的状态后，f就不合法了②，而sf就是合法的了③。</p>
<p>如其他可移动对象一样，转移所有权是对右值的隐式操作，所以可以通过<code>std::promise</code>对象的成员函数get_future()的返回值，直接构造一个<code>std::shared_future</code>对象，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;std::string&gt; p;</span><br><span class="line"><span class="function">std::shared_future&lt;std::string&gt; <span class="title">sf</span><span class="params">(p.get_future())</span></span>;  <span class="comment">// 1 隐式转移所有权</span></span><br></pre></td></tr></table></figure>
<p>转移所有权是隐式的，用右值构造<code>std::shared_future&lt;&gt;</code>，得到<code>std::future&lt;std::string&gt;</code>类型的实例①。</p>
<p><code>std::future</code>的这种特性，可促进<code>std::shared_future</code>的使用，容器可以自动的对类型进行推断，从而初始化该类型的变量(详见附录A，A.6节)。<code>std::future</code>有一个share()成员函数，可用来创建新的<code>std::shared_future</code>
，并且可以直接转移future的所有权。这样也就能保存很多类型，并且使得代码易于修改：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt; std::map&lt; SomeIndexType, SomeDataType, SomeComparator,</span><br><span class="line">     SomeAllocator&gt;::iterator&gt; p;</span><br><span class="line"><span class="keyword">auto</span> sf=p.<span class="built_in">get_future</span>().<span class="built_in">share</span>();</span><br></pre></td></tr></table></figure>
<p>这个例子中，sf的类型推导为<code>std::shared_future&lt;std::map&lt;SomeIndexType, SomeDataType, SomeComparator, SomeAllocator&gt;::iterator&gt;</code>，还真的长。当比较器或分配器有所改动，只需要对promise的类型进行修改即可。future的类型会自动与promise的修改进行匹配。</p>
<p>有时需要限定等待事件的时间，不论是因为时间上有硬性规定(一段指定的代码需要在某段时间内完成)，还是因为在事件没有很快的触发，或是有工作需要特定线程来完成，为了处理这种情况，需要等待函数能对超时进行指定。</p>
<hr />
<h2 id="进程与线程">进程与线程</h2>
<ul>
<li><p>进程（英语：process），是指计算机中已运行的程序。进程为曾经是分时系统的基本运作单位。在面向进程设计的系统（如早期的UNIX，Linux
2.4及更早的版本）中，进程是程序的基本执行实体；</p></li>
<li><p>线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。
## re-entrant、 thread-safe、 async-signal safe</p></li>
</ul>
<h3 id="re-entrant可重入">re-entrant（可重入）</h3>
<p>A function is <strong>reentrant</strong> if:</p>
<ul>
<li>it can be <strong>interrupted at any point during its execution and
then safely called again</strong> ("re-entered") before its previous
invocations complete execution.</li>
</ul>
<h3 id="thread-safe线程安全">thread-safe（线程安全）</h3>
<p>A function is <strong>thread-safe</strong> if:</p>
<ul>
<li>it only manipulates shared data structures in a manner that
guarantees safe <strong>execution by multiple threads at the same
time</strong>.</li>
</ul>
<p>常见的无锁编程提供的就是线程安全的接口。</p>
<h3 id="async-signal-safe">async-signal safe</h3>
<p>We say that a function that is <strong>safe to be reentered from an
asynchronous signal handler</strong> is async-signal safe.</p>
<h3 id="总结">总结</h3>
<p>可重入并不保证线程安全，反之亦然，例子见<a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Reentrancy_(computing)">wiki</a>。</p>
<p>async-signal safe是增强版的re-entrant。</p>
<h2 id="管理当前线程">管理当前线程</h2>
<table>
<thead>
<tr class="header">
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>yield</td>
<td>让出处理器，重新调度各执行线程</td>
</tr>
<tr class="even">
<td>get_id</td>
<td>返回当前线程的线程id</td>
</tr>
<tr class="odd">
<td>sleep_for</td>
<td>使当前线程的执行停止指定的时间段</td>
</tr>
<tr class="even">
<td>sleep_until</td>
<td>使当前线程的执行停止直到指定的时间点</td>
</tr>
</tbody>
</table>
<p>上面是一些在线程内部使用的API，它们用来对当前线程做一些控制。</p>
<ul>
<li><p><code>yield</code>
通常用在自己的主要任务已经完成的时候，此时希望让出处理器给其他任务使用。暂时放弃当前线程的执行，并会将线程放入就绪状态，以便其他线程有机会执行。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!condition) &#123;</span><br><span class="line">    <span class="comment">// 执行一些操作</span></span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>get_id</code>
返回当前线程的id，可以以此来标识不同的线程。</p></li>
<li><p><code>sleep_for</code> 是让当前线程停止一段时间。</p></li>
<li><p><code>sleep_until</code>
和<code>sleep_for</code>类似，但是是以具体的时间点为参数。这两个API都以<a
target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/header/chrono">chrono</a>
API为基础, 见<code>&lt;chrono&gt;</code>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h2 id="互斥体与锁">互斥体与锁</h2>
<h3 id="mutex">mutex</h3>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>mutex</td>
<td>提供基本互斥设施</td>
</tr>
<tr class="even">
<td>timed_mutex</td>
<td>提供互斥设施，带有超时功能</td>
</tr>
<tr class="odd">
<td>recursive_mutex</td>
<td>提供能被同一线程递归锁定的互斥设施</td>
</tr>
<tr class="even">
<td>recursive_timed_mutex</td>
<td>提供能被同一线程递归锁定的互斥设施，带有超时功能</td>
</tr>
<tr class="odd">
<td>shared_timed_mutex</td>
<td>提供共享互斥设施并带有超时功能</td>
</tr>
<tr class="even">
<td>shared_mutex</td>
<td>提供共享互斥设施</td>
</tr>
</tbody>
</table>
<p>这些类都提供了下面三个方法，并且它们的功能是一样的:</p>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>lock</td>
<td>锁定互斥体，如果不可用，则阻塞</td>
</tr>
<tr class="even">
<td>try_lock</td>
<td>尝试锁定互斥体，如果不可用，直接返回</td>
</tr>
<tr class="odd">
<td>unlock</td>
<td>解锁互斥体</td>
</tr>
</tbody>
</table>
<p>在这些基础功能之上，其他的类分别在下面三个方面进行了扩展： -
超时：<code>timed_mutex</code>，<code>recursive_timed_mutex</code>，<code>shared_timed_mutex</code>的名称都带有<code>timed</code>，这意味着它们都支持超时功能。它们都提供了<code>try_lock_for</code>和<code>try_lock_until</code>方法，这两个方法分别可以指定超时的时间长度和时间点。如果在超时的时间范围内没有能获取到锁，则直接返回，不再继续等待。
-
可重入：<code>recursive_mutex</code>和<code>recursive_timed_mutex</code>的名称都带有<code>recursive</code>。可重入或者叫做可递归，是指在同一个线程中，同一把锁可以锁定多次。这就避免了一些不必要的死锁。
-
共享：<code>shared_timed_mutex</code>和<code>shared_mutex</code>提供了共享功能。对于这类互斥体，实际上是提供了两把锁：一把是共享锁，一把是互斥锁。共享锁通常用在读者写者模型上。</p>
<pre><code>| 方法 | 说明 |
|-|-|
|lock_shared    | 获取互斥体的共享锁，如果无法获取则阻塞|
|try_lock_shared    | 尝试获取共享锁，如果不可用，直接返回|
|unlock_shared  | 解锁共享锁|</code></pre>
<h3 id="通用锁定算法">通用锁定算法</h3>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>lock</td>
<td>锁定指定的互斥体，若任何一个不可用则阻塞</td>
</tr>
<tr class="even">
<td>try_lock</td>
<td>试图通过重复调用 try_lock 获得互斥体的所有权</td>
</tr>
</tbody>
</table>
<p>这两个方法对所有的锁进行排序，每次一定要按照顺序来获取锁，不允许乱序；避免了死锁。</p>
<h3 id="通用互斥管理">通用互斥管理</h3>
<table>
<thead>
<tr class="header">
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>｜ lock_guard ｜ 实现严格基于作用域的互斥体所有权包装器 ｜ ｜
unique_lock ｜ 实现可移动的互斥体所有权包装器 ｜ ｜ shared_lock ｜
实现可移动的共享互斥体所有权封装器 ｜ ｜ scoped_lock ｜
用于多个互斥体的免死锁 RAII 封装器 ｜</p>
<p>这些类都提供了下面三个方法，并且它们的功能是一样的:</p>
<table>
<thead>
<tr class="header">
<th>锁定策略</th>
<th>说明</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>｜defer_lock ｜ 类型为 defer_lock_t，不获得互斥的所有权｜
｜try_to_lock ｜ 类型为try_to_lock_t，尝试获得互斥的所有权而不阻塞｜
｜adopt_lock ｜ 类型为adopt_lock_t，假设调用方已拥有互斥的所有权｜</p>
<p>eg： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lock</span>(*accountA-&gt;<span class="built_in">getLock</span>(), *accountB-&gt;<span class="built_in">getLock</span>());</span><br><span class="line"><span class="function">lock_guard <span class="title">lockA</span><span class="params">(*accountA-&gt;getLock(), adopt_lock)</span></span>;</span><br><span class="line"><span class="function">lock_guard <span class="title">lockB</span><span class="params">(*accountB-&gt;getLock(), adopt_lock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 如果使用unique_lock这三行代码还有一种等价的写法：</span></span><br><span class="line"><span class="function">unique_lock <span class="title">lockA</span><span class="params">(*accountA-&gt;getLock(), defer_lock)</span></span>;</span><br><span class="line"><span class="function">unique_lock <span class="title">lockB</span><span class="params">(*accountB-&gt;getLock(), defer_lock)</span></span>;</span><br><span class="line"><span class="built_in">lock</span>(*accountA-&gt;<span class="built_in">getLock</span>(), *accountB-&gt;<span class="built_in">getLock</span>());</span><br><span class="line"><span class="comment">// 请注意这里lock方法的调用位置。这里先定义unique_lock指定了defer_lock，因此实际没有锁定互斥体，而是到第三行才进行锁定。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 借助scoped_lock，我们可以将三行代码合成一行，这种写法也是等价的。</span></span><br><span class="line"><span class="function">scoped_lock <span class="title">lockAll</span><span class="params">(*accountA-&gt;getLock(), *accountB-&gt;getLock())</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="条件变量-1">条件变量</h3>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>condition_variable</td>
<td>提供与 std::unique_lock 关联的条件变量</td>
</tr>
<tr class="even">
<td>condition_variable_any</td>
<td>提供与任何锁类型关联的条件变量</td>
</tr>
<tr class="odd">
<td>notify_all_at_thread_exit</td>
<td>安排到在此线程完全结束时对 notify_all 的调用</td>
</tr>
<tr class="even">
<td>cv_status</td>
<td>列出条件变量上定时等待的可能结果</td>
</tr>
</tbody>
</table>
<p>eg: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">changeMoney</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="function">unique_lock <span class="title">lock</span><span class="params">(mMoneyLock)</span></span>; <span class="comment">// ②</span></span><br><span class="line">    mConditionVar.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>, amount] &#123; <span class="comment">// ③</span></span><br><span class="line">      <span class="keyword">return</span> mMoney + amount &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    mMoney += amount;</span><br><span class="line">    mConditionVar.<span class="built_in">notify_all</span>(); <span class="comment">// ④</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="type">double</span> mMoney;</span><br><span class="line">  mutex mMoneyLock;</span><br><span class="line">  condition_variable mConditionVar; <span class="comment">// ①</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 1.
这里声明了一个条件变量，用来在多个线程之间协作。 2.
这里使用的是<code>unique_lock</code>，这是为了与条件变量相配合。因为条件变量会解锁和重新锁定互斥体。
3.
这里是比较重要的一个地方：通过条件变量进行等待。此时：会通过后面的lambda表达式判断条件是否满足。如果满足则继续；如果不满足，则此处会解锁互斥体，并让当前线程等待。
4.
此处也很重要。当金额发生变动之后，我们需要通知所有在条件变量上等待的其他线程。此时所有调用<code>wait</code>线程都会再次唤醒，然后尝试获取锁（当然，只有一个能获取到）并再次判断条件是否满足。除了<code>notify_all</code>还有<code>notify_one</code>，它只通知一个等待的线程。wait和notify就构成了线程间互相协作的工具。</p>
<h2 id="future-1">future</h2>
<p>都位于<future>头文件中。 |API |说明| |-|-| | async |
异步运行一个函数，并返回保有其结果的std::future | | future |
等待被异步设置的值 | | packaged_task |
打包一个函数，存储其返回值以进行异步获取 | | promise |
存储一个值以进行异步获取 | | shared_future |
等待被异步设置的值（可能为其他 future 所引用） |</p>
<h3 id="async">async</h3>
<ol type="1">
<li>async是启动一个新的线程，还是以同步的方式（不启动新的线程）运行任务，由具体的编译器决定。</li>
<li>如果希望一定要以新的线程来异步执行任务，可以通过launch::async来明确说明。launch中有两个常量：</li>
</ol>
<ul>
<li>async：运行新线程，以异步执行任务。</li>
<li>deferred：调用方线程上第一次请求其结果时才执行任务，即惰性求值。</li>
</ul>
<ol start="3" type="1">
<li>返回一个<code>future</code>对象,用来存储异步任务的执行结果</li>
</ol>
<p>eg: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f2 = <span class="built_in">async</span>(launch::async, [&amp;result]() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= MAX; i++) &#123;</span><br><span class="line">    result += <span class="built_in">sqrt</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">f2.<span class="built_in">wait</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">Worker <span class="title">w</span><span class="params">(<span class="number">0</span>, MAX)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> f3 = <span class="built_in">async</span>(&amp;Worker::work, &amp;w); <span class="comment">// 面向对象</span></span><br><span class="line">f3.<span class="built_in">wait</span>();</span><br></pre></td></tr></table></figure> ### packaged_task
<code>packaged_task</code>绑定到一个函数或者可调用对象上。当它被调用时，它就会调用其绑定的函数或者可调用对象。并且，可以通过与之相关联的<code>future</code>来获取任务的结果。调度程序只需要处理<code>packaged_task</code>，而非各个函数。</p>
<p><code>packaged_task</code>对象是一个可调用对象，它可以被封装成一个<code>std::fucntion</code>，或者作为线程函数传递给<code>std::thread</code>，或者直接调用。</p>
<p>eg: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">concurrent_worker</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> </span>&#123;</span><br><span class="line">  <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;future&lt;<span class="type">double</span>&gt;&gt; results; <span class="comment">// 创建一个集合来存储future对象。我们将用它来获取任务的结果。</span></span><br><span class="line">...</span><br><span class="line"><span class="function">packaged_task&lt;<span class="title">double</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">(concurrent_worker)</span></span>;</span><br><span class="line">results.<span class="built_in">push_back</span>(task.<span class="built_in">get_future</span>());  <span class="comment">// 通过一个新的线程来执行任务，并传入需要的参数。</span></span><br><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(std::move(task), min, range)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>可以借助于packaged_task将任务组装成队列，然后通过线程池的方式进行调度</p>
<h3 id="promise与future">promise与future</h3>
<p>在上面的例子中，<code>concurrent_task</code>的结果是通过<code>return</code>返回的。但在一些时候，我们可能不能这么做：在得到任务结果之后，可能还有一些事情需要继续处理，例如清理工作。</p>
<p>这个时候，就可以将<code>promise</code>与<code>future</code>配对使用。这样就可以将返回结果和任务结束两个事情分开。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">concurrent_task</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max, promise&lt;<span class="type">double</span>&gt;* result)</span> </span>&#123; <span class="comment">// ①</span></span><br><span class="line">  ...</span><br><span class="line">  result-&gt;<span class="built_in">set_value</span>(sum); <span class="comment">// ②</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  promise&lt;<span class="type">double</span>&gt; sum; <span class="comment">// ③</span></span><br><span class="line">  <span class="built_in">concurrent_task</span>(<span class="number">0</span>, MAX, &amp;sum);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; sum.<span class="built_in">get_future</span>().<span class="built_in">get</span>() &lt;&lt; endl; <span class="comment">// ④</span></span><br></pre></td></tr></table></figure>
<ol type="1">
<li><code>concurrent_task</code>不再直接返回计算结果，而是增加了一个<code>promise</code>对象来存放结果。</li>
<li>在任务计算完成之后，将总结过设置到<code>promise</code>对象上。一旦这里调用了<code>set_value</code>，其相关联的<code>future</code>对象就会就绪。</li>
<li>这里创建一个<code>promise</code>来存放结果，并以指针的形式传递进<code>concurrent_task</code>中。</li>
<li>通过<code>sum.get_future().get()</code>来获取结果。</li>
</ol>
<p>需要注意的是，<code>future</code>对象只有被一个线程获取值。并且在调用<code>get()</code>之后，就没有可以获取的值了。如果从多个线程调用<code>get()</code>会出现数据竞争，其结果是未定义的。</p>
<p>如果真的需要在多个线程中获取<code>future</code>的结果，可以使用<code>shared_future</code>。</p>
<h3 id="总结-1">总结</h3>
<p>这三者分别工作在不同的抽象层次上。</p>
<ol type="1">
<li>async层次最高，你只需要给它提供一个函数，它就会返回一个future对象。接下来就只需等待结果了。</li>
<li>packaged_task次之，你在创建了packaged_task后，还要创建一个thread，并把packaged_task交给它执行。</li>
<li>promise就最低了。在创建了thread之后，你还要把对应的promise作为参数传入。这还没完，别忘了在函数中手动设置promise的值。</li>
</ol>
<h2 id="并行算法">并行算法</h2>
<p>从C++17开始。<algorithm>和<numeric>
头文件的中的很多算法都添加了一个新的参数：<code>sequenced_policy</code>。</p>
<p>借助这个参数，开发者可以直接使用这些算法的并行版本，不用再自己创建并发系统和划分数据来调度这些算法。</p>
<p>sequenced_policy可能的取值有三种，它们的说明如下：</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th>变量</th>
<th>类型</th>
<th>C++版本</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>execution::seq</td>
<td>execution::sequenced_policy</td>
<td>C++17</td>
<td>要求并行算法的执行可以不并行化</td>
</tr>
<tr class="even">
<td>execution::par</td>
<td>execution::parallel_policy</td>
<td>C++17</td>
<td>指示并行算法的执行可以并行化</td>
</tr>
<tr class="odd">
<td>execution::par_unseq</td>
<td>execution::parallel_unsequenced_policy</td>
<td>C++17</td>
<td>指示并行算法的执行可以并行化、向量化</td>
</tr>
</tbody>
</table>
<p>注意：想要编译这部分代码，你需要使用gcc
9.0或更高版本，同时还需要安装Intel Threading Building Blocks。</p>
<p>eg: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(execution::seq, copy1.<span class="built_in">begin</span>(), copy1.<span class="built_in">end</span>()); <span class="comment">// ④</span></span><br><span class="line"><span class="built_in">sort</span>(execution::par, copy2.<span class="built_in">begin</span>(),copy2.<span class="built_in">end</span>()); <span class="comment">// ⑥</span></span><br><span class="line"><span class="built_in">sort</span>(execution::par_unseq, copy2.<span class="built_in">begin</span>(),copy2.<span class="built_in">end</span>()); <span class="comment">// ⑦</span></span><br></pre></td></tr></table></figure></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Yuhang Zhang
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://zyh-eric.gitee.io/zyhjy/2023/06/04/C++%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="笔记：C++ Concurrency in Action 2ed">https://zyh-eric.gitee.io/zyhjy/2023/06/04/C++并发编程/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/zyhjy/2023/06/04/C++%E4%BE%AF%E6%8D%B7STL%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" rel="prev" title="C++并发编程">
      <i class="fa fa-chevron-left"></i> C++并发编程
    </a></div>
      <div class="post-nav-item">
    <a href="/zyhjy/2023/06/06/gmock/" rel="next" title="">
       <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <style>
        #taboola-livere { display: none;}
    </style>
    <div id="lv-container" data-id="city" data-uid="MTAyMC81ODg3Ni8zNTMzOA=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="nav-text">第一章 并发与并行</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91concurrent%E4%B8%8E%E5%B9%B6%E8%A1%8Cparallel"><span class="nav-text">并发（Concurrent）与并行（Parallel）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%B9%B6%E5%8F%91"><span class="nav-text">为什么要使用并发</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-text">第二章 线程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">线程的基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8Bstdthread%E6%9E%84%E9%80%A0"><span class="nav-text">启动线程（std::thread构造）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="nav-text">传递参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stdthread%E6%9E%90%E6%9E%84"><span class="nav-text">std::thread析构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#join-or-detach"><span class="nav-text">join or detach</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#join"><span class="nav-text">join</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%97%AE%E5%A6%82%E6%9E%9C%E5%9C%A8%E4%B8%BB%E7%BA%BF%E7%A8%8B%E2%91%A0%E6%89%A7%E8%A1%8C%E4%B9%8B%E5%90%8E%E2%91%A1%E6%89%A7%E8%A1%8C%E4%B9%8B%E5%89%8D%E4%BB%8E%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9D%9F%E4%BA%86%E4%BC%9A%E6%80%8E%E6%A0%B7"><span class="nav-text">问：如果在主线程①执行之后，②执行之前，从线程执行结束了，会怎样？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#detach"><span class="nav-text">detach</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E7%A7%BB%E6%89%80%E6%9C%89%E6%9D%83"><span class="nav-text">转移所有权</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AE%E5%AE%9A%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F"><span class="nav-text">确定线程数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%A0%87%E8%AF%86"><span class="nav-text">线程标识</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="nav-text">第三章 共享数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F"><span class="nav-text">互斥量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mutex-lock_guard"><span class="nav-text">mutex &amp;&amp; lock_guard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stdlock-stdscope_lock"><span class="nav-text">std::lock &amp;&amp;
std::scope_lock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%B1%82%E6%AC%A1%E9%94%81hierarchical_mutex"><span class="nav-text">避免死锁的设计：层次锁hierarchical_mutex</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="nav-text">设计思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stdunique_lock%E7%81%B5%E6%B4%BB%E7%9A%84%E9%94%81"><span class="nav-text">std::unique_lock——灵活的锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="nav-text">保护共享数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="nav-text">保护共享数据的初始化过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%A1%88%E4%B8%80-naive"><span class="nav-text">方案一 ： naive</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%A1%88%E4%BA%8C%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81"><span class="nav-text">方案二：双重检查锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%A1%88%E4%B8%89%E6%8E%A8%E8%8D%90stdcall_once"><span class="nav-text">方案三（推荐）：std::call_once</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%A1%88%E5%9B%9B%E6%8E%A8%E8%8D%90static%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-text">方案四（推荐）：static局部变量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E4%B8%8D%E5%B8%B8%E6%9B%B4%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84----%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-text">保护不常更新的数据结构 --
读写锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#stdrecursive_mutex"><span class="nav-text">std::recursive_mutex</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%90%8C%E6%AD%A5%E6%93%8D%E4%BD%9C"><span class="nav-text">第四章 同步操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-text">条件变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#future"><span class="nav-text">future</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-text">后台任务的返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#future%E4%B8%8E%E4%BB%BB%E5%8A%A1%E5%85%B3%E8%81%94"><span class="nav-text">4.2.2 future与任务关联</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8stdpromises"><span class="nav-text">4.2.3 使用std::promises</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E5%BC%82%E5%B8%B8%E5%AD%98%E4%B8%8Efuture%E4%B8%AD"><span class="nav-text">4.2.4 将异常存与future中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AD%89%E5%BE%85"><span class="nav-text">4.2.5 多个线程的等待</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="nav-text">进程与线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#re-entrant%E5%8F%AF%E9%87%8D%E5%85%A5"><span class="nav-text">re-entrant（可重入）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#thread-safe%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-text">thread-safe（线程安全）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#async-signal-safe"><span class="nav-text">async-signal safe</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B"><span class="nav-text">管理当前线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E4%BD%93%E4%B8%8E%E9%94%81"><span class="nav-text">互斥体与锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mutex"><span class="nav-text">mutex</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E9%94%81%E5%AE%9A%E7%AE%97%E6%B3%95"><span class="nav-text">通用锁定算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E4%BA%92%E6%96%A5%E7%AE%A1%E7%90%86"><span class="nav-text">通用互斥管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F-1"><span class="nav-text">条件变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#future-1"><span class="nav-text">future</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#async"><span class="nav-text">async</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#promise%E4%B8%8Efuture"><span class="nav-text">promise与future</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95"><span class="nav-text">并行算法</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yuhang Zhang"
      src="/zyhjy/images/zyhjy.png">
  <p class="site-author-name" itemprop="name">Yuhang Zhang</p>
  <div class="site-description" itemprop="description">爱小雅，爱生活，爱物理!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/zyhjy/archives/">
        
          <span class="site-state-item-count">80</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/zyhjy/categories/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/zyhjy/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/zyhjy/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuhang Zhang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">441k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">12:15</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/zyhjy/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>

<script src="/zyhjy/js/utils.js"></script>


<script src="/zyhjy/js/schemes/pisces.js"></script>


<script src="/zyhjy/js/next-boot.js"></script>




  




  
<script src="/zyhjy/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
