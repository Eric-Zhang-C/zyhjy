<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
<meta name="referrer" content="no-referrer">
  <link rel="apple-touch-icon" sizes="180x180" href="/zyhjy/images/relativity128.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/zyhjy/images/relativity32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/zyhjy/images/relativity16.png">
  <link rel="mask-icon" href="/zyhjy/images/logo.svg" color="#222">

<link rel="stylesheet" href="/zyhjy/css/main.css">

<link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css?family=Comic Sans MS:300,300italic,400,400italic,700,700italic|Noto Serif SC:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/zyhjy/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zyh-eric.gitee.io","root":"/zyhjy/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="爱小雅，爱生活，爱物理!">
<meta property="og:type" content="website">
<meta property="og:title" content="ZYHJY">
<meta property="og:url" content="https://zyh-eric.gitee.io/zyhjy/page/5/">
<meta property="og:site_name" content="ZYHJY">
<meta property="og:description" content="爱小雅，爱生活，爱物理!">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yuhang Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zyh-eric.gitee.io/zyhjy/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>ZYHJY</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-J17VP3T2B4"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-J17VP3T2B4');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/zyhjy/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ZYHJY</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/zyhjy/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/zyhjy/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/zyhjy/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/zyhjy/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/zyhjy/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2023/02/07/Qemu%E7%BF%BB%E8%AF%91%E5%AE%9E%E4%BE%8B--%E4%BB%A5arrch64%20--%3E%3E%20x86-64%E4%B8%BA%E4%BE%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2023/02/07/Qemu%E7%BF%BB%E8%AF%91%E5%AE%9E%E4%BE%8B--%E4%BB%A5arrch64%20--%3E%3E%20x86-64%E4%B8%BA%E4%BE%8B/" class="post-title-link" itemprop="url">Qemu翻译实例--以arrch64 -->> x86-64为例</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-07 17:28:50" itemprop="dateCreated datePublished" datetime="2023-02-07T17:28:50+08:00">2023-02-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:50" itemprop="dateModified" datetime="2023-07-30T18:15:50+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="qemu翻译实例--以arrch64----i386为例">Qemu翻译实例--以arrch64
--&gt;&gt; i386为例</h1>
<h2 id="前言">0.前言</h2>
<ul>
<li>QEMU 是一个仿真器(emulator)，可以user mode 或是system mode 运行。
<ul>
<li>user mode 可以运行不同ISA 同一OS 的binary;</li>
<li>system mode 可以在当前作业系统上运行另外一个OS.</li>
</ul></li>
<li>对QEMU 而言，被仿真的平台被称为guest，又称target; 运行QEMU
的平台称为host。
<ul>
<li>QEMU 是利用动态翻译(dynamic translation) 的技术将guest binary
动态翻译成host binary，并交由host 运行翻译所得的host binary。</li>
<li>Tiny Code Generator (TCG) 是QEMU 中负责动态翻译的组件。
<ul>
<li>对TCG 而言，target 有不同的含意，它代表TCG 是针对哪一个host 生成host
binary。</li>
</ul></li>
</ul></li>
<li>QEMU
极为依赖macro，这使得直接阅读源代码通常无法确定其函数呼叫，或是执行流程倒底为何。</li>
<li>请在编译QEMU
的时候加上<code>--extra-cflags="-save-temps"</code>，如此可得展开marco
的 <code>*.i</code> 档。</li>
</ul>
<h2 id="tcg">1. TCG</h2>
<ul>
<li>TCG 是QEMU 的核心。其基本流程如下:
<ul>
<li>guest binary -&gt; TCG IR -&gt; host binary</li>
</ul></li>
</ul>
<h3 id="tcg-ir">1.1 TCG IR</h3>
<ul>
<li><p>TCG 定义了一组IR (intermediate representation)，熟悉GCC
的各位对此应该不陌生。</p></li>
<li><p>TCG IR 大致分成以下几类:</p>
<ul>
<li>Move Operation: mov, movi, …</li>
<li>Logic Operation: and, or, xor, shl, shr, …</li>
<li>Arithmetic peration: add, sub, mul, div, …</li>
<li>Branch Operation: jmp, br, brcond</li>
<li>Fuction call: call</li>
<li>Memory Operation: ld, st</li>
<li>QEMU specific Operation: tb_exit, goto_tb, qemu_ld/qemu_st</li>
</ul></li>
<li><p>请见tcg/*，特别是tcg.i，可以看到TCGOpcode。</p></li>
<li><p>tcg/README 也别忘了。</p></li>
<li><p>TCG 在翻译guest binary 的时候是以一个translation block (tb)
为单位，其结尾通常是分支指令。</p></li>
<li><p>target/ARCH/* 定义了如何将ARCH binary 反汇编成TCG IR。</p>
<ul>
<li>target/arm</li>
</ul></li>
<li><p>tcg/ARCH 定义了如何将TCG IR 翻译成ARCH binary。</p>
<ul>
<li>tcg/i386</li>
</ul></li>
</ul>
<h3 id="tcg-flow">1.2 TCG Flow</h3>
<ul>
<li><p>gen_opc_buf 和gen_opparam_buf (translate-all.c) 分别放置TCG
Opcode 和Operand。</p></li>
<li><p>如果使用静态配置的缓冲区，static_code_gen_buffer (exec.c)
即为code cache，放置host binary。</p></li>
<li><p>在跳入/出code cache
执行之前/后，要执行prologue/epilogue，请见code_gen_prologue
(exec.c)。</p></li>
<li><p>这边的prologue/epilogue 就是指function
prologue/epilogue。</p></li>
<li><p>QEMU 将跳至code cache (host binary)
执行的过程看成是函式呼叫，故有此prologue/epilogue。</p></li>
<li><p>以qemu-arm 为例，流程大致如下:</p>
<ul>
<li><p>main() // vl.c</p></li>
<li><p>--&gt;&gt; main_loop() // vl.c</p></li>
<li><p>--&gt;&gt; arm_cpu_realizefn() //
target/arm/cpu.c，实例化虚拟机CPU设备模型 [GUEST]_cpu_realizefn</p></li>
<li><p>--&gt;&gt; qemu_init_vcpu() //
softmmu/cpus.c，KVM没有enable，并且启_cpu_thread_fn用了TCG的情况下，tcg_enabled()</p></li>
<li><p>--&gt;&gt; qemu_tcg_init_vcpu() //
启动VCPU线程，线程处理函数为qemu_tcg_cpu_thread_fn</p></li>
<li><p>--&gt;&gt; qemu_tcg_cpu_thread_fn()</p></li>
<li><p>--&gt;&gt; tcg_exec_all()</p></li>
<li><p>--&gt;&gt; tcg_cpu_exec()</p></li>
<li><p>--&gt;&gt; cpu_exec() //cpu-exee.c</p></li>
<li><p>user mode:</p>
<ul>
<li>main (linux-user/main.c) -&gt; cpu_create -&gt; tcg_prologue_init
(tcg/tcg.c) -&gt; cpu_loop (linux-user/main.c)</li>
</ul></li>
</ul></li>
<li><p>这边只介绍tcg_prologue_init (tcg/tcg.c) -&gt; cpu_loop
(linux-user/arm/cpu_loop.c) 这一段，因为这一段跟TCG 较为相关。</p></li>
<li><p>容我先讲cpu_loop (linux-user/arm/cpu_loop.c)。</p></li>
<li><p>cpu_loop(CPUARMState *env) (linux-user/arm/cpu_loop.c) -&gt;
cpu_exec (accel/tcg/cpu-exec.c)。</p></li>
<li><p>cpu_exec 是主要执行回圈，其结构大致如下: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* prepare setjmp context for exception handling */</span> </span><br><span class="line"><span class="keyword">if</span> (sigsetjmp(cpu-&gt;jmp_env, <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!cpu_handle_exception(cpu, &amp;ret)) &#123;</span><br><span class="line">    <span class="keyword">while</span> (!cpu_handle_interrupt(cpu, &amp;last_tb)) &#123; </span><br><span class="line">        tb = tb_lookup(cpu, pc, cs_base, flags, cflags); <span class="comment">// 寻找下一个TB</span></span><br><span class="line">        <span class="keyword">if</span> (tb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            tb = tb_gen_code(cpu, pc, cs_base, flags, cflags);</span><br><span class="line">        &#125;</span><br><span class="line">        cpu_loop_exec_tb(cpu, tb, &amp;last_tb, &amp;tb_exit);<span class="comment">// 跳至code cache 执行。</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">cpu_exec_exit(cpu);</span><br></pre></td></tr></table></figure></p></li>
<li><p>tcg_prologue_init (tcg/tcg.c) -&gt; tcg_target_qemu_prologue
(tcg/arm/tcg-target.c.inc)。</p></li>
<li><p>如前所述，QEMU 将跳至code cache (host binary)
执行的过程看成是函式呼叫。</p></li>
<li><p>不同平台的calling convention 各有不同，tcg_prologue_init
将产生prologue/epilogue 的工作转交tcg_target_qemu_prologue。
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tcg_target_qemu_prologue</span><span class="params">(TCGContext *s)</span> &#123; </span><br><span class="line">    <span class="comment">/* Calling convention requires us to save r4-r11 and lr.  */</span></span><br><span class="line">    <span class="comment">/* stmdb sp!, &#123; r4 - r11, lr &#125; */</span></span><br><span class="line">    tcg_out32(s, (COND_AL &lt;&lt; <span class="number">28</span>) | <span class="number">0x092d4ff0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reserve callee argument and tcg temp space.  */</span></span><br><span class="line">    tcg_out_dat_rI(s, COND_AL, ARITH_SUB, TCG_REG_CALL_STACK,</span><br><span class="line">                   TCG_REG_CALL_STACK, STACK_ADDEND, <span class="number">1</span>);</span><br><span class="line">    tcg_set_frame(s, TCG_REG_CALL_STACK, TCG_STATIC_CALL_ARGS_SIZE,</span><br><span class="line">                  CPU_TEMP_BUF_NLONGS * <span class="keyword">sizeof</span>(<span class="type">long</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* QEMU (cpu_exec) -&gt; 入栈*/</span> </span><br><span class="line">    tcg_out_mov(s, TCG_TYPE_PTR, TCG_AREG0, tcg_target_call_iarg_regs[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tcg_target_call_iarg_regs 是函式呼叫负责传递参数的暂存器。</span></span><br><span class="line">    <span class="comment">// 跳至code cache 执行。</span></span><br><span class="line">    tcg_out_bx(s, COND_AL, tcg_target_call_iarg_regs[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 此时，s-&gt;code_ptr 指向code_gen_prologue 中prologue 和jmp to code cache 之后的位址。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Return path for goto_ptr. Set return value to 0, a-la exit_tb,</span></span><br><span class="line"><span class="comment">     * and fall through to the rest of the epilogue.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    tcg_code_gen_epilogue = tcg_splitwx_to_rx(s-&gt;code_ptr);</span><br><span class="line">    tcg_out_movi(s, TCG_TYPE_PTR, TCG_REG_R0, <span class="number">0</span>);</span><br><span class="line">    tcg_out_epilogue(s); <span class="comment">/* 出栈-&gt; 返回QEMU (cpu_exec)，确切的讲是返回tcg_qemu_tb_exec */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>这边小结一下。</p>
<ul>
<li>QEMU -&gt; prologue -&gt; code cache -&gt; epilogue -&gt; QEMU</li>
</ul></li>
<li><p>在介绍cpu_exec 之前，我先介绍几个QEMU
资料结构，请善用SOURCEARCHIVE.com。</p></li>
<li><p>我们要知道所谓仿真或是虚拟化一个CPU
(ISA)，简单来说就是用一个资料结构(struct) 储存该CPU的状态。</p></li>
<li><p>执行该虚拟CPU，就是从内存中读取该虚拟CPU的资料结构，运算后再存回去。</p></li>
<li><p>CPUX86State: 保存x86 register，eflags，eip，cs，…。</p></li>
<li><p>不同ISA 之间通用的资料结构被QEMU #define 成CPU_COMMON。</p></li>
<li><p>一般称此资料结构为CPUState。下文所提env 即为CPUState。</p></li>
<li><p>QEMU 运行虚拟CPU 都会利用env 这个变数。</p></li>
<li><p>TranslationBlock: 之前说过，QEMU 是以一个translation block
为单位进行翻译。</p></li>
<li><p>其中保存此translation block 对应guest binary 的pc, cs_base,
eflags。</p></li>
<li><p>另外，tc_ptr 指向code cache (host
binary)。其它栏位待以后再谈。</p></li>
<li><p>PageDesc: 主要保存guest page 中的第一个tb (TranslationBlock
*)。</p></li>
<li><p>这跟QEMU 内部运作机制有关。某些情况下，guest page (guest binary)
可能被替换或是被写。</p></li>
<li><p>这个时候，QEMU 会以guest page (guest binary)
为单位，清空与它相关联的TB (code cache)。</p></li>
<li><p>这时再回来讲 TranslationBlock。TranslationBlock
有底下两个栏位:</p>
<ul>
<li>page_addr[2]: 存放TranslationBlock 对应guest binary 所在的guest
page。注意! guest binary 有可能跨guest page，故这里有两个栏位。</li>
<li>page_next[2]: 当透过PageDesc-&gt;first_tb 找到该guest page
的第一个tb，tb-&gt;page_next 就被用来找寻该guest page 的下一个tb。</li>
</ul></li>
<li><p>再回来讲PageDesc。QEMU 替PageDesc
维护了一个二级页表l1_map。page_find 这个函式根据输入的address
搜寻l1_map，返回PageDesc。这在以guest page (guest binary)
为单位，清空与它相关联的TB (code cache)
的时候会用到。有一个名字很像的资料结构叫PhysPageDesc，QEMU
也替它维护一个二级页表l1_phys_map。这是在system mode
做地址转换之用，这边不谈。</p></li>
<li><p>TCGContext: 生成TCG IR 时会用到。</p></li>
<li><p>DisasContext: 反汇编guest binary 时会用到</p></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2023/01/14/spec2006%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2023/01/14/spec2006%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/" class="post-title-link" itemprop="url">SPEC2006交叉编译</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-14 17:28:50" itemprop="dateCreated datePublished" datetime="2023-01-14T17:28:50+08:00">2023-01-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:18" itemprop="dateModified" datetime="2023-07-30T18:15:18+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>982</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="spec2006说明">1. SPEC2006说明</h1>
<ul>
<li>CPU Benchmark</li>
<li>用例具体内容见官网<code>http://www.spec.org/cpu2006/docs/用例名.html</code></li>
<li>运行时注意不要漏掉参数(Input)</li>
<li>例:</li>
</ul>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="header">
<th>子项目</th>
<th>类别</th>
<th>语言</th>
<th>说明</th>
<th>Web</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>462.libquantum</td>
<td>物理：量子计算</td>
<td>ISO/IEC 9899:1999(“C99”)</td>
<td>libquantum是模拟量子计算机的库文件，用来进行量子计算机应用的研究</td>
<td>http://www.spec.org/cpu2006/docs/462.libquantum.html</td>
</tr>
</tbody>
</table>
<h1 id="交叉编译">2. 交叉编译</h1>
<ol type="1">
<li>解压下载的SPEC2006压缩包</li>
<li>安装SPEC <code>./install.sh</code></li>
<li>安装aarch64交叉编译环境
<ul>
<li>gcc、g++、gfortran</li>
<li><code>sudo apt install gfortran-8-aarch64-linux-gnu</code></li>
</ul></li>
<li>加载环境变量
<ul>
<li>只要需要用到SPEC2006的指令，都需要在打开终端时加入<code>source ./shrc</code></li>
</ul></li>
<li>交叉编译配置
<ol type="1">
<li>进入<code>config</code>目录下，复制<code>Example-linux64-amd64-gcc43+</code>的配置文件（这个文件的选择根据Gem5中模拟的核模型来选择），将其重命名为<code>aarch64.cfg</code>（可以任意命名为其它名称）</li>
<li>修改配置文件<code>aarch64.cfg</code>，指定编译工具
<ul>
<li>分别找到CC，CXX，FC</li>
<li>改成如下格式： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CC =  your-cross-compiler-gcc</span><br><span class="line"></span><br><span class="line">CXX = your-cross-compiler-g++</span><br><span class="line"></span><br><span class="line">FC = your-cross-compiler-gfortran</span><br></pre></td></tr></table></figure></li>
<li>在gem5中运行的样例需要静态编译，故对COPTIMIZE、CXXOPTIMIZE、FOPTIMIZE加上<code>-static</code>标签</li>
<li>修改完后保存退出，其他地方不用改。</li>
</ul></li>
</ol></li>
<li>编译speccpu:</li>
</ol>
<ul>
<li><p><code>runspec --action=build --config=aarch64.cfg --tune=base int</code>
（只编译int型benchmark，不运行）</p></li>
<li><p>生成可执行文件<code>runspec --config=&lt;你的配置文件名&gt; --size=ref --noreportable --tune=base --iterations=1 &lt;样例名称&gt;</code></p></li>
</ul>
<ol start="7" type="1">
<li>将编译好的文件（在源码目录下，如<code>benchspec/CPU2006/400.perlbench/build/</code>）拷贝出来就可以在目标板或者模拟器上运行了。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2022/11/15/Effective%20C++(6)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2022/11/15/Effective%20C++(6)/" class="post-title-link" itemprop="url">Effective C++(6)--继承与面向对象设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-15 22:28:50" itemprop="dateCreated datePublished" datetime="2022-11-15T22:28:50+08:00">2022-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:32" itemprop="dateModified" datetime="2023-07-30T18:15:32+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/c/" itemprop="url" rel="index"><span itemprop="name">c++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="条款32-确定public继承塑模出is-a关系">条款32
确定public继承塑模出is-a关系</h1>
<ul>
<li>public继承意味"is-a"</li>
<li>Liskov替换原则
<ul>
<li>class D : class B { ... }</li>
<li>适用于B身上的每一件事也适用于D，反之不然</li>
</ul></li>
</ul>
<h1 id="条款33-避免遮掩继承而来的名称">条款33
避免遮掩继承而来的名称</h1>
<h2 id="继承体系内的名称可视性">继承体系内的"名称可视性"</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>base class内所有名为mf1和mf3的函数都被derived
class内的mf1和mf3函数遮掩了 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.<span class="built_in">mf1</span>();    <span class="comment">/// ok</span></span><br><span class="line">d.<span class="built_in">mf1</span>(x);   <span class="comment">/// error, Base::mf1被遮掩</span></span><br><span class="line">d.<span class="built_in">mf2</span>();    <span class="comment">/// ok, Base::mf2</span></span><br><span class="line">d.<span class="built_in">mf3</span>();    <span class="comment">/// ok, Derived::mf3</span></span><br><span class="line">d.<span class="built_in">mf3</span>(x);   <span class="comment">/// error, Base::mf3被遮掩</span></span><br></pre></td></tr></table></figure></li>
<li>该机制的目的在于提醒base和derived class之间的is-a关系 ##
override缺省遮掩行为</li>
<li>一般不在public继承下使用，破坏了is-a的关系</li>
<li>在private继承下有用 ### 使用using声明式 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::mf1;    <span class="comment">/// 让Base class内名为mf1和mf3的所有东西</span></span><br><span class="line">    <span class="keyword">using</span> Base::mf3;    <span class="comment">/// 在Derived作用域内可见(且public)</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.<span class="built_in">mf1</span>();    <span class="comment">/// ok，Derived::mf1</span></span><br><span class="line">d.<span class="built_in">mf1</span>(x);   <span class="comment">/// ok, Base::mf1</span></span><br><span class="line">d.<span class="built_in">mf2</span>();    <span class="comment">/// ok, Base::mf2</span></span><br><span class="line">d.<span class="built_in">mf3</span>();    <span class="comment">/// ok, Derived::mf3</span></span><br><span class="line">d.<span class="built_in">mf3</span>(x);   <span class="comment">/// ok, Base::mf3</span></span><br></pre></td></tr></table></figure> ###
转交函数(forwarding function)</li>
<li>Derived private继承Base，且只想继承无参数版本的的mf1
<ul>
<li>using会导入所有同名函数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span>  <span class="comment">/// 转交函数</span></span></span><br><span class="line"><span class="function">    </span>&#123; Base::mf1; &#125;      <span class="comment">/// 暗自成为inline函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">d.<span class="built_in">mf1</span>();    <span class="comment">/// ok，Derived::mf1</span></span><br><span class="line">d.<span class="built_in">mf1</span>(x);   <span class="comment">/// error, Base::mf1被遮掩</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h1 id="条款34-区分接口继承和实现继承">条款34
区分接口继承和实现继承</h1>
<ul>
<li>声明一个pure virtual函数的目的是为了让derived class只继承函数接口。
<ul>
<li>1个构造函数 + 1个析构函数 + n个赋值操作</li>
</ul></li>
<li>做法B
<ul>
<li>n个构造函数 + n个析构函数</li>
</ul></li>
<li>当classes的一个赋值成本低于一组构造+析构成本，做法A大体而言比较高效</li>
<li>此外A造成w的作用域比B更大，会对易维护性造成冲突 ### 结论</li>
<li>当满足以下两点时使用方法A，否则使用方法B
<ol type="1">
<li>赋值成本低于构造+析构</li>
<li>代码对效率高度敏感</li>
</ol></li>
</ul>
<h1 id="条款27-尽量少做转型动作">条款27 尽量少做转型动作</h1>
<ul>
<li>C++规则的设计目标之一:
<ul>
<li>保证<em>类型错误</em>绝不可能发生</li>
</ul></li>
<li>C风格转型/旧式转型 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(T)<span class="function">expression</span></span><br><span class="line"><span class="function"><span class="title">T</span><span class="params">(expression)</span> <span class="comment">/// 二者等价，将expression转型为T类型</span></span></span><br></pre></td></tr></table></figure></li>
<li>新式转型(<em>C++-style casts</em>) <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">const_cast</span>&lt;T&gt;( expression )         </span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;T&gt;( expression )</span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;T&gt;( expression )</span><br><span class="line"><span class="built_in">static_cast</span>&lt;T&gt;( expression )</span><br></pre></td></tr></table></figure> ###
新式转型更受欢迎:</li>
</ul>
<ol type="1">
<li>易辨识</li>
<li>转型动作的目标越窄化，编译器越可能诊断出错误的运用 ###
唯一使用旧式转型的时机</li>
</ol>
<ul>
<li>调用一个explicit构造函数将一个对象传递给一个函数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(<span class="type">int</span> size)</span></span>; </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomeWork</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>;</span><br><span class="line"><span class="built_in">doSomeWork</span>(<span class="built_in">Widget</span>(<span class="number">15</span>));</span><br><span class="line"><span class="built_in">doSomeWork</span>(<span class="built_in">static_cast</span>&lt;Widget&gt;(<span class="number">15</span>));</span><br></pre></td></tr></table></figure> ##
const_cast</li>
<li>常量性转除</li>
<li>唯一有此功能的新式转型 ## dynamic_cast</li>
<li>安全向下转型(safe downcasting)</li>
<li>唯一无法由旧式语法执行的动作</li>
<li>唯一可能耗费重大运行成本的转型动作 ### 实现(一个普遍的版本)</li>
<li>基于class名称的字符串比较
<ul>
<li>调用strcmp</li>
<li>深度、多重继承体系成本更高 ## reinterpret_cast</li>
</ul></li>
<li>执行低级转型</li>
<li>不可移植
<ul>
<li>实际动作及结果取决于编译器</li>
<li>如将<code>pointer to int</code>转化为<code>int</code> ##
static_cast</li>
</ul></li>
<li>强迫隐式转换(implicit conversion)
<ul>
<li>non-const --&gt; const</li>
<li>void* --&gt; typed*</li>
<li>pointer-to-base --&gt; pointer-to-derived ##
转型往往真的令编译器编译出运行期执行的码</li>
</ul></li>
<li>不只是告诉编译器将某种类型视为另一种类型 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">...</span><br><span class="line"><span class="type">double</span> d = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(x) / y;</span><br></pre></td></tr></table></figure></li>
<li>将int转型为double几乎肯定会产生代码
<ul>
<li>在大部分计算机体系结构中，int的底层表述不同于double
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; ... &#125;;</span><br><span class="line">Derived d;</span><br><span class="line">Base* pb = &amp;d; <span class="comment">/// 隐喻地将Derived*转换为Base*</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>同一个对象的Derived指针与Base指针值可能并不相同
<ul>
<li>与编译器如何实现有关</li>
<li>有时候存在一个偏移量</li>
<li>运行时会计算偏移量以转型</li>
<li>多重继承中几乎必然发生，单一继承中可能发生</li>
</ul></li>
<li>避免做出“对象在C++中如何布局”的假设</li>
</ul>
<h1 id="条款28-避免返回handles指向对象内部分">条款28
避免返回handles指向对象内部分</h1>
<h1 id="条款29-strive-for-exception-safe-code.">条款29 Strive for
exception-safe code.</h1>
<ul>
<li>不泄露任何资源</li>
<li>不允许数据败坏 ## 异常安全函数提供以下三个保证之一:</li>
</ul>
<ol type="1">
<li>基本承诺:
<ul>
<li>异常抛出时，程序内的任何事物仍然保持在有效状态下。</li>
<li>但在哪个有效状态不可预料</li>
</ul></li>
<li>强烈保证:
<ul>
<li>异常抛出时，程序状态不改变。</li>
<li>成功 --&gt; 完全成功</li>
<li>失败 --&gt; 回复到</li>
<li>往往以copy-and-swap实现</li>
<li>并非对所有函数都可实现或具备意义</li>
</ul></li>
<li>不抛掷(nothrow)保证:
<ul>
<li>承诺绝不抛出异常</li>
<li>内置类型的操作均遵守</li>
</ul></li>
</ol>
<h1 id="条款30-透彻了解inline的里里外外">条款30
透彻了解inline的里里外外</h1>
<h2 id="inline">inline</h2>
<h3 id="优点">优点</h3>
<ul>
<li>免除函数调用成本</li>
<li>编译器最优化机制通常用于浓缩“不含函数调用的代码” ### 缺点</li>
<li>增加<code>object code</code>的大小
<ul>
<li>可能导致额外的的换页</li>
<li>降低cache命中率 ## inline是对编译器的一个申请，不是强制命令</li>
</ul></li>
<li>编译器拒绝inline复杂函数
<ul>
<li>如递归、循环、virtual(运行期决定)</li>
</ul></li>
<li>编译器无法inline将给出告警 ### 隐式申请</li>
<li>将函数定义为class定义式内 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">age</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> theAge; &#125; <span class="comment">// 一个隐喻的inline申请</span></span><br><span class="line">    ...                                <span class="comment">// age被定义与class定义式内</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> theAge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>这样的函数通常是成员函数，但是friend函数也可定义与class内(见 条款46)
### 显式申请</li>
<li>在定义式前加上关键字inline <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;algorithm&gt;</span></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">inline</span> <span class="type">const</span> T&amp; <span class="title">max</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ##
inline函数通常被置于头文件内</li>
<li>编译期进行inline</li>
<li>方便编译器将函数调用替换为函数本体</li>
<li>template的具现化与inline无关
<ul>
<li>通常被置于头文件内，方便编译器具现化 ##
有时即便编译器inline某个函数，可能还是为该函数生成一个函数本体</li>
</ul></li>
<li>例如要取某个inline函数的地址时</li>
<li>编译器不对通过函数指针进行的调用实施inline <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="built_in">void</span> ( *pf ) = f;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">f</span>();        <span class="comment">// inline</span></span><br><span class="line"><span class="built_in">pf</span>();       <span class="comment">// outline</span></span><br></pre></td></tr></table></figure></li>
<li>编译器有时会自动生成inline函数的ouline副本
<ul>
<li>比如生成构造和析构函数的副本，这样在array中可使用函数指针进行构造和析构
## 构造函数和析构函数时inline糟糕的候选人 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::srting bm1, bm2;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123; &#125;;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::srting dm1, dm2, dm3;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>看起来构造函数和析构函数没有什么代码量，但其实不然</li>
<li>例如，一种可能的编译器实现: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Derived::<span class="built_in">Derived</span>() &#123;</span><br><span class="line">    Base::<span class="built_in">Base</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123; dm1.std::string::<span class="built_in">string</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123; </span><br><span class="line">        Base::~<span class="built_in">Base</span>();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123; dm2.std::string::<span class="built_in">string</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123; </span><br><span class="line">        Base::~<span class="built_in">Base</span>();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123; dm3.std::string::<span class="built_in">string</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123; </span><br><span class="line">        Base::~<span class="built_in">Base</span>();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="条款31-将文件间的编译依存关系降至最低">条款31
将文件间的编译依存关系降至最低</h1>
<h2 id="编译依存关系">编译依存关系</h2>
<ul>
<li>class的定义式不只详细描述了class接口，还包括十足的实现细目
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name. <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;    <span class="comment">/// 实现细目</span></span><br><span class="line">    Date theBirthDate;      <span class="comment">/// 实现细目</span></span><br><span class="line">    Address theAddress;     <span class="comment">/// 实现细目</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>C++将实现细目置于定义式中
<ul>
<li>编译器需要根据定义式确定分配多大空间</li>
</ul></li>
<li>Person若要通过编译，需要classes string，Date，Address的定义式
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;date.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;address.h&quot;</span></span></span><br></pre></td></tr></table></figure></li>
<li>但是，如此一来，Person定义文件和其含入文件形成了编译依存关系
<ul>
<li>如果这些头文件有一个被改变，或者这些头文件所依赖的其他文件有任何改变，那么每一个含入和使用Person
class的文件也必须重新编译 ## 编译依存性最小化 -- 接口与实现分离</li>
</ul></li>
<li>通过Handle classes和Interface
classes解除了接口和实现之间的耦合，降低了文件之间的编译依存性 ### pimpl
idiom -- <code>Handle class</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>   <span class="comment">// 标准程序组件不该被前置声明</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>   <span class="comment">// for shared_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PresonImpl</span>;   <span class="comment">// Person实现类的前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;         <span class="comment">// Person接口用到的classes的前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;PresonImpl&gt; pImpl_;</span><br><span class="line">&#125;;</span><br><span class="line">Person::<span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr)</span><br><span class="line">    : <span class="built_in">pImpl</span>(<span class="keyword">new</span> <span class="built_in">PresonImpl</span>(name, birthday, addr))</span><br><span class="line">    &#123;&#125;</span><br><span class="line"><span class="function">std::string <span class="title">Person::name</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pImpl-&gt;<span class="built_in">name</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Person的客户端完全与Date，Address以及Person的实现细目分开 ###
抽象基类(abstract base class、Interface class)</li>
<li>详细一一描述derived class的接口
<ul>
<li>一组pure virtual函数</li>
</ul></li>
<li>通常不带成员变量，也没有构造函数</li>
<li>只有一个virtual析构函数(见条款7) <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>客户必须以Person的pointers和references来撰写应用程序
<ul>
<li>除非Interface class修改，否则不用编译</li>
</ul></li>
<li>客户必须有办法为这种class创建新对象
<ul>
<li>工厂函数
<ul>
<li>返回指针指向动态分配所得的对象</li>
<li>往往在Interface class中声明为static <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;Person&gt; <span class="title">create</span><span class="params">(<span class="type">const</span> std::string&amp; name, </span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> Date&amp; birthday, </span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> Address&amp; addr)</span></span>; <span class="comment">// why shared_ptr;见条款18</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 客户如此使用</span></span><br><span class="line">std::string; name, </span><br><span class="line">Date dateodBirth, </span><br><span class="line">Address address;</span><br><span class="line">...</span><br><span class="line"><span class="function">std::shared_ptr&lt;Person&gt; <span class="title">pp</span><span class="params">(Person::create(name, dateodBirth, address))</span></span>;</span><br><span class="line">...</span><br><span class="line">std::cout &lt;&lt; pp-&gt;<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li>当然，支持Interface
class接口的那个具象类(<code>concrete class</code>)必须被定义出来
<ul>
<li>一切都在virtual构造函数的实现码所在文件内秘密发生 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealPerson</span> : <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RealPerson</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr)</span><br><span class="line">        : <span class="built_in">theName</span>(name), <span class="built_in">theBirthDate</span>(birthday), <span class="built_in">theAddress</span>(addr)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">RealPerson</span>() &#123;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;    </span><br><span class="line">    Date theBirthDate;      </span><br><span class="line">    Address theAddress;     </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> std::shared_ptr&lt;Person&gt; <span class="title">Person::create</span><span class="params">(<span class="type">const</span> std::string&amp; name, </span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">const</span> Date&amp; birthday, </span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">const</span> Address&amp; addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> <span class="built_in">RealPerson</span>(name, dateodBirth, addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>更现实的Person::create实现代码会创建不同的derived class ### 开销
#### Handle classes</li>
</ul></li>
</ul>
<ol type="1">
<li>成员函数必须通过implementation pointer取得对象数据，
<ul>
<li>每次访问增加一次间接性</li>
</ul></li>
<li>每个对象的内存消耗多一个implementation pointer的大小</li>
<li>implementation pointer必须初始化，指向动态分配的implementation内存
<ul>
<li>涉及到动态分配 #### Interface class</li>
</ul></li>
<li>virtual函数带来间接跳跃(见条款7)</li>
<li>派生类对象有一个vptr(见条款7) ### 本质</li>
</ol>
<ul>
<li>声明的依存性 替换 定义的依存性</li>
<li>尽量让头文件自我满足，做不到则让它与其他头文件内的声明式而非定义式相依
## 方法 ### 如果使用object
reference/pointer可以完成任务，就不要使用object</li>
<li>前者仅需声明，后者需要定义 ###
如果能够，尽量用class声明式替换class定义式</li>
<li>注意，当声明一个函数而它用到某个class的定义时，并不需要该class的定义
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;                         <span class="comment">// class声明式</span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span></span>;                       <span class="comment">// 没问题，这里并不需要Date的定义式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>;</span><br></pre></td></tr></table></figure> ### 为声明式和定义式提供不同的头文件</li>
<li>程序库客户应该总是#include一个声明文件而非前置声明若干class或函数
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;datafw.h&quot;</span>  <span class="comment">// 这个头文件内声明单未定义class Date</span></span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span></span>;                      </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>只含声明式的头文件名为"datefw.h",命名方式取法C++标准库的<iosfwd>
<ul>
<li><iosfwd>内含iostream各组件的声明式，其定义则分布在相应的头文件，包括<sstream>,<streambuf>,<fstream>,<iostream></li>
</ul></li>
<li>此方法同样适用于template
<ul>
<li>export关键字同样可以，但很少使用</li>
</ul></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2022/11/15/ARM64%E6%B1%87%E7%BC%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2022/11/15/ARM64%E6%B1%87%E7%BC%96/" class="post-title-link" itemprop="url">ARM64汇编</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-15 22:28:50" itemprop="dateCreated datePublished" datetime="2022-11-15T22:28:50+08:00">2022-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:18" itemprop="dateModified" datetime="2023-07-30T18:15:18+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/c/" itemprop="url" rel="index"><span itemprop="name">c++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="寄存器">寄存器</h1>
<ul>
<li>在arm64架构下，所有的寄存器都是64位，并且每个寄存器都有名字的，按照功能来划分，可分为一下几类，分别为：
<ol type="1">
<li>通用寄存器</li>
<li>程序计数器</li>
<li>堆栈指针</li>
<li>链接寄存器</li>
<li>程序状态寄存器</li>
<li>零寄存器</li>
</ol></li>
<li>下面分别说明这些寄存器的作用</li>
</ul>
<h2 id="通用寄存器">通用寄存器</h2>
<ul>
<li>64bit : x0 ~ x28 ，每个寄存器都是64bit</li>
<li>32bit：w0 ~ w28，实际上是x0~x28寄存器的低32bit</li>
<li>x0~x7：通过用来存储函数的参数，如果函数有更多的参数使用堆栈来传递</li>
<li>x0：通常用来存放函数的返回值</li>
</ul>
<h2 id="程序计数器">程序计数器</h2>
<ul>
<li>程序计数器叫<code>Program Counter</code>，俗称<code>PC</code>，也就是<code>x32</code>寄存器，存储着CPU当前正在执行的地址。</li>
</ul>
<h2 id="堆栈指针">堆栈指针</h2>
<ul>
<li><code>SP</code>
(<code>Stack Pointer</code>)，就是<code>x31</code>寄存器，存储的是栈顶的地址</li>
<li><code>FP</code>
(<code>Frame Pointer</code>)，<code>FP</code>也就是<code>x29</code>寄存器，存储着栈底的地址</li>
<li>随着函数的调用，<code>SP</code>、<code>FP</code>会不断的变化。</li>
</ul>
<h2 id="链接寄存器">链接寄存器</h2>
<p><code>LR</code>（<code>Link Register</code>），也就是<code>x30</code>寄存器，存储着函数的返回地址。
-
当函数结束时，就是通过LR寄存器的值，跳转到调用函数的位置继续往下执行。</p>
<h2 id="程序状态寄存器">程序状态寄存器</h2>
<ul>
<li><code>CPSR</code>
(<code>Current Program Status Register</code>)</li>
<li><code>SPSR</code>
(<code>Saved Program Status Register</code>)，在异常状态下使用，当发生异常时，会把<code>CPSR</code>的内容写入<code>SPSR</code>,
等异常恢复之后，又会把<code>SPSR</code>写会到<code>CPSR</code>中。</li>
</ul>
<p>零寄存器 WZR XZR 里面存储的值都是0。</p>
<p>常用指令 算术运算指令 mov 赋值指令</p>
<p>mov x0, #2 // 把2这个值赋值给x0寄存器 mov x0, x1 //
把x1寄存器中的值赋值给x0寄存器中 add
两个操作数相加，相加的结果存放到一个寄存器中</p>
<p>add, x2, x0, x1 //把x0的值与x1的值相加，得到的结果存放到x2寄存器中
add, x2, x0, #3 // 把x0的值与3相加，得到的结果存放到x2寄存器中 sub
第一个操作数减第一个操作数，得到的结果存放到一个寄存器中</p>
<p>sub, x2, x1, x0 //
x1的值减去x0的值，得到的结果存放到<em>x2</em>寄存器中 sub, x2, x1, #4 //
x1的值减去4，得到的结果存放到x2寄存器中 mul 乘法指令</p>
<p>mul x3, x1, x2 // x1 乘以 x2 的结果存放在 x3 中 sdiv 除法指令</p>
<p>sdiv w0, w0, w1 // w0 除以 w1 的结果存放在 w0 中 逻辑运算指令
这里的运算是指位运算</p>
<p>LSL 逻辑左移 按操作数所指定的数量向左移位，低位用零来填充 ASL
算术左移 通逻辑左移，ASL 与 LSL等价 lsl x0, x0, #1 asl x1, x1, x0 LSR
逻辑右移 按操作数所指定的数量向右移位，左端用零来填充。</p>
<p>ASR 算术右移 按操作数所指定的数量向右移位，左端用最高位位的值来填充
，如果是负数，最高位为1</p>
<p>lsr w1, w2, #1 asr x1, x2, #2 ROR 循环右移
按操作数所指定的数量向右循环移位，
左端用右端移出的位来填充。其中，操作数可以是通用寄存器，也可以是立即数。
当进行寄存器bit位数的循环右移操作时，通用寄存器中的值不改变。 ror x0, #6
ror w0, #32 // 循环移动了32位，w0的值不变 跳转指令 ret
相当于高级编程语言的return，函数返回。</p>
<p>cmp 将两个操作数相减，相减的结果会影响cpsr
寄存器的标志位，当结果小于0时，CPSR寄存器的N位为1， 等于0时，
CPSR寄存器的Z为位1。 cmp x0, x1</p>
<p>b
跳转指令，跳转找指定的标记处执行；可以带条件跳转，一般跟cmp配合使用，使用到的条件域如下：</p>
<p>EQ：equal NE：not equal GT：great than GE：great equal LT：less than
LE：less equal 普通跳转 b testCode，testCode是汇编代码中的一个标记</p>
<p>条件跳转，当x0和x1的值相等时，才跳转到testCode标记处执行代码</p>
<p>cmp x0, x1 beq testCode bl
带返回值的跳转指令，这个指令会做两个操作</p>
<p>将下一条指令的地址存储到lr （x30）寄存器中 跳转到标记处开始执行代码
bl
testCode，当执行完testCode标记处代码后，又会返回来执行bl指令下面的指令。
内存操作 load从内存中读取数据</p>
<p>ldr 地址没有偏移或者偏移为正数时使用 ldur 地址偏移为负数时使用 a) str
x5 [x0] x0中是内存的地址，读取的值存放在x5寄存器中, x寄存器读取8个字节
b）str w6 [x0] x0中是内存的地址，读取的值存放在w5寄存器中,
w寄存器读取4个字节 说明: 地址还可以偏移 str x5 [x0, #0x4] , stur x5 [x0,
#-0x4] ,
偏移量为正数往高地址偏移，使用str指令、偏移量为负数往低地址偏移，使用stur指令。</p>
<p>ldp 从指定内存中读取数据到一对寄存器中， p 是
pair的意思，这一对寄存器必须是同类型的，要么x类型,
要么w类型。其中低位读取到第一个寄存器、高位读取到第二个寄存器 ldp w5,
w6, [x0] , 地址可以偏移 ldp x5, x6, [x0, #-x04] store
往指定的内存写入数据</p>
<p>str str x1, [x0] str w2, [x1] str w3, [x1, #4] stur stur x3, [x0,
#-4] stur w2, [x1, #-4] stp stp x2, x3, [x0] stp w4, w5, [x0]
使用方法与从内存中读取数据类似，只不过是往内存写入数据。</p>
<p>总结
本文整理了一些在逆向iOS程序时常见的一些汇编指令，当然在实际逆向的过程所看到的汇编指令更加复杂，比如还有函数调用栈，这是下篇的内容。如有错误请指正。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2022/11/15/Effective%20C++(5)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2022/11/15/Effective%20C++(5)/" class="post-title-link" itemprop="url">Effective C++(5)--实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-15 10:28:50" itemprop="dateCreated datePublished" datetime="2022-11-15T10:28:50+08:00">2022-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:32" itemprop="dateModified" datetime="2023-07-30T18:15:32+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/c/" itemprop="url" rel="index"><span itemprop="name">c++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="条款26-尽量延后变量定义式出现的时间">条款26
尽量延后变量定义式出现的时间</h1>
<h2 id="循环">循环</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法A 定义于循环外</span></span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    w = 取决于某个i的值;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法B 定义于循环内</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="function">Widget <span class="title">w</span><span class="params">(取决于某个i的值)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="分析">分析</h3>
<ul>
<li>做法A
<ul>
<li>1个构造函数 + 1个析构函数 + n个赋值操作</li>
</ul></li>
<li>做法B
<ul>
<li>n个构造函数 + n个析构函数</li>
</ul></li>
<li>当classes的一个赋值成本低于一组构造+析构成本，做法A大体而言比较高效</li>
<li>此外A造成w的作用域比B更大，会对易维护性造成冲突 ### 结论</li>
<li>当满足以下两点时使用方法A，否则使用方法B
<ol type="1">
<li>赋值成本低于构造+析构</li>
<li>代码对效率高度敏感</li>
</ol></li>
</ul>
<h1 id="条款27-尽量少做转型动作">条款27 尽量少做转型动作</h1>
<ul>
<li>C++规则的设计目标之一:
<ul>
<li>保证<em>类型错误</em>绝不可能发生</li>
</ul></li>
<li>C风格转型/旧式转型 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(T)<span class="function">expression</span></span><br><span class="line"><span class="function"><span class="title">T</span><span class="params">(expression)</span> <span class="comment">/// 二者等价，将expression转型为T类型</span></span></span><br></pre></td></tr></table></figure></li>
<li>新式转型(<em>C++-style casts</em>) <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">const_cast</span>&lt;T&gt;( expression )         </span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;T&gt;( expression )</span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;T&gt;( expression )</span><br><span class="line"><span class="built_in">static_cast</span>&lt;T&gt;( expression )</span><br></pre></td></tr></table></figure> ###
新式转型更受欢迎:</li>
</ul>
<ol type="1">
<li>易辨识</li>
<li>转型动作的目标越窄化，编译器越可能诊断出错误的运用 ###
唯一使用旧式转型的时机</li>
</ol>
<ul>
<li>调用一个explicit构造函数将一个对象传递给一个函数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(<span class="type">int</span> size)</span></span>; </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomeWork</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>;</span><br><span class="line"><span class="built_in">doSomeWork</span>(<span class="built_in">Widget</span>(<span class="number">15</span>));</span><br><span class="line"><span class="built_in">doSomeWork</span>(<span class="built_in">static_cast</span>&lt;Widget&gt;(<span class="number">15</span>));</span><br></pre></td></tr></table></figure> ##
const_cast</li>
<li>常量性转除</li>
<li>唯一有此功能的新式转型 ## dynamic_cast</li>
<li>安全向下转型(safe downcasting)</li>
<li>唯一无法由旧式语法执行的动作</li>
<li>唯一可能耗费重大运行成本的转型动作 ### 实现(一个普遍的版本)</li>
<li>基于class名称的字符串比较
<ul>
<li>调用strcmp</li>
<li>深度、多重继承体系成本更高 ## reinterpret_cast</li>
</ul></li>
<li>执行低级转型</li>
<li>不可移植
<ul>
<li>实际动作及结果取决于编译器</li>
<li>如将<code>pointer to int</code>转化为<code>int</code> ##
static_cast</li>
</ul></li>
<li>强迫隐式转换(implicit conversion)
<ul>
<li>non-const --&gt; const</li>
<li>void* --&gt; typed*</li>
<li>pointer-to-base --&gt; pointer-to-derived ##
转型往往真的令编译器编译出运行期执行的码</li>
</ul></li>
<li>不只是告诉编译器将某种类型视为另一种类型 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">...</span><br><span class="line"><span class="type">double</span> d = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(x) / y;</span><br></pre></td></tr></table></figure></li>
<li>将int转型为double几乎肯定会产生代码
<ul>
<li>在大部分计算机体系结构中，int的底层表述不同于double
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; ... &#125;;</span><br><span class="line">Derived d;</span><br><span class="line">Base* pb = &amp;d; <span class="comment">/// 隐喻地将Derived*转换为Base*</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>同一个对象的Derived指针与Base指针值可能并不相同
<ul>
<li>与编译器如何实现有关</li>
<li>有时候存在一个偏移量</li>
<li>运行时会计算偏移量以转型</li>
<li>多重继承中几乎必然发生，单一继承中可能发生</li>
</ul></li>
<li>避免做出“对象在C++中如何布局”的假设</li>
</ul>
<h1 id="条款28-避免返回handles指向对象内部分">条款28
避免返回handles指向对象内部分</h1>
<h1 id="条款29-strive-for-exception-safe-code.">条款29 Strive for
exception-safe code.</h1>
<ul>
<li>不泄露任何资源</li>
<li>不允许数据败坏 ## 异常安全函数提供以下三个保证之一:</li>
</ul>
<ol type="1">
<li>基本承诺:
<ul>
<li>异常抛出时，程序内的任何事物仍然保持在有效状态下。</li>
<li>但在哪个有效状态不可预料</li>
</ul></li>
<li>强烈保证:
<ul>
<li>异常抛出时，程序状态不改变。</li>
<li>成功 --&gt; 完全成功</li>
<li>失败 --&gt; 回复到</li>
<li>往往以copy-and-swap实现</li>
<li>并非对所有函数都可实现或具备意义</li>
</ul></li>
<li>不抛掷(nothrow)保证:
<ul>
<li>承诺绝不抛出异常</li>
<li>内置类型的操作均遵守</li>
</ul></li>
</ol>
<h1 id="条款30-透彻了解inline的里里外外">条款30
透彻了解inline的里里外外</h1>
<h2 id="inline">inline</h2>
<h3 id="优点">优点</h3>
<ul>
<li>免除函数调用成本</li>
<li>编译器最优化机制通常用于浓缩“不含函数调用的代码” ### 缺点</li>
<li>增加<code>object code</code>的大小
<ul>
<li>可能导致额外的的换页</li>
<li>降低cache命中率 ## inline是对编译器的一个申请，不是强制命令</li>
</ul></li>
<li>编译器拒绝inline复杂函数
<ul>
<li>如递归、循环、virtual(运行期决定)</li>
</ul></li>
<li>编译器无法inline将给出告警 ### 隐式申请</li>
<li>将函数定义为class定义式内 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">age</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> theAge; &#125; <span class="comment">// 一个隐喻的inline申请</span></span><br><span class="line">    ...                                <span class="comment">// age被定义与class定义式内</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> theAge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>这样的函数通常是成员函数，但是friend函数也可定义与class内(见 条款46)
### 显式申请</li>
<li>在定义式前加上关键字inline <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;algorithm&gt;</span></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">inline</span> <span class="type">const</span> T&amp; <span class="title">max</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ##
inline函数通常被置于头文件内</li>
<li>编译期进行inline</li>
<li>方便编译器将函数调用替换为函数本体</li>
<li>template的具现化与inline无关
<ul>
<li>通常被置于头文件内，方便编译器具现化 ##
有时即便编译器inline某个函数，可能还是为该函数生成一个函数本体</li>
</ul></li>
<li>例如要取某个inline函数的地址时</li>
<li>编译器不对通过函数指针进行的调用实施inline <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="built_in">void</span> ( *pf ) = f;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">f</span>();        <span class="comment">// inline</span></span><br><span class="line"><span class="built_in">pf</span>();       <span class="comment">// outline</span></span><br></pre></td></tr></table></figure></li>
<li>编译器有时会自动生成inline函数的ouline副本
<ul>
<li>比如生成构造和析构函数的副本，这样在array中可使用函数指针进行构造和析构
## 构造函数和析构函数时inline糟糕的候选人 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::srting bm1, bm2;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123; &#125;;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::srting dm1, dm2, dm3;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>看起来构造函数和析构函数没有什么代码量，但其实不然</li>
<li>例如，一种可能的编译器实现: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Derived::<span class="built_in">Derived</span>() &#123;</span><br><span class="line">    Base::<span class="built_in">Base</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123; dm1.std::string::<span class="built_in">string</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123; </span><br><span class="line">        Base::~<span class="built_in">Base</span>();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123; dm2.std::string::<span class="built_in">string</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123; </span><br><span class="line">        Base::~<span class="built_in">Base</span>();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123; dm3.std::string::<span class="built_in">string</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123; </span><br><span class="line">        Base::~<span class="built_in">Base</span>();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="条款31-将文件间的编译依存关系降至最低">条款31
将文件间的编译依存关系降至最低</h1>
<h2 id="编译依存关系">编译依存关系</h2>
<ul>
<li>class的定义式不只详细描述了class接口，还包括十足的实现细目
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name. <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;    <span class="comment">/// 实现细目</span></span><br><span class="line">    Date theBirthDate;      <span class="comment">/// 实现细目</span></span><br><span class="line">    Address theAddress;     <span class="comment">/// 实现细目</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>C++将实现细目置于定义式中
<ul>
<li>编译器需要根据定义式确定分配多大空间</li>
</ul></li>
<li>Person若要通过编译，需要classes string，Date，Address的定义式
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;date.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;address.h&quot;</span></span></span><br></pre></td></tr></table></figure></li>
<li>但是，如此一来，Person定义文件和其含入文件形成了编译依存关系
<ul>
<li>如果这些头文件有一个被改变，或者这些头文件所依赖的其他文件有任何改变，那么每一个含入和使用Person
class的文件也必须重新编译 ## 编译依存性最小化 -- 接口与实现分离</li>
</ul></li>
<li>通过Handle classes和Interface
classes解除了接口和实现之间的耦合，降低了文件之间的编译依存性 ### pimpl
idiom -- <code>Handle class</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>   <span class="comment">// 标准程序组件不该被前置声明</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>   <span class="comment">// for shared_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PresonImpl</span>;   <span class="comment">// Person实现类的前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;         <span class="comment">// Person接口用到的classes的前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;PresonImpl&gt; pImpl_;</span><br><span class="line">&#125;;</span><br><span class="line">Person::<span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr)</span><br><span class="line">    : <span class="built_in">pImpl</span>(<span class="keyword">new</span> <span class="built_in">PresonImpl</span>(name, birthday, addr))</span><br><span class="line">    &#123;&#125;</span><br><span class="line"><span class="function">std::string <span class="title">Person::name</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pImpl-&gt;<span class="built_in">name</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Person的客户端完全与Date，Address以及Person的实现细目分开 ###
抽象基类(abstract base class、Interface class)</li>
<li>详细一一描述derived class的接口
<ul>
<li>一组pure virtual函数</li>
</ul></li>
<li>通常不带成员变量，也没有构造函数</li>
<li>只有一个virtual析构函数(见条款7) <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>客户必须以Person的pointers和references来撰写应用程序
<ul>
<li>除非Interface class修改，否则不用编译</li>
</ul></li>
<li>客户必须有办法为这种class创建新对象
<ul>
<li>工厂函数
<ul>
<li>返回指针指向动态分配所得的对象</li>
<li>往往在Interface class中声明为static <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;Person&gt; <span class="title">create</span><span class="params">(<span class="type">const</span> std::string&amp; name, </span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> Date&amp; birthday, </span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> Address&amp; addr)</span></span>; <span class="comment">// why shared_ptr;见条款18</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 客户如此使用</span></span><br><span class="line">std::string; name, </span><br><span class="line">Date dateodBirth, </span><br><span class="line">Address address;</span><br><span class="line">...</span><br><span class="line"><span class="function">std::shared_ptr&lt;Person&gt; <span class="title">pp</span><span class="params">(Person::create(name, dateodBirth, address))</span></span>;</span><br><span class="line">...</span><br><span class="line">std::cout &lt;&lt; pp-&gt;<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li>当然，支持Interface
class接口的那个具象类(<code>concrete class</code>)必须被定义出来
<ul>
<li>一切都在virtual构造函数的实现码所在文件内秘密发生 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealPerson</span> : <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RealPerson</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr)</span><br><span class="line">        : <span class="built_in">theName</span>(name), <span class="built_in">theBirthDate</span>(birthday), <span class="built_in">theAddress</span>(addr)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">RealPerson</span>() &#123;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;    </span><br><span class="line">    Date theBirthDate;      </span><br><span class="line">    Address theAddress;     </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> std::shared_ptr&lt;Person&gt; <span class="title">Person::create</span><span class="params">(<span class="type">const</span> std::string&amp; name, </span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">const</span> Date&amp; birthday, </span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">const</span> Address&amp; addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> <span class="built_in">RealPerson</span>(name, dateodBirth, addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>更现实的Person::create实现代码会创建不同的derived class ### 开销
#### Handle classes</li>
</ul></li>
</ul>
<ol type="1">
<li>成员函数必须通过implementation pointer取得对象数据，
<ul>
<li>每次访问增加一次间接性</li>
</ul></li>
<li>每个对象的内存消耗多一个implementation pointer的大小</li>
<li>implementation pointer必须初始化，指向动态分配的implementation内存
<ul>
<li>涉及到动态分配 #### Interface class</li>
</ul></li>
<li>virtual函数带来间接跳跃(见条款7)</li>
<li>派生类对象有一个vptr(见条款7) ### 本质</li>
</ol>
<ul>
<li>声明的依存性 替换 定义的依存性</li>
<li>尽量让头文件自我满足，做不到则让它与其他头文件内的声明式而非定义式相依
## 方法 ### 如果使用object
reference/pointer可以完成任务，就不要使用object</li>
<li>前者仅需声明，后者需要定义 ###
如果能够，尽量用class声明式替换class定义式</li>
<li>注意，当声明一个函数而它用到某个class的定义时，并不需要该class的定义
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;                         <span class="comment">// class声明式</span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span></span>;                       <span class="comment">// 没问题，这里并不需要Date的定义式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>;</span><br></pre></td></tr></table></figure> ### 为声明式和定义式提供不同的头文件</li>
<li>程序库客户应该总是#include一个声明文件而非前置声明若干class或函数
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;datafw.h&quot;</span>  <span class="comment">// 这个头文件内声明单未定义class Date</span></span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span></span>;                      </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>只含声明式的头文件名为"datefw.h",命名方式取法C++标准库的<iosfwd>
<ul>
<li><iosfwd>内含iostream各组件的声明式，其定义则分布在相应的头文件，包括<sstream>,<streambuf>,<fstream>,<iostream></li>
</ul></li>
<li>此方法同样适用于template
<ul>
<li>export关键字同样可以，但很少使用</li>
</ul></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2022/11/13/Tomasulo%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2022/11/13/Tomasulo%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">Tomasulo算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-13 22:00:05" itemprop="dateCreated datePublished" datetime="2022-11-13T22:00:05+08:00">2022-11-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:18" itemprop="dateModified" datetime="2023-07-30T18:15:18+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/CPU-pipeline/" itemprop="url" rel="index"><span itemprop="name">CPU pipeline</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>371</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="背景">背景</h3>
<ul>
<li>流水线运行的一个主要限制是：它们使用循序指令发射与执行的方式 ###
思想</li>
<li>动态调度 ### 乱序执行</li>
<li>操作数可用时立即执行程序</li>
<li>指令的循序发射以及乱序执行 ### 寄存器重命名</li>
<li>在写结果时，先将计算结果写到CDB（公共数据总线）中。然后CDB上进行广播，看这个计算结果有没有作为是其他指令源操作数的。如果保留站发现有，就会更新保留站源操作数的值。这样就代替了流水线寄存器。
### 循序提交</li>
<li>引入ROB(重排缓冲区, Reorder Buffer)</li>
<li>允许指令乱序执行，但必须循序提交</li>
<li>支持分支预测
<ul>
<li>对于推测错误就很好处理了，
<ul>
<li>因为哪怕已经执行了分支之后的命令，由于之前的指令还没有执行完毕，分支之后的指令就无法提交，所以很容易的就程序计数器改为正确的分支地址，而不影响其他指令结果。</li>
</ul></li>
<li>预测错误的概率还是相对较低的，在Intel Core
i7的分支预测器中错误预测率平均在5%以下</li>
</ul></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2022/11/13/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E5%99%A8-TAGE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2022/11/13/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E5%99%A8-TAGE/" class="post-title-link" itemprop="url">分支预测器-TAGE</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-13 22:00:05" itemprop="dateCreated datePublished" datetime="2022-11-13T22:00:05+08:00">2022-11-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:18" itemprop="dateModified" datetime="2023-07-30T18:15:18+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/CPU-pipeline/" itemprop="url" rel="index"><span itemprop="name">CPU pipeline</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>482</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="abstract">Abstract</h3>
<ul>
<li>conditional branch predicor
<ul>
<li>combine several predictions</li>
<li>adder tree?</li>
</ul></li>
<li>文章实现了一个组合预测器
<ul>
<li>预测器的下标代表该预测器对应的history length ### 背景</li>
</ul></li>
<li>流水线运行的一个主要限制是：它们使用循序指令发射与执行的方式 ###
思想</li>
<li>动态调度 ### 乱序执行</li>
<li>操作数可用时立即执行程序</li>
<li>指令的循序发射以及乱序执行 ### 寄存器重命名</li>
<li>在写结果时，先将计算结果写到CDB（公共数据总线）中。然后CDB上进行广播，看这个计算结果有没有作为是其他指令源操作数的。如果保留站发现有，就会更新保留站源操作数的值。这样就代替了流水线寄存器。
### 循序提交</li>
<li>引入ROB(重排缓冲区, Reorder Buffer)</li>
<li>允许指令乱序执行，但必须循序提交</li>
<li>支持分支预测
<ul>
<li>对于推测错误就很好处理了，
<ul>
<li>因为哪怕已经执行了分支之后的命令，由于之前的指令还没有执行完毕，分支之后的指令就无法提交，所以很容易的就程序计数器改为正确的分支地址，而不影响其他指令结果。</li>
</ul></li>
<li>预测错误的概率还是相对较低的，在Intel Core
i7的分支预测器中错误预测率平均在5%以下</li>
</ul></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2022/10/26/Docker%E4%BD%BF%E7%94%A8tips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2022/10/26/Docker%E4%BD%BF%E7%94%A8tips/" class="post-title-link" itemprop="url">Docker使用Tips</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-26 16:28:50" itemprop="dateCreated datePublished" datetime="2022-10-26T16:28:50+08:00">2022-10-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:18" itemprop="dateModified" datetime="2023-07-30T18:15:18+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/docker/" itemprop="url" rel="index"><span itemprop="name">docker</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="docker基本命令">docker基本命令</h1>
<h2 id="查看docker占用空间">查看docker占用空间</h2>
<pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker system df</span><br></pre></td></tr></table></figure></code></pre>
<h2 id="清理无用镜像缓存挂载数据">清理无用镜像、缓存、挂载数据：</h2>
<ul>
<li><code>docker system prune -a</code>
<ul>
<li>已停止的容器（container）</li>
<li>未被任何容器所使用的卷（volume）</li>
<li>未被任何容器所关联的网络（network）</li>
<li>所有悬空镜像（image）</li>
</ul></li>
</ul>
<h2 id="docker导出载入镜像库里的镜像">docker导出/载入镜像库里的镜像</h2>
<pre><code>- `docker save -o qemu-gem5-o3.tar  qemu-gem5-o3:v2.0` REPOSITORY:TAG
- 载入镜像`docker load &lt; images/qemu-gem5-o3.tar`</code></pre>
<h1 id="其他">其他</h1>
<h2 id="容器的磁盘占用">容器的磁盘占用</h2>
<pre><code>- 每次创建一个容器时，都会有一些文件和目录被创建，
    - 例如：`/var/lib/docker/containers/ID`目录，
    - 如果容器使用了默认的日志模式，他的所有日志都会以JSON形式保存到此目录下。
    - `/var/lib/docker/overlay2` 目录下含有容器的读写层，如果容器使用自己的文件系统保存了数据，那么就会写到此目录下。
- 进入到/var/lib/docker/containers 目录下 通过 du -h --max-depth=1 查找大文件占用,发现这些文件中占用空间最大的是***-json.log**文件。而此文件的内容为docker生成的日志文件。
- 然后可使用如下命令对该文件的内容进行清理：`cat /dev/null &gt; *-json.log`清理完成可不重启服务，
    - 但如果允许建议重启一下docker服务。在此执行`df -h`命令之后，你会发现overlay2所占的磁盘空间已经减小。

- 可以定期删除的地方，有3. ipch（可完全删除）</code></pre>
<h2 id="vscode-server-no-space-left-on-device">vscode-server : No space
left on device</h2>
<ul>
<li>删除diff和merged下的bin文件<code>rm -rf ~/.vscode-server/bin/*</code></li>
</ul>
<h2
id="docker中使用了叫overlay2的层叠式结构">docker中使用了叫overlay2的层叠式结构，</h2>
<ul>
<li><p>为了简化存储，一个容器运行后会直接把镜像的存储状况作为容器的存储状况，然后针对容器运行产生的任何改动，都会在容器下相关目录中进行存储差分信息，也就是说一个容器中的存储情况由镜像原始存储情况和改动差分内容共同组成。</p></li>
<li><p>以centos为例，docker的默认存储路径位于/var/lib/docker</p>
<ul>
<li>其中container文件夹保存着容器的相关信息，</li>
<li>image保存着镜像的相关信息，overlay2保存着容器虚拟文件系统的相关信息。
### overlay2中有diff目录和merged目录，</li>
</ul></li>
<li><p>diff中保存的就是差分信息</p></li>
<li><p>merged是在容器运行时才会出现的存储情况集合，我们可以直接对差分信息进行修改，也可以在merged中进行修改，修改后的结果也会出现在diff中，同时容器内部也会直观的看到我们的修改内容</p></li>
</ul>
<p>docker exec -it
f9922cef36973708172b909b7f3115248ebca48a359bef99c0051cd8c87ba89d bash
docker run -it -v ~/FDU/PPI/2023spring:/home gem5-amd64-env</p>
<h1 id="安装docker">安装docker</h1>
<ul>
<li>用国内 daocloud 一键安装命令：
<code>curl -sSL https://get.daocloud.io/docker | sh</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2022/10/22/Effective%20C++(4)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2022/10/22/Effective%20C++(4)/" class="post-title-link" itemprop="url">Effective C++(4)--设计与声明</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-22 16:28:50" itemprop="dateCreated datePublished" datetime="2022-10-22T16:28:50+08:00">2022-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:32" itemprop="dateModified" datetime="2023-07-30T18:15:32+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/c/" itemprop="url" rel="index"><span itemprop="name">c++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="让接口容易被正确使用不易被误用">18
让接口容易被正确使用，不易被误用</h2>
<h3 id="考虑用户可能犯怎样的错误">考虑用户可能犯怎样的错误</h3>
<ul>
<li>容易引起错误的做法 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> month, <span class="type">int</span> day, <span class="type">int</span> year);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>wrapper types
<ul>
<li>enum不具备类型安全性，可被用作ints <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Day</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Day</span><span class="params">(<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function">    : val(d) &#123;</span>&#125;    </span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">const</span> Month&amp; m, <span class="type">const</span> Day&amp; d, <span class="type">int</span> year);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Date</span>(<span class="number">30</span>, <span class="number">3</span>, <span class="number">1995</span>); <span class="comment">/// wrong! 不正确的类型</span></span><br><span class="line"><span class="built_in">Date</span>(<span class="built_in">Day</span>(<span class="number">30</span>), <span class="built_in">Month</span>(<span class="number">3</span>), <span class="built_in">Year</span>(<span class="number">1995</span>)); <span class="comment">/// wrong! 不正确的类型</span></span><br><span class="line"><span class="built_in">Date</span>(<span class="built_in">Month</span>(<span class="number">3</span>), <span class="built_in">Day</span>(<span class="number">30</span>), <span class="built_in">Year</span>(<span class="number">1995</span>)); <span class="comment">/// OK! 类型正确</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Month</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Month <span class="title">Jan</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Month</span>(<span class="number">1</span>); &#125; <span class="comment">/// 每次调用都会触发一次构造函数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Month <span class="title">Feb</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="type">static</span> <span class="keyword">auto</span> feb = <span class="built_in">Month</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> feb; </span><br><span class="line">    &#125; <span class="comment">/// only call once</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">static</span> Month <span class="title">Dec</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Month</span>(<span class="number">12</span>); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Month</span><span class="params">(<span class="type">int</span> m)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Date</span>(Month::<span class="built_in">Mar</span>(), <span class="built_in">Day</span>(<span class="number">30</span>), <span class="built_in">Year</span>(<span class="number">1995</span>));</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3
id="限制类型内什么事可做什么事不可做">限制类型内什么事可做，什么事不可做</h3>
<pre><code>- 常见的限制是加上const</code></pre>
<h3
id="除非有好理由尽量使types的行为与内置类型一致">除非有好理由，尽量使types的行为与内置类型一致</h3>
<pre><code>- 如ints，对a*b赋值不合法
- STL基本一致</code></pre>
<h3 id="消除客户的管理资源责任">消除客户的管理资源责任</h3>
<ul>
<li>例，工厂函数：返回智能指针
<ul>
<li><code>std::shared_ptr&lt;TimeKeeper&gt; getTimeKeeper();</code></li>
</ul></li>
<li><code>std::shared_ptr</code>允许指针被建立起来时指定一个资源释放函数（删除器，deleter）
<ul>
<li>auto_ptr不支持 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;TimeKeeper&gt; <span class="title">pTime</span><span class="params">(<span class="keyword">static_cast</span>&lt;TimeKeeper*&gt;(<span class="number">0</span>), getRidOfClock)</span></span>;</span><br><span class="line"><span class="comment">/// getRidOfClock是函数，删除器</span></span><br></pre></td></tr></table></figure></li>
<li>避免了DLL问题</li>
<li><code>std::shared_ptr</code>
<ul>
<li>是raw pointer两倍大（计数，删除器）</li>
<li>以virtual形式调用删除器</li>
<li>修改引用计数时线程同步化带来开销</li>
</ul></li>
</ul></li>
</ul>
<h2 id="设计class犹如设计type">19 设计class犹如设计type</h2>
<ul>
<li>对象应该如何被创建和销毁
<ul>
<li>构造函数</li>
<li>析构函数</li>
<li>内存分配和释放函数
<ul>
<li>operator new</li>
<li>operator new[]</li>
<li>operator delete</li>
<li>operator delete[]</li>
</ul></li>
</ul></li>
<li>对象的初始化和赋值该有什么的差别
<ul>
<li>拷贝构造函数 和 拷贝赋值函数</li>
</ul></li>
<li>什么是新type的合法值</li>
<li>新type需要配合inheritance graph吗</li>
<li>新type需要什么样的转换
<ul>
<li>如果允许T1对象被隐式转换为T2，
<ul>
<li>则需要在class T1内实现operator T2</li>
<li>或在class T2内实现一个non-explicit-one-argument的构造函数</li>
</ul></li>
</ul></li>
<li>什么样的操作符和函数对新type是合理的</li>
<li>什么样的标准函数应该驳回</li>
<li>谁该去用新type
<ul>
<li>哪些成员为 pubulic protected private</li>
<li>哪些class function为friends</li>
</ul></li>
<li>什么是新type的未声明接口</li>
<li>新type有多么一般化
<ul>
<li>如果定义一整个types家族，考虑template</li>
</ul></li>
<li>真的需要一个新type吗
<ul>
<li>如果定义新的derived
class只是为已有的class添加机能，考虑non-member函数或templates</li>
</ul></li>
</ul>
<h2 id="prefer-pass-by-reference-to-const-to-pass-by-value">20 Prefer
pass-by-reference-to-const to pass-by-value</h2>
<ul>
<li>前者效率高，且避免切割问题</li>
<li>以上规则并不适用于内置类型，STL的迭代器和函数对象。
<ul>
<li>pass-by-value往往更合适</li>
</ul></li>
<li>对象小并不意味着copy构造函数不昂贵
<ul>
<li>许多对象如大多数STL容器，内含的东西只比指针多一些，但复制这种对象却包括复制那些指针指向的每一样东西</li>
</ul></li>
</ul>
<h2 id="必须返回对象时别妄想返回其reference">21
必须返回对象时，别妄想返回其reference</h2>
<ul>
<li>构造函数是必须承担的成本</li>
</ul>
<h2 id="将成员变量声明为private">22 将成员变量声明为private</h2>
<ul>
<li>为class提供充分实现弹性</li>
<li><code>protected</code>成员变量的封装性并没有高过<code>public</code>成员变量
<ul>
<li><code>protected</code>成员变量的改变将会影响所有的<code>derived class</code></li>
</ul></li>
</ul>
<h2 id="prefer-non-member-non-friend-fuctions-to-member-functions">23
Prefer non-member non-friend fuctions to member functions</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrowser</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearHistory</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeCookies</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>许多用户想一次执行所有这些动作，那么哪种实现好呢？ <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// member函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrowser</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearEverything</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// non-member函数，更好的实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    wb.<span class="built_in">clearCache</span>();</span><br><span class="line">    wb.<span class="built_in">clearHistory</span>();</span><br><span class="line">    wb.<span class="built_in">removeCookies</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>non-member</code>函数
<ul>
<li>可允许对WebBrowser相关机能有较大的包裹弹性，最终导致较低的编译相依度，增加WebBrowser的可延展性
<ul>
<li>通过namespace分割不同类别的功能，并可以向namespace中添加新的non-member函数扩充</li>
</ul></li>
<li>原因，该函数并不需要看到WebBrowser内部的成员变量</li>
</ul></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// non-member函数，一般的做法，将两者放在同一个namespace</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WebBrowser</span> &#123; ... &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>namespace可跨越多个源码文件而classes不同，例如： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webbrowser.h -- 这个头文件针对class WebBrowser自身及其核心机能</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WebBrowser</span> &#123; ... &#125;;</span><br><span class="line">    ... <span class="comment">// 核心机能，例如所有客户都需要的non-member函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webbrowserbookmarks.h</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line">    ... <span class="comment">// 与书签相关的便利函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webbrowsercookies.h</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line">    ... <span class="comment">// 与cookie相关的便利函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这正是C++标准程序库的组织方式
<ul>
<li>std命名空间分散在许多头文件
<ul>
<li><vector>, <algorithm>, <memory> ...</li>
</ul></li>
<li>允许客户只对他们所用的一小部分系统形成编译相依
<ul>
<li>此方式并不适用于class成员函数，一个class必须整体定义，不能被分割为片段</li>
</ul></li>
</ul></li>
</ul>
<h2 id="若所有参数皆需类型转换请为此采用non-member函数">24
若所有参数皆需类型转换，请为此采用non-member函数</h2>
<ul>
<li>令class支持隐式转换通常是糟糕的主意
<ul>
<li>有例外，如建立在数值类型 ### 设计一个class表示有理数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">int</span> numerator = <span class="number">0</span>,       <span class="comment">/// 构造函数刻意不为explicit</span></span><br><span class="line">             <span class="type">int</span> denominator = <span class="number">1</span>);    <span class="comment">/// 允许int-to-Rational隐式转换</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numerator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">denominator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
#### Rational支持算术运算诸如加法、乘法</li>
</ul></li>
<li>member or non-member func？ ##### member函数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">const</span> Rational <span class="keyword">operator</span>* (<span class="type">const</span> Rational&amp; rhs) <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>可以支持两个有理数相乘</li>
<li>但是混合算术只有一半行得通,不满足交换律 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">result = oneHalf * <span class="number">2</span>;   <span class="comment">// good</span></span><br><span class="line">result = <span class="number">2</span> * oneHalf;   <span class="comment">// wrong</span></span><br></pre></td></tr></table></figure></li>
<li>oneHalf是一个内含operator*的class的对象，所以编译器调用该函数</li>
<li>然而整数2没有相应的class，也就是没有operator<em>成语函数；编译器会尝试寻找形如以下这般调用的non-member
operator</em>(在命名空间或global作用域内): <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = operator*(2, oneHalf);   // wrong,本例并不存在这样的函数，查找失败</span><br></pre></td></tr></table></figure></li>
<li>第一种发生了隐式转换 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// result = oneHalf * 2;   // good, non-expicit构造函数</span></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="function"><span class="type">const</span> Rational <span class="title">temp</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">result = oneHalf * temp;</span><br></pre></td></tr></table></figure></li>
<li>第二种无法触发non-expicit构造函数 ##### non-member函数</li>
<li>允许编译器在每一个实惨上执行隐式类型转换 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>* (<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(), </span><br><span class="line">                    lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominator</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Rational <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">result = oneHalf * <span class="number">2</span>;   <span class="comment">// ok</span></span><br><span class="line">result = <span class="number">2</span> * oneHalf;   <span class="comment">// ok</span></span><br></pre></td></tr></table></figure></li>
<li>此处不需要成为friend函数 ##### --&gt;&gt; template class</li>
<li>见条款46 ###
如果需要为某个函数的所有参数(包括this指针所指的隐喻参数)进行类型转换，则该函数必须为non-member</li>
</ul>
<h1 id="考虑写出一个不抛异常的swap函数">25
考虑写出一个不抛异常的swap函数</h1>
<ul>
<li>swap
<ul>
<li>STL的一部分</li>
<li>异常安全性编程的脊柱(见条款29)</li>
<li>处理自我赋值可能性的常见机制 ## 缺省情况下标准库的swap
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">        a = b;</span><br><span class="line">        b = a;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>只要T支持拷贝构造函数和拷贝赋值函数 ## pimpl手法 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetImpl</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; v;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs) &#123; <span class="comment">/// 复制Widget时，复制其WidgetImpl对象</span></span><br><span class="line">        ...</span><br><span class="line">        *pImpl = *(rhs.pImpl);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImpl* pImpl;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>要置换Widget时，我们只需要置换起pImpl指针,但缺省算法调用还复制了三个WidgetImpl对象
###
我们希望告诉std::swap当Widgets被置换时应该做的是置换其内部的pImpl指针</li>
<li>将std::swap针对Widget特化 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="comment">/// 表示它是std::swap的一个全特化</span></span><br><span class="line">    <span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt;(Widget&amp; a, Widget&amp; b) &#123; <span class="comment">/// &#x27;&lt;Widget&gt;&#x27;表明“针对T是Widget”而设计</span></span><br><span class="line">        <span class="built_in">swap</span>(a.pImpl, b.pImpl);     <span class="comment">/// 无法通过编译, pImpl is private data</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>当一般性的swap template施行于Widgets上时便会启用这个版本</li>
<li>通常我们不被允许改变std命名空间内的任何东西，但可以为标准template制造特化版本
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">const</span> Widget&amp; other)</span> </span>&#123; <span class="comment">/// 复制Widget时，复制其WidgetImpl对象</span></span><br><span class="line">        <span class="keyword">using</span> std::swap;</span><br><span class="line">        <span class="built_in">swap</span>(pImpl, other.pImpl);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="comment">/// 表示它是std::swap的一个全特化</span></span><br><span class="line">    <span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt;(Widget&amp; a, Widget&amp; b) &#123; <span class="comment">/// &#x27;&lt;Widget&gt;&#x27;表明“针对T是Widget”而设计</span></span><br><span class="line">        a.<span class="built_in">swap</span>(b);     <span class="comment">/// OK!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>该做法与STL容器具有一致性（public swap + std::swap特化版本） ##
Widget与WidgetImpl都是template <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetImpl</span> &#123;...&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;...&#125;;</span><br></pre></td></tr></table></figure> ### 偏特化</li>
<li>放个swap成员函数与之前相同，但是像上述方法一样特化std::swap会遇上乱流
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">const</span> Widget&amp; other)</span> </span>&#123; </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">    <span class="type">void</span> swap&lt;Widget&lt;T&gt;&gt;(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b) &#123; <span class="comment">/// 错误，不合法</span></span><br><span class="line">        a.<span class="built_in">swap</span>(b); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>C++只允许对<code>class template</code>偏特化，不允许对<code>function template</code>(<code>std::swap</code>)偏特化
<ul>
<li>全特化是所有的模板参数都被进行特化，偏特化也就是局部的参数特化</li>
<li>此处只对Widget特化，没有特化T，所以为偏特化</li>
</ul></li>
</ul>
<h3 id="重载1">重载(1)</h3>
<ul>
<li>当打算偏特化一个function
template时，惯常做法是<code>添加一个重载版本</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="comment">/// std::swap的重载版本</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span> </span>&#123; <span class="comment">/// 错误，不合法</span></span><br><span class="line">        a.<span class="built_in">swap</span>(b); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一般而言行得通，但是std是个特殊的命名空间
<ul>
<li>客户可以全特化std内的template</li>
<li>但不可添加新的template、class、function等任何东西</li>
</ul></li>
</ul></li>
<li><h3 id="重载2">重载(2)</h3></li>
<li>将<code>重载版本</code>放在新的命名空间 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Widget</span> &#123;...&#125;;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>现在，如果想置换两个Widget对象因而调用swap，C++的名称查找法则(<code>name lookup rules</code>;<code>argument-dependent lookup</code>或<code>Koenig lookup</code>)会找到WidgetStuff空间内的swap</li>
</ul>
<h2 id="应该调用哪个swap">应该调用哪个swap?</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(T&amp; obj1, T&amp; obj2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;    <span class="comment">// 令std::swap在此函数内可用</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">swap</span>(obj1, obj2);   <span class="comment">// 为T型对象调用最佳swap版本</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用优先级(以T是Widget为例):
<ol type="1">
<li><code>WidgetStuff::swap</code></li>
<li><code>template&lt;&gt; void swap&lt;Widget&gt;</code></li>
<li><code>std::swap</code></li>
</ol></li>
</ul>
<h2 id="总结">总结</h2>
<h3
id="如果swap的缺省实现代码提供足够的效率不需要额外做任何事">如果swap的缺省实现代码提供足够的效率，不需要额外做任何事</h3>
<h3
id="如果swap的缺省实现代码效率不足试着做以下事情">如果swap的缺省实现代码效率不足，试着做以下事情:</h3>
<ol type="1">
<li>提供一个public swap成员函数，高效置换
<ul>
<li>成员版的swap不可抛出异常
<ul>
<li>这是帮助class和class template提供强烈的异常安全保障</li>
</ul></li>
</ul></li>
<li>在class或template所在命名空间内提供一个non-member
swap，并调用上述成员函数</li>
<li>如果正在编写class而非class
template，为class特化std::swap,并调用成员函数</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2022/09/22/gem5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2022/09/22/gem5/" class="post-title-link" itemprop="url">Gem5</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-22 16:10:50" itemprop="dateCreated datePublished" datetime="2022-09-22T16:10:50+08:00">2022-09-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:18" itemprop="dateModified" datetime="2023-07-30T18:15:18+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/Gem5/" itemprop="url" rel="index"><span itemprop="name">Gem5</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>ROB</p>
<p>Branch Misspeculation 时钟触发tick() 遍历所有线程（what is thread） -
检查stall/squash 如果exe不在squash - IEW::executeInsts() - Check if
branch prediction was correct, if not then we need to tell commit to
squash in flight instructions. - squashDueToBranch</p>
<p>build/ARM/gem5.opt configs/example/se.py
--cmd=tests/test-progs/hello/bin/arm/linux/hello --cpu-type=O3CPU
--caches --l1d_size=64kB --l1i_size=16kB /home/zyh/2022fall/gem5#
build/X86/gem5.opt configs/example/se.py
--cmd=tests/test-progs/hello/bin/x86/linux/hello --cpu-type=O3CPU
--caches --l1d_size=64kB --l1i_size=16kB</p>
<h1 id="fetch">Fetch</h1>
<p>set(toIEW-&gt;commitInfo[tid].pc, fromIEW-&gt;pc[tid]);</p>
<p>squash(*fromCommit-&gt;commitInfo[tid].pc,
fromCommit-&gt;commitInfo[tid].doneSeqNum,
fromCommit-&gt;commitInfo[tid].squashInst, tid);</p>
<p>Fetch::doSquash（）</p>
<p>set(pc[tid], new_pc); decoder[tid]-&gt;reset(); memReq[tid] = NULL;
fetchStatus[tid] = Squashing; fetchQueue[tid].clear();</p>
<p>cpu-&gt;removeInstsNotInROB(tid);</p>
<pre><code>    squashInstIt(inst_it, tid);
            (*instIt)-&gt;setSquashed();
            removeList.push(instIt);</code></pre>
<p>cpu的instList里存了所有当前在流水线中的指令(包括在ROB的)</p>
<h1 id="commit">commit</h1>
<p>rob-&gt;squash() Status[tid] = Squashing;</p>
<h1 id="decode">decode</h1>
<p>fromFetch-&gt;insts[i]-&gt;setSquashed();
toFetch-&gt;decodeUnblock[tid] = 1;</p>
<h1 id="rename">rename</h1>
<p>toDecode-&gt;renameUnblock[tid] = 1; serializeInst[tid] = NULL;
Status[tid] = Squashing; renameStatus[tid] = Squashing;</p>
<h1 id="iew">iew</h1>
<p>收到通知 IEW::checkSignalsAndUpdate - squash(tid);
instQueue.squash(tid);
ldstQueue.squash(fromCommit-&gt;commitInfo[tid].doneSeqNum, tid);
emptyRenameInsts(tid);</p>
<p>通知 set(toCommit-&gt;pc[tid], inst-&gt;pcState());
inst-&gt;staticInst-&gt;advancePC(*toCommit-&gt;pc[tid]);</p>
<pre><code>    toCommit-&gt;mispredictInst[tid] = inst;
    toCommit-&gt;includeSquashInst[tid] = false;</code></pre>
<p>加了一页cpu状态和thread状态，gem5这边thread状态是跟流水线相关的，之后cpustate统称为thread状态
1、目标加一个当前整理gem5 cpu
state的原因，是由于之前是FMTM紧耦合，现在FM到QEMU去了，希望看到misprediction的时候可以用cpustate但是不会提交修改其状态，qemu给其需要的错误路径，让TM这边可以有中间结果进行流转
2、分支预测或cpu流水线流程执行的时候，相关cpu状态是copy备份了一份还是有更新把中间结果存到队列里？是否有ROB队列，其作用是什么？
主要整理一下分支预测到分支预测结果出来前，这些中间结果是怎么流转的。(似乎没有备份，有队列来存后面回退)</p>
<p>scoreboard 跟踪记录物理reg是否可使用 renameMap记录了idx-&gt;对应的reg
Rename::renameDestRegs(const DynInstPtr &amp;inst, ThreadID
tid)将inst-&gt;destRegIdx对应的reg的指针取出由inst保存，并将map中inst-&gt;destRegIdx对应的reg换成从freelist取出的reg
指令执行后由forward恢复</p>
<p>instruction’s view of the register file(s) -&gt; actual storage
locations -
类似虚拟内存到物理内存的映射，我们需要把指令视角下的寄存器映射到扁平化的物理内存上
- 该部分工作由cpu完成， - ISA负责解码后的指令需要的寄存器(指令视角)
,cpu将寄存器翻译成物理内存(寄存器) - %g1 --&gt; phy index[9]</p>
<p>/// 使用直接映射的问题
虚拟内存空间可能非常大（可能有间隙）并映射到较小的物理空间，
或者它可能很小并映射到较大的物理空间，其中额外的空间用于其他时间使用的其他虚拟空间。
您需要确保使用正确的尺寸（展平后）来调整表格的大小，因为这是可能的选择空间</p>
<p>另一个棘手的部分来自我们在索引中添加偏移量以区分整数、浮点数和杂项。
这些偏移在预展平世界中可能是一回事，但在展平后世界中需要是另一回事，以防止事物相互重叠而不会留下间隙。在这里很容易犯错，这也是我不喜欢这种抵消想法作为将不同类型分开的一种方式的原因之一。我宁愿看到一个二维索引，其中第二个坐标是寄存器类型。但在当今世界上，这是你必须跟踪的事情。</p>
<p>gem5选择使用rename and map</p>
<p>Relative
相对寄存器索引是在机器指令中编码的索引。每类寄存器（整数、浮点等）都有一个单独的索引空间，从
0
开始。寄存器类由操作码隐含。因此，源寄存器字段中的值“1”可能意味着整数寄存器1（例如，“%r1”）或浮点寄存器1（例如，“%f1”），这取决于指令的类型</p>
<p>Unified
虽然相对寄存器索引有助于保持指令编码紧凑，但它们是模棱两可的，因此不便于管理依赖项等事情。为了避免这种歧义，解码器通过添加特定于类的偏移量将每个相对索引范围重新定位到唯一位置，将相对寄存器索引映射到统一的寄存器空间。整数寄存器未修改，并继续从零开始。浮点寄存器索引（至少）偏移整数寄存器的数量，以便第一个
FP
寄存器（例如，“%f0”）获得大于最后一个整数寄存器的统一索引。类似地，杂项（又名控制）寄存器映射到
FP 寄存器索引空间的末尾</p>
<p>Flattened
统一的寄存器索引提供了对在执行中的给定点可作为指令操作数访问的所有寄存器的明确描述。不幸的是，由于某些
ISA
的复杂特性，它们并不总是明确地识别指令所引用的实际状态。例如，在具有寄存器窗口（尤其是
SPARC）的 ISA
中，特定的寄存器标识符（例如“%o0”）在“保存”或“恢复”操作后将引用与以前不同的寄存器。一些
ISA 具有在正常操作中隐藏的寄存器，但在发生中断时（例如，ARM
的特定于模式的寄存器）或在显式管理器控制下（例如，SPARC
的“备用全局变量”）被映射到普通寄存器之上。</p>
<p>我们通过维护一个扁平的寄存器空间来解决这个问题，该空间为每个唯一的寄存器存储位置提供不同的索引。例如，SPARC扁平寄存器空间的整数部分对全局变量和备用全局变量以及每个可用寄存器窗口都有不同的索引。从统一或相对寄存器索引转换为扁平寄存器索引的“扁平化”过程因
ISA 而异。在某些 ISA
上，映射是微不足道的，而另一些则使用表查找来进行转换。</p>
<p>生成统一寄存器索引和扁平寄存器索引之间的一个关键区别是前者总是可以静态完成，而后者通常取决于动态处理器状态。也就是说，从相对索引到统一索引的转换仅取决于指令本身提供的上下文（这很方便，因为转换是在解码器中完成的）。相反，到扁平寄存器索引的映射可能取决于处理器状态，例如中断级别或
SPARC 上的当前窗口指针。</p>
<p>组合寄存器索引类型 尽管修改寄存器索引的典型过程是相对 -&gt; 统一
-&gt; 扁平 ，但事实证明，相对与统一以及 扁平 与非 扁平
是正交属性。相对与统一指示索引是相对于其寄存器类（整数、FP
或杂项）的基址寄存器还是添加了其类的基址偏移量。扁平化与非扁平化表明索引是否已调整到帐户用于运行时上下文，例如寄存器窗口调整或备用寄存器文件模式。因此，相对扁平化的寄存器索引是其中已经考虑了运行时上下文，但仍相对于其类的基本偏移量表示的索引。</p>
<p>一组特定于类的偏移量用于从相对索引生成统一索引，无论索引是扁平的还是非扁平的。因此，即使在使用扁平地址时，偏移量也必须足够大以分隔寄存器类。因此，非扁平的统一寄存器空间通常是不连续的。</p>
<p>诸如 O3 之类的无序 CPU
模型通过将这些架构寄存器（使用扁平寄存器索引）重命名为底层物理寄存器文件，增加了另一层复杂性</p>
<p>静态工具 StaticInst 为二进制指令提供所有静态信息和方法。</p>
<p>它包含以下信息/方法：</p>
<p>指示它是哪种指令的标志（整数、浮点、分支、内存屏障等） 指令的 op 类
源和目标寄存器的数量 使用的整数和 FP 寄存器的数量 将二进制指令解码为
StaticInst 的方法 虚函数
execute()，它定义了如何为指令采取特定的架构操作（例如读取
r1、r2、添加它们并存储在 r3 中。） 处理启动和完成内存操作的虚函数
用于将内存操作拆分为两个操作的模型分别执行地址计算和内存访问的虚拟函数
反汇编指令的方法，以人类可读的格式打印出来。（例如 addq r1 r2 r3）
它没有动态信息，例如指令的 PC 或源寄存器的值或结果。这允许将 StaticInst
一对一映射到唯一的二进制机器指令。我们通过在 hash_map 中缓存二进制指令到
StaticInst
的映射来利用这一事实，允许我们只解码二进制指令一次，并在其余时间直接使用
StaticInst。</p>
<p>每条 ISA 指令都从 StaticInst 派生并实现自己的构造函数 execute()
函数，如果是内存指令，则实现内存访问函数。有关如何指定这些 ISA
指令的详细信息，请参阅 ISA_description_system。</p>
<p>动力装置 DynInst
用于保存有关指令的动态信息。这对于更详细的模型或无序模型是必要的，这两种模型都可能需要静态指令之外的额外信息才能正确执行指令。它存储的一些动态信息包括：</p>
<p>指令的PC 源寄存器和目标寄存器的重命名寄存器索引 预测的下一代 PC
指令结果 指令的线程号 正在执行指令的 CPU 指令是否被压缩 此外，DynInst
提供了 ExecContext 接口。当 ISA 指令执行时，DynInst 作为 ExecContext
传入，处理 ISA 对 CPU 状态的所有访问。</p>
<p>详细的 CPU 模型可以从 DynInst 派生并创建自己的特定 DynInst
子类，这些子类实现可能需要的任何其他状态或功能。有关此示例，请参见
src/cpu/o3/alpha/dyn_inst.hh。</p>
<p>decode收到squash信号后将该线程的，指令标记为Squashed，在随后的执行中，直接删除指令</p>
<p>-- help 打印所有指令</p>
<h1 id="ldmstm">ldmstm</h1>
<ul>
<li>arm32中使用，arm64已不再用</li>
<li>load multiple registers
<ul>
<li>包括pc</li>
<li>修改pc时被认为是控制指令</li>
</ul></li>
</ul>
<h1 id="gem5执行所有指令时都会检查cc-reg">gem5执行所有指令时都会检查CC
reg</h1>
<ul>
<li>如果不满足xc-&gt;setPredicate(false);
<ul>
<li>不会真正执行指令</li>
</ul></li>
<li>问： testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV,
condCode)是根据什么判断是否mis branch</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/zyhjy/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/zyhjy/">1</a><span class="space">&hellip;</span><a class="page-number" href="/zyhjy/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/zyhjy/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/zyhjy/page/8/">8</a><a class="extend next" rel="next" href="/zyhjy/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yuhang Zhang"
      src="/zyhjy/images/zyhjy.png">
  <p class="site-author-name" itemprop="name">Yuhang Zhang</p>
  <div class="site-description" itemprop="description">爱小雅，爱生活，爱物理!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/zyhjy/archives/">
        
          <span class="site-state-item-count">75</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/zyhjy/categories/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/zyhjy/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/zyhjy/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuhang Zhang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">407k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">11:19</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/zyhjy/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>

<script src="/zyhjy/js/utils.js"></script>


<script src="/zyhjy/js/schemes/pisces.js"></script>


<script src="/zyhjy/js/next-boot.js"></script>




  




  
<script src="/zyhjy/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>


</body>
</html>
