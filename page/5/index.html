<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
<meta name="referrer" content="no-referrer">
  <link rel="apple-touch-icon" sizes="180x180" href="/zyhjy/images/relativity128.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/zyhjy/images/relativity32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/zyhjy/images/relativity16.png">
  <link rel="mask-icon" href="/zyhjy/images/logo.svg" color="#222">

<link rel="stylesheet" href="/zyhjy/css/main.css">

<link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css?family=Comic Sans MS:300,300italic,400,400italic,700,700italic|Noto Serif SC:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/zyhjy/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/zyhjy/lib/pace/pace-theme-minimal.min.css">
  <script src="/zyhjy/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zyh-eric.gitee.io","root":"/zyhjy/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="爱小雅，爱生活，爱物理!">
<meta property="og:type" content="website">
<meta property="og:title" content="ZYHJY">
<meta property="og:url" content="https://zyh-eric.gitee.io/zyhjy/page/5/">
<meta property="og:site_name" content="ZYHJY">
<meta property="og:description" content="爱小雅，爱生活，爱物理!">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yuhang Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zyh-eric.gitee.io/zyhjy/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>ZYHJY</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-J17VP3T2B4"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-J17VP3T2B4');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/zyhjy/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ZYHJY</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/zyhjy/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/zyhjy/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/zyhjy/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/zyhjy/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/zyhjy/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-solutions">

    <a href="/zyhjy/solutions/" rel="section"><i class="fa fa-code fa-fw"></i>算法题解</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2023/04/12/Chiplets/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2023/04/12/Chiplets/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-12 00:00:00" itemprop="dateCreated datePublished" datetime="2023-04-12T00:00:00+08:00">2023-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:18" itemprop="dateModified" datetime="2023-07-30T18:15:18+08:00">2023-07-30</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>34 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>该论文讨论了系统级芯片（SoC）的复杂性和硅成本的增加促使将SoC分解为更小的“芯片块”。基于芯片块的SoC设计过程有望通过使用先进的封装技术将多个不同的芯片（例如CPU、GPU、内存、FPGA）紧密集成到一起来实现快速的SoC构建。然而，当将芯片块组装成单个SoC时，由于芯片块之间路由的复杂性增加，会出现正确性和性能问题。该论文提出了一种模块化但无死锁的路由方法，用于具有各种拓扑结构的基于芯片块的系统。</p>
<h1 id="introduction">INTRODUCTION</h1>
<p>在越来越复杂的工艺技术中，大型片上系统（SoC）的成本不断上升，这促使了基于“芯片”设计的SoC的出现。这个概念将传统的单片式SoC分解成几个更小的芯片，每个芯片都可以更便宜地开发，更容易在多个产品中重复使用，并使用最合适的工艺技术进行实现。芯片方法正在学术界[1]-[4]、工业界[5]-[11]和政府机构[12]中得到积极的研究
基于芯片的体系结构存在许多研究和工程挑战；我们关注其中一个具体但关键的问题。遵循模块化设计方法，每个单独的芯片都应该在不了解整个系统的情况下进行设计和验证。当从多个芯片构建SoC时，即使每个单独的组件都经过了正确的验证，完全集成的系统仍然可能存在正确性问题。互连网络特别容易受到这种影响。每个单独的芯片可能包含其自己的本地网络芯片（NoC），该NoC对于芯片内部流量是本地死锁自由且正常运行的。但是，连接多个NoC在一起可能会引入新的资源周期，从而导致跨芯片的循环依赖关系。”
虽然已经宣布了相对简单的基于芯片的体系结构[13]，或者甚至已经可用[14]，但这项工作进一步展望了基于在活动硅中间层上堆叠多个芯片的新兴体系结构（尽管我们也解释了如何将我们的方法应用于更接近的集成方法，例如被动中间层）。我们首先提供一些有关芯片的背景，并描述现有多芯片体系结构所涉及的模块化挑战。然后，我们介绍了一种新的基于芯片的路由方法，使每个芯片都可以独立设计，而不需要了解其他芯片或中间层的NoC细节，这是先前技术不支持的关键属性。我们的可组合路由方法利用了一个简单而强大的见解：从单个芯片的角度来看，整个系统可以抽象为单个虚拟节点。转向限制仅应用于连接芯片与虚拟节点之间的边界路由器，从而实现了以单个芯片为粒度的可处理分析和优化。
# II. CHIPLET-BASED SYSTEMS
“摩尔定律”和“丹纳德缩放定律”的减速使得先进工艺技术变得越来越复杂和昂贵。为了抵消缩放的减速，许多芯片变得更大，以继续在功能和性能上进行世代改进；最近的例子是使用了815平方毫米芯片的NVidia“Volta”GPU
[15]。最近，行业和政府正在追求和倡导基于“芯片组”的SoC设计概念，其中一个大型昂贵的SoC可以分解成多个较小、产量更高、成本更低的芯片组，然后使用先进的封装技术重新组装起来。这些技术包括AMD的超级计算APU愿景[6]，[10]，NVidia的MCM-GPU
[11]，TSMC的CoWoS（芯片-在-晶片-在-基板）服务，Marvell的MoChiTM（模块化芯片）架构[7]，[8]和DARPA的CHIPS项目[12]。芯片组方法还使得SoC可以结合来自不同公司的硅，例如最近宣布的Intel
Core处理器与AMD Radeon
Graphics技术[13]。计算机体系结构研究文献也反映了这些趋势，涉及使用被动硅中间层[16]、带微流控冷却的被动中间层[17]、有源硅中间层[2]、[18]和光子芯片组[3]、[4]等芯片组类似体系结构的研究。
## A. Active-interposer Chiplet SoCs
尽管当前的多芯片架构采用硅中间层[6]和多芯片模块[11]，[14]等被动集成技术，但本文展望了基于新兴活性硅中间层的芯片组SoC设计，如图1所示（我们在第VI节中探讨了其他封装技术）。尽管被动基板（仅有线而没有逻辑）[19]-[21]是近期商业关注的焦点，但越来越多的学术界[2]，[4]，[22]，工业界和政府研究机构[23]-[28]正在关注活性中间层。已经展示了一种带有3D
NoC的工作活性中间层原型[29]。
多常见的SoC功能可以移动到有源中间层，例如外部存储器接口、芯片间连接（即NoC）、外部IO和系统管理和调试（例如复位、JTAG）。这使得单个芯片可以更简单（减少设计时间）和更小（提高产量/成本）。如果芯片在更昂贵的技术节点（例如14nm）上实现，而中间层在更成熟和更便宜的工艺（例如28nm、20nm）上实现，则从更昂贵的芯片中移动逻辑到中间层可以获得额外的成本效益[2]。最近的分析得出结论，与被动硅中间层相比，有源中间层对于大型SoC来说也可以具有成本效益[30]。
## B. Baseline Assumptions
虽然我们提出的方法适用于各种可能的基于芯片的SoC，但我们专注于特定的架构作为工作示例。我们考虑了一个多芯片异构计算系统（“APU”），由CPU和GPU组件组成。图2显示了针对GPU计算进行优化的基线系统。有四个GPU芯片，每个芯片提供16个GPU
SIMD计算单元（CUs），以及一个中央CPU芯片，用于支持GPGPU工作负载的CPU阶段。这五个芯片堆叠在一个实现自己的NoC以相互连接芯片和其他常见系统功能的活动中间层上。
我们的基线配置使用网格拓扑结构来连接芯片和互连器的NoC子网络。每个GPU芯片的16个CU排列成4×4网格，互连器层也有一个4×4网格连接芯片。所有NoC组件都使用静态路由，采用路由表实现，这是当前商业系统（例如HyperTransport
[31]或QuickPath
Interconnect（QPI）[32]）的典型特征。每个芯片的本地网格和互连器网格使用X-Y路由。有关其他详细信息，例如NoC路由器配置（例如缓冲区大小，管道深度），请参见第V-A节。我们的基线提供了一个APU，其中包含64个GPU计算单元，4个CPU核心和8个外部内存通道，同时保持相对简单的结构以帮助我们的解释、评估和分析。
# 3. MOTIVATION ## A -
NoC提供了一种统一的接口，用于连接不同系统组件。与强制系统设计者在每对通信块之间实现特定接口并(更糟糕的是)验证每个接口的正确行为相比,NoC方法使得更模块化和可扩展的设计方法成为可能，这是将不同芯片连接在一起的自然选择。
- 路由可以显著影响网络性能、可靠性和功能性
。设计不良的路由算法可能会导致网络中的资源依赖关系，从而导致死锁，这可能对系统产生致命影响。我们在基于芯片片的系统中开发了一种模块化但无死锁的路由方法，该方法具有各种拓扑结构。
## B. Chiplet Composability Challenges -
对于多芯片SoC，小芯片可能来自不同的供应商[13]，即使由单个供应商提供，也可能由不同的团队独立设计。小芯片可能部署在多个产品中，包括在小芯片设计时甚至没有定义的未来产品，全局SoC路由信息可能不可用。因此，设计用于可扩展SoC或拓扑的小芯片变得极具挑战性，因为尽管每个小芯片的NoC可能是无死锁的，但它们仍然可以以在最终SoC中引入死锁的方式连接在一起。图3a显示了一个例子，其中两个4×4网状小芯片通过额外的链路连接。尽管每个单独的小芯片使用无死锁的X-Y路由，但仍然存在可能导致死锁的信道依赖性。图3b显示了一个基于两个小芯片插入器的系统，其中突出显示了一些潜在的依赖循环
-
大多数现有的无死锁路由算法都假设有完整的系统级信息可用，而这在基于小芯片的系统中并不一定有效。因此，这些方法不适用于路由可在多种SoC设计和拓扑中重复使用的模块化、独立设计的小芯片。我们解决了这个问题，并为未来SoC的模块化设计提出了一种可组合的路由算法。
## C. Deadlock Avoidance -
死锁是通过防止NoC的资源依赖关系图中的循环来避免的。有两种主要技术可以避免循环依赖：（1）<code>虚拟通道</code>（<code>VC</code>）方法[34]，以及（2）转弯模型[35]，[36]。转向模型不依赖于额外的虚拟通道来防止死锁。相反，它们对某些路径施加转向限制，以防止循环形成。在这项工作中，我们利用转弯限制来确保多芯片、基于插入器的NoC的死锁自由度，但我们引入了一种路由方法，该方法只需要在小芯片和插入器之间的“边界”处选择一些转弯限制。我们现在讨论相关工作，并在基于可重复使用的模块化小芯片的SoC的背景下解释其限制。
### VC-based Approaches -
基于VC的方法以<em>时间复用</em>的方式将物理信道划分为多个虚拟信道。每个VC都是独立管理的，并且在每个NoC路由器中都有专用的（每个VC）微片缓冲区。通过将不同的网络流分配给不相交的VC来消除循环依赖。请注意，除了避免协议级死锁所需的虚拟网络之外，还有路由死锁自由的VC。因此，对于需要复杂一致性协议的异构系统，所需的VC数量可能相当大（影响NoC路由器面积、功率等）。对于可组合的基于小芯片的系统，<em>必须预先配置VC数量，以支持最大的系统</em>，系统中的所有个体都必须为最大数量的VC实现这一点，导致小型系统的过度供应和单个小芯片的更高成本。
-
增加VC的数量会直接影响NoC路由器的面积和功率，因为每个VC都有自己的输入缓冲器，并且仲裁逻辑会随着VC的数量而扩展。从基于小芯片的系统的角度来看，单个小芯片的NoC可以设计成具有不同数量的VC，以保证死锁自由，这取决于本地拓扑和路由方案；这使得在集成多个这样的网络时设计和验证VC分配/仲裁逻辑极其复杂。为了使用VC消除死锁，设计人员需要提前了解完整的系统细节，过度配置VC，和/或限制每个小芯片和/或插入器的允许NoC。出于这些原因，我们寻求基于VC的方法的替代方案，以解决多芯片、基于插入器的SoC中的死锁。
### Flat Networks -
将整个系统作为一个平面网络，并应用统一的全局路由算法。在这种背景下，已经提出了许多拓扑不可知的路由算法。第一个这样的算法是up<em>/down</em>[37]，它使用由根节点形成的广度优先搜索（BFS）生成树。指向根的链接是上行链路，而其余的是下行链路。通过禁止消息从下行链路切换到上行链路来避免信道依赖性。上行*/下行路由需要以全局方式分析和编程所有路由表，这<strong>不允许单个芯片使用（更好的）本地路由决策。这也严重降低了系统的模块性和可组合性</strong>。我们还发现，上下路由会导致<strong>流量不平衡</strong>，因为<strong>根节点附近的链路往往比叶节点附近的更拥塞</strong>。
-
基于分段的路由将网络划分为子网，将子网划分为分段，并在每个分段内设置双向切换限制[38]。对于形成循环的起始段，除了起始路由器外，任何路由器都可以设置转弯限制；对于常规段，通过在任何路由器上设置双向转向限制来打破循环；对于仅由一条链路组成的一个路段，不允许任何流量穿过该链路（因此，在链路的一侧，必须在该链路和其他相邻链路之间设置双向转弯限制）。优化是可能的，因为转弯限制可以在一个路段内自由设置，而不依赖于其他路段。
-
Nue[39]是InfiniBand的一种基于目的地的遗忘路由实现。在网络的完全信道依赖图（CDG）的基础上，Nue构建了一个生成树，保证了死锁的自由性和连通性。然后，它使用Dijkstra算法计算从一个源节点到完整CDG中所有其他节点的最短路径，同时保持无循环约束。Nue不依赖VC来提供死锁自由，尽管额外的VC确实提高了负载平衡和性能
### ALL -
所有这些平面路由方法都需要目标SoC的全局信息来构建CDG，在CDG上可以实现死锁自由。对CDG进行全面分析的成本可能高得令人望而却步[40]。如前所述，完整的SoC配置和拓扑信息预计不可用于基于小芯片的系统（例如，小芯片可能用于未来尚未指定的SoC）。虽然我们提供了与其中几种方法的实验比较，但我们强调，这些现有方法都不能满足实现真正模块化和可重复使用的小芯片与独立优化的小芯片本地NoC的目标。
### Hierarchical Approaches: -
另一种方法是将NoC拓扑分解为几个层次结构层。在内部路由中，设计者可以自由地为单个级别选择任何现有的路由算法；并且每个节点只知道其级别内的本地节点。目的地为另一个级别的消息首先转发到连接到另一个层次结构级别的富时路由器。消息从源边界路由器指向其目的地通过其他边界路由器。分层路由的一个优点是独立分析本地网络的每一级，并且可以应用局部最优路由算法。然而，正如我们前面所讨论的，当<strong>将单个网络组合在一起时，全局网络仍然可能出现死锁</strong>。因此，必须小心避免全局死锁，这通常会导致对所有可能的全局路由路径进行逐案分析[41]，[42]。先前的工作提出了基于规则拓扑（如总线、环形、网格和树）的分层NoC[42]-[44]。然而，<strong>来自不同制造商的小芯片可能没有使用规则NoC进行设计，并且集成SoC系统可能不是对称的</strong>。因此，系统级的死锁避免仍然需要付出很大的努力，而且很容易出错。
## D. Comparison of Modularity -
虽然“模块化”可能有很多可能的定义，但我们将重点放在表I中列出的关键属性上。
- Table I: Comparison of deadlock avoidance approaches</p>
<table style="width:100%;">
<colgroup>
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>Independently Designed Chiplets</th>
<th>Enables Local Op-timization</th>
<th>Global CDG</th>
<th>Not Required Future-proof Chiplets</th>
<th>HW Cost</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>VC-based</td>
<td>-</td>
<td>++</td>
<td>+</td>
<td>-</td>
<td>High</td>
</tr>
<tr class="even">
<td>Flat NoCs</td>
<td>--</td>
<td>-</td>
<td>--</td>
<td>-</td>
<td>Low</td>
</tr>
<tr class="odd">
<td>Hierarchical</td>
<td>-</td>
<td>+</td>
<td>-</td>
<td>--</td>
<td>Low</td>
</tr>
<tr class="even">
<td>Composable(this work)</td>
<td>+</td>
<td>++</td>
<td>++</td>
<td>++</td>
<td>Low</td>
</tr>
</tbody>
</table>
<h3 id="independently-designed-chiplets">Independently Designed
Chiplets:</h3>
<ul>
<li>单个芯片的架构师应该能够设计和优化他们的本地NoC，而对整个SoC的其余部分知之甚少。基于VC的方法要求小芯片架构要么拥有整个SoC组织的信息（小芯片设计不再独立），要么过度提供VC的数量，以支持所有可能使用小芯片的SoC。扁平和分层的NoC通常也需要完整的SoC信息来分析和确保锁定自由
### Enables Local Optimization</li>
<li>模块化设计方法应允许小芯片架构师在独立于最终SoC组织的情况下局部优化一个chiplet的NoC。扁平化方法需要全局SoC信息，因此影响本地拓扑、路由算法、负载平衡等的芯片内优化，不能孤立地进行。分层NoC确实实现了一定程度的局部小芯片级优化，尽管这可能仍然受到完整CDG的全局分析的限制，以消除死锁。基于VC的方法以及本文提出的可组合方案有效地允许任意小芯片级别的NoC组织和优化
### Global CDG Not Required</li>
<li>平面和分层的NoC不是模块化的，因为构建依赖图需要所有通道的连接，并且在所有小芯片网络最终确定之前无法执行路由分配。在不影响全局路由决策的情况下优化本地NoC也是极其困难的，因为修改本地网络会改变全局CDG。基于VC的方法在局部优化方面提供了更大的灵活性，并且不需要全局CDG；他们需要一些全局信息来分配VC。我们的可组合方法要求与SoC集成商共享关于小芯片的一些有限信息（但远低于全套信道依赖性），并要求在独立的小芯片设计之间共享节点依赖性信息。
### Future-proof Chiplets</li>
<li>一个小芯片可能会集成到未来尚未设计的SoC中。由于扁平化和分层NoC方法需要全局CDG，小芯片将很难重复使用，因为本地NoC设计和优化可能已经固定。基于风险投资的方法可能会更好，但为尚未考虑的SoC过度提供风险投资可能会很昂贵。我们的可组合方法将与到/从中介器到SoC设计时间的流量相关的NoC决策延迟绑定（与设计小芯片时相反），从而在新的SoC组织中部署小芯片所需的效率和返工最少
### Hardware Cost:</li>
<li>除了基于VC的设计外，其他方法修改不同NoC组件的路由表，因此硬件开销很小。对于基于VC的方法，特别是如果需要为未来的系统进行超额配置，则支持更多VC的区域影响可能会相对昂贵。</li>
</ul>
<h1 id="iv.-multi-chiplet-routing">IV. MULTI-CHIPLET ROUTING</h1>
<p>在本节中，我们为芯片组系统提出了一种可组合、拓扑无关、无死锁的路由方法。关键的洞察力是简单而强大的：从任何单个芯片的角度来看，整个系统（与其他芯片的总数或中间层复杂性无关）都可以抽象成一个单一的虚拟节点，这使得在芯片粒度上进行可处理性分析、优化和正确性成为可能。我们详细介绍了一种基于芯片的路由具体方法，但这只是我们的关键洞察力所能实现的一种可能解决方案。
## A. Overview - Before describing our methodology, we define some
terms. ### 定义1： -
芯片组的边界路由器通过边界链路将芯片组连接到中间层。从中间层到芯片组的流量称为入站流量；从芯片组到中间层的流量称为出站流量。
### 定义2： -
边界路由器b的入站可达性InR(b)是从中间层通过路由器b可以到达的芯片上路由器的比例；0
&lt; <em>InR(b)</em> ≤ 1。 ### 定义3： -
边界路由器b的出站可达性OutR(b)是可以通过路由器b到达中间层的芯片上路由器的比例；0
&lt; <em>OutR(b)</em> ≤ 1。 ### 定义4： -
<em>InD(r)</em>是芯片路由器r的入站距离，是从最近的可以到达r的边界路由器到路由器r的拓扑距离。
### 定义5： -
芯片上路由器r的出站距离<em>OutD(r)</em>是从r到其最近可达边界路由器的拓扑距离。</p>
<p>这段话是在讨论可组合路由方法的目标。该方法的目标是尽可能地隔离单个芯片和中间层的设计，允许对每个芯片和中间层进行独立的负载平衡优化，同时为整个系统提供无死锁路由。</p>
<p>具体来说，我们在每个芯片上的边界路由器上放置单向转向限制。当应用转向限制时，系统的其余部分被抽象为一个与所有边界路由器相连的单个节点。转向限制确定了每个边界路由器的入站和出站可达性，并保证每个芯片内不存在循环通道依赖关系。然后，可达性信息传播到中间层，中间层负责将消息从一个边界路由器路由到另一个边界路由器。有了边界路由器可达性的知识，消息就会被转发到正确的目标芯片。一旦消息到达目标边界路由器，本地芯片NoC将把消息路由到其最终目的地。这种分层方法使用两组路由表来为每个芯片提供服务。第一组表用于在同一芯片内本地路由消息（这是常规的芯片内部路由），而第二组表则将出站消息引导到适当的边界路由器。本节末提供了更多实现细节。与第一条路由表（芯片内部）相对应的路由决策可以完全独立于系统的其余部分进行，这可能甚至尚未定义。
## B. Chiplet Design Guidelines
在设计芯片级NoC时，边界路由器的数量和位置是两个关键的设计参数，它们可以影响整个系统的性能。这些与芯片和中介器之间的垂直（微颗粒）链接数量有关
### Number of Boundary Routers: -
边界路由器的数量决定了芯片可以维持发送/接收离片流量的吞吐量；边界路由器越多，离片流量带宽就越高。一个极端情况是将芯片上的每个路由器都连接到中介器上，使每个路由器都成为边界路由器，这是先前其他人考虑过的[2]，[22]。然而，这样的设计可能会超额配置预期的离片流量，并可能受到可用微颗粒密度的限制。
-
在确定每个芯片的边界路由器数量时，一个关键观察是，虽然可能的边界路由器最大数量是芯片面积的函数，但最大有用带宽是其周长的函数。对于一个n×n网格的芯片，我们已经分析确定，在本文考虑的中介器拓扑结构下，n个边界路由器就足够了（为简洁起见，完整分析被省略）。对于我们大多数实验中假定的4×4芯片，我们每个芯片使用四个边界路由器。虽然我们专注于网格，但我们的方法适用于其他拓扑结构（请参见第VI节）。
### Turn Restrictions at Boundary Routers -
图3中的简单示例表明，通过中介器、其他芯片等，可能存在大量潜在的依赖循环，导致需要分析的可能路径数量爆炸。为了使单个芯片级别的路由决策成为可能，并使芯片间依赖分析可行，我们将系统的其余部分抽象为单个节点，并将所有边界路由器连接到抽象节点上（图4）。与之前的工作不同，这种新颖的抽象步骤是实现芯片独立设计的关键，而不需要全局CDG信息。
-
我们使用转向限制来打破包含抽象节点和一对边界路由器的循环。抽象节点代表单个芯片设计者不需要了解的系统的其余部分，因此<strong>转向限制不适用于抽象节点</strong>。在为边界路由器选择禁止转向时，必须保持连通性（即，每个芯片路由器到抽象节点之间必须存在路径，反之亦然），因此<strong>禁止导致断开NoC的转向限制</strong>。
-
在保持连通性的同时打破所有循环足以确保与该芯片相关的操作的正确性。但是，为了性能原因，仍然需要仔细选择转向限制和路由。可以采用不同的启发式方法；我们描述了一种在实践中表现良好的可能方法。我们考虑负载平衡的入站和出站可达性。不平衡的入站或出站可达性可能会导致芯片和/或中介器拥塞。同时，所有芯片路由器的入站和出站距离的平均值应该最小化，因为当路由到芯片外时，如果消息有多个边界路由器候选，则首选最近的边界路由器。总体而言，在选择禁止转向时，我们的目标是最小化平均距离/平均可达性，其中距离和可达性在第IV-A节中定义，并且平均值是在所有芯片上计算的。具体而言，平均距离是芯片上所有路由器的入站和出站距离的平均值。平均可达性类似地计算每个边界路由器的入站和出站可达性。我们的启发式方法选择具有较低平均距离和较高平均可达性的组合。
-
为了可视化指标，图4给出了一个4×4网格的示例，其中有3个边界路由器a、b和c；其余的系统用x表示。假设本地芯片NoC采用X-Y路由，禁止转弯的箭头在边界路由器处被划掉。包含x和任意一对边界路由器的循环通过禁止某些转弯来打破。
在此示例中，a 的入站可达性 (InR(a)) 为
1/2，因为其入站转向限制与小芯片的本地 X-Y
路由相结合，使得小芯片的左半部分无法从节点 x 通过 a 到达。
由于a没有出站转向限制，其出站可达性OutR(a)为1，即每台路由器都可以通过a到达x。
x → a → c → x 的环路在 c 处因出站转弯限制而中断，导致 OutR(c) = 1/2。
或者，不是在路由器 c 处断开环路，而是可以在路由器 a 处放置入站转弯限制 x
→ a → (3, 3) 以断开相同的环路，为此 InR(a) 变为 1/4（仅列 编号 2
可通过路由器 a
到达，因为两个单独的入站转弯限制用于打破两个不同的环路），并且 OutR©
变为 1。 路由器 m 的入站距离为 3，从边界路由器 b 测量； 出站距离为 3，到
a 或 b。 同样，从路由器c测得的路由器InD(n)=1； OutD(n) = 2 到路由器 a。
虽然此示例出于说明目的有些特别，但我们提供了一个具体的算法来确定下面的所有这些。
### Boundary Router Placement -
给定一个内部芯片级路由算法，边界路由器的选择会影响它们的入站和出站可达性以及芯片上的流量分布。我们提出了以下选择边界路由器的准则。
首先，避免将边界路由器聚集在一起，以减少创建网络热点的机会。
其次，应该以一种使所有边界路由器的入站/出站可达性保持平衡的方式放置边界路由器。
第三，更喜欢具有较低基数的路由器。
前两个准则旨在优化网络性能和吞吐量。第三个准则旨在最小化电路复杂性。例如，在图4中，芯片中间的四个路由器每个都有五个端口（四个连接到相邻路由器，第五个连接到它连接的网络端点，例如GPU
CU）。向其中一个“内部”路由器添加垂直链接将强制该路由器实现六个端口，这会增加面积并可能影响电路时序。但是，向芯片边缘上的任何一个路由器添加垂直链接都可以使所有路由器继续具有五个或更少的端口。
### Boundary Router Placement and Turn Restriction Algorithm - 算法1
确定每个芯片的边界路由器位置和转向限制。
PlaceBoundaryRouter通过调用SetTurns迭代所有边界路由器位置，以查找更好的位置和转向限制。
对于每个放置，函数identifyAllBoundaryTurns枚举所有可能的边界转弯并将它们存储在列表bturn
[]中。另一个列表pturn
[]存储禁止的边界转弯，这在SetTurns中递归更新。变量max是消除所有死锁所需的最大禁止边界转弯数。
- 过程 SetTurns
使用启发式方法检查所有边界转弯组合，如果当前限制改进了用户指定的目标函数，则更新迄今为止找到的最佳位置。
我们使用 CDG [39]、[45] 的矩阵表示。 最初，允许所有边界转弯。
更新函数（第 16 行）使用 Floyd Warshall 全对最短路径算法 [46]
传播到整个图的通道连接的禁止边界转弯列表 pt[] 更新 CDG。
这提供了来自更新的 CDG 的连接信息、边界路由器可达性和跳数。
下一步检查用户指定的目标函数是否得到改进（第 17 行）。 在第 19
行，connected 函数检查 CDG
是否仍然连接，因为任何导致网络断开的转向限制都应该被丢弃。
如果图是连通的，hasLoop
会检测入站通道（从抽象节点到边界路由器）是否连接到出站通道（从边界路由器到抽象节点）。
如果没有找到循环，则在第 22 行更新最佳位置，递归终止。 第 24
行控制递归的深度，因为只需要一定数量的边界限制就可以消除死锁。 如果 CDG
已连接但循环仍然存在，则第 27-29 行调用对 SetTurns
的递归调用以根据需要添加更多转弯限制。 ## C. Interposer NoC
Configuration -
确定了芯片的进出转向限制后，我们现在解释如何编程中继器的路由表。请注意，当单独考虑中继器网络（不包括芯片）时，中继器网络本身也应该是无死锁的。中继器负责将消息从一个边界路由器路由到另一个边界路由器。为此，必须向中继器提供某些芯片级别的信息。
首先，我们需要知道每个单独边界路由器可达的芯片节点（终端节点）。我们使用这个来确保消息从可以到达目的地的芯片边界路由器路由。其次，我们可以选择使用每个边界路由器和其可达芯片节点之间的拓扑距离来优化路由距离和负载平衡。请注意，这些信息可以简单地以“列表”格式列出（例如，节点x可以从边界节点y到达）；不需要芯片的本地NoC的完整细节（例如，网络的拓扑和请求如何从y到x的路由决策），并且这些信息独立于interposer和任何其他芯片。
我们现在描述我们的互连路由方案。对于每个目标路由器的消息，以下算法决定将该消息发送到目标芯片的哪个边界路由器。如果目标只能通过单个边界路由器到达，则中间件必须将消息路由到该特定边界路由器。否则，我们选择边界路由器以在边界路由器之间平衡网络负载（平均利用芯片-中间件带宽），同时最小化路径长度（避免发送消息在高度迂回的情况下只是为了负载平衡）。下面，我们正式指定算法。
- 对于给定的边界路由器i，仅由i可到达的节点集合称为Ai。 -
对于可以被多个边界路由器到达的其余节点，列表Ci包含所有节点，这些节点在拓扑上比任何其他边界路由器更接近i。对于不同的边界路由器j和k，Cj∩Ck=∅。
-
剩余的节点与至少两个边界路由器等距。设Ei，j是同时等距于边界路由器i和j的节点列表。虽然可能等距于两个以上的边界路由器，但为简单起见，我们仅考虑两个路由器的情况。
• 执行以下步骤将芯片上的节点分配给边界路由器。 -
第1步。在所有边界路由器中，选择具有Ai中最小项目数的路由器i。 -
第2步。逐个将Ci中的节点分配给Ai，直到Ai中的项目数不再是最小值。将项目分配给Ai时，从Ci中删除该项。如果Ai仍然具有最小数量的项目，则逐个从Ei，j中分配节点到Ai。将项目分配给Ai后，从Ei，j和Ej，i中删除该项。
-
第3步。如果无法进行进一步分配，则完成对边界路由器i的节点分配。重复步骤1-3，直到Ci
= ∅且Ei，j = ∅对于所有边界路由器i和j。
完成后，每个边界路由器的节点分配信息都存储在Ai中。通过参考这些信息，配置相应的中间层路由表。系统集成商可以自由选择任何对于中间层网络来说是死锁自由的底层路由算法。
- 考虑图4中的示例。对于边界路由器a、b和c，Aa = {(2, 0),(2, 1),(2, 2),
a}，Ab = {(0, 0),(0, 1), m,(0, 3), b,(1, 1),(1, 2),(1, 3)}，Ac = ∅；Ca =
{(3, 3)}，Cb = ∅，Cc = {(3, 0), c,
n}。在这个网络中没有等距集。节点分配从边界路由器c开始，因为Ac为空。Cc中的所有元素都分配给Ac，Ac
= {(3, 0), c,
n}。对于c，不能进行进一步的分配，因此算法选择下一个路由器a。Ca中唯一的元素被分配给Aa，Aa
= {(2, 0),(2, 1),(2, 2), a,(3,
3)}。到目前为止，每个芯片上的节点都被分配给了一个边界路由器；这些分配存储在Aa、Ab和Ac中。有了上述信息，互连器就能将消息路由到正确的边界路由器（a、b或c），如果消息是发送到该芯片的话。
## D. Deadlock Freedom and Connectivity -
现在我们展示可组合路由方案是无死锁且连通的。假设存在一个循环r1，l1，r2，l2，…，rn，ln，其中r表示路由器，l是连接到r的链接。如果所有路由器和链接都属于同一个芯片，则与基本假设芯片级网络无死锁相矛盾。否则，如果循环的子集属于插板和其他芯片，则可以用单个节点x来抽象这个子集。因此，该循环转换为r1，l1，…，rj，x，rk，lk，…，rn，ln。因为删除了包含x的循环中的所有循环依赖项，所以新循环是无死锁的。因此，可组合路由方案是无死锁的。
-
单个芯片内的任何网络都是连接的，因为边界路由器转向限制不影响内部芯片网络。芯片上的任何节点都能通过至少一个边界路由器到达中间层。中间层网络是通过构造连接的（即，每个中间层路由器都可以到达其他中间层路由器）。对于任何一对芯片节点，都存在一条路径。因此，该系统是连接的。
## E. Microarchitectural Issues -
每个芯片需要实现两个不同的路由表。第一个处理从不到达互连器的芯片内部流量。这个路由表可以以芯片设计者认为合适的任何方式填充。第二个路由表将出站流量定向到适当的边界路由器。这种组织方式假定整个系统中所有路由器端点都有全局ID空间。类似于用于检测系统中所有内存和计算资源（特别是在多插槽SMP系统中）的引导序列，可组合的基于互连器的SoC需要一个类似的系统配置协议。这个过程的一部分将是检测可用的NoC端点，为每个端点分配唯一ID，并计算和填充次级路由表。与系统引导不同，这个过程只会由SoC集成器在物理组装SoC后执行一次（尽管也可以提供钩子以在以后的某个时间点更新表，例如处理失败的链接[32]）
-
在我们的设计中，每个网络接口（NI）都有一个查找表，将出站数据包的目标ID映射到边界路由器ID。然后将边界路由器ID嵌入标题flit中，并用于芯片内路由，直到数据包离开芯片。关于面积/功率开销，每个NI中的查找表需要针对给定产品的最大系统大小进行配置。路由表通常比其他路由器组件（如缓冲区和交叉点）小得多。此外，每个芯片中第二个路由表的大小仅与边界路由器的数量成比例；因此，它比第一个路由表小得多。有几种实现互连路由器的方法：1）为最大系统大小提供路由表，导致相对较大的互连路由表；或2）添加另一层目标映射以将目标ID转换为目标边界路由器ID，导致更小的路由表但更复杂的边界路由器。总体而言，与规范的两级路由器相比，我们的设计不应产生显着的额外功率/面积/时间影响。
# V. EVALUATION ## A. Experimental Methodology -
为了评估网络性能，我们使用由 gem5 [47] 和 GPU 模型 [48] 的修改版本组成的
APU 模拟平台进行周期级执行驱动模拟。 我们使用 Garnet [49]
来模拟使用每通道 4-flit 缓冲区的 2 级路由器的网络。 我们的初始实验使用图
2 所示的多芯片 APU 配置，包括四个 GPU 芯片、一个 CPU
芯片和一个有源中介层。 CPU chiplet 由 CPU 内核、专用 CPU L1 和 L2
缓存以及末级缓存组成。 每个 GPU 小芯片由 16 个计算单元 (CU) 和 8 个 GPU
L2 缓存组组成。 我们的内存模型使用内置的 gem5 模型
[50]，每个通道有八个内存通道和八个存储体。 图 2 还显示了由我们的算法从第
IV 节确定的边界节点的位置。 -
我们同时使用合成流量和基于应用程序的模拟。对于合成流量，每个数据包宽度为8个flits，并且网络模拟了200万个周期。对于系统级（非合成）模拟，我们使用AMD
SDK [51]、Rodinia [52]和Pannotia
[53]套件中的APU应用程序，其中芯片外通信包括GPU
CUs之间的缓存一致性和到主存储器的流量。 ## B. Comparison Points -
即使从定性上看，基于VC的方法是昂贵且不太吸引人的，但为了完整性，我们提供了一个比较。使用与EbDa
[40]类似的方法，我们实现了一个支持最小路径自适应路由的VC-based死锁避免机制：对于单个2D网格，需要两个VC来避免死锁；通过在芯片和interposer之间引入垂直连接，需要两个更多的VC来隔离入站和出站流量。我们还实现了第III-C节中描述的三种全局路由算法：up<em>/down</em>
[37]、基于段[38]和Nue路由[39]。请注意，所有三种算法都需要完整的CDG知识，并且不支持独立设计和芯片复用。我们将其与之进行比较作为我们所知道的最相关的工作，但它们无法满足我们的关键芯片模块化标准。
-
在应用转向限制之前，通过找到与所有其他节点的平均距离最小的节点来选择上<em>/下</em>路由中的根节点。基于段的路由中的起始段是从系统的左上角（左上GPU芯片的左上路由器）形成的。在我们的可组合路由方案中，本地芯片算法和互连器算法都使用维度排序路由。为了与基于VC的方法进行公平比较，我们为每个基于转向的方案提供了四个VC。
-
我们还将我们的结果与理想化系统（表示为最短路径）进行比较，该系统使用不切实际的大量虚拟通道来避免死锁。
路由表是使用全对最短路径 (APSP)
算法配置的（与现有技术和我们自己提出的一些路由可能不是最短的方案形成对比）。
请注意，这个理想化的系统不一定能提供真正的最佳性能，因为 APSP
仍然会导致某些链路中的拥塞程度高于其他链路。
然而在实践中，我们发现这种最短路径配置通常优于实际的替代方案，因此它提供了一个乐观的性能目标来进行比较。</p>
<h2
id="c.-basic-throughput-evaluations-with-synthetic-traffic-使用合成流量进行基本吞吐量评估">C.
Basic Throughput Evaluations with Synthetic Traffic
使用合成流量进行基本吞吐量评估</h2>
<ul>
<li>在本节中，我们评估了一个由四个芯片组成的64-CU系统，每个芯片组由16个CU组成，组织为4×4网格。每个芯片组通过四个边界路由器连接到中间层。中间层网络是4×4网格。</li>
<li>图5a和图5b显示了均匀随机和位补码流量下的负载延迟曲线。我们观察到，许多异构多芯片工作负载与均匀随机流量相似：实际系统具有混合的芯片内、芯片间、芯片到互连器和芯片到内存的流量，涵盖了一致性和主存储器请求和响应；这些在总体上“平均”，使得均匀随机流量的高级性能趋势与我们的几项应用驱动研究大致相符。位补码流量模式强制所有数据包离开芯片，因此进一步加重了互连器的压力并创建了网络热点。我们运行了其他合成流量模式，但总体趋势非常相似，因此没有显示。</li>
<li>我们的可组合方案优于up<em>/down</em>、基于段的和VC-based方法。在相同数量的虚拟通道下，可组合方案的性能优于VC-based方法，主要是因为额外的虚拟通道减少了头阻塞。典型的一致性协议需要3-5个虚拟网络，每个虚拟网络都需要四个VC以实现死锁自由。异构架构的一致性协议可能需要更多的虚拟网络，使得VC-based方法变得更加昂贵。虽然VC-based方法需要每个虚拟网络四个VC以实现正确性，但是由于VC-based和可组合方案之间的性能差距，需要更多的VC以实现更好的性能。</li>
<li>基于段的路由在零负载延迟方面存在问题，并且具有最低的饱和吞吐量。这主要是因为它是为2D网格状网络设计和优化的。虽然评估系统由多个网格网络组成，但全局拓扑结构仍然不规则，因此基于段的路由无法有效处理它。基线基于段的算法并不总是形成最优段；从边界路由器向中间件开始的段可能会绕到同一芯片上的路由器上结束，或者通过另一个芯片跨越多个跳跃，直到到达属于现有段的路由器。这样的链式段在较大的系统中可能非常长，并且在段内断开任何双向转弯将导致更多的非最小路径（对于基线APU，我们观察到平均路由距离近11个跳跃，而其他方法则为∼8个跳跃）。虽然拓扑感知优化可能会改善基于段的路由性能，但这超出了本文的范围。¹</li>
<li>上行<em>/下行</em>
路由具有低零负载延迟，这表明消息可能会在评估系统中采用最少的路由。
然而，与其他方法相比，它相对较早地饱和。
根节点附近的链路本质上比叶节点附近的链路更拥塞。
当注入率增加时，这些环节会饱和并成为瓶颈。 Nue
路由优于我们的可组合方法，但这只是因为它具有利用完整 CDG
知识优化其路由的优势，从而导致与理想的最短路径算法类似的行为。
有了足够的
VC（我们为其提供），它会找到优化的路径来平衡网络工作负载。</li>
<li>我们的组合方案优于up<em>/down和基于段的路由，因为芯片和互连网络更加负载平衡，芯片和互连器之间的垂直链接也是如此。Nue提供更好的负载平衡，因此表现接近理想的最短路径路由，但与其他先前的工作一样，它不适用于独立设计和重用芯片以进行模块化SoC构建。与理想的最短路径路由相比，我们的方案覆盖了从up/down</em>到理想化最短路径路由的吞吐量差距的大部分，但仍然存在一些余地。这是因为1）由于转向限制而仍然存在一些负载不平衡，以及2）理想化网络具有更多的虚拟通道以改善头部阻塞。总体而言，尽管我们提出的方法没有实现全局负载平衡优化的全部性能，但我们的结果表明，我们的方案确保了正确性，并提供了高性能的多芯片SoC，它独特地实现了一种模块化芯片设计方法论，不需要对整个系统的CDG有先验知识。
## D. Application-level Impact ### Network Latency:
我们使用执行驱动模拟对非合成工作负载评估了我们的可组合路由方案。图6a显示了平均网络延迟，归一化为理想的最短路径方法。基于段的路由未显示，因为在给定的系统大小下，它始终表现出色并且明显优于其余方法。我们省略了基于VC的方案，因为评估的异构系统需要大量的VC才能避免路由和协议级死锁，同时保持性能。总体而言，我们的可组合方法实现的网络延迟几乎与最短路径相同。在一些情况下（bfs、nw、srad），可组合路由比最短路径表现略好；正如前面所讨论的，最短路径并不是真正的最优解，有时会出现局部流量突发（这种情况在GPU工作负载中比传统CPU应用程序更常见），会导致最短路径配置中的拥塞/负载不平衡。
由于根节点在高负载下成为瓶颈，因此上下行方法的大多数基准测试的平均网络延迟增加了50%以上，如第V-C节所讨论的。这种瓶颈限制了系统的有效带宽，并导致了显着的网络缓冲延迟。
### Application Performance:
图6b显示了程序执行时间，归一化为理想的最短路径方法。总体而言，可组合路由与最短路径相比实现了类似（在1%以内）的系统性能。虽然APU/GPGPU应用程序会生成大量的NoC/内存流量（这对于压力网络来说非常好），但对应用程序执行时间的总体影响却很小，因为大多数GPU应用程序本质上对延迟不太敏感（即，丰富的SIMD并行性可以更容易地容忍增加的延迟）。虽然有流量突发，但应用程序的大部分部分不会使NoC接近饱和，因此对总执行时间的影响较小。尽管如此，我们仍然观察到一些工作负载使用up<em>/down</em>路由时性能下降了5-10%，而我们的方法在大约与最短路径方法相同的水平上执行。
### Case Study – HotSpot:
图7显示了执行HotSpot时最常用的链接的最大链接利用率。仅显示了互连网络和GPU芯片上的边界路由器，因为其余部分利用率较低。对于每个10000个周期，我们对每个链接的利用率进行了采样。链接的最大利用率是整个程序执行过程中观察到的最大采样结果。最大链接利用率向我们展示了在突发流量行为下最糟糕的链接拥塞发生在哪里，从而使我们能够可视化全局网络流量并定位任何NoC瓶颈。一般来说，可组合路由比最短路径具有更少的拥塞链接。但是，前者在互连器上具有略微不平衡的流量分布，这表明最大链接利用率更大。这是由于转向限制偏向边界路由器的可达性（即，某些边界路由器接收更多流量）。对于上<em>/下</em>路由，根节点位于互连器上。如预期所示，靠近根节点的链接比其他链接更加利用。
# VI. BROADER APPLICABILITY 更广泛的适用性
前一节展示了我们方法在一个特定的芯片组SoC上的有效性。在本节中，我们提供了额外的实验结果，因为各种系统假设被修改，然后我们还讨论了如何将该提议应用于没有活动互连器的芯片组系统。
## A. Design Guideline Justification 设计指南的证明
在第IV-B节中，我们描述了如何确定边界路由器的数量、选择转向限制的目标函数以及边界路由器的放置。为了证明所提出的指南的有效性，我们使用均匀随机流量评估了其他设计方案。图8a显示了从2个边界路由器增加到8个路由器时吞吐量的提高。在所有情况下，互连网络保持相同的大小；当有8个边界路由器时，2个边界路由器集中到一个互连路由器上，这增加了路由器的复杂性和面积。从4个边界路由器到8个边界路由器的改进要比从2个边界路由器到4个边界路由器的改进小得多。不足的边界路由器可能会影响系统吞吐量。通过提供更多的边界路由器，可以增加芯片外带宽，从而减少与芯片内通信的干扰。在16个边界路由器的极端情况下，每个芯片路由器都有一个垂直连接，与芯片外通信不会影响芯片内通信/拥塞。然而，这样的设计是不切实际的，因为需要大量垂直线。总体而言，在性能和硬件成本方面，4个边界路由器是一个合理的设计选择。
图8b比较了不同目标函数的系统吞吐量，包括最小化平均距离、最大化平均可达性和我们提出的度量（即最小化平均距离/平均可达性）。结果表明，我们提出的目标函数是有效的，并且与其他度量相比提供了最佳性能。仅考虑平均距离或平均可达性往往会创建不平衡的芯片内流量。
在某些情况下，设计者可能没有自由选择边界路由器放置位置的自由（例如，布局限制，物理设计约束）。图8c考虑了边界路由器位置已移动到较不理想的位置（例如，聚集在一起），分散到角落，位于同一行（即与我们的方法分配给它们的位置不同）。我们重新运行了确定转向限制的算法。结果表明，边界路由器的随机放置最终导致某些链接被使用得比其他链接更多，从而影响了系统吞吐量，但死锁自由仍然得以保持。
## B. Sensitivity Studies 我们考虑了以下基线的变体：
系统规模：基线具有4个GPU芯片，每个芯片有16个CU，总计算能力为64个CU。我们还考虑了两种128-CU配置（CPU数量保持不变），分别由（1）每个芯片32个CU的4个芯片和（2）每个芯片16个CU的8个芯片组成。在这两种情况下，每个芯片仍然有四个边界路由器。
Interposer
NoC拓扑结构：为了支持这一论点，即中介器的NoC可以独立于芯片设计，我们评估了基线系统，但将中介器的网状NoC替换为“双蝴蝶”拓扑结构[22]
不规则芯片拓扑结构：为了支持芯片的NoC拓扑结构可以独立设计的类似主张，我们评估了一个系统，其中每个GPU芯片都实现了一个不同的本地NoC拓扑结构，包括网格、环、蝴蝶和树形拓扑结构
结果：本节中的分析仅呈现了均匀随机流量的负载延迟曲线。我们也进行了应用程序级别的实验，但总体趋势非常一致，因此我们由于空间原因和重复性而省略了这些附加图形。这些实验的主要目的是证明我们的提议是一种在广泛的基于芯片组的系统可能性范围内实现高性能并确保死锁自由的强大方法。
图9a和b显示了更大的128-CU配置的结果，我们的组合方法轻松地优于上/下路由。这两个配置之间的主要区别是芯片内和芯片间流量的比例。与最短路径相比，我们的组合方法对流量分布不太敏感，因为具有更好的芯片级和互连器级负载平衡。”
的中文翻译是：“图9a和b显示了更大的128-CU配置的结果，我们的组合方法轻松地优于上/下路由。这两个配置之间的主要区别是芯片内和芯片间流量的比例。与最短路径相比，我们的组合方法对流量分布不太敏感，因为具有更好的芯片级和互连器级负载平衡。
图9c显示了当插层NoC具有蝴蝶式拓扑结构时的结果。结果与网格的基准系统类似，总体上这有助于证明可以轻松地独立设计单个芯片，而不受插层NoC拓扑结构的影响。
图9d显示了当每个GPU芯片组具有不同的本地NoC拓扑时的结果。这里的结果更有趣，因为我们的提议导致的饱和吞吐量比具有丰富虚拟通道和最短路径路由的“理想”情况更高。这是因为在处理芯片间通信时，最短路径会偏向于靠近互连器中心的边界路由器，而我们的提议方法实现了更好的互连器流量分布。”
的中文翻译是
“图9d显示了当每个GPU芯片组具有不同的本地NoC拓扑时的结果。这里的结果更有趣，因为我们的提议导致的饱和吞吐量比具有丰富虚拟通道和最短路径路由的“理想”情况更高。这是因为在处理芯片间通信时，最短路径会偏向于靠近互连器中心的边界路由器，而我们的提议方法实现了更好的互连器流量分布。
## C. Other Chiplet Packaging Options
到目前为止，我们的研究集中在基于新兴活性硅中间层技术构建的芯片组系统上。虽然活性硅中间层可能是实用的，特别是如果可以将用于逻辑的总中间层面积最小化[2]，[30]，但近期芯片组系统可能会受到被动基板的限制。无论是使用被动硅中间层[19]-[21]还是更传统的封装基板[7]，[11]，[14]，[54]，一个可能的担忧是芯片组下方缺乏活性层可能会限制我们方法的适用性。
图10a显示了一个在被动基板上具有芯片的示例系统。此布局假定提供了常见功能的中央芯片（否则将放置在活动互连器上，例如内存控制器、NoC、系统管理），计算芯片以星形拓扑结构从中央芯片向外扩展。使用这种类型的布局，我们的建议方法可以直接应用于此系统，无需进行任何修改，方法是将中央芯片与我们之前的工作示例中的活动互连器相同对待。选择最佳边界节点放置的过程可以更有效，因为芯片上可供选择的合理节点较少（即最靠近中央芯片的节点）。
## D. Other Chiplet Topologies
即使对于非星型拓扑的芯片，他们的方法也可以进行适应。图10b显示了一个基于芯片的系统，其中两个CPU芯片具有额外的点对点链接（例如，用于低延迟高速缓存一致性），这些链接不通过中央芯片进行路由。为了支持这一点，这两个CPU芯片被有效地视为单个虚拟芯片，以应用他们的方法来确定路由限制。仍然需要CPU芯片设计人员确保两个CPU芯片之间的直接路由是正确的（即无死锁），但设计人员无需担心从/到中央芯片进入/离开任一芯片的流量，因为他们的方法确定适当的转向限制以确保整个SoC的正常运行。
同样，图10c显示了一个没有单个“中央”芯片的系统，而是有两个芯片连接到其他芯片。在这里，我们应用了类似的技术，其中两个芯片被视为单个虚拟芯片，以便于此方法。与上面的两个CPU芯片示例类似，SoC设计人员必须确保一对芯片是相互/本地死锁自由的，但是任何剩余的与其他芯片的连接都将得到正确处理。大多数合理的芯片拓扑都可以迭代地合并，直到将拓扑转换为类似星形的组织为止，此时我们的方法可以直接应用。
# VII. RELATED WORK
平面网络：在第III-C节中，我们介绍了一种避免死锁的平面网络方法。对up<em>/down</em>路由的进一步优化已被提出：Koibuchi等人基于BFS生成树构建了一个从左到右的有向图，并在根节点周围分配流量[55]；Sancho等人使用深度优先搜索（DFS）生成树[56]；他们通过在每个周期中单独删除每个方向上的通道依赖关系来改善流量平衡[57]。
分层网络：HiRA
[41]是一种用于分层NoC中无死锁路由的方法。在HiRA中，网络被划分为子网（具有独立无死锁路由算法的网络）和外部链接（子网之间的链接）。通过在每个子网中选择安全边界节点并在边界节点上应用转向限制来避免死锁。当连接到其他子网时，如果边界节点不会发生死锁并且可以保证连通性而不修改子网的内部路由算法，则边界节点是安全的。在应用边界节点上的转向限制时，使用包含所有边界节点的CDG。虽然HiRA可应用于具有被动互连器的芯片组系统，但对于两个主要原因，它不适用于主动互连器SoC。首先，仍需要系统级CDG，并且转向限制在很大程度上取决于子网路由算法。其次，HiRA缺乏中央网络（即主动互连器）的路由算法，该网络连接到所有芯片组。
“3D NoC中的路由：常规3D
NoC的死锁避免技术包括DoR和基于转向的路由[35]，[58] -
[60]和基于VC的方法[61] -
[63]。其中许多技术不直接适用，因为它们的基于转向的算法要求每个路由器在堆栈中具有垂直连接（我们不做出这种假设），这会增加每个芯片TSV区域开销。其他3D
VC技术创建与芯片在堆叠中的垂直位置相关联的单调VC排序；芯片在中间层上的物理拓扑结构使得很难强制实施总排序。我们不提供这些作品的实验评估，因为不明显如何将它们适应不仅由单个垂直3D芯片堆栈组成的拓扑结构。”
# VIII. CONCLUSIONS
基于芯片组的复杂SoCs的构建非常令人兴奋，因为它可以实现各种类型的系统，但这些系统必须易于设计和组装。当使用来自第三方硅IP供应商的黑盒芯片构建系统时，确保正确性变得更加具有挑战性和重要性。本文对基于芯片组的SoC设计方法论做出了重大贡献，重点是互连；然而，仍有其他有益的研究领域。如果系统中的不同芯片要具有高速缓存一致性，则必须设计一个正确运行并跨不同物理芯片扩展（以性能为准）的高速缓存一致性协议。虽然不是严格的正确性问题，但可能需要设计服务质量机制，以确保不同的芯片集成在一起“友好地协作”，特别是在实时组件（例如图形和音频）或更高级别的性能目标（例如数据中心服务级别协议）方面。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2023/03/22/Clion%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2023/03/22/Clion%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">Clion使用指南!</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-22 11:00:50" itemprop="dateCreated datePublished" datetime="2023-03-22T11:00:50+08:00">2023-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:18" itemprop="dateModified" datetime="2023-07-30T18:15:18+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/Clion/" itemprop="url" rel="index"><span itemprop="name">Clion</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>73</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="常用快捷键">常用快捷键</h2>
<table>
<thead>
<tr class="header">
<th>｜shortcut</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>cmd + opt + -&gt; / &lt;-</td>
<td>恢复/撤销光标上次操作</td>
</tr>
<tr class="even">
<td>cmd+shift+ -</td>
<td>折叠所有代码块</td>
</tr>
</tbody>
</table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2023/03/21/Effective%20C++(7)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2023/03/21/Effective%20C++(7)/" class="post-title-link" itemprop="url">Effective C++(7)--模版与范型编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-21 11:37:00" itemprop="dateCreated datePublished" datetime="2023-03-21T11:37:00+08:00">2023-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:32" itemprop="dateModified" datetime="2023-07-30T18:15:32+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="条款44-将参数无关的代码抽离templates">条款44
将参数无关的代码抽离templates</h1>
<ul>
<li><code>template</code>可能会带来膨胀的重复的二进制代码</li>
<li>在<code>template</code>代码中，重复是隐晦的 ## EG1.
固定尺寸的正方矩阵的template ### 原始版本</li>
<li>n * n矩阵，元素类型是<code>T</code>，支持矩阵求逆 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;	<span class="comment">/// n * n矩阵，元素类型是T</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/// ...</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">()</span></span>;	<span class="comment">/// 求逆矩阵</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SquareMatrix&lt;<span class="type">double</span>, <span class="number">5</span>&gt; sm1;</span><br><span class="line">sm1.<span class="built_in">invert</span>();	<span class="comment">/// 调用SquareMatrix&lt;double, 5&gt;::invert()</span></span><br><span class="line">SquareMatrix&lt;<span class="type">double</span>, <span class="number">10</span>&gt; sm2;</span><br><span class="line">sm2.<span class="built_in">invert</span>();	<span class="comment">/// 调用SquareMatrix&lt;double, 10&gt;::invert()</span></span><br></pre></td></tr></table></figure></li>
<li>这里具现化两份invert代码，但是除了常量5和10，代码完全相同 ### Mod1.
建立带参数的函数</li>
<li>以5和10调用函数，减少重复代码 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;	<span class="comment">/// 与尺寸无关的base class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">/// ...</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">(std::<span class="type">size_t</span> matrixSize)</span></span>;	<span class="comment">/// 求逆矩阵</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;	<span class="comment">/// n * n矩阵，元素类型是T</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> : <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">using</span> SquareMatrixBase&lt;T&gt;::invert;	<span class="comment">/// 避免遮掩，见条款33</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/// ...</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>-&gt;<span class="built_in">invert</span>(n); &#125;;	<span class="comment">/// inline版的的调用，why this-&gt;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><code>SquareMatrixBase</code>模板只对元素类型T初始化，不对矩阵的尺寸参数初始化</li>
<li>Eg1中的<code>sm1</code>和<code>sm2</code>将共享<code>SquareMatrixBase&lt;double&gt;::invert</code></li>
<li><code>SquareMatrixBase&lt;double&gt;::invert</code>避免派生类代码重复</li>
<li>inline : 额外的调用成本是0</li>
<li>若不使用this-&gt;，模板化基类SquareMatrixBase<T>内的函数名会被派生类遮掩(条款43？)</li>
<li>private继承，仅帮助实现，不是表现is-a的关系(条款39？) #### 问题</li>
<li><code>SquareMatrixBase&lt;T&gt;::invert</code>如何知道矩阵数据在哪
### Mod2. 令SquareMatrixBase储存一个指针 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">SquareMatrixBase</span>(<span class="type">size_t</span> Size, T *pMem) : <span class="built_in">size</span>(Size), <span class="built_in">pData</span>(pMem) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setDataPtr</span><span class="params">(T *PData)</span> </span>&#123; pData = PData; &#125;</span><br><span class="line">	<span class="comment">/// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::<span class="type">size_t</span> size;</span><br><span class="line">	T* pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>这允许Derived Classes决定内存分配方式 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 该版本将矩阵数据存储在SquareMatrix内部</span></span><br><span class="line"><span class="comment">/// 这种类型的对象不需要动态内存分配，但对象自身可能非常大</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;	<span class="comment">/// n * n矩阵，元素类型是T</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> : <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SquareMatrix</span>() : <span class="built_in">SquareMatrixBase</span>&lt;T&gt;(n, data) &#123;&#125;;</span><br><span class="line">	<span class="comment">/// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T data[n * n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 该版本将矩阵数据放入heap</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;	<span class="comment">/// n * n矩阵，元素类型是T</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> : <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SquareMatrix</span>()</span><br><span class="line">		: <span class="built_in">SquareMatrixBase</span>&lt;T&gt;(n, <span class="literal">nullptr</span>), <span class="built_in">pData</span>(<span class="keyword">new</span> T[n * n])</span><br><span class="line">		&#123; <span class="keyword">this</span>-&gt;<span class="built_in">setDataPtr</span>(pData.<span class="built_in">get</span>()); &#125;</span><br><span class="line">	<span class="comment">/// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::array&lt;T&gt; pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
### 总结</li>
<li>SquareMatrix成员函数可以单纯的以inline方式调用base class版本
<ul>
<li>后者由持相同T的矩阵共享</li>
</ul></li>
<li>强行绑定矩阵尺寸的invert[Eg1.]
<ul>
<li>可能有更好的编译器实现和优化，但是会有大量重复的二进制代码</li>
</ul></li>
<li>不绑定尺寸的invert[Mod1., Mod2.]
<ul>
<li>减少执行文件大小</li>
<li>降低程序的working
set大小，(一个在VM下执行的进程所使用的那一组内存页)</li>
<li>强化指令高速缓冲区内的引用集中化(locality) ## 小结</li>
</ul></li>
<li>template不该与造成膨胀的模板参产生关系</li>
<li>non-type template
parameters(非类型模板参数)造成的代码膨胀，往往可以消除，做法是用函数或class成员变量替换template参数
## type parameters(类型参数)也会带来代码膨胀</li>
<li>如许多平台上int和long有相同的二进制表述
<ul>
<li>vector<int>和vector<long>应该共用一份底层实现</li>
</ul></li>
<li>指针往往也具有相同的二进制表述</li>
<li>让有相同的二进制表述的具现类型(instantiation types)共享实现码</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2023/02/07/Qemu%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2023/02/07/Qemu%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">Qemu使用记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-07 17:28:50" itemprop="dateCreated datePublished" datetime="2023-02-07T17:28:50+08:00">2023-02-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-22 21:45:32" itemprop="dateModified" datetime="2023-09-22T21:45:32+08:00">2023-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="qemu说明">1. Qemu说明</h1>
<ul>
<li>通用的开源机器和用户空间模拟器和虚拟器</li>
<li>具体内容见官网<code>https://github.com/qemu/qemu</code></li>
<li>比如：Qemu可以模拟出一个ARM系统中的：CPU. 内存.
IO设备等，然后在这个模拟层之上，可以跑一台ARM虚拟机，这个ARM虚拟机认为自己在和硬件进行打交道，但实际上这些硬件都是Qemu模拟出来的。</li>
</ul>
<h2 id="qemu的两种模式">Qemu的两种模式</h2>
<ol type="1">
<li>用户模式(User
mode)：利用动态代码翻译机制来执行不同主机架构的代码，例如：在x86平台上模拟执行ARM代码，也就是说：我们写一条ARM指令，传入整个模拟器中，模拟器会把整个指令翻译成x86平台的指令，然后在x86的CPU中执行。</li>
<li>系统模式(System mode)：模拟整个电脑系统，利用其它VMM(Xen,
KVM)来使用硬件提供的虚拟化支持，创建接近于主机性能的全功能虚拟机。</li>
</ol>
<h1 id="qemu编译">qemu编译</h1>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">../configure  </span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./compile-aarch64-system.sh</span><br><span class="line">cd build</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<h1 id="qemu执行流程">2. qemu执行流程</h1>
<h2 id="宏">0. 宏</h2>
<ul>
<li><code>#ifdef PPI_QR_FUNC</code> 宏是我们所有改动加的宏 ## 1.
qemu启动</li>
<li>file: softmmu/vl.c</li>
<li>初始化参数</li>
<li>调用vcpu初始化。 ## 2. vcpu初始化</li>
<li>file: target/arm/cpu64.c</li>
<li>func:
<ul>
<li>aarch64_cpu_class_init</li>
<li>aarch64_cpu_instance_init
<ul>
<li>对cpu实例进行初始化</li>
<li>共享内存初始化(包括qemu要用的向gem5传输的共享内存)
<ul>
<li>ringbuf_init 进行初始化环形队列。</li>
<li>第二块共享内存是shm_init。</li>
</ul></li>
<li>每个qemu vcpu会初始化调用一次aarch64_cpu_instance_init
<ul>
<li>eg：run.sh里是16 cpu，那么就调用16次aarch64_cpu_instance_init，所以
也会初始化16个ringbuf_init，共享内存队列，每个核维护一个。key_insoff+channel_d+i是每个共享内存的id。</li>
</ul></li>
<li>这里面的cpu以及cpu-&gt;env就是
qemu的vcpu，其中cpu-&gt;env就是cpuarmstate。这个时候已经初始化完毕。 ##
3. 翻译</li>
</ul></li>
</ul></li>
<li>初始化之后开始主流程翻译</li>
<li>翻译是两步，
<ol type="1">
<li>guest-&gt;ir</li>
<li>ir-&gt;host</li>
</ol>
<ul>
<li>eg: 也就是比如 用户程序是 arm，arm-&gt;ir ir-&gt;x86
code，host运行x86
code。如果是用户程序是x86，host也是，那么不用翻译，直接在host上执行。
### guest-&gt;ir</li>
</ul></li>
</ul>
<ol type="1">
<li>调用<code>tb_find</code>[accel/tcg/cpu-exec.c]
<ul>
<li>找是否有翻译过,若无则进行2.(刚开始肯定无)</li>
</ul></li>
<li>调用<code>tb_gen_code</code>[accel/tcg/cpu-exec.c]
<ul>
<li>翻译主函数</li>
</ul></li>
<li>这个又调用gen_intermediate_code，
<ul>
<li>进行guest-&gt;ir的翻译。</li>
</ul></li>
<li>上面又继续调用translator_loop
<ul>
<li>来到accel/tcg/translator.c。</li>
<li>translator_loop 函数 对tb里的每一个指令 进行翻译。</li>
<li>while (true)就是每条指令循环翻译。</li>
</ul></li>
<li>aarch64_tr_translate_insn函数。
<ul>
<li>添加函数名，target/arm/translate-a64.c</li>
</ul></li>
<li>调用disas_a64_insn
<ul>
<li>就是每个指令进行decoder</li>
<li>里面switch (extract32(insn, 25, 4)) { 看是哪类指令。</li>
</ul></li>
</ol>
<ul>
<li>至此完成了 guest-&gt;ir的翻译。 ### ir-&gt;host的暂不考虑</li>
</ul>
<h2 id="执行">4. 执行</h2>
<ul>
<li>翻译之后，host代码已经生成，需要执行。</li>
<li>我们采用在guest的tb开始和结束前插callback函数的方式
<ul>
<li>target/arm/translate.c 里的函数
<ul>
<li>helper_start_callback插在tb执行开始前的。插在它tb guest的开头，</li>
<li><code>helper_end_callback</code>在结尾</li>
<li>会随tb一起翻译。</li>
</ul></li>
</ul></li>
<li>那么执行就是先 helper_start_callback -&gt; tb -&gt;
helper_end_callback</li>
<li>当执行helper_end_callback的时候，整个tb都执行好了。</li>
<li>所以可以对下一个执行的tb进行预测。</li>
<li>tb-&gt;tt里存放我们记下来的tb的trace，包括 pc insn。</li>
<li>env-&gt;sendbuf-&gt;real_insn_num记了tb的实际指令数。</li>
<li>helper_end_callback调用lookupAndUpdateNextPC预测。</li>
<li>执行tb 是一串二进制代码，无法代码操作。 只能通过cb来操作。</li>
<li>bt-&gt;IsControl 是true 说明是分支指令，需要存。所以在这里可以存cpu
state</li>
</ul>
<h3 id="内存处理">内存处理</h3>
<ul>
<li>主函数如果是ld st指令</li>
<li>mem信息我们额外插了cb进行收集mem 访存信息。</li>
<li>ppi_insert_mem_st[tcg/tcg-op.c]进行ld st插桩。
<ul>
<li>函数体insert_mem_st[target/arm/translate.c]<br />
</li>
</ul></li>
<li><code>helper_load_callback</code> 里，env-&gt;sendbuf 是 cpu
armstate结构体里划出来的一块临时内存。</li>
<li>mem cb里会将mem trace 记在这里。</li>
<li>env里是否有mem的寄存器信息？</li>
<li>到end
cb的时候，helper_load_callback里的所有东西都记好了，env的sendbuf里有完整的tb里的mem
insn trace</li>
</ul>
<h2 id="qemu主函数调用">qemu主函数调用</h2>
<ol type="1">
<li><p>main[./softmmu/vl.c]</p></li>
<li><p>aarch64_cpu_instance_init[target/arm/cpu64.c]</p></li>
<li><p>aarch64_cpu_class_init[target/arm/cpu64.c]</p></li>
<li><p>cpu_exec[accel/tcg/cpu-exec.c]</p>
<ul>
<li>main execution loop</li>
</ul>
<ol type="1">
<li>tb_gen_code[accel/tcg/translate-all.c]
<ul>
<li>生成下一个tb块代码</li>
</ul>
<ol type="1">
<li>cpu_loop_exit[accel/tcg/cpu-exec-common.c]
<ul>
<li>exit the current TB</li>
<li>抛出异常时触发</li>
</ul>
<ol type="1">
<li>helper_end_callback[target/arm/translate.c]
<ul>
<li>移植了gem5的分支预测器</li>
</ul></li>
</ol></li>
</ol></li>
<li>cpu_loop_exec_tb[accel/tcg/cpu-exec.c]
<ol type="1">
<li>cpu_tb_exec[accel/tcg/cpu-exec.c]</li>
</ol></li>
</ol></li>
<li><p>cpu_exec_exit[accel/tcg/cpu-exec.c]</p></li>
</ol>
<ul>
<li>退出qemu<code>ctrl+A+X</code></li>
</ul>
<h1 id="问题">问题</h1>
<p>分支预测加在了每个tb运行结束的末尾，在运行到tb末尾时进行预测
当下一个tb运行完之后，取出该tb的头地址，并与上次预测结果比对验证</p>
<p>checkpoint是系统层面的快照接口 在程序内部调用不好处理</p>
<p>接下来首先篡改执行的tb路径，即迫使qemu按照分支预测结果执行</p>
<p>在cpu_exec中主循环通过调用tb_lookup/tb_gen_code来获得下一个执行的tb
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tb = tb_lookup(cpu, pc, cs_base, flags, cflags);</span><br><span class="line">tb = tb_gen_code(cpu, pc, cs_base, flags, cflags);</span><br></pre></td></tr></table></figure>
我们可以通过改变cpu的pc来控制下一个tb，既可以迫使其走上错误分支，也可以再恢复状态后安排它执行正确的pc
pc在这里取出<code>cpu_get_tb_cpu_state(cpu-&gt;env_ptr, &amp;pc, &amp;cs_base, &amp;flags);</code>，根据<code>cpu-&gt;env_ptr</code>内的值
这个指针实际指向CPUARMState
cpu_get_tb_cpu_state[target/arm/helper.c]中pc的值分两种情况 pc /
regs[15] 怎么选取?</p>
<p>core的时候打屏可以 写文件不行</p>
<ul>
<li>s0, add a new file to do the following things</li>
<li>s1, todo: secondery pointer, deep copy the whole struct</li>
<li>s2, todo: backup the memory</li>
<li>s3, checkpoint?</li>
<li>当前仅修改pc，不做备份，只为了篡改执行路径</li>
</ul>
<p>分支当前的pc是tb块的最后一条指令(有时为跳转指令)的pc</p>
<p>Tiny Code Generator (TCG)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tb_trace</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> insn_num;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> pc_start;     <span class="comment">/* tb first pc */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trace_info</span> <span class="title">ti</span>[512];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TranslationBlock</span> &#123;</span></span><br><span class="line">    target_ulong pc;   <span class="comment">/* simulated PC corresponding to this block (EIP + CS base) */</span></span><br><span class="line">    target_ulong cs_base; <span class="comment">/* CS base for this block */</span></span><br><span class="line">    <span class="type">uint32_t</span> flags; <span class="comment">/* flags defining in which context the code was generated */</span></span><br><span class="line">    <span class="type">uint32_t</span> cflags;    <span class="comment">/* compile flags */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Per-vCPU dynamic tracing state used to generate this TB */</span></span><br><span class="line">    <span class="type">uint32_t</span> trace_vcpu_dstate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Above fields used for comparing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* size of target code for this block (1 &lt;= size &lt;= TARGET_PAGE_SIZE) */</span></span><br><span class="line">    <span class="type">uint16_t</span> size;</span><br><span class="line">    <span class="type">uint16_t</span> icount;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tb_tc</span> <span class="title">tc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* first and second physical page containing code. The lower bit</span></span><br><span class="line"><span class="comment">       of the pointer tells the index in page_next[].</span></span><br><span class="line"><span class="comment">       The list is protected by the TB&#x27;s page(&#x27;s) lock(s) */</span></span><br><span class="line">    <span class="type">uintptr_t</span> page_next[<span class="number">2</span>];</span><br><span class="line">    <span class="type">tb_page_addr_t</span> page_addr[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* jmp_lock placed here to fill a 4-byte hole. Its documentation is below */</span></span><br><span class="line">    QemuSpin jmp_lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The following data are used to directly call another TB from</span></span><br><span class="line"><span class="comment">     * the code of this one. This can be done either by emitting direct or</span></span><br><span class="line"><span class="comment">     * indirect native jump instructions. These jumps are reset so that the TB</span></span><br><span class="line"><span class="comment">     * just continues its execution. The TB can be linked to another one by</span></span><br><span class="line"><span class="comment">     * setting one of the jump targets (or patching the jump instruction). Only</span></span><br><span class="line"><span class="comment">     * two of such jumps are supported.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint16_t</span> jmp_reset_offset[<span class="number">2</span>]; <span class="comment">/* offset of original jump target */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TB_JMP_RESET_OFFSET_INVALID 0xffff <span class="comment">/* indicates no jump generated */</span></span></span><br><span class="line">    <span class="type">uintptr_t</span> jmp_target_arg[<span class="number">2</span>];  <span class="comment">/* target address or offset */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Each TB has a NULL-terminated list (jmp_list_head) of incoming jumps.</span></span><br><span class="line"><span class="comment">     * Each TB can have two outgoing jumps, and therefore can participate</span></span><br><span class="line"><span class="comment">     * in two lists. The list entries are kept in jmp_list_next[2]. The least</span></span><br><span class="line"><span class="comment">     * significant bit (LSB) of the pointers in these lists is used to encode</span></span><br><span class="line"><span class="comment">     * which of the two list entries is to be used in the pointed TB.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * List traversals are protected by jmp_lock. The destination TB of each</span></span><br><span class="line"><span class="comment">     * outgoing jump is kept in jmp_dest[] so that the appropriate jmp_lock</span></span><br><span class="line"><span class="comment">     * can be acquired from any origin TB.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * jmp_dest[] are tagged pointers as well. The LSB is set when the TB is</span></span><br><span class="line"><span class="comment">     * being invalidated, so that no further outgoing jumps from it can be set.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * jmp_lock also protects the CF_INVALID cflag; a jump must not be chained</span></span><br><span class="line"><span class="comment">     * to a destination TB that has CF_INVALID set.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uintptr_t</span> jmp_list_head;</span><br><span class="line">    <span class="type">uintptr_t</span> jmp_list_next[<span class="number">2</span>];</span><br><span class="line">    <span class="type">uintptr_t</span> jmp_dest[<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PPI_QR_FUNC</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tb_trace</span> *<span class="title">tt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tb_mem</span> *<span class="title">tm</span>;</span></span><br><span class="line">    <span class="type">int</span> cpu_id;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>{standard input}: Assembler messages: {standard input}:166160:
Warning: end of file not at end of a line; newline inserted {standard
input}:166333: Error: expected comma after name
`_ZNSt8_Rb_treeIiSt4pairIKiSt3setI11met' in .size directive
x86_64-xxx-linux-g++: internal compiler error: Killed (program cc1plus)
Please submit a full bug report, with preprocessed source if
appropriate. See for instructions. make[3]: *** [mds/Server.lo] Error 1
make[3]: *** Waiting for unfinished jobs....</p>
<p>这个错误的原因通常是，host机器内存不够导致的。
解决的办法是增加内存。硬件上的增加内存可以解决，或者kill系统当前其他的applications。甚至重新启动host，给编译器一个较为宽松的运行环境</p>
<p>QEMU以TB为单位进行翻译并执行。这也就是说每当在code
cache执行完一个TB之后，控制权必须交还给QEMU。这很没有效率。所以只要TB执行完之后，它的跳跃目标确定且该跳跃目标也已经在code
cache里，那我们就把这两个TB串接起来。这个就叫做block
chaining。有时QEMU开始执行一个基本块，然后被中断。然后，它可能会从一开始就重新执行该块，或者转换尚未执行的块的一部分并执行它。这将导致edge
map中出现一些额外的edge。所以首先禁用QEMU的chaining特性。</p>
<p>Tcgout branch生成两条 条件分支 一条b翻译成四条 非条件 条件 8条 jmmj
tcg_out_bl 条件跳转 翻译成call指令 改pc calue target
Guest知道bb最后一条</p>
<p>Tcg gencode预测 翻译的时候记录指令 在此之前disas已经完成
在这里插入跳转指令</p>
<p>2&gt; 输出系统错误</p>
<p>guest -&gt; ir -&gt; host</p>
<p>printf会影响回调函数的个数?</p>
<ol type="1">
<li>start_callback
是当前block执行前执行的函数，在里面对当前block的最后一条分支指令进行分支预测。</li>
<li>在当前block跳转指令执行前确定分支指令的跳转情况，用这个真实的跳转信息更新预测器</li>
<li>修改ir的目标地址，使得下一个block为预测方向的block</li>
<li>在错误路径执行N个block后恢复上次保存的信息，恢复到正常流程(N可以先写个固定的interval
比如5个block)</li>
</ol>
<ul>
<li>cpu_gen_code 負責 guest binary → TCG IR → host binary 的翻譯。
<ul>
<li>gen_intermediate_code_internal (target-*/translate.c) 初始化並呼叫
disas_insn 反組譯 guest binary 成 TCG IR。
<ul>
<li>disas_insn 呼叫 tcg_gen_xxx (tcg/tcg-op.h) 產生 TCG IR。分別將
opcode 寫入 gen_opc_ptr 指向的緩衝區 (translate-all.c 裡的 gen_opc_buf);
operand 寫入 gen_opparam_ptr 指向的緩衝區 (translate-all.c 裡的
gen_opparam_buf )。</li>
</ul></li>
<li>tcg_gen_code (tcg/tcg.c) 呼叫 tcg_gen_code_common (tcg/tcg.c) 將 TCG
IR 轉成 host binary</li>
</ul></li>
<li>tb_find_fast/slow 傳回 translation block 後，交給 tcg_qemu_tb_exec
執行。</li>
</ul>
<ol start="0" type="1">
<li>插桩 start_cb, 插在BB块开始的部分，会随着BB一起翻译、执行</li>
<li>翻译代码 Guest ---(teg_gen)--&gt; IR ---(tcg_out)--&gt; Host
<ul>
<li>aarch64_tr_translate_insn 调用tcg_gen</li>
<li>在tcg_out_xxx中插桩，在执行阶段中会被执行</li>
</ul></li>
<li>执行host代码</li>
</ol>
<h2 id="以cbz指令为例">以cbz指令为例</h2>
<p>Guest(arrch64) ---(teg_gen)--&gt; IR ---(tcg_out)--&gt; Host(i386)
tcg_gen_brcondi_i64(tcg/tcg-op.c)生成 ir</p>
<p>brcond_i64 tmp2,<span class="math inline">\(0x0,eq,\)</span>L1</p>
<p>目标 找到一条arrch64的分支指令究竟被翻译成了哪些IR
这些IR又变成了哪些host指令(i386) 然后
在tcg_out中插桩，获得我想要的真实信息，篡改执行的BB块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tcg_out_op</span><span class="params">(TCGContext* s, TCGOpcode opc, <span class="type">const</span> TCGArg* args, <span class="type">const</span> <span class="type">int</span>* const_args)</span></span><br><span class="line">&#123;</span><br><span class="line">    TCGArg a0, a1, a2;</span><br><span class="line">    <span class="type">int</span> c, const_a2, vexop, rexw = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取最常见的参数 Hoist the loads of the most common arguments.  */</span></span><br><span class="line">    a0 = args[<span class="number">0</span>];     <span class="comment">// = TCG_REG_EBP, 代表要比较的寄存器</span></span><br><span class="line">    a1 = args[<span class="number">1</span>];    <span class="comment">// = 0, 要比较的常数</span></span><br><span class="line">    a2 = args[<span class="number">2</span>];    <span class="comment">// = 0x9, 表示分支的条件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (opc) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> INDEX_op_brcond_i32:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            a2: 表示分支条件; </span></span><br><span class="line"><span class="comment">            a0 a1为要比较的变量和值, </span></span><br><span class="line"><span class="comment">            const_args[1]: 表示a1是否为常数</span></span><br><span class="line"><span class="comment">            arg_label(args[3]): 表示跳转目标的标签</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        tcg_out_brcond32(s, a2, a0, a1, const_args[<span class="number">1</span>], arg_label(args[<span class="number">3</span>]), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">accel/tcg/translate-all.c::tb_gen_code --&gt;&gt; </span><br><span class="line">tcg/tcg.c::tcg_gen_code --&gt;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TCGContext</span> &#123;</span></span><br><span class="line">    ...;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> gen_next_op_idx;    <span class="comment">//写入下一个操作码的位置</span></span><br><span class="line">    <span class="type">int</span> gen_next_parm_idx;    <span class="comment">//写入下一个操作数的位置</span></span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line"></span><br><span class="line">    TCGOp gen_op_buf[OPC_BUF_SIZE]; <span class="comment">//保存生成的中间指令</span></span><br><span class="line">    TCGArg gen_opparam_buf[OPPARAM_BUF_SIZE];   <span class="comment">//保存中间指令的操作数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> gen_insn_end_off[TCG_MAX_INSNS];</span><br><span class="line">    target_ulong gen_insn_data[TCG_MAX_INSNS][TARGET_INSN_START_WORDS];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line">    <span class="comment">/// 放Host指令的地方</span></span><br><span class="line">    <span class="type">void</span> *code_gen_buffer;      <span class="comment">//保存生成的指令的缓冲区</span></span><br><span class="line">    <span class="type">size_t</span> code_gen_buffer_size;    <span class="comment">//缓冲区大小</span></span><br><span class="line">    <span class="type">void</span> *code_gen_ptr;     <span class="comment">//写入下一个生成指令的位置, 位于code_gen_buffer内部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TCGCond</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    <span class="comment">/* non-signed */</span></span><br><span class="line">    TCG_COND_NEVER  = <span class="number">0</span> | <span class="number">0</span> | <span class="number">0</span> | <span class="number">0</span>,</span><br><span class="line">    TCG_COND_ALWAYS = <span class="number">0</span> | <span class="number">0</span> | <span class="number">0</span> | <span class="number">1</span>,</span><br><span class="line">    TCG_COND_EQ     = <span class="number">8</span> ,</span><br><span class="line">    TCG_COND_NE     = <span class="number">9</span>,</span><br><span class="line">    <span class="comment">/* signed */</span></span><br><span class="line">    TCG_COND_LT     = <span class="number">0</span> | <span class="number">0</span> | <span class="number">2</span> | <span class="number">0</span>,</span><br><span class="line">    TCG_COND_GE     = <span class="number">0</span> | <span class="number">0</span> | <span class="number">2</span> | <span class="number">1</span>,</span><br><span class="line">    TCG_COND_LE     = <span class="number">8</span> | <span class="number">0</span> | <span class="number">2</span> | <span class="number">0</span>,</span><br><span class="line">    TCG_COND_GT     = <span class="number">8</span> | <span class="number">0</span> | <span class="number">2</span> | <span class="number">1</span>,</span><br><span class="line">    <span class="comment">/* unsigned */</span></span><br><span class="line">    TCG_COND_LTU    = <span class="number">0</span> | <span class="number">4</span> | <span class="number">0</span> | <span class="number">0</span>,</span><br><span class="line">    TCG_COND_GEU    = <span class="number">0</span> | <span class="number">4</span> | <span class="number">0</span> | <span class="number">1</span>,</span><br><span class="line">    TCG_COND_LEU    = <span class="number">8</span> | <span class="number">4</span> | <span class="number">0</span> | <span class="number">0</span>,</span><br><span class="line">    TCG_COND_GTU    = <span class="number">8</span> | <span class="number">4</span> | <span class="number">0</span> | <span class="number">1</span>,</span><br><span class="line">&#125; TCGCond;</span><br></pre></td></tr></table></figure>
<p>armv8指令手册 page202 Unconditional branch BL Branch with link BR
Branch to register BLR Branch with link to register</p>
<p>Conditional branch B.cond Branch conditionally CBNZ Compare and
branch if nonzero CBZ Compare and branch if zero TBNZ Test bit and
branch if nonzero TBZ Test bit and branch if zero</p>
<p>翻译的时候已经拿到预测结果 所以可以强行在tcg_out加跳转指令，
但是同时还需要知道真实的跳转指令，以便决定后面是否需要恢复
我可以利用重定向来进行篡改</p>
<h1 id="prologue初始化">prologue初始化</h1>
<ul>
<li>prologue 用来切换 qemu 代码和 code cache 的代码上下文，在
tcg_prologue_init(tcg_ctx) 调用 host 的 tcg_target_qemu_prologue
来组装这块代码。</li>
</ul>
<p>在x86上组装出来的代码如下: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0x5644ca0ab000:  push   %rbp               //函数调用过程中将callee saved的入栈保存,完成了callee本身需要做的事情，因此在执行tb代码时可以使用所有的寄存器，在tb执行过程中不遵循函数调用的接口规范了</span><br><span class="line">0x5644ca0ab001:  push   %rbx  </span><br><span class="line">0x5644ca0ab002:  push   %r12  </span><br><span class="line">0x5644ca0ab004:  push   %r13  </span><br><span class="line">0x5644ca0ab006:  push   %r14  </span><br><span class="line">0x5644ca0ab008:  push   %r15  </span><br><span class="line">0x5644ca0ab00a:  mov    %rdi,%r14      //env到r14中，本身指向CPULOONGARCHState的对象，tb操作的对象都在</span><br><span class="line">0x5644ca0ab00d:  add    $0xfffffffffffffb78,%rsp      //</span><br><span class="line">0x5644ca0ab014:  jmpq   *%rsi      //跳转的tb的起始位置</span><br><span class="line"></span><br><span class="line">0x5644ca0ab016:  xor    %eax,%eax           //epilogue位置，返回值为0. 主要是为了goto_ptr使用</span><br><span class="line">0x5644ca0ab018:  add    $0x488,%rsp      //正常退出</span><br><span class="line">0x5644ca0ab01f:  emms   </span><br><span class="line">0x5644ca0ab022:  pop    %r15          //saved寄存器出栈</span><br><span class="line">0x5644ca0ab024:  pop    %r14  </span><br><span class="line">0x5644ca0ab026:  pop    %r13  </span><br><span class="line">0x5644ca0ab028:  pop    %r12  </span><br><span class="line">0x5644ca0ab02a:  pop    %rbx  </span><br><span class="line">0x5644ca0ab02b:  pop    %rbp  </span><br><span class="line">0x5644ca0ab02c:  retq                    //退出到qemu中</span><br></pre></td></tr></table></figure></p>
<h1 id="frontend的翻译">frontend的翻译</h1>
<ul>
<li>在target指令翻译过程TB以跳转指令结束，其他指令只需要根据语义翻译成IR指令就可以。
<ul>
<li>其中比较特殊的是跳转指令，TB开始和TB结束时的一些特殊代码. ##
TB开始位置: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gen_tb_start</span><br><span class="line">    ld_i32 tmp0,env,$0xffffffffffffffe4        //env指向CPULOONGARCHState，偏移是CPUState.icount_decr.u32相对于env的偏移;</span><br><span class="line">    movi_i32 tmp1,$0x0</span><br><span class="line">    brcond_i32 tmp0,tmp1,lt,$L0        //如果icount_decr.u32小于0则跳转到label 0处</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<p>参考文档:
https://qemu.readthedocs.io/en/latest/devel/tcg-icount.html</p>
<ul>
<li>icount只有在SOFTMMU中才有用，并且不能用在multi-threaded TCG
中，主要用于执行过程中指令的计数，后面详细再讲。</li>
</ul>
<h2 id="tb结束">TB结束:</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gen_tb_end</span><br><span class="line">   set_label $L0            //生成一个label 0，给`br $label`或者`brcond_i32/i64 label`，`goto_tb`这些提供錨点</span><br><span class="line">   exit_tb $0x55f975f8bec3     //退出到tb_ret_addr</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2023/02/07/C%E8%AF%AD%E8%A8%80%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2023/02/07/C%E8%AF%AD%E8%A8%80%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/" class="post-title-link" itemprop="url">C语言内联汇编</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-07 17:28:50" itemprop="dateCreated datePublished" datetime="2023-02-07T17:28:50+08:00">2023-02-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:18" itemprop="dateModified" datetime="2023-07-30T18:15:18+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/C-C-asm/" itemprop="url" rel="index"><span itemprop="name">C/C++ asm</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>877</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="basic-inline.">0. Basic Inline.</h1>
<ul>
<li>The format of basic inline assembly is very much straight forward.
Its basic form is ## 基本形式: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;assembly code&quot;</span>);</span><br></pre></td></tr></table></figure> ## Example. <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;movl %ecx %eax&quot;</span>); <span class="comment">/* moves the contents of ecx to eax */</span></span><br></pre></td></tr></table></figure>
## 说明:</li>
</ul>
<ol type="1">
<li>asm的语法规定mov的方向是从左到右，即<code>mov %src %dst</code> # 1.
extended assembly</li>
</ol>
<ul>
<li>可指定输入、输出,与asm外部的C程序交互 ## 基本形式: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> ( assembler template </span><br><span class="line">    : output operands                  <span class="comment">/* optional */</span></span><br><span class="line">    : input operands                   <span class="comment">/* optional */</span></span><br><span class="line">    : <span class="built_in">list</span> of clobbered registers      <span class="comment">/* optional */</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure> ##
说明:</li>
</ul>
<ol type="1">
<li>output
operands代表输出值，即该值可在执行中从asm寄存器获取到外部C程序中</li>
<li>input
operands代表输入值，即该值可从外部C程序传递给asm中的寄存器</li>
<li>list of clobbered
registers代表这段内联汇编执行后，哪些寄存器的值被破坏，来告知编译器做好备份和恢复工作
## Example</li>
</ol>
<ul>
<li>Example1: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>, b;</span><br><span class="line"><span class="keyword">asm</span> (<span class="string">&quot;movl %1, %%eax; </span></span><br><span class="line"><span class="string">      movl %%eax, %0;&quot;</span></span><br><span class="line">     :<span class="string">&quot;=r&quot;</span>(b)        <span class="comment">/* output */</span></span><br><span class="line">     :<span class="string">&quot;r&quot;</span>(a)         <span class="comment">/* input */</span></span><br><span class="line">     :<span class="string">&quot;%eax&quot;</span>         <span class="comment">/* clobbered register */</span></span><br><span class="line">     );  </span><br></pre></td></tr></table></figure>
<ul>
<li>第一行将a的内容写入<code>%eax</code></li>
<li>第二行将<code>%eax</code>的内容输出到b</li>
<li><code>%1</code>,<code>%0</code>是占位符，会根据顺序和位置在下面的output、input匹配对应的的变量
<ul>
<li><code>%src</code>匹配input ；<code>%dst</code>匹配output</li>
</ul></li>
</ul></li>
</ul>
<p>Check out the <a
target="_blank" rel="noopener" href="https://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">GCC
Inline Assembly</a> for more info on how to get the most out of ASM.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2023/02/07/Qemu%E7%BF%BB%E8%AF%91%E5%AE%9E%E4%BE%8B--%E4%BB%A5arrch64%20--%3E%3E%20x86-64%E4%B8%BA%E4%BE%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2023/02/07/Qemu%E7%BF%BB%E8%AF%91%E5%AE%9E%E4%BE%8B--%E4%BB%A5arrch64%20--%3E%3E%20x86-64%E4%B8%BA%E4%BE%8B/" class="post-title-link" itemprop="url">Qemu翻译实例--以arrch64 -->> x86-64为例</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-07 17:28:50" itemprop="dateCreated datePublished" datetime="2023-02-07T17:28:50+08:00">2023-02-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:50" itemprop="dateModified" datetime="2023-07-30T18:15:50+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="qemu翻译实例--以arrch64----i386为例">Qemu翻译实例--以arrch64
--&gt;&gt; i386为例</h1>
<h2 id="前言">0.前言</h2>
<ul>
<li>QEMU 是一个仿真器(emulator)，可以user mode 或是system mode 运行。
<ul>
<li>user mode 可以运行不同ISA 同一OS 的binary;</li>
<li>system mode 可以在当前作业系统上运行另外一个OS.</li>
</ul></li>
<li>对QEMU 而言，被仿真的平台被称为guest，又称target; 运行QEMU
的平台称为host。
<ul>
<li>QEMU 是利用动态翻译(dynamic translation) 的技术将guest binary
动态翻译成host binary，并交由host 运行翻译所得的host binary。</li>
<li>Tiny Code Generator (TCG) 是QEMU 中负责动态翻译的组件。
<ul>
<li>对TCG 而言，target 有不同的含意，它代表TCG 是针对哪一个host 生成host
binary。</li>
</ul></li>
</ul></li>
<li>QEMU
极为依赖macro，这使得直接阅读源代码通常无法确定其函数呼叫，或是执行流程倒底为何。</li>
<li>请在编译QEMU
的时候加上<code>--extra-cflags="-save-temps"</code>，如此可得展开marco
的 <code>*.i</code> 档。</li>
</ul>
<h2 id="tcg">1. TCG</h2>
<ul>
<li>TCG 是QEMU 的核心。其基本流程如下:
<ul>
<li>guest binary -&gt; TCG IR -&gt; host binary</li>
</ul></li>
</ul>
<h3 id="tcg-ir">1.1 TCG IR</h3>
<ul>
<li><p>TCG 定义了一组IR (intermediate representation)，熟悉GCC
的各位对此应该不陌生。</p></li>
<li><p>TCG IR 大致分成以下几类:</p>
<ul>
<li>Move Operation: mov, movi, …</li>
<li>Logic Operation: and, or, xor, shl, shr, …</li>
<li>Arithmetic peration: add, sub, mul, div, …</li>
<li>Branch Operation: jmp, br, brcond</li>
<li>Fuction call: call</li>
<li>Memory Operation: ld, st</li>
<li>QEMU specific Operation: tb_exit, goto_tb, qemu_ld/qemu_st</li>
</ul></li>
<li><p>请见tcg/*，特别是tcg.i，可以看到TCGOpcode。</p></li>
<li><p>tcg/README 也别忘了。</p></li>
<li><p>TCG 在翻译guest binary 的时候是以一个translation block (tb)
为单位，其结尾通常是分支指令。</p></li>
<li><p>target/ARCH/* 定义了如何将ARCH binary 反汇编成TCG IR。</p>
<ul>
<li>target/arm</li>
</ul></li>
<li><p>tcg/ARCH 定义了如何将TCG IR 翻译成ARCH binary。</p>
<ul>
<li>tcg/i386</li>
</ul></li>
</ul>
<h3 id="tcg-flow">1.2 TCG Flow</h3>
<ul>
<li><p>gen_opc_buf 和gen_opparam_buf (translate-all.c) 分别放置TCG
Opcode 和Operand。</p></li>
<li><p>如果使用静态配置的缓冲区，static_code_gen_buffer (exec.c)
即为code cache，放置host binary。</p></li>
<li><p>在跳入/出code cache
执行之前/后，要执行prologue/epilogue，请见code_gen_prologue
(exec.c)。</p></li>
<li><p>这边的prologue/epilogue 就是指function
prologue/epilogue。</p></li>
<li><p>QEMU 将跳至code cache (host binary)
执行的过程看成是函式呼叫，故有此prologue/epilogue。</p></li>
<li><p>以qemu-arm 为例，流程大致如下:</p>
<ul>
<li><p>main() // vl.c</p></li>
<li><p>--&gt;&gt; main_loop() // vl.c</p></li>
<li><p>--&gt;&gt; arm_cpu_realizefn() //
target/arm/cpu.c，实例化虚拟机CPU设备模型 [GUEST]_cpu_realizefn</p></li>
<li><p>--&gt;&gt; qemu_init_vcpu() //
softmmu/cpus.c，KVM没有enable，并且启_cpu_thread_fn用了TCG的情况下，tcg_enabled()</p></li>
<li><p>--&gt;&gt; qemu_tcg_init_vcpu() //
启动VCPU线程，线程处理函数为qemu_tcg_cpu_thread_fn</p></li>
<li><p>--&gt;&gt; qemu_tcg_cpu_thread_fn()</p></li>
<li><p>--&gt;&gt; tcg_exec_all()</p></li>
<li><p>--&gt;&gt; tcg_cpu_exec()</p></li>
<li><p>--&gt;&gt; cpu_exec() //cpu-exee.c</p></li>
<li><p>user mode:</p>
<ul>
<li>main (linux-user/main.c) -&gt; cpu_create -&gt; tcg_prologue_init
(tcg/tcg.c) -&gt; cpu_loop (linux-user/main.c)</li>
</ul></li>
</ul></li>
<li><p>这边只介绍tcg_prologue_init (tcg/tcg.c) -&gt; cpu_loop
(linux-user/arm/cpu_loop.c) 这一段，因为这一段跟TCG 较为相关。</p></li>
<li><p>容我先讲cpu_loop (linux-user/arm/cpu_loop.c)。</p></li>
<li><p>cpu_loop(CPUARMState *env) (linux-user/arm/cpu_loop.c) -&gt;
cpu_exec (accel/tcg/cpu-exec.c)。</p></li>
<li><p>cpu_exec 是主要执行回圈，其结构大致如下: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* prepare setjmp context for exception handling */</span> </span><br><span class="line"><span class="keyword">if</span> (sigsetjmp(cpu-&gt;jmp_env, <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!cpu_handle_exception(cpu, &amp;ret)) &#123;</span><br><span class="line">    <span class="keyword">while</span> (!cpu_handle_interrupt(cpu, &amp;last_tb)) &#123; </span><br><span class="line">        tb = tb_lookup(cpu, pc, cs_base, flags, cflags); <span class="comment">// 寻找下一个TB</span></span><br><span class="line">        <span class="keyword">if</span> (tb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            tb = tb_gen_code(cpu, pc, cs_base, flags, cflags);</span><br><span class="line">        &#125;</span><br><span class="line">        cpu_loop_exec_tb(cpu, tb, &amp;last_tb, &amp;tb_exit);<span class="comment">// 跳至code cache 执行。</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">cpu_exec_exit(cpu);</span><br></pre></td></tr></table></figure></p></li>
<li><p>tcg_prologue_init (tcg/tcg.c) -&gt; tcg_target_qemu_prologue
(tcg/arm/tcg-target.c.inc)。</p></li>
<li><p>如前所述，QEMU 将跳至code cache (host binary)
执行的过程看成是函式呼叫。</p></li>
<li><p>不同平台的calling convention 各有不同，tcg_prologue_init
将产生prologue/epilogue 的工作转交tcg_target_qemu_prologue。
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tcg_target_qemu_prologue</span><span class="params">(TCGContext *s)</span> &#123; </span><br><span class="line">    <span class="comment">/* Calling convention requires us to save r4-r11 and lr.  */</span></span><br><span class="line">    <span class="comment">/* stmdb sp!, &#123; r4 - r11, lr &#125; */</span></span><br><span class="line">    tcg_out32(s, (COND_AL &lt;&lt; <span class="number">28</span>) | <span class="number">0x092d4ff0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reserve callee argument and tcg temp space.  */</span></span><br><span class="line">    tcg_out_dat_rI(s, COND_AL, ARITH_SUB, TCG_REG_CALL_STACK,</span><br><span class="line">                   TCG_REG_CALL_STACK, STACK_ADDEND, <span class="number">1</span>);</span><br><span class="line">    tcg_set_frame(s, TCG_REG_CALL_STACK, TCG_STATIC_CALL_ARGS_SIZE,</span><br><span class="line">                  CPU_TEMP_BUF_NLONGS * <span class="keyword">sizeof</span>(<span class="type">long</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* QEMU (cpu_exec) -&gt; 入栈*/</span> </span><br><span class="line">    tcg_out_mov(s, TCG_TYPE_PTR, TCG_AREG0, tcg_target_call_iarg_regs[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tcg_target_call_iarg_regs 是函式呼叫负责传递参数的暂存器。</span></span><br><span class="line">    <span class="comment">// 跳至code cache 执行。</span></span><br><span class="line">    tcg_out_bx(s, COND_AL, tcg_target_call_iarg_regs[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 此时，s-&gt;code_ptr 指向code_gen_prologue 中prologue 和jmp to code cache 之后的位址。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Return path for goto_ptr. Set return value to 0, a-la exit_tb,</span></span><br><span class="line"><span class="comment">     * and fall through to the rest of the epilogue.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    tcg_code_gen_epilogue = tcg_splitwx_to_rx(s-&gt;code_ptr);</span><br><span class="line">    tcg_out_movi(s, TCG_TYPE_PTR, TCG_REG_R0, <span class="number">0</span>);</span><br><span class="line">    tcg_out_epilogue(s); <span class="comment">/* 出栈-&gt; 返回QEMU (cpu_exec)，确切的讲是返回tcg_qemu_tb_exec */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>这边小结一下。</p>
<ul>
<li>QEMU -&gt; prologue -&gt; code cache -&gt; epilogue -&gt; QEMU</li>
</ul></li>
<li><p>在介绍cpu_exec 之前，我先介绍几个QEMU
资料结构，请善用SOURCEARCHIVE.com。</p></li>
<li><p>我们要知道所谓仿真或是虚拟化一个CPU
(ISA)，简单来说就是用一个资料结构(struct) 储存该CPU的状态。</p></li>
<li><p>执行该虚拟CPU，就是从内存中读取该虚拟CPU的资料结构，运算后再存回去。</p></li>
<li><p>CPUX86State: 保存x86 register，eflags，eip，cs，…。</p></li>
<li><p>不同ISA 之间通用的资料结构被QEMU #define 成CPU_COMMON。</p></li>
<li><p>一般称此资料结构为CPUState。下文所提env 即为CPUState。</p></li>
<li><p>QEMU 运行虚拟CPU 都会利用env 这个变数。</p></li>
<li><p>TranslationBlock: 之前说过，QEMU 是以一个translation block
为单位进行翻译。</p></li>
<li><p>其中保存此translation block 对应guest binary 的pc, cs_base,
eflags。</p></li>
<li><p>另外，tc_ptr 指向code cache (host
binary)。其它栏位待以后再谈。</p></li>
<li><p>PageDesc: 主要保存guest page 中的第一个tb (TranslationBlock
*)。</p></li>
<li><p>这跟QEMU 内部运作机制有关。某些情况下，guest page (guest binary)
可能被替换或是被写。</p></li>
<li><p>这个时候，QEMU 会以guest page (guest binary)
为单位，清空与它相关联的TB (code cache)。</p></li>
<li><p>这时再回来讲 TranslationBlock。TranslationBlock
有底下两个栏位:</p>
<ul>
<li>page_addr[2]: 存放TranslationBlock 对应guest binary 所在的guest
page。注意! guest binary 有可能跨guest page，故这里有两个栏位。</li>
<li>page_next[2]: 当透过PageDesc-&gt;first_tb 找到该guest page
的第一个tb，tb-&gt;page_next 就被用来找寻该guest page 的下一个tb。</li>
</ul></li>
<li><p>再回来讲PageDesc。QEMU 替PageDesc
维护了一个二级页表l1_map。page_find 这个函式根据输入的address
搜寻l1_map，返回PageDesc。这在以guest page (guest binary)
为单位，清空与它相关联的TB (code cache)
的时候会用到。有一个名字很像的资料结构叫PhysPageDesc，QEMU
也替它维护一个二级页表l1_phys_map。这是在system mode
做地址转换之用，这边不谈。</p></li>
<li><p>TCGContext: 生成TCG IR 时会用到。</p></li>
<li><p>DisasContext: 反汇编guest binary 时会用到</p></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2023/01/14/spec2006%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2023/01/14/spec2006%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/" class="post-title-link" itemprop="url">SPEC2006交叉编译</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-14 17:28:50" itemprop="dateCreated datePublished" datetime="2023-01-14T17:28:50+08:00">2023-01-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:18" itemprop="dateModified" datetime="2023-07-30T18:15:18+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>982</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="spec2006说明">1. SPEC2006说明</h1>
<ul>
<li>CPU Benchmark</li>
<li>用例具体内容见官网<code>http://www.spec.org/cpu2006/docs/用例名.html</code></li>
<li>运行时注意不要漏掉参数(Input)</li>
<li>例:</li>
</ul>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="header">
<th>子项目</th>
<th>类别</th>
<th>语言</th>
<th>说明</th>
<th>Web</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>462.libquantum</td>
<td>物理：量子计算</td>
<td>ISO/IEC 9899:1999(“C99”)</td>
<td>libquantum是模拟量子计算机的库文件，用来进行量子计算机应用的研究</td>
<td>http://www.spec.org/cpu2006/docs/462.libquantum.html</td>
</tr>
</tbody>
</table>
<h1 id="交叉编译">2. 交叉编译</h1>
<ol type="1">
<li>解压下载的SPEC2006压缩包</li>
<li>安装SPEC <code>./install.sh</code></li>
<li>安装aarch64交叉编译环境
<ul>
<li>gcc、g++、gfortran</li>
<li><code>sudo apt install gfortran-8-aarch64-linux-gnu</code></li>
</ul></li>
<li>加载环境变量
<ul>
<li>只要需要用到SPEC2006的指令，都需要在打开终端时加入<code>source ./shrc</code></li>
</ul></li>
<li>交叉编译配置
<ol type="1">
<li>进入<code>config</code>目录下，复制<code>Example-linux64-amd64-gcc43+</code>的配置文件（这个文件的选择根据Gem5中模拟的核模型来选择），将其重命名为<code>aarch64.cfg</code>（可以任意命名为其它名称）</li>
<li>修改配置文件<code>aarch64.cfg</code>，指定编译工具
<ul>
<li>分别找到CC，CXX，FC</li>
<li>改成如下格式： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CC =  your-cross-compiler-gcc</span><br><span class="line"></span><br><span class="line">CXX = your-cross-compiler-g++</span><br><span class="line"></span><br><span class="line">FC = your-cross-compiler-gfortran</span><br></pre></td></tr></table></figure></li>
<li>在gem5中运行的样例需要静态编译，故对COPTIMIZE、CXXOPTIMIZE、FOPTIMIZE加上<code>-static</code>标签</li>
<li>修改完后保存退出，其他地方不用改。</li>
</ul></li>
</ol></li>
<li>编译speccpu:</li>
</ol>
<ul>
<li><p><code>runspec --action=build --config=aarch64.cfg --tune=base int</code>
（只编译int型benchmark，不运行）</p></li>
<li><p>生成可执行文件<code>runspec --config=&lt;你的配置文件名&gt; --size=ref --noreportable --tune=base --iterations=1 &lt;样例名称&gt;</code></p></li>
</ul>
<ol start="7" type="1">
<li>将编译好的文件（在源码目录下，如<code>benchspec/CPU2006/400.perlbench/build/</code>）拷贝出来就可以在目标板或者模拟器上运行了。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2022/11/15/Effective%20C++(6)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2022/11/15/Effective%20C++(6)/" class="post-title-link" itemprop="url">Effective C++(6)--继承与面向对象设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-15 22:28:50" itemprop="dateCreated datePublished" datetime="2022-11-15T22:28:50+08:00">2022-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:32" itemprop="dateModified" datetime="2023-07-30T18:15:32+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/c/" itemprop="url" rel="index"><span itemprop="name">c++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="条款32-确定public继承塑模出is-a关系">条款32
确定public继承塑模出is-a关系</h1>
<ul>
<li>public继承意味"is-a"</li>
<li>Liskov替换原则
<ul>
<li>class D : class B { ... }</li>
<li>适用于B身上的每一件事也适用于D，反之不然</li>
</ul></li>
</ul>
<h1 id="条款33-避免遮掩继承而来的名称">条款33
避免遮掩继承而来的名称</h1>
<h2 id="继承体系内的名称可视性">继承体系内的"名称可视性"</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>base class内所有名为mf1和mf3的函数都被derived
class内的mf1和mf3函数遮掩了 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.<span class="built_in">mf1</span>();    <span class="comment">/// ok</span></span><br><span class="line">d.<span class="built_in">mf1</span>(x);   <span class="comment">/// error, Base::mf1被遮掩</span></span><br><span class="line">d.<span class="built_in">mf2</span>();    <span class="comment">/// ok, Base::mf2</span></span><br><span class="line">d.<span class="built_in">mf3</span>();    <span class="comment">/// ok, Derived::mf3</span></span><br><span class="line">d.<span class="built_in">mf3</span>(x);   <span class="comment">/// error, Base::mf3被遮掩</span></span><br></pre></td></tr></table></figure></li>
<li>该机制的目的在于提醒base和derived class之间的is-a关系 ##
override缺省遮掩行为</li>
<li>一般不在public继承下使用，破坏了is-a的关系</li>
<li>在private继承下有用 ### 使用using声明式 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::mf1;    <span class="comment">/// 让Base class内名为mf1和mf3的所有东西</span></span><br><span class="line">    <span class="keyword">using</span> Base::mf3;    <span class="comment">/// 在Derived作用域内可见(且public)</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.<span class="built_in">mf1</span>();    <span class="comment">/// ok，Derived::mf1</span></span><br><span class="line">d.<span class="built_in">mf1</span>(x);   <span class="comment">/// ok, Base::mf1</span></span><br><span class="line">d.<span class="built_in">mf2</span>();    <span class="comment">/// ok, Base::mf2</span></span><br><span class="line">d.<span class="built_in">mf3</span>();    <span class="comment">/// ok, Derived::mf3</span></span><br><span class="line">d.<span class="built_in">mf3</span>(x);   <span class="comment">/// ok, Base::mf3</span></span><br></pre></td></tr></table></figure> ###
转交函数(forwarding function)</li>
<li>Derived private继承Base，且只想继承无参数版本的的mf1
<ul>
<li>using会导入所有同名函数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span>  <span class="comment">/// 转交函数</span></span></span><br><span class="line"><span class="function">    </span>&#123; Base::mf1; &#125;      <span class="comment">/// 暗自成为inline函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">d.<span class="built_in">mf1</span>();    <span class="comment">/// ok，Derived::mf1</span></span><br><span class="line">d.<span class="built_in">mf1</span>(x);   <span class="comment">/// error, Base::mf1被遮掩</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h1 id="条款34-区分接口继承和实现继承">条款34
区分接口继承和实现继承</h1>
<ul>
<li>声明一个pure virtual函数的目的是为了让derived class只继承函数接口。
<ul>
<li>1个构造函数 + 1个析构函数 + n个赋值操作</li>
</ul></li>
<li>做法B
<ul>
<li>n个构造函数 + n个析构函数</li>
</ul></li>
<li>当classes的一个赋值成本低于一组构造+析构成本，做法A大体而言比较高效</li>
<li>此外A造成w的作用域比B更大，会对易维护性造成冲突 ### 结论</li>
<li>当满足以下两点时使用方法A，否则使用方法B
<ol type="1">
<li>赋值成本低于构造+析构</li>
<li>代码对效率高度敏感</li>
</ol></li>
</ul>
<h1 id="条款27-尽量少做转型动作">条款27 尽量少做转型动作</h1>
<ul>
<li>C++规则的设计目标之一:
<ul>
<li>保证<em>类型错误</em>绝不可能发生</li>
</ul></li>
<li>C风格转型/旧式转型 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(T)<span class="function">expression</span></span><br><span class="line"><span class="function"><span class="title">T</span><span class="params">(expression)</span> <span class="comment">/// 二者等价，将expression转型为T类型</span></span></span><br></pre></td></tr></table></figure></li>
<li>新式转型(<em>C++-style casts</em>) <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">const_cast</span>&lt;T&gt;( expression )         </span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;T&gt;( expression )</span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;T&gt;( expression )</span><br><span class="line"><span class="built_in">static_cast</span>&lt;T&gt;( expression )</span><br></pre></td></tr></table></figure> ###
新式转型更受欢迎:</li>
</ul>
<ol type="1">
<li>易辨识</li>
<li>转型动作的目标越窄化，编译器越可能诊断出错误的运用 ###
唯一使用旧式转型的时机</li>
</ol>
<ul>
<li>调用一个explicit构造函数将一个对象传递给一个函数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(<span class="type">int</span> size)</span></span>; </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomeWork</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>;</span><br><span class="line"><span class="built_in">doSomeWork</span>(<span class="built_in">Widget</span>(<span class="number">15</span>));</span><br><span class="line"><span class="built_in">doSomeWork</span>(<span class="built_in">static_cast</span>&lt;Widget&gt;(<span class="number">15</span>));</span><br></pre></td></tr></table></figure> ##
const_cast</li>
<li>常量性转除</li>
<li>唯一有此功能的新式转型 ## dynamic_cast</li>
<li>安全向下转型(safe downcasting)</li>
<li>唯一无法由旧式语法执行的动作</li>
<li>唯一可能耗费重大运行成本的转型动作 ### 实现(一个普遍的版本)</li>
<li>基于class名称的字符串比较
<ul>
<li>调用strcmp</li>
<li>深度、多重继承体系成本更高 ## reinterpret_cast</li>
</ul></li>
<li>执行低级转型</li>
<li>不可移植
<ul>
<li>实际动作及结果取决于编译器</li>
<li>如将<code>pointer to int</code>转化为<code>int</code> ##
static_cast</li>
</ul></li>
<li>强迫隐式转换(implicit conversion)
<ul>
<li>non-const --&gt; const</li>
<li>void* --&gt; typed*</li>
<li>pointer-to-base --&gt; pointer-to-derived ##
转型往往真的令编译器编译出运行期执行的码</li>
</ul></li>
<li>不只是告诉编译器将某种类型视为另一种类型 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">...</span><br><span class="line"><span class="type">double</span> d = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(x) / y;</span><br></pre></td></tr></table></figure></li>
<li>将int转型为double几乎肯定会产生代码
<ul>
<li>在大部分计算机体系结构中，int的底层表述不同于double
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; ... &#125;;</span><br><span class="line">Derived d;</span><br><span class="line">Base* pb = &amp;d; <span class="comment">/// 隐喻地将Derived*转换为Base*</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>同一个对象的Derived指针与Base指针值可能并不相同
<ul>
<li>与编译器如何实现有关</li>
<li>有时候存在一个偏移量</li>
<li>运行时会计算偏移量以转型</li>
<li>多重继承中几乎必然发生，单一继承中可能发生</li>
</ul></li>
<li>避免做出“对象在C++中如何布局”的假设</li>
</ul>
<h1 id="条款28-避免返回handles指向对象内部分">条款28
避免返回handles指向对象内部分</h1>
<h1 id="条款29-strive-for-exception-safe-code.">条款29 Strive for
exception-safe code.</h1>
<ul>
<li>不泄露任何资源</li>
<li>不允许数据败坏 ## 异常安全函数提供以下三个保证之一:</li>
</ul>
<ol type="1">
<li>基本承诺:
<ul>
<li>异常抛出时，程序内的任何事物仍然保持在有效状态下。</li>
<li>但在哪个有效状态不可预料</li>
</ul></li>
<li>强烈保证:
<ul>
<li>异常抛出时，程序状态不改变。</li>
<li>成功 --&gt; 完全成功</li>
<li>失败 --&gt; 回复到</li>
<li>往往以copy-and-swap实现</li>
<li>并非对所有函数都可实现或具备意义</li>
</ul></li>
<li>不抛掷(nothrow)保证:
<ul>
<li>承诺绝不抛出异常</li>
<li>内置类型的操作均遵守</li>
</ul></li>
</ol>
<h1 id="条款30-透彻了解inline的里里外外">条款30
透彻了解inline的里里外外</h1>
<h2 id="inline">inline</h2>
<h3 id="优点">优点</h3>
<ul>
<li>免除函数调用成本</li>
<li>编译器最优化机制通常用于浓缩“不含函数调用的代码” ### 缺点</li>
<li>增加<code>object code</code>的大小
<ul>
<li>可能导致额外的的换页</li>
<li>降低cache命中率 ## inline是对编译器的一个申请，不是强制命令</li>
</ul></li>
<li>编译器拒绝inline复杂函数
<ul>
<li>如递归、循环、virtual(运行期决定)</li>
</ul></li>
<li>编译器无法inline将给出告警 ### 隐式申请</li>
<li>将函数定义为class定义式内 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">age</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> theAge; &#125; <span class="comment">// 一个隐喻的inline申请</span></span><br><span class="line">    ...                                <span class="comment">// age被定义与class定义式内</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> theAge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>这样的函数通常是成员函数，但是friend函数也可定义与class内(见 条款46)
### 显式申请</li>
<li>在定义式前加上关键字inline <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;algorithm&gt;</span></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">inline</span> <span class="type">const</span> T&amp; <span class="title">max</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ##
inline函数通常被置于头文件内</li>
<li>编译期进行inline</li>
<li>方便编译器将函数调用替换为函数本体</li>
<li>template的具现化与inline无关
<ul>
<li>通常被置于头文件内，方便编译器具现化 ##
有时即便编译器inline某个函数，可能还是为该函数生成一个函数本体</li>
</ul></li>
<li>例如要取某个inline函数的地址时</li>
<li>编译器不对通过函数指针进行的调用实施inline <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="built_in">void</span> ( *pf ) = f;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">f</span>();        <span class="comment">// inline</span></span><br><span class="line"><span class="built_in">pf</span>();       <span class="comment">// outline</span></span><br></pre></td></tr></table></figure></li>
<li>编译器有时会自动生成inline函数的ouline副本
<ul>
<li>比如生成构造和析构函数的副本，这样在array中可使用函数指针进行构造和析构
## 构造函数和析构函数时inline糟糕的候选人 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::srting bm1, bm2;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123; &#125;;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::srting dm1, dm2, dm3;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>看起来构造函数和析构函数没有什么代码量，但其实不然</li>
<li>例如，一种可能的编译器实现: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Derived::<span class="built_in">Derived</span>() &#123;</span><br><span class="line">    Base::<span class="built_in">Base</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123; dm1.std::string::<span class="built_in">string</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123; </span><br><span class="line">        Base::~<span class="built_in">Base</span>();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123; dm2.std::string::<span class="built_in">string</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123; </span><br><span class="line">        Base::~<span class="built_in">Base</span>();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123; dm3.std::string::<span class="built_in">string</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123; </span><br><span class="line">        Base::~<span class="built_in">Base</span>();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="条款31-将文件间的编译依存关系降至最低">条款31
将文件间的编译依存关系降至最低</h1>
<h2 id="编译依存关系">编译依存关系</h2>
<ul>
<li>class的定义式不只详细描述了class接口，还包括十足的实现细目
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name. <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;    <span class="comment">/// 实现细目</span></span><br><span class="line">    Date theBirthDate;      <span class="comment">/// 实现细目</span></span><br><span class="line">    Address theAddress;     <span class="comment">/// 实现细目</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>C++将实现细目置于定义式中
<ul>
<li>编译器需要根据定义式确定分配多大空间</li>
</ul></li>
<li>Person若要通过编译，需要classes string，Date，Address的定义式
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;date.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;address.h&quot;</span></span></span><br></pre></td></tr></table></figure></li>
<li>但是，如此一来，Person定义文件和其含入文件形成了编译依存关系
<ul>
<li>如果这些头文件有一个被改变，或者这些头文件所依赖的其他文件有任何改变，那么每一个含入和使用Person
class的文件也必须重新编译 ## 编译依存性最小化 -- 接口与实现分离</li>
</ul></li>
<li>通过Handle classes和Interface
classes解除了接口和实现之间的耦合，降低了文件之间的编译依存性 ### pimpl
idiom -- <code>Handle class</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>   <span class="comment">// 标准程序组件不该被前置声明</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>   <span class="comment">// for shared_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PresonImpl</span>;   <span class="comment">// Person实现类的前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;         <span class="comment">// Person接口用到的classes的前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;PresonImpl&gt; pImpl_;</span><br><span class="line">&#125;;</span><br><span class="line">Person::<span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr)</span><br><span class="line">    : <span class="built_in">pImpl</span>(<span class="keyword">new</span> <span class="built_in">PresonImpl</span>(name, birthday, addr))</span><br><span class="line">    &#123;&#125;</span><br><span class="line"><span class="function">std::string <span class="title">Person::name</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pImpl-&gt;<span class="built_in">name</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Person的客户端完全与Date，Address以及Person的实现细目分开 ###
抽象基类(abstract base class、Interface class)</li>
<li>详细一一描述derived class的接口
<ul>
<li>一组pure virtual函数</li>
</ul></li>
<li>通常不带成员变量，也没有构造函数</li>
<li>只有一个virtual析构函数(见条款7) <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>客户必须以Person的pointers和references来撰写应用程序
<ul>
<li>除非Interface class修改，否则不用编译</li>
</ul></li>
<li>客户必须有办法为这种class创建新对象
<ul>
<li>工厂函数
<ul>
<li>返回指针指向动态分配所得的对象</li>
<li>往往在Interface class中声明为static <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;Person&gt; <span class="title">create</span><span class="params">(<span class="type">const</span> std::string&amp; name, </span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> Date&amp; birthday, </span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> Address&amp; addr)</span></span>; <span class="comment">// why shared_ptr;见条款18</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 客户如此使用</span></span><br><span class="line">std::string; name, </span><br><span class="line">Date dateodBirth, </span><br><span class="line">Address address;</span><br><span class="line">...</span><br><span class="line"><span class="function">std::shared_ptr&lt;Person&gt; <span class="title">pp</span><span class="params">(Person::create(name, dateodBirth, address))</span></span>;</span><br><span class="line">...</span><br><span class="line">std::cout &lt;&lt; pp-&gt;<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li>当然，支持Interface
class接口的那个具象类(<code>concrete class</code>)必须被定义出来
<ul>
<li>一切都在virtual构造函数的实现码所在文件内秘密发生 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealPerson</span> : <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RealPerson</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr)</span><br><span class="line">        : <span class="built_in">theName</span>(name), <span class="built_in">theBirthDate</span>(birthday), <span class="built_in">theAddress</span>(addr)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">RealPerson</span>() &#123;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;    </span><br><span class="line">    Date theBirthDate;      </span><br><span class="line">    Address theAddress;     </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> std::shared_ptr&lt;Person&gt; <span class="title">Person::create</span><span class="params">(<span class="type">const</span> std::string&amp; name, </span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">const</span> Date&amp; birthday, </span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">const</span> Address&amp; addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> <span class="built_in">RealPerson</span>(name, dateodBirth, addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>更现实的Person::create实现代码会创建不同的derived class ### 开销
#### Handle classes</li>
</ul></li>
</ul>
<ol type="1">
<li>成员函数必须通过implementation pointer取得对象数据，
<ul>
<li>每次访问增加一次间接性</li>
</ul></li>
<li>每个对象的内存消耗多一个implementation pointer的大小</li>
<li>implementation pointer必须初始化，指向动态分配的implementation内存
<ul>
<li>涉及到动态分配 #### Interface class</li>
</ul></li>
<li>virtual函数带来间接跳跃(见条款7)</li>
<li>派生类对象有一个vptr(见条款7) ### 本质</li>
</ol>
<ul>
<li>声明的依存性 替换 定义的依存性</li>
<li>尽量让头文件自我满足，做不到则让它与其他头文件内的声明式而非定义式相依
## 方法 ### 如果使用object
reference/pointer可以完成任务，就不要使用object</li>
<li>前者仅需声明，后者需要定义 ###
如果能够，尽量用class声明式替换class定义式</li>
<li>注意，当声明一个函数而它用到某个class的定义时，并不需要该class的定义
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;                         <span class="comment">// class声明式</span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span></span>;                       <span class="comment">// 没问题，这里并不需要Date的定义式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>;</span><br></pre></td></tr></table></figure> ### 为声明式和定义式提供不同的头文件</li>
<li>程序库客户应该总是#include一个声明文件而非前置声明若干class或函数
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;datafw.h&quot;</span>  <span class="comment">// 这个头文件内声明单未定义class Date</span></span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span></span>;                      </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>只含声明式的头文件名为"datefw.h",命名方式取法C++标准库的<iosfwd>
<ul>
<li><iosfwd>内含iostream各组件的声明式，其定义则分布在相应的头文件，包括<sstream>,<streambuf>,<fstream>,<iostream></li>
</ul></li>
<li>此方法同样适用于template
<ul>
<li>export关键字同样可以，但很少使用</li>
</ul></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2022/11/15/ARM64%E6%B1%87%E7%BC%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2022/11/15/ARM64%E6%B1%87%E7%BC%96/" class="post-title-link" itemprop="url">ARM64汇编</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-15 22:28:50" itemprop="dateCreated datePublished" datetime="2022-11-15T22:28:50+08:00">2022-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:18" itemprop="dateModified" datetime="2023-07-30T18:15:18+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/c/" itemprop="url" rel="index"><span itemprop="name">c++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="寄存器">寄存器</h1>
<ul>
<li>在arm64架构下，所有的寄存器都是64位，并且每个寄存器都有名字的，按照功能来划分，可分为一下几类，分别为：
<ol type="1">
<li>通用寄存器</li>
<li>程序计数器</li>
<li>堆栈指针</li>
<li>链接寄存器</li>
<li>程序状态寄存器</li>
<li>零寄存器</li>
</ol></li>
<li>下面分别说明这些寄存器的作用</li>
</ul>
<h2 id="通用寄存器">通用寄存器</h2>
<ul>
<li>64bit : x0 ~ x28 ，每个寄存器都是64bit</li>
<li>32bit：w0 ~ w28，实际上是x0~x28寄存器的低32bit</li>
<li>x0~x7：通过用来存储函数的参数，如果函数有更多的参数使用堆栈来传递</li>
<li>x0：通常用来存放函数的返回值</li>
</ul>
<h2 id="程序计数器">程序计数器</h2>
<ul>
<li>程序计数器叫<code>Program Counter</code>，俗称<code>PC</code>，也就是<code>x32</code>寄存器，存储着CPU当前正在执行的地址。</li>
</ul>
<h2 id="堆栈指针">堆栈指针</h2>
<ul>
<li><code>SP</code>
(<code>Stack Pointer</code>)，就是<code>x31</code>寄存器，存储的是栈顶的地址</li>
<li><code>FP</code>
(<code>Frame Pointer</code>)，<code>FP</code>也就是<code>x29</code>寄存器，存储着栈底的地址</li>
<li>随着函数的调用，<code>SP</code>、<code>FP</code>会不断的变化。</li>
</ul>
<h2 id="链接寄存器">链接寄存器</h2>
<p><code>LR</code>（<code>Link Register</code>），也就是<code>x30</code>寄存器，存储着函数的返回地址。
-
当函数结束时，就是通过LR寄存器的值，跳转到调用函数的位置继续往下执行。</p>
<h2 id="程序状态寄存器">程序状态寄存器</h2>
<ul>
<li><code>CPSR</code>
(<code>Current Program Status Register</code>)</li>
<li><code>SPSR</code>
(<code>Saved Program Status Register</code>)，在异常状态下使用，当发生异常时，会把<code>CPSR</code>的内容写入<code>SPSR</code>,
等异常恢复之后，又会把<code>SPSR</code>写会到<code>CPSR</code>中。</li>
</ul>
<p>零寄存器 WZR XZR 里面存储的值都是0。</p>
<p>常用指令 算术运算指令 mov 赋值指令</p>
<p>mov x0, #2 // 把2这个值赋值给x0寄存器 mov x0, x1 //
把x1寄存器中的值赋值给x0寄存器中 add
两个操作数相加，相加的结果存放到一个寄存器中</p>
<p>add, x2, x0, x1 //把x0的值与x1的值相加，得到的结果存放到x2寄存器中
add, x2, x0, #3 // 把x0的值与3相加，得到的结果存放到x2寄存器中 sub
第一个操作数减第一个操作数，得到的结果存放到一个寄存器中</p>
<p>sub, x2, x1, x0 //
x1的值减去x0的值，得到的结果存放到<em>x2</em>寄存器中 sub, x2, x1, #4 //
x1的值减去4，得到的结果存放到x2寄存器中 mul 乘法指令</p>
<p>mul x3, x1, x2 // x1 乘以 x2 的结果存放在 x3 中 sdiv 除法指令</p>
<p>sdiv w0, w0, w1 // w0 除以 w1 的结果存放在 w0 中 逻辑运算指令
这里的运算是指位运算</p>
<p>LSL 逻辑左移 按操作数所指定的数量向左移位，低位用零来填充 ASL
算术左移 通逻辑左移，ASL 与 LSL等价 lsl x0, x0, #1 asl x1, x1, x0 LSR
逻辑右移 按操作数所指定的数量向右移位，左端用零来填充。</p>
<p>ASR 算术右移 按操作数所指定的数量向右移位，左端用最高位位的值来填充
，如果是负数，最高位为1</p>
<p>lsr w1, w2, #1 asr x1, x2, #2 ROR 循环右移
按操作数所指定的数量向右循环移位，
左端用右端移出的位来填充。其中，操作数可以是通用寄存器，也可以是立即数。
当进行寄存器bit位数的循环右移操作时，通用寄存器中的值不改变。 ror x0, #6
ror w0, #32 // 循环移动了32位，w0的值不变 跳转指令 ret
相当于高级编程语言的return，函数返回。</p>
<p>cmp 将两个操作数相减，相减的结果会影响cpsr
寄存器的标志位，当结果小于0时，CPSR寄存器的N位为1， 等于0时，
CPSR寄存器的Z为位1。 cmp x0, x1</p>
<p>b
跳转指令，跳转找指定的标记处执行；可以带条件跳转，一般跟cmp配合使用，使用到的条件域如下：</p>
<p>EQ：equal NE：not equal GT：great than GE：great equal LT：less than
LE：less equal 普通跳转 b testCode，testCode是汇编代码中的一个标记</p>
<p>条件跳转，当x0和x1的值相等时，才跳转到testCode标记处执行代码</p>
<p>cmp x0, x1 beq testCode bl
带返回值的跳转指令，这个指令会做两个操作</p>
<p>将下一条指令的地址存储到lr （x30）寄存器中 跳转到标记处开始执行代码
bl
testCode，当执行完testCode标记处代码后，又会返回来执行bl指令下面的指令。
内存操作 load从内存中读取数据</p>
<p>ldr 地址没有偏移或者偏移为正数时使用 ldur 地址偏移为负数时使用 a) str
x5 [x0] x0中是内存的地址，读取的值存放在x5寄存器中, x寄存器读取8个字节
b）str w6 [x0] x0中是内存的地址，读取的值存放在w5寄存器中,
w寄存器读取4个字节 说明: 地址还可以偏移 str x5 [x0, #0x4] , stur x5 [x0,
#-0x4] ,
偏移量为正数往高地址偏移，使用str指令、偏移量为负数往低地址偏移，使用stur指令。</p>
<p>ldp 从指定内存中读取数据到一对寄存器中， p 是
pair的意思，这一对寄存器必须是同类型的，要么x类型,
要么w类型。其中低位读取到第一个寄存器、高位读取到第二个寄存器 ldp w5,
w6, [x0] , 地址可以偏移 ldp x5, x6, [x0, #-x04] store
往指定的内存写入数据</p>
<p>str str x1, [x0] str w2, [x1] str w3, [x1, #4] stur stur x3, [x0,
#-4] stur w2, [x1, #-4] stp stp x2, x3, [x0] stp w4, w5, [x0]
使用方法与从内存中读取数据类似，只不过是往内存写入数据。</p>
<p>总结
本文整理了一些在逆向iOS程序时常见的一些汇编指令，当然在实际逆向的过程所看到的汇编指令更加复杂，比如还有函数调用栈，这是下篇的内容。如有错误请指正。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2022/11/15/Effective%20C++(5)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2022/11/15/Effective%20C++(5)/" class="post-title-link" itemprop="url">Effective C++(5)--实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-15 10:28:50" itemprop="dateCreated datePublished" datetime="2022-11-15T10:28:50+08:00">2022-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:32" itemprop="dateModified" datetime="2023-07-30T18:15:32+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/c/" itemprop="url" rel="index"><span itemprop="name">c++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="条款26-尽量延后变量定义式出现的时间">条款26
尽量延后变量定义式出现的时间</h1>
<h2 id="循环">循环</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法A 定义于循环外</span></span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    w = 取决于某个i的值;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法B 定义于循环内</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="function">Widget <span class="title">w</span><span class="params">(取决于某个i的值)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="分析">分析</h3>
<ul>
<li>做法A
<ul>
<li>1个构造函数 + 1个析构函数 + n个赋值操作</li>
</ul></li>
<li>做法B
<ul>
<li>n个构造函数 + n个析构函数</li>
</ul></li>
<li>当classes的一个赋值成本低于一组构造+析构成本，做法A大体而言比较高效</li>
<li>此外A造成w的作用域比B更大，会对易维护性造成冲突 ### 结论</li>
<li>当满足以下两点时使用方法A，否则使用方法B
<ol type="1">
<li>赋值成本低于构造+析构</li>
<li>代码对效率高度敏感</li>
</ol></li>
</ul>
<h1 id="条款27-尽量少做转型动作">条款27 尽量少做转型动作</h1>
<ul>
<li>C++规则的设计目标之一:
<ul>
<li>保证<em>类型错误</em>绝不可能发生</li>
</ul></li>
<li>C风格转型/旧式转型 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(T)<span class="function">expression</span></span><br><span class="line"><span class="function"><span class="title">T</span><span class="params">(expression)</span> <span class="comment">/// 二者等价，将expression转型为T类型</span></span></span><br></pre></td></tr></table></figure></li>
<li>新式转型(<em>C++-style casts</em>) <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">const_cast</span>&lt;T&gt;( expression )         </span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;T&gt;( expression )</span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;T&gt;( expression )</span><br><span class="line"><span class="built_in">static_cast</span>&lt;T&gt;( expression )</span><br></pre></td></tr></table></figure> ###
新式转型更受欢迎:</li>
</ul>
<ol type="1">
<li>易辨识</li>
<li>转型动作的目标越窄化，编译器越可能诊断出错误的运用 ###
唯一使用旧式转型的时机</li>
</ol>
<ul>
<li>调用一个explicit构造函数将一个对象传递给一个函数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(<span class="type">int</span> size)</span></span>; </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomeWork</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>;</span><br><span class="line"><span class="built_in">doSomeWork</span>(<span class="built_in">Widget</span>(<span class="number">15</span>));</span><br><span class="line"><span class="built_in">doSomeWork</span>(<span class="built_in">static_cast</span>&lt;Widget&gt;(<span class="number">15</span>));</span><br></pre></td></tr></table></figure> ##
const_cast</li>
<li>常量性转除</li>
<li>唯一有此功能的新式转型 ## dynamic_cast</li>
<li>安全向下转型(safe downcasting)</li>
<li>唯一无法由旧式语法执行的动作</li>
<li>唯一可能耗费重大运行成本的转型动作 ### 实现(一个普遍的版本)</li>
<li>基于class名称的字符串比较
<ul>
<li>调用strcmp</li>
<li>深度、多重继承体系成本更高 ## reinterpret_cast</li>
</ul></li>
<li>执行低级转型</li>
<li>不可移植
<ul>
<li>实际动作及结果取决于编译器</li>
<li>如将<code>pointer to int</code>转化为<code>int</code> ##
static_cast</li>
</ul></li>
<li>强迫隐式转换(implicit conversion)
<ul>
<li>non-const --&gt; const</li>
<li>void* --&gt; typed*</li>
<li>pointer-to-base --&gt; pointer-to-derived ##
转型往往真的令编译器编译出运行期执行的码</li>
</ul></li>
<li>不只是告诉编译器将某种类型视为另一种类型 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">...</span><br><span class="line"><span class="type">double</span> d = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(x) / y;</span><br></pre></td></tr></table></figure></li>
<li>将int转型为double几乎肯定会产生代码
<ul>
<li>在大部分计算机体系结构中，int的底层表述不同于double
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; ... &#125;;</span><br><span class="line">Derived d;</span><br><span class="line">Base* pb = &amp;d; <span class="comment">/// 隐喻地将Derived*转换为Base*</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>同一个对象的Derived指针与Base指针值可能并不相同
<ul>
<li>与编译器如何实现有关</li>
<li>有时候存在一个偏移量</li>
<li>运行时会计算偏移量以转型</li>
<li>多重继承中几乎必然发生，单一继承中可能发生</li>
</ul></li>
<li>避免做出“对象在C++中如何布局”的假设</li>
</ul>
<h1 id="条款28-避免返回handles指向对象内部分">条款28
避免返回handles指向对象内部分</h1>
<h1 id="条款29-strive-for-exception-safe-code.">条款29 Strive for
exception-safe code.</h1>
<ul>
<li>不泄露任何资源</li>
<li>不允许数据败坏 ## 异常安全函数提供以下三个保证之一:</li>
</ul>
<ol type="1">
<li>基本承诺:
<ul>
<li>异常抛出时，程序内的任何事物仍然保持在有效状态下。</li>
<li>但在哪个有效状态不可预料</li>
</ul></li>
<li>强烈保证:
<ul>
<li>异常抛出时，程序状态不改变。</li>
<li>成功 --&gt; 完全成功</li>
<li>失败 --&gt; 回复到</li>
<li>往往以copy-and-swap实现</li>
<li>并非对所有函数都可实现或具备意义</li>
</ul></li>
<li>不抛掷(nothrow)保证:
<ul>
<li>承诺绝不抛出异常</li>
<li>内置类型的操作均遵守</li>
</ul></li>
</ol>
<h1 id="条款30-透彻了解inline的里里外外">条款30
透彻了解inline的里里外外</h1>
<h2 id="inline">inline</h2>
<h3 id="优点">优点</h3>
<ul>
<li>免除函数调用成本</li>
<li>编译器最优化机制通常用于浓缩“不含函数调用的代码” ### 缺点</li>
<li>增加<code>object code</code>的大小
<ul>
<li>可能导致额外的的换页</li>
<li>降低cache命中率 ## inline是对编译器的一个申请，不是强制命令</li>
</ul></li>
<li>编译器拒绝inline复杂函数
<ul>
<li>如递归、循环、virtual(运行期决定)</li>
</ul></li>
<li>编译器无法inline将给出告警 ### 隐式申请</li>
<li>将函数定义为class定义式内 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">age</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> theAge; &#125; <span class="comment">// 一个隐喻的inline申请</span></span><br><span class="line">    ...                                <span class="comment">// age被定义与class定义式内</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> theAge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>这样的函数通常是成员函数，但是friend函数也可定义与class内(见 条款46)
### 显式申请</li>
<li>在定义式前加上关键字inline <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;algorithm&gt;</span></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">inline</span> <span class="type">const</span> T&amp; <span class="title">max</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ##
inline函数通常被置于头文件内</li>
<li>编译期进行inline</li>
<li>方便编译器将函数调用替换为函数本体</li>
<li>template的具现化与inline无关
<ul>
<li>通常被置于头文件内，方便编译器具现化 ##
有时即便编译器inline某个函数，可能还是为该函数生成一个函数本体</li>
</ul></li>
<li>例如要取某个inline函数的地址时</li>
<li>编译器不对通过函数指针进行的调用实施inline <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="built_in">void</span> ( *pf ) = f;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">f</span>();        <span class="comment">// inline</span></span><br><span class="line"><span class="built_in">pf</span>();       <span class="comment">// outline</span></span><br></pre></td></tr></table></figure></li>
<li>编译器有时会自动生成inline函数的ouline副本
<ul>
<li>比如生成构造和析构函数的副本，这样在array中可使用函数指针进行构造和析构
## 构造函数和析构函数时inline糟糕的候选人 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::srting bm1, bm2;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123; &#125;;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::srting dm1, dm2, dm3;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>看起来构造函数和析构函数没有什么代码量，但其实不然</li>
<li>例如，一种可能的编译器实现: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Derived::<span class="built_in">Derived</span>() &#123;</span><br><span class="line">    Base::<span class="built_in">Base</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123; dm1.std::string::<span class="built_in">string</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123; </span><br><span class="line">        Base::~<span class="built_in">Base</span>();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123; dm2.std::string::<span class="built_in">string</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123; </span><br><span class="line">        Base::~<span class="built_in">Base</span>();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123; dm3.std::string::<span class="built_in">string</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123; </span><br><span class="line">        Base::~<span class="built_in">Base</span>();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="条款31-将文件间的编译依存关系降至最低">条款31
将文件间的编译依存关系降至最低</h1>
<h2 id="编译依存关系">编译依存关系</h2>
<ul>
<li>class的定义式不只详细描述了class接口，还包括十足的实现细目
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name. <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;    <span class="comment">/// 实现细目</span></span><br><span class="line">    Date theBirthDate;      <span class="comment">/// 实现细目</span></span><br><span class="line">    Address theAddress;     <span class="comment">/// 实现细目</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>C++将实现细目置于定义式中
<ul>
<li>编译器需要根据定义式确定分配多大空间</li>
</ul></li>
<li>Person若要通过编译，需要classes string，Date，Address的定义式
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;date.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;address.h&quot;</span></span></span><br></pre></td></tr></table></figure></li>
<li>但是，如此一来，Person定义文件和其含入文件形成了编译依存关系
<ul>
<li>如果这些头文件有一个被改变，或者这些头文件所依赖的其他文件有任何改变，那么每一个含入和使用Person
class的文件也必须重新编译 ## 编译依存性最小化 -- 接口与实现分离</li>
</ul></li>
<li>通过Handle classes和Interface
classes解除了接口和实现之间的耦合，降低了文件之间的编译依存性 ### pimpl
idiom -- <code>Handle class</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>   <span class="comment">// 标准程序组件不该被前置声明</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>   <span class="comment">// for shared_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PresonImpl</span>;   <span class="comment">// Person实现类的前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;         <span class="comment">// Person接口用到的classes的前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;PresonImpl&gt; pImpl_;</span><br><span class="line">&#125;;</span><br><span class="line">Person::<span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr)</span><br><span class="line">    : <span class="built_in">pImpl</span>(<span class="keyword">new</span> <span class="built_in">PresonImpl</span>(name, birthday, addr))</span><br><span class="line">    &#123;&#125;</span><br><span class="line"><span class="function">std::string <span class="title">Person::name</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pImpl-&gt;<span class="built_in">name</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Person的客户端完全与Date，Address以及Person的实现细目分开 ###
抽象基类(abstract base class、Interface class)</li>
<li>详细一一描述derived class的接口
<ul>
<li>一组pure virtual函数</li>
</ul></li>
<li>通常不带成员变量，也没有构造函数</li>
<li>只有一个virtual析构函数(见条款7) <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>客户必须以Person的pointers和references来撰写应用程序
<ul>
<li>除非Interface class修改，否则不用编译</li>
</ul></li>
<li>客户必须有办法为这种class创建新对象
<ul>
<li>工厂函数
<ul>
<li>返回指针指向动态分配所得的对象</li>
<li>往往在Interface class中声明为static <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;Person&gt; <span class="title">create</span><span class="params">(<span class="type">const</span> std::string&amp; name, </span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> Date&amp; birthday, </span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> Address&amp; addr)</span></span>; <span class="comment">// why shared_ptr;见条款18</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 客户如此使用</span></span><br><span class="line">std::string; name, </span><br><span class="line">Date dateodBirth, </span><br><span class="line">Address address;</span><br><span class="line">...</span><br><span class="line"><span class="function">std::shared_ptr&lt;Person&gt; <span class="title">pp</span><span class="params">(Person::create(name, dateodBirth, address))</span></span>;</span><br><span class="line">...</span><br><span class="line">std::cout &lt;&lt; pp-&gt;<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li>当然，支持Interface
class接口的那个具象类(<code>concrete class</code>)必须被定义出来
<ul>
<li>一切都在virtual构造函数的实现码所在文件内秘密发生 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealPerson</span> : <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RealPerson</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr)</span><br><span class="line">        : <span class="built_in">theName</span>(name), <span class="built_in">theBirthDate</span>(birthday), <span class="built_in">theAddress</span>(addr)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">RealPerson</span>() &#123;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;    </span><br><span class="line">    Date theBirthDate;      </span><br><span class="line">    Address theAddress;     </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> std::shared_ptr&lt;Person&gt; <span class="title">Person::create</span><span class="params">(<span class="type">const</span> std::string&amp; name, </span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">const</span> Date&amp; birthday, </span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">const</span> Address&amp; addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> <span class="built_in">RealPerson</span>(name, dateodBirth, addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>更现实的Person::create实现代码会创建不同的derived class ### 开销
#### Handle classes</li>
</ul></li>
</ul>
<ol type="1">
<li>成员函数必须通过implementation pointer取得对象数据，
<ul>
<li>每次访问增加一次间接性</li>
</ul></li>
<li>每个对象的内存消耗多一个implementation pointer的大小</li>
<li>implementation pointer必须初始化，指向动态分配的implementation内存
<ul>
<li>涉及到动态分配 #### Interface class</li>
</ul></li>
<li>virtual函数带来间接跳跃(见条款7)</li>
<li>派生类对象有一个vptr(见条款7) ### 本质</li>
</ol>
<ul>
<li>声明的依存性 替换 定义的依存性</li>
<li>尽量让头文件自我满足，做不到则让它与其他头文件内的声明式而非定义式相依
## 方法 ### 如果使用object
reference/pointer可以完成任务，就不要使用object</li>
<li>前者仅需声明，后者需要定义 ###
如果能够，尽量用class声明式替换class定义式</li>
<li>注意，当声明一个函数而它用到某个class的定义时，并不需要该class的定义
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;                         <span class="comment">// class声明式</span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span></span>;                       <span class="comment">// 没问题，这里并不需要Date的定义式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>;</span><br></pre></td></tr></table></figure> ### 为声明式和定义式提供不同的头文件</li>
<li>程序库客户应该总是#include一个声明文件而非前置声明若干class或函数
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;datafw.h&quot;</span>  <span class="comment">// 这个头文件内声明单未定义class Date</span></span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span></span>;                      </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>只含声明式的头文件名为"datefw.h",命名方式取法C++标准库的<iosfwd>
<ul>
<li><iosfwd>内含iostream各组件的声明式，其定义则分布在相应的头文件，包括<sstream>,<streambuf>,<fstream>,<iostream></li>
</ul></li>
<li>此方法同样适用于template
<ul>
<li>export关键字同样可以，但很少使用</li>
</ul></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/zyhjy/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/zyhjy/">1</a><span class="space">&hellip;</span><a class="page-number" href="/zyhjy/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/zyhjy/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/zyhjy/page/8/">8</a><a class="extend next" rel="next" href="/zyhjy/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yuhang Zhang"
      src="/zyhjy/images/zyhjy.png">
  <p class="site-author-name" itemprop="name">Yuhang Zhang</p>
  <div class="site-description" itemprop="description">爱小雅，爱生活，爱物理!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/zyhjy/archives/">
        
          <span class="site-state-item-count">80</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/zyhjy/categories/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/zyhjy/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/zyhjy/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuhang Zhang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">439k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">12:12</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/zyhjy/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>

<script src="/zyhjy/js/utils.js"></script>


<script src="/zyhjy/js/schemes/pisces.js"></script>


<script src="/zyhjy/js/next-boot.js"></script>




  




  
<script src="/zyhjy/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>


</body>
</html>
