<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
<meta name="referrer" content="no-referrer">
  <link rel="apple-touch-icon" sizes="180x180" href="/zyhjy/images/relativity128.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/zyhjy/images/relativity32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/zyhjy/images/relativity16.png">
  <link rel="mask-icon" href="/zyhjy/images/logo.svg" color="#222">

<link rel="stylesheet" href="/zyhjy/css/main.css">

<link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css?family=Comic Sans MS:300,300italic,400,400italic,700,700italic|Noto Serif SC:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/zyhjy/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zyh-eric.gitee.io","root":"/zyhjy/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="爱小雅，爱生活，爱物理!">
<meta property="og:type" content="website">
<meta property="og:title" content="ZYHJY">
<meta property="og:url" content="https://zyh-eric.gitee.io/zyhjy/page/4/">
<meta property="og:site_name" content="ZYHJY">
<meta property="og:description" content="爱小雅，爱生活，爱物理!">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yuhang Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zyh-eric.gitee.io/zyhjy/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>ZYHJY</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-J17VP3T2B4"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-J17VP3T2B4');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/zyhjy/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ZYHJY</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/zyhjy/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/zyhjy/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/zyhjy/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/zyhjy/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/zyhjy/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2023/05/19/Arrch64%20MMU/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2023/05/19/Arrch64%20MMU/" class="post-title-link" itemprop="url">Arrch64 CPU Structure</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-19 20:45:50" itemprop="dateCreated datePublished" datetime="2023-05-19T20:45:50+08:00">2023-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:50" itemprop="dateModified" datetime="2023-07-30T18:15:50+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/Qemu/" itemprop="url" rel="index"><span itemprop="name">Qemu</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="the-memory-management-unit">The Memory Management Unit</h1>
<p>内存管理单元（Memory Management
Unit，MMU）的一个重要功能是使系统能够运行多个任务，这些任务作为独立的程序在它们自己的私有虚拟内存空间中运行。它们不需要知道系统的物理内存映射，也就是硬件实际使用的地址，或者其他可能同时执行的程序。</p>
<p>您可以为每个程序使用相同的虚拟内存地址空间。即使物理内存是碎片化的，您也可以使用连续的虚拟内存映射。这个虚拟地址空间与系统中实际的物理内存映射是分离的。您可以编写、编译和链接应用程序以在虚拟内存空间中运行。</p>
<p><a
target="_blank" rel="noopener" href="https://developer.arm.com/documentation/den0024/a/The-Memory-Management-Unit?lang=en#BABBEBII">图12.2</a>展示了一个示例系统，说明了内存的虚拟视图和物理视图。在单个系统中，不同的处理器和设备可能具有不同的虚拟和物理地址映射。操作系统会对MMU进行编程，以在这两个内存视图之间进行转换。</p>
<p>为了实现这一点，在虚拟内存系统中的硬件必须提供地址转换，即将处理器发出的虚拟地址转换为主内存中的物理地址。</p>
<p>虚拟地址是您、编译器和链接器在将代码放入内存时使用的地址。物理地址是实际硬件系统使用的地址。</p>
<p>MMU使用虚拟地址的最高有效位来索引翻译表中的条目，并确定正在访问的块。MMU将代码和数据的虚拟地址转换为实际系统中的物理地址。这种转换是在硬件中自动进行的，并且对应用程序是透明的。除了地址转换之外，MMU还控制每个内存区域的内存访问权限、内存排序和缓存策略。</p>
<h2 id="the-translation-lookaside-buffer">The Translation Lookaside
Buffer</h2>
<p>Translation Lookaside Buffer
(TLB)是MMU中最近访问的页面转换的高速缓存。对于处理器执行的每个内存访问，MMU都会检查TLB中是否缓存了相应的转换。如果请求的地址转换在TLB中命中，地址的转换结果将立即可用。</p>
<p>每个TLB条目通常不仅包含物理地址和虚拟地址，还包括诸如内存类型、缓存策略、访问权限、地址空间ID（ASID）和虚拟机ID（VMID）等属性。如果TLB中没有包含处理器发出的虚拟地址的有效转换，即TLB未命中，就会执行外部的转换表查找或遍历。MMU内的专用硬件使其能够读取内存中的转换表。新加载的转换结果可以被缓存到TLB中，以备后续使用，如果转换表的遍历过程不会导致页面错误。TLB的具体结构在不同的ARM处理器实现之间会有所不同。</p>
<p>如果操作系统修改了可能缓存在TLB中的转换条目，那么操作系统有责任使这些过时的TLB条目失效。</p>
<h2
id="separation-of-kernel-and-application-virtual-address-spaces">Separation
of kernel and application Virtual Address spaces</h2>
<p>操作系统通常会同时运行多个应用程序或任务。每个应用程序都有自己独特的转换表集合，并且内核在切换上下文时会从一个转换表切换到另一个。然而，大部分内存系统只被内核使用，并具有固定的虚拟到物理地址映射，其中转换表条目很少改变。ARMv8架构提供了一些功能来有效地处理这一要求。</p>
<p>转换表的基地址在Translation Table Base Registers
(TTBR0_EL1)和(TTBR1_EL1)中指定。当VA的高位全为0时，选择TTBR0指向的转换表。当VA的高位全部设置为1时，选择TTBR1指向的转换表。您可以启用VA标记以排除检查过程中的前8位。</p>
<p>处理器从指令获取或数据访问的虚拟地址是64位。然而，在48位物理地址内存映射中，您必须同时映射上述两个定义的区域。</p>
<p>EL2和EL3都有一个TTBR0，但没有TTBR1。这意味着：</p>
<p>如果EL2正在使用AArch64，它只能使用范围为0x0至0x0000FFFF_FFFFFFFF的虚拟地址。</p>
<p>如果EL3正在使用AArch64，它只能使用范围为0x0至0x0000FFFF_FFFFFFFF的虚拟地址。</p>
<p><a
target="_blank" rel="noopener" href="https://developer.arm.com/documentation/den0024/a/The-Memory-Management-Unit/Separation-of-kernel-and-application-Virtual-Address-spaces?lang=en#CDDFFEJB">图12.4</a>显示了内核空间如何映射到内存的最高有效区域，每个应用程序关联的虚拟地址空间映射到内存的最低有效区域。然而，这两者都映射到一个更小的物理地址空间。</p>
<p>TCR_EL1是转换控制寄存器，它定义了需要进行检查的最高有效位的确切数量。TCR_EL1包含了大小字段T0SZ[5:0]和T1SZ[5:0]。字段中的整数表示必须是全0或全1的最高有效位的数量。这些字段有指定的最小和最大值，这些值随着颗粒大小和起始表级别的不同而变化。因此，在所有系统中，您必须始终使用两个转换表，并且至少需要两个转换表。即使是一个没有操作系统的简单裸机系统，也需要一个包含错误条目的小型上层表。</p>
<h2 id="context-switching-上下文切换">Context switching 上下文切换</h2>
<p>实现ARMv8-A架构的处理器通常用于运行具有许多并发应用程序或任务的复杂操作系统的系统中。每个进程在物理内存中都有自己独特的转换表。当一个应用程序启动时，操作系统会为其分配一组转换表条目，将应用程序使用的代码和数据映射到物理内存。这些表可以随后由内核进行修改，例如映射额外的空间，并在应用程序不再运行时被删除。</p>
<p>因此，内存系统中可能存在多个任务。内核调度程序定期将执行从一个任务转移至另一个任务。这被称为上下文切换，要求内核保存与进程关联的所有执行状态，并恢复要运行的进程的状态。内核还切换转换表条目到下一个要运行的进程的条目。当前未运行的任务的内存完全受到正在运行的任务的保护。</p>
<p>实际上需要保存和恢复的内容因不同操作系统而异，但通常进程上下文切换包括保存或恢复以下一些或全部元素：
- 通用寄存器 X0-X30。 - 高级SIMD和浮点寄存器 V0-V31。 - 一些状态寄存器。
- TTBR0_EL1 和 TTBR0。 - 线程进程ID（TPIDxxx）寄存器。 -
地址空间ID（ASID）。</p>
<p>对于EL0和EL1，有两个转换表。TTBR0_EL1为虚拟地址空间底部（通常是应用程序空间）提供转换，而TTBR1_EL1覆盖虚拟地址空间的顶部（通常是内核空间）。这种分割意味着操作系统映射不必复制到每个任务的转换表中。</p>
<p>转换表条目包含一个非全局（nG）位。如果nG位设置为特定页面，则与特定任务或应用程序相关联。如果该位标记为0，则条目是全局的，适用于所有任务。</p>
<p>对于非全局条目，在更新TLB并将条目标记为非全局时，除了常规转换信息之外，还在TLB条目中存储一个值。该值称为地址空间ID（ASID），由操作系统分配给每个单独的任务。仅当当前ASID与存储在条目中的ASID匹配时，后续的TLB查找才与该条目匹配。这允许多个有效的TLB条目存在于标记为非全局的特定页面中，但具有不同的ASID值。换句话说，我们在上下文切换时不一定需要刷新TLB。</p>
<p>在AArch64中，ASID值可以指定为8位或16位的值，由TCR_EL1.AS位控制。当前ASID值在TTBR0_EL1或TTBR1_EL1中指定。TCR_EL1控制哪个TTBR持有ASID，但通常是TTBR0_EL1，因为它对应应用程序空间。</p>
<p>注意 -
将当前ASID值存储在转换表寄存器中意味着您可以在一条指令中原子地修改转换表和ASID。与ARMv7-A架构相比，这简化了更改表和ASID的过程。</p>
<p>此外，ARMv8-A架构提供了用于操作系统软件的线程ID寄存器。这些寄存器在硬件上没有特殊意义，通常由线程库用作每个线程数据的基指针。这通常称为线程本地存储（TLS）。例如，pthread库使用了这个特性，并包括以下寄存器：
- 用户读写线程ID寄存器（TPIDR_EL0）。 -
用户只读线程ID寄存器（TPIDRRO_EL0）。 -
线程ID寄存器，仅特权访问（TPIDR_EL1）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">uint64_t</span> c14_cntfrq; <span class="comment">/* Counter Frequency register */</span></span><br><span class="line">        <span class="type">uint64_t</span> c14_cntkctl; <span class="comment">/* Timer Control register */</span></span><br><span class="line">        <span class="type">uint32_t</span> cnthctl_el2; <span class="comment">/* Counter/Timer Hyp Control register */</span></span><br><span class="line">        <span class="type">uint64_t</span> cntvoff_el2; <span class="comment">/* Counter Virtual Offset register */</span></span><br><span class="line">        ARMGenericTimer c14_timer[NUM_GTIMERS];</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* Stores the architectural value of the counter *the last time it was</span></span><br><span class="line"><span class="comment">         * updated* by pmccntr_op_start. Accesses should always be surrounded</span></span><br><span class="line"><span class="comment">         * by pmccntr_op_start/pmccntr_op_finish to guarantee the latest</span></span><br><span class="line"><span class="comment">         * architecturally-correct value is being read/set.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">uint64_t</span> c15_ccnt;</span><br><span class="line">        <span class="comment">/* Stores the delta between the architectural value and the underlying</span></span><br><span class="line"><span class="comment">         * cycle count during normal operation. It is used to update c15_ccnt</span></span><br><span class="line"><span class="comment">         * to be the correct architectural value before accesses. During</span></span><br><span class="line"><span class="comment">         * accesses, c15_ccnt_delta contains the underlying count being used</span></span><br><span class="line"><span class="comment">         * for the access, after which it reverts to the delta value in</span></span><br><span class="line"><span class="comment">         * pmccntr_op_finish.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">uint64_t</span> c15_ccnt_delta;</span><br><span class="line">        <span class="type">uint64_t</span> c14_pmevcntr[<span class="number">31</span>];</span><br><span class="line">        <span class="type">uint64_t</span> c14_pmevcntr_delta[<span class="number">31</span>];</span><br><span class="line">        <span class="type">uint64_t</span> c14_pmevtyper[<span class="number">31</span>];</span><br><span class="line">        <span class="type">uint64_t</span> pmccfiltr_el0; <span class="comment">/* Performance Monitor Filter Register */</span></span><br><span class="line">    &#125; cp15;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2023/05/18/Qemu%20TCG%20IR/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2023/05/18/Qemu%20TCG%20IR/" class="post-title-link" itemprop="url">Qemu TCG IR</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-18 20:46:50" itemprop="dateCreated datePublished" datetime="2023-05-18T20:46:50+08:00">2023-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:50" itemprop="dateModified" datetime="2023-07-30T18:15:50+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/Qemu/" itemprop="url" rel="index"><span itemprop="name">Qemu</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>26 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1
id="tcg-intermediate-representation-tcgtiny-code-generator中间表示">TCG
Intermediate Representation / TCG（Tiny Code Generator）中间表示</h1>
<h2 id="introduction-介绍">Introduction / 介绍</h2>
<ul>
<li>TCG（Tiny Code
Generator）最初是作为一个C编译器的通用后端而开始的。它经过简化后用于QEMU。</li>
<li>它还源于由Paul Brook编写的QOP代码生成器。</li>
</ul>
<h2 id="definitions-定义">Definitions / 定义</h2>
<ul>
<li><p>TCG的<em>目标</em>是我们生成代码的架构。</p></li>
<li><p>它当然不同于QEMU的"目标"，QEMU的目标是被模拟的架构。</p></li>
<li><p>当TCG作为一个用于交叉编译的通用C后端开始时，假设TCG的目标可能与主机不同，尽管对于QEMU来说永远不会是这种情况。</p></li>
<li><p>在这个文档中，我们使用<em>guest</em>来指定我们正在模拟的架构；<em>target</em>始终指的是TCG的目标，也就是我们运行QEMU的机器。</p></li>
<li><p>具有<em>未定义行为</em>的操作可能导致崩溃。</p></li>
<li><p>具有<em>未指定行为</em>的操作不会崩溃。然而，结果可能是多种可能性之一，因此可能被视为<em>未定义的结果</em>。</p></li>
</ul>
<h2 id="basic-blocks-基本块">Basic Blocks / 基本块</h2>
<ul>
<li><p>TCG的<em>基本块</em>是一个单入口、多出口的区域，对应于一系列指令，并以标签或任何跳转指令结尾。</p></li>
<li><p>TCG的<em>扩展基本块</em>是一个单入口、多出口的区域，对应于一系列指令，并以标签或无条件跳转指令结尾。</p></li>
<li><p>具体来说，扩展基本块是由零个或多个条件跳转指令的顺序连接起来的一系列基本块。</p></li>
</ul>
<h2 id="operations-操作">Operations / 操作</h2>
<ul>
<li><p>在TCG中，TCG指令或操作（ops）作用于TCG变量，它们都具有强类型。</p></li>
<li><p>每个指令都有固定数量的输出变量操作数、输入变量操作数和常量操作数。</p></li>
<li><p>向量指令具有指定向量中元素大小的字段。需要注意的例外是调用指令，它具有可变数量的输出和输入。</p></li>
<li><p>在文本形式中，输出操作数通常首先出现，然后是输入操作数，最后是常量操作数。</p></li>
<li><p>指令名称中包含输出类型。</p></li>
<li><p>常量以'$'前缀表示。</p></li>
<li><p>例如：</p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_i32 t0, t1, t2    /* (t0 &lt;- t1 + t2) */</span><br></pre></td></tr></table></figure>
<ul>
<li>上述示例中，<code>add_i32</code>表示整数相加的指令，<code>t0</code>是输出变量，<code>t1</code>和<code>t2</code>是输入变量。指令执行后，<code>t0</code>的值将等于<code>t1</code>和<code>t2</code>的和。</li>
</ul>
<h1 id="variables">Variables</h1>
<ul>
<li><p><code>TEMP_FIXED</code></p>
<p>There is one TCG <em>fixed global</em> variable,
<code>cpu_env</code>, which is live in all translation blocks, and holds
a pointer to <code>CPUArchState</code>. This variable is held in a host
cpu register at all times in all translation blocks.</p></li>
<li><p><code>TEMP_GLOBAL</code></p>
<p>A TCG <em>global</em> is a variable which is live in all translation
blocks, and corresponds to memory location that is within
<code>CPUArchState</code>. These may be specified as an offset from
<code>cpu_env</code>, in which case they are called <em>direct
globals</em>, or may be specified as an offset from a direct global, in
which case they are called <em>indirect globals</em>. Even indirect
globals should still reference memory within <code>CPUArchState</code>.
All TCG globals are defined during <code>TCGCPUOps.initialize</code>,
before any translation blocks are generated.</p></li>
<li><p><code>TEMP_CONST</code></p>
<p>A TCG <em>constant</em> is a variable which is live throughout the
entire translation block, and contains a constant value. These variables
are allocated on demand during translation and are hashed so that there
is exactly one variable holding a given value.</p></li>
<li><p><code>TEMP_TB</code></p>
<p>A TCG <em>translation block temporary</em> is a variable which is
live throughout the entire translation block, but dies on any exit.
These temporaries are allocated explicitly during translation.</p></li>
<li><p><code>TEMP_EBB</code></p>
<p>A TCG <em>extended basic block temporary</em> is a variable which is
live throughout an extended basic block, but dies on any exit. These
temporaries are allocated explicitly during translation.</p></li>
</ul>
<h1 id="types">Types</h1>
<ul>
<li><p><code>TCG_TYPE_I32</code></p>
<p>A 32-bit integer.</p></li>
<li><p><code>TCG_TYPE_I64</code></p>
<p>A 64-bit integer. For 32-bit hosts, such variables are split into a
pair of variables with <code>type=TCG_TYPE_I32</code> and
<code>base_type=TCG_TYPE_I64</code>. The <code>temp_subindex</code> for
each indicates where it falls within the host-endian
representation.</p></li>
<li><p><code>TCG_TYPE_PTR</code></p>
<p>An alias for <code>TCG_TYPE_I32</code> or <code>TCG_TYPE_I64</code>,
depending on the size of a pointer for the host.</p></li>
<li><p><code>TCG_TYPE_REG</code></p>
<p>An alias for <code>TCG_TYPE_I32</code> or <code>TCG_TYPE_I64</code>,
depending on the size of the integer registers for the host. This may be
larger than <code>TCG_TYPE_PTR</code> depending on the host
ABI.</p></li>
<li><p><code>TCG_TYPE_I128</code></p>
<p>A 128-bit integer. For all hosts, such variables are split into a
number of variables with <code>type=TCG_TYPE_REG</code> and
<code>base_type=TCG_TYPE_I128</code>. The <code>temp_subindex</code> for
each indicates where it falls within the host-endian
representation.</p></li>
<li><p><code>TCG_TYPE_V64</code></p>
<p>A 64-bit vector. This type is valid only if the TCG target sets
<code>TCG_TARGET_HAS_v64</code>.</p></li>
<li><p><code>TCG_TYPE_V128</code></p>
<p>A 128-bit vector. This type is valid only if the TCG target sets
<code>TCG_TARGET_HAS_v128</code>.</p></li>
<li><p><code>TCG_TYPE_V256</code></p>
<p>A 256-bit vector. This type is valid only if the TCG target sets
<code>TCG_TARGET_HAS_v256</code>.</p></li>
</ul>
<h2 id="helpers-辅助函数">Helpers / 辅助函数</h2>
<ul>
<li><p>在TCG中，辅助函数（helpers）通过在特定于客户机的<code>helper.h</code>中注册，并处理生成<code>tcg_gen_helper_*</code>函数。</p></li>
<li><p>借助这些函数，可以调用接受i32、i64、i128或指针类型的函数。</p></li>
<li><p>默认情况下，在调用辅助函数之前，所有全局变量都会存储在其规范位置上。</p></li>
<li><p>默认情况下，辅助函数允许修改CPU状态（包括由tcg全局变量表示的状态）或引发异常。</p></li>
<li><p>可以使用以下函数修饰符来覆盖默认行为：</p>
<ul>
<li><code>TCG_CALL_NO_WRITE_GLOBALS</code>
<ul>
<li>辅助函数不会修改任何全局变量，但可能会读取它们。</li>
<li>在调用辅助函数之前，全局变量将保存在其规范位置，但在调用后不需要重新加载。</li>
</ul></li>
<li><code>TCG_CALL_NO_READ_GLOBALS</code>
<ul>
<li>辅助函数不会直接或通过异常读取全局变量。</li>
<li>在调用辅助函数之前，它们将不会保存到其规范位置。</li>
<li>这意味着它隐含了<code>TCG_CALL_NO_WRITE_GLOBALS</code>。</li>
</ul></li>
<li><code>TCG_CALL_NO_SIDE_EFFECTS</code>
<ul>
<li>如果没有使用返回值，则可以删除对辅助函数的调用。这意味着它不能修改任何CPU状态，也不能引发异常。</li>
</ul></li>
</ul></li>
</ul>
<h2 id="code-optimizations">Code Optimizations</h2>
<ul>
<li><p>在生成指令时，可以依赖至少以下优化：</p>
<ul>
<li>单个指令会进行简化，例如： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and_i32 t0, t0, $0xffffffff</span><br></pre></td></tr></table></figure> 会被抑制。</li>
</ul></li>
<li><p>在基本块级别进行寄存器活跃性分析。</p></li>
<li><p>这些信息用于消除从一个无用变量到另一个无用变量的移动操作。</p></li>
<li><p>还可以用于删除计算无用结果的指令。</p></li>
<li><p>这对于QEMU中的条件代码优化特别有用。</p>
<ul>
<li>在下面的示例中： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_i32 t0, t1, t2</span><br><span class="line">add_i32 t0, t0, $1</span><br><span class="line">mov_i32 t0, $1</span><br></pre></td></tr></table></figure> 只会保留最后一条指令。</li>
</ul></li>
</ul>
<h2 id="instruction-reference">Instruction Reference</h2>
<h3 id="function-call">Function call</h3>
<p>.. list-table::</p>
<ul>
<li><ul>
<li><p>call <em><ret></em> <em><params></em> ptr</p></li>
<li><div class="line-block"> call function 'ptr' (pointer type)<br />
<br />
 <em><ret></em> optional 32 bit or 64 bit return value<br />
 <em><params></em> optional 32 bit or 64 bit parameters</div></li>
</ul></li>
</ul>
<h3 id="jumpslabels">Jumps/Labels</h3>
<p>.. list-table::</p>
<ul>
<li><ul>
<li><p>set_label $label</p></li>
<li><div class="line-block">Define label 'label' at the current program
point.</div></li>
</ul></li>
<li><ul>
<li><p>br $label</p></li>
<li><div class="line-block">Jump to label.</div></li>
</ul></li>
<li><ul>
<li><p>brcond_i32/i64 <em>t0</em>, <em>t1</em>, <em>cond</em>,
<em>label</em></p></li>
<li><div class="line-block">Conditional jump if <em>t0</em>
<em>cond</em> <em>t1</em> is true. <em>cond</em> can be:<br />
<br />
  <code>TCG_COND_EQ</code><br />
  <code>TCG_COND_NE</code><br />
  <code>TCG_COND_LT /* signed */</code><br />
  <code>TCG_COND_GE /* signed */</code><br />
  <code>TCG_COND_LE /* signed */</code><br />
  <code>TCG_COND_GT /* signed */</code><br />
  <code>TCG_COND_LTU /* unsigned */</code><br />
  <code>TCG_COND_GEU /* unsigned */</code><br />
  <code>TCG_COND_LEU /* unsigned */</code><br />
  <code>TCG_COND_GTU /* unsigned */</code></div></li>
</ul></li>
</ul>
<h3 id="arithmetic">Arithmetic</h3>
<p>.. list-table::</p>
<ul>
<li><ul>
<li><p>add_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> +
<em>t2</em></div></li>
</ul></li>
<li><ul>
<li><p>sub_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> -
<em>t2</em></div></li>
</ul></li>
<li><ul>
<li><p>neg_i32/i64 <em>t0</em>, <em>t1</em></p></li>
<li><div class="line-block"><em>t0</em> = -<em>t1</em> (two's
complement)</div></li>
</ul></li>
<li><ul>
<li><p>mul_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> *
<em>t2</em></div></li>
</ul></li>
<li><ul>
<li><p>div_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> / <em>t2</em>
(signed)<br />
Undefined behavior if division by zero or overflow.</div></li>
</ul></li>
<li><ul>
<li><p>divu_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> / <em>t2</em>
(unsigned)<br />
Undefined behavior if division by zero.</div></li>
</ul></li>
<li><ul>
<li><p>rem_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> % <em>t2</em>
(signed)<br />
Undefined behavior if division by zero or overflow.</div></li>
</ul></li>
<li><ul>
<li><p>remu_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> % <em>t2</em>
(unsigned)<br />
Undefined behavior if division by zero.</div></li>
</ul></li>
</ul>
<h3 id="logical">Logical</h3>
<p>.. list-table::</p>
<ul>
<li><ul>
<li><p>and_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> &amp;
<em>t2</em></div></li>
</ul></li>
<li><ul>
<li><p>or_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> |
<em>t2</em></div></li>
</ul></li>
<li><ul>
<li><p>xor_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> ^
<em>t2</em></div></li>
</ul></li>
<li><ul>
<li><p>not_i32/i64 <em>t0</em>, <em>t1</em></p></li>
<li><div class="line-block"><em>t0</em> = ~ <em>t1</em></div></li>
</ul></li>
<li><ul>
<li><p>andc_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> &amp;
~ <em>t2</em></div></li>
</ul></li>
<li><ul>
<li><p>eqv_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = ~(<em>t1</em> ^ <em>t2</em>),
or equivalently, <em>t0</em> = <em>t1</em> ^ ~ <em>t2</em></div></li>
</ul></li>
<li><ul>
<li><p>nand_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = ~(<em>t1</em> &amp;
<em>t2</em>)</div></li>
</ul></li>
<li><ul>
<li><p>nor_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = ~(<em>t1</em> |
<em>t2</em>)</div></li>
</ul></li>
<li><ul>
<li><p>orc_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> |
~ <em>t2</em></div></li>
</ul></li>
<li><ul>
<li><p>clz_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> ? clz(<em>t1</em>)
: <em>t2</em></div></li>
</ul></li>
<li><ul>
<li><p>ctz_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> ? ctz(<em>t1</em>)
: <em>t2</em></div></li>
</ul></li>
<li><ul>
<li><p>ctpop_i32/i64 <em>t0</em>, <em>t1</em></p></li>
<li><div class="line-block"><em>t0</em> = number of bits set in
<em>t1</em><br />
<br />
With <em>ctpop</em> short for "count population", matching<br />
the function name used in
<code>include/qemu/host-utils.h</code>.</div></li>
</ul></li>
</ul>
<h3 id="shiftsrotates">Shifts/Rotates</h3>
<p>.. list-table::</p>
<ul>
<li><ul>
<li><p>shl_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> &lt;&lt;
<em>t2</em><br />
Unspecified behavior if <em>t2</em> &lt; 0 or <em>t2</em> &gt;= 32 (resp
64)</div></li>
</ul></li>
<li><ul>
<li><p>shr_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> &gt;&gt;
<em>t2</em> (unsigned)<br />
Unspecified behavior if <em>t2</em> &lt; 0 or <em>t2</em> &gt;= 32 (resp
64)</div></li>
</ul></li>
<li><ul>
<li><p>sar_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em> &gt;&gt;
<em>t2</em> (signed)<br />
Unspecified behavior if <em>t2</em> &lt; 0 or <em>t2</em> &gt;= 32 (resp
64)</div></li>
</ul></li>
<li><ul>
<li><p>rotl_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block">Rotation of <em>t2</em> bits to the
left<br />
Unspecified behavior if <em>t2</em> &lt; 0 or <em>t2</em> &gt;= 32 (resp
64)</div></li>
</ul></li>
<li><ul>
<li><p>rotr_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block">Rotation of <em>t2</em> bits to the
right.<br />
Unspecified behavior if <em>t2</em> &lt; 0 or <em>t2</em> &gt;= 32 (resp
64)</div></li>
</ul></li>
</ul>
<h3 id="misc">Misc</h3>
<p>.. list-table::</p>
<ul>
<li><ul>
<li><p>mov_i32/i64 <em>t0</em>, <em>t1</em></p></li>
<li><div class="line-block"><em>t0</em> = <em>t1</em><br />
Move <em>t1</em> to <em>t0</em> (both operands must have the same
type).</div></li>
</ul></li>
<li><ul>
<li><p>ext8s_i32/i64 <em>t0</em>, <em>t1</em></p>
<p>ext8u_i32/i64 <em>t0</em>, <em>t1</em></p>
<p>ext16s_i32/i64 <em>t0</em>, <em>t1</em></p>
<p>ext16u_i32/i64 <em>t0</em>, <em>t1</em></p>
<p>ext32s_i64 <em>t0</em>, <em>t1</em></p>
<p>ext32u_i64 <em>t0</em>, <em>t1</em></p></li>
<li><div class="line-block">8, 16 or 32 bit sign/zero extension (both
operands must have the same type)</div></li>
</ul></li>
<li><ul>
<li><p>bswap16_i32/i64 <em>t0</em>, <em>t1</em>, <em>flags</em></p></li>
<li><div class="line-block">16 bit byte swap on the low bits of a 32/64
bit input.<br />
<br />
If <em>flags</em> &amp; <code>TCG_BSWAP_IZ</code>, then <em>t1</em> is
known to be zero-extended from bit 15.<br />
If <em>flags</em> &amp; <code>TCG_BSWAP_OZ</code>, then <em>t0</em> will
be zero-extended from bit 15.<br />
If <em>flags</em> &amp; <code>TCG_BSWAP_OS</code>, then <em>t0</em> will
be sign-extended from bit 15.<br />
<br />
If neither <code>TCG_BSWAP_OZ</code> nor <code>TCG_BSWAP_OS</code> are
set, then the bits of <em>t0</em> above bit 15 may contain any
value.</div></li>
</ul></li>
<li><ul>
<li><p>bswap32_i64 <em>t0</em>, <em>t1</em>, <em>flags</em></p></li>
<li><div class="line-block">32 bit byte swap on a 64-bit value. The
flags are the same as for bswap16, except they apply from bit 31 instead
of bit 15.</div></li>
</ul></li>
<li><ul>
<li><p>bswap32_i32 <em>t0</em>, <em>t1</em>, <em>flags</em></p>
<p>bswap64_i64 <em>t0</em>, <em>t1</em>, <em>flags</em></p></li>
<li><div class="line-block">32/64 bit byte swap. The flags are ignored,
but still present for consistency with the other bswap
opcodes.</div></li>
</ul></li>
<li><ul>
<li><p>discard_i32/i64 <em>t0</em></p></li>
<li><div class="line-block">Indicate that the value of <em>t0</em> won't
be used later. It is useful to force dead code elimination.</div></li>
</ul></li>
<li><ul>
<li><p>deposit_i32/i64 <em>dest</em>, <em>t1</em>, <em>t2</em>,
<em>pos</em>, <em>len</em></p></li>
<li><div class="line-block">Deposit <em>t2</em> as a bitfield into
<em>t1</em>, placing the result in <em>dest</em>.<br />
<br />
The bitfield is described by <em>pos</em>/<em>len</em>, which are
immediate values:<br />
<br />
    <em>len</em> - the length of the bitfield<br />
    <em>pos</em> - the position of the first bit, counting from the
LSB<br />
<br />
For example, "deposit_i32 dest, t1, t2, 8, 4" indicates a 4-bit field at
bit 8. This operation would be equivalent to<br />
<br />
    <em>dest</em> = (<em>t1</em> &amp; ~0x0f00) | ((<em>t2</em> &lt;&lt;
8) &amp; 0x0f00)</div></li>
</ul></li>
<li><ul>
<li><p>extract_i32/i64 <em>dest</em>, <em>t1</em>, <em>pos</em>,
<em>len</em></p>
<p>sextract_i32/i64 <em>dest</em>, <em>t1</em>, <em>pos</em>,
<em>len</em></p></li>
<li><div class="line-block">Extract a bitfield from <em>t1</em>, placing
the result in <em>dest</em>.<br />
<br />
The bitfield is described by <em>pos</em>/<em>len</em>, which are
immediate values, as above for deposit. For extract_<em>, the result
will be extended to the left with zeros; for sextract_</em>, the result
will be extended to the left with copies of the bitfield sign bit at
<em>pos</em> + <em>len</em> - 1.<br />
<br />
For example, "sextract_i32 dest, t1, 8, 4" indicates a 4-bit field at
bit 8. This operation would be equivalent to<br />
<br />
   <em>dest</em> = (<em>t1</em> &lt;&lt; 20) &gt;&gt; 28<br />
<br />
(using an arithmetic right shift).</div></li>
</ul></li>
<li><ul>
<li><p>extract2_i32/i64 <em>dest</em>, <em>t1</em>, <em>t2</em>,
<em>pos</em></p></li>
<li><div class="line-block">For N = {32,64}, extract an N-bit quantity
from the concatenation of <em>t2</em>:<em>t1</em>, beginning at
<em>pos</em>. The tcg_gen_extract2_{i32,i64} expander accepts 0 &lt;=
<em>pos</em> &lt;= N as inputs. The backend code generator will not see
either 0 or N as inputs for these opcodes.</div></li>
</ul></li>
<li><ul>
<li><p>extrl_i64_i32 <em>t0</em>, <em>t1</em></p></li>
<li><div class="line-block">For 64-bit hosts only, extract the low
32-bits of input <em>t1</em> and place it into 32-bit output
<em>t0</em>. Depending on the host, this may be a simple move, or may
require additional canonicalization.</div></li>
</ul></li>
<li><ul>
<li><p>extrh_i64_i32 <em>t0</em>, <em>t1</em></p></li>
<li><div class="line-block">For 64-bit hosts only, extract the high
32-bits of input <em>t1</em> and place it into 32-bit output
<em>t0</em>. Depending on the host, this may be a simple shift, or may
require additional canonicalization.</div></li>
</ul></li>
</ul>
<h3 id="conditional-moves">Conditional moves</h3>
<p>.. list-table::</p>
<ul>
<li><ul>
<li><p>setcond_i32/i64 <em>dest</em>, <em>t1</em>, <em>t2</em>,
<em>cond</em></p></li>
<li><div class="line-block"><em>dest</em> = (<em>t1</em> <em>cond</em>
<em>t2</em>)<br />
<br />
Set <em>dest</em> to 1 if (<em>t1</em> <em>cond</em> <em>t2</em>) is
true, otherwise set to 0.</div></li>
</ul></li>
<li><ul>
<li><p>movcond_i32/i64 <em>dest</em>, <em>c1</em>, <em>c2</em>,
<em>v1</em>, <em>v2</em>, <em>cond</em></p></li>
<li><div class="line-block"><em>dest</em> = (<em>c1</em> <em>cond</em>
<em>c2</em> ? <em>v1</em> : <em>v2</em>)<br />
<br />
Set <em>dest</em> to <em>v1</em> if (<em>c1</em> <em>cond</em>
<em>c2</em>) is true, otherwise set to <em>v2</em>.</div></li>
</ul></li>
</ul>
<h3 id="type-conversions">Type conversions</h3>
<p>.. list-table::</p>
<ul>
<li><ul>
<li><p>ext_i32_i64 <em>t0</em>, <em>t1</em></p></li>
<li><div class="line-block">Convert <em>t1</em> (32 bit) to <em>t0</em>
(64 bit) and does sign extension</div></li>
</ul></li>
<li><ul>
<li><p>extu_i32_i64 <em>t0</em>, <em>t1</em></p></li>
<li><div class="line-block">Convert <em>t1</em> (32 bit) to <em>t0</em>
(64 bit) and does zero extension</div></li>
</ul></li>
<li><ul>
<li><p>trunc_i64_i32 <em>t0</em>, <em>t1</em></p></li>
<li><div class="line-block">Truncate <em>t1</em> (64 bit) to <em>t0</em>
(32 bit)</div></li>
</ul></li>
<li><ul>
<li><p>concat_i32_i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block">Construct <em>t0</em> (64-bit) taking the
low half from <em>t1</em> (32 bit) and the high half from <em>t2</em>
(32 bit).</div></li>
</ul></li>
<li><ul>
<li><p>concat32_i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block">Construct <em>t0</em> (64-bit) taking the
low half from <em>t1</em> (64 bit) and the high half from <em>t2</em>
(64 bit).</div></li>
</ul></li>
</ul>
<h3 id="loadstore">Load/Store</h3>
<p>.. list-table::</p>
<ul>
<li><ul>
<li><p>ld_i32/i64 <em>t0</em>, <em>t1</em>, <em>offset</em></p>
<p>ld8s_i32/i64 <em>t0</em>, <em>t1</em>, <em>offset</em></p>
<p>ld8u_i32/i64 <em>t0</em>, <em>t1</em>, <em>offset</em></p>
<p>ld16s_i32/i64 <em>t0</em>, <em>t1</em>, <em>offset</em></p>
<p>ld16u_i32/i64 <em>t0</em>, <em>t1</em>, <em>offset</em></p>
<p>ld32s_i64 t0, <em>t1</em>, <em>offset</em></p>
<p>ld32u_i64 t0, <em>t1</em>, <em>offset</em></p></li>
<li><div class="line-block"><em>t0</em> = read(<em>t1</em> +
<em>offset</em>)<br />
<br />
Load 8, 16, 32 or 64 bits with or without sign extension from host
memory. <em>offset</em> must be a constant.</div></li>
</ul></li>
<li><ul>
<li><p>st_i32/i64 <em>t0</em>, <em>t1</em>, <em>offset</em></p>
<p>st8_i32/i64 <em>t0</em>, <em>t1</em>, <em>offset</em></p>
<p>st16_i32/i64 <em>t0</em>, <em>t1</em>, <em>offset</em></p>
<p>st32_i64 <em>t0</em>, <em>t1</em>, <em>offset</em></p></li>
<li><div class="line-block">write(<em>t0</em>, <em>t1</em> +
<em>offset</em>)<br />
<br />
Write 8, 16, 32 or 64 bits to host memory.</div></li>
</ul></li>
</ul>
<p>All this opcodes assume that the pointed host memory doesn't
correspond to a global. In the latter case the behaviour is
unpredictable.</p>
<h3 id="multiword-arithmetic-support">Multiword arithmetic support</h3>
<p>.. list-table::</p>
<ul>
<li><ul>
<li><p>add2_i32/i64 <em>t0_low</em>, <em>t0_high</em>, <em>t1_low</em>,
<em>t1_high</em>, <em>t2_low</em>, <em>t2_high</em></p>
<p>sub2_i32/i64 <em>t0_low</em>, <em>t0_high</em>, <em>t1_low</em>,
<em>t1_high</em>, <em>t2_low</em>, <em>t2_high</em></p></li>
<li><div class="line-block">Similar to add/sub, except that the
double-word inputs <em>t1</em> and <em>t2</em> are formed from two
single-word arguments, and the double-word output <em>t0</em> is
returned in two single-word outputs.</div></li>
</ul></li>
<li><ul>
<li><p>mulu2_i32/i64 <em>t0_low</em>, <em>t0_high</em>, <em>t1</em>,
<em>t2</em></p></li>
<li><div class="line-block">Similar to mul, except two unsigned inputs
<em>t1</em> and <em>t2</em> yielding the full double-word product
<em>t0</em>. The latter is returned in two single-word
outputs.</div></li>
</ul></li>
<li><ul>
<li><p>muls2_i32/i64 <em>t0_low</em>, <em>t0_high</em>, <em>t1</em>,
<em>t2</em></p></li>
<li><div class="line-block">Similar to mulu2, except the two inputs
<em>t1</em> and <em>t2</em> are signed.</div></li>
</ul></li>
<li><ul>
<li><p>mulsh_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p>
<p>muluh_i32/i64 <em>t0</em>, <em>t1</em>, <em>t2</em></p></li>
<li><div class="line-block">Provide the high part of a signed or
unsigned multiply, respectively.<br />
<br />
If mulu2/muls2 are not provided by the backend, the tcg-op generator can
obtain the same results by emitting a pair of opcodes, mul +
muluh/mulsh.</div></li>
</ul></li>
</ul>
<h3 id="memory-barrier-support">Memory Barrier support</h3>
<p>.. list-table::</p>
<ul>
<li><ul>
<li><p>mb <em>&lt;$arg&gt;</em></p></li>
<li><div class="line-block">Generate a target memory barrier instruction
to ensure memory ordering as being enforced by a corresponding guest
memory barrier instruction.<br />
<br />
The ordering enforced by the backend may be stricter than the ordering
required by the guest. It cannot be weaker. This opcode takes a constant
argument which is required to generate the appropriate barrier
instruction. The backend should take care to emit the target barrier
instruction only when necessary i.e., for SMP guests and when MTTCG is
enabled.<br />
<br />
The guest translators should generate this opcode for all guest
instructions which have ordering side effects.<br />
<br />
Please see :ref:<code>atomics-ref</code> for more information on memory
barriers.</div></li>
</ul></li>
</ul>
<h3 id="bit-guest-on-32-bit-host-support">64-bit guest on 32-bit host
support</h3>
<p>The following opcodes are internal to TCG. Thus they are to be
implemented by 32-bit host code generators, but are not to be emitted by
guest translators. They are emitted as needed by inline functions within
<code>tcg-op.h</code>.</p>
<p>.. list-table::</p>
<ul>
<li><ul>
<li><p>brcond2_i32 <em>t0_low</em>, <em>t0_high</em>, <em>t1_low</em>,
<em>t1_high</em>, <em>cond</em>, <em>label</em></p></li>
<li><div class="line-block">Similar to brcond, except that the 64-bit
values <em>t0</em> and <em>t1</em> are formed from two 32-bit
arguments.</div></li>
</ul></li>
<li><ul>
<li><p>setcond2_i32 <em>dest</em>, <em>t1_low</em>, <em>t1_high</em>,
<em>t2_low</em>, <em>t2_high</em>, <em>cond</em></p></li>
<li><div class="line-block">Similar to setcond, except that the 64-bit
values <em>t1</em> and <em>t2</em> are formed from two 32-bit arguments.
The result is a 32-bit value.</div></li>
</ul></li>
</ul>
<h3 id="qemu-specific-operations">QEMU specific operations</h3>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>operations</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>exit_tb <em>t0</em></td>
<td>退出当前的翻译块（Translation
Block）并返回变量<em>t0</em>的值（字类型）</td>
</tr>
<tr class="even">
<td>goto_tb <em>index</em></td>
<td>退出当前的翻译块（Translation Block）并根据条件跳转到索引为 index
的翻译块，如果当前的翻译块与目标翻译块相连。否则，继续执行下一条指令。只有索引为
0 和 1 是有效的，每个翻译块最多可以使用一次 tcg_gen_goto_tb
指令来跳转到每个索引。 tcg_gen_goto_tb may be issued at most once with
each slot index per TB.</td>
</tr>
<tr class="odd">
<td>lookup_and_goto_ptr <em>tb_addr</em></td>
<td>查找一个翻译块的地址<em>tb_addr</em>，并根据其有效性进行跳转。如果翻译块地址有效，则跳转到该地址；如果无效，则跳转到TCG的收尾部分以返回执行循环。</td>
</tr>
<tr class="even">
<td>qemu_ld_i32/i64/i128 <em>t0</em>, <em>t1</em>, <em>flags</em>,
<em>memidx</em><br>qemu_st_i32/i64/i128 <em>t0</em>, <em>t1</em>,
<em>flags</em>, <em>memidx</em><br>qemu_st8_i32 <em>t0</em>,
<em>t1</em>, <em>flags</em>, <em>memidx</em></td>
<td>加载位于虚拟地址 t1 处的数据到 t0，或者将 t0 中的数据存储到虚拟地址
t1 处。_i32/_i64/_i128 大小适用于输入/输出寄存器 t0 的大小。地址 t1
总是根据虚拟机的大小进行定位，而内存操作的宽度由 flags 控制。<br>在处理
64 位数据（在 32 位主机上）或 128 位数据（在 64 位主机上）时，t0 和 t1
可能会被拆分为按小端顺序排列的寄存器对。<br>memidx 用于选择要使用的 QEMU
TLB 索引（例如，用户或内核访问）。flags 是 MemOp
位，用于选择内存访问的符号、宽度和字节顺序。<br>对于 32 位主机，保证仅在
flags 中指定了 64 位内存访问时才使用 qemu_ld/st_i64。<br>对于
qemu_ld/st_i128，仅在 64 位主机上支持。<br>对于 i386，qemu_st8_i32 与
qemu_st_i32 完全相同，只是内存操作的大小已知为 8
位。这允许后端提供不同的寄存器约束。</td>
</tr>
</tbody>
</table>
<h2 id="host-vector-operations">Host vector operations</h2>
<p>All of the vector ops have two parameters, <code>TCGOP_VECL</code>
&amp; <code>TCGOP_VECE</code>. The former specifies the length of the
vector in log2 64-bit units; the latter specifies the length of the
element (if applicable) in log2 8-bit units. E.g. VECL = 1 -&gt; 64
&lt;&lt; 1 -&gt; v128, and VECE = 2 -&gt; 1 &lt;&lt; 2 -&gt; i32.</p>
<p>.. list-table::</p>
<ul>
<li><ul>
<li><p>mov_vec <em>v0</em>, <em>v1</em> ld_vec <em>v0</em>, <em>t1</em>
st_vec <em>v0</em>, <em>t1</em></p></li>
<li><div class="line-block">Move, load and store.</div></li>
</ul></li>
<li><ul>
<li><p>dup_vec <em>v0</em>, <em>r1</em></p></li>
<li><div class="line-block">Duplicate the low N bits of <em>r1</em> into
VECL/VECE copies across <em>v0</em>.</div></li>
</ul></li>
<li><ul>
<li><p>dupi_vec <em>v0</em>, <em>c</em></p></li>
<li><div class="line-block">Similarly, for a constant.<br />
Smaller values will be replicated to host register size by the
expanders.</div></li>
</ul></li>
<li><ul>
<li><p>dup2_vec <em>v0</em>, <em>r1</em>, <em>r2</em></p></li>
<li><div class="line-block">Duplicate <em>r2</em>:<em>r1</em> into
VECL/64 copies across <em>v0</em>. This opcode is only present for
32-bit hosts.</div></li>
</ul></li>
<li><ul>
<li><p>add_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p></li>
<li><div class="line-block"><em>v0</em> = <em>v1</em> + <em>v2</em>, in
elements across the vector.</div></li>
</ul></li>
<li><ul>
<li><p>sub_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p></li>
<li><div class="line-block">Similarly, <em>v0</em> = <em>v1</em> -
<em>v2</em>.</div></li>
</ul></li>
<li><ul>
<li><p>mul_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p></li>
<li><div class="line-block">Similarly, <em>v0</em> = <em>v1</em> *
<em>v2</em>.</div></li>
</ul></li>
<li><ul>
<li><p>neg_vec <em>v0</em>, <em>v1</em></p></li>
<li><div class="line-block">Similarly, <em>v0</em> =
-<em>v1</em>.</div></li>
</ul></li>
<li><ul>
<li><p>abs_vec <em>v0</em>, <em>v1</em></p></li>
<li><div class="line-block">Similarly, <em>v0</em> = <em>v1</em> &lt; 0
? -<em>v1</em> : <em>v1</em>, in elements across the vector.</div></li>
</ul></li>
<li><ul>
<li><p>smin_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p>
<p>umin_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p></li>
<li><div class="line-block">Similarly, <em>v0</em> = MIN(<em>v1</em>,
<em>v2</em>), for signed and unsigned element types.</div></li>
</ul></li>
<li><ul>
<li><p>smax_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p>
<p>umax_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p></li>
<li><div class="line-block">Similarly, <em>v0</em> = MAX(<em>v1</em>,
<em>v2</em>), for signed and unsigned element types.</div></li>
</ul></li>
<li><ul>
<li><p>ssadd_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p>
<p>sssub_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p>
<p>usadd_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p>
<p>ussub_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p></li>
<li><div class="line-block">Signed and unsigned saturating addition and
subtraction.<br />
<br />
If the true result is not representable within the element type, the
element is set to the minimum or maximum value for the type.</div></li>
</ul></li>
<li><ul>
<li><p>and_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p>
<p>or_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p>
<p>xor_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p>
<p>andc_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p>
<p>orc_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p>
<p>not_vec <em>v0</em>, <em>v1</em></p></li>
<li><div class="line-block">Similarly, logical operations with and
without complement.<br />
<br />
Note that VECE is unused.</div></li>
</ul></li>
<li><ul>
<li><p>shli_vec <em>v0</em>, <em>v1</em>, <em>i2</em></p>
<p>shls_vec <em>v0</em>, <em>v1</em>, <em>s2</em></p></li>
<li><div class="line-block">Shift all elements from v1 by a scalar
<em>i2</em>/<em>s2</em>. I.e.</div>
<p>.. code-block:: c</p>
<p>for (i = 0; i &lt; VECL/VECE; ++i) { v0[i] = v1[i] &lt;&lt; s2;
}</p></li>
</ul></li>
<li><ul>
<li><p>shri_vec <em>v0</em>, <em>v1</em>, <em>i2</em></p>
<p>sari_vec <em>v0</em>, <em>v1</em>, <em>i2</em></p>
<p>rotli_vec <em>v0</em>, <em>v1</em>, <em>i2</em></p>
<p>shrs_vec <em>v0</em>, <em>v1</em>, <em>s2</em></p>
<p>sars_vec <em>v0</em>, <em>v1</em>, <em>s2</em></p></li>
<li><div class="line-block">Similarly for logical and arithmetic right
shift, and left rotate.</div></li>
</ul></li>
<li><ul>
<li><p>shlv_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p></li>
<li><div class="line-block">Shift elements from <em>v1</em> by elements
from <em>v2</em>. I.e.</div>
<p>.. code-block:: c</p>
<p>for (i = 0; i &lt; VECL/VECE; ++i) { v0[i] = v1[i] &lt;&lt; v2[i];
}</p></li>
</ul></li>
<li><ul>
<li><p>shrv_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p>
<p>sarv_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p>
<p>rotlv_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p>
<p>rotrv_vec <em>v0</em>, <em>v1</em>, <em>v2</em></p></li>
<li><div class="line-block">Similarly for logical and arithmetic right
shift, and rotates.</div></li>
</ul></li>
<li><ul>
<li><p>cmp_vec <em>v0</em>, <em>v1</em>, <em>v2</em>,
<em>cond</em></p></li>
<li><div class="line-block">Compare vectors by element, storing -1 for
true and 0 for false.</div></li>
</ul></li>
<li><ul>
<li><p>bitsel_vec <em>v0</em>, <em>v1</em>, <em>v2</em>,
<em>v3</em></p></li>
<li><div class="line-block">Bitwise select, <em>v0</em> = (<em>v2</em>
&amp; <em>v1</em>) | (<em>v3</em> &amp; ~ <em>v1</em>), across the
entire vector.</div></li>
</ul></li>
<li><ul>
<li><p>cmpsel_vec <em>v0</em>, <em>c1</em>, <em>c2</em>, <em>v3</em>,
<em>v4</em>, <em>cond</em></p></li>
<li><div class="line-block">Select elements based on comparison
results:</div>
<p>.. code-block:: c</p>
<p>for (i = 0; i &lt; n; ++i) { v0[i] = (c1[i] cond c2[i]) ? v3[i] :
v4[i]. }</p></li>
</ul></li>
</ul>
<p><strong>Note 1</strong>: Some shortcuts are defined when the last
operand is known to be a constant (e.g. addi for add, movi for mov).</p>
<p><strong>Note 2</strong>: When using TCG, the opcodes must never be
generated directly as some of them may not be available as "real"
opcodes. Always use the function tcg_gen_xxx(args).</p>
<h2 id="backend-后端">Backend / 后端</h2>
<ul>
<li><code>tcg-target.h</code> 是包含目标特定定义的文件。</li>
<li><code>tcg-target.c.inc</code> 是目标特定代码的文件，它通过
<code>#include</code> 被 <code>tcg/tcg.c</code>
包含，而不是作为一个独立的 C 文件存在。</li>
</ul>
<h3 id="assumptions-假设">Assumptions / 假设</h3>
<ul>
<li><p>目标字长（<code>TCG_TARGET_REG_BITS</code>）预期为32位或64位。</p></li>
<li><p>假设指针的大小与字长相同。</p></li>
<li><p>在32位目标上，所有64位操作都会转换为32位。</p></li>
<li><p>需要实现一些特定的操作来支持这一点（参见<code>add2_i32</code>，<code>sub2_i32</code>，<code>brcond2_i32</code>）。</p></li>
<li><p>在64位目标上，通过以下操作在32位和64位寄存器之间传输值：</p>
<ul>
<li><code>trunc_shr_i64_i32</code></li>
<li><code>ext_i32_i64</code></li>
<li><code>extu_i32_i64</code></li>
</ul></li>
<li><p>它们确保在从32位寄存器移动到64位寄存器或反之时，值被正确截断或扩展。请注意，<code>trunc_shr_i64_i32</code>是一个可选的操作。</p></li>
<li><p>如果满足以下所有条件，则不需要实现它：</p>
<ul>
<li>64位寄存器可以容纳32位值</li>
<li>64位寄存器中的32位值不需要保持零扩展或符号扩展</li>
<li>所有32位TCG操作忽略64位寄存器的高位部分</li>
</ul></li>
<li><p>此版本不支持浮点操作。代码生成器的先前版本对其有全面支持，但最好先集中精力处理整数操作。</p></li>
</ul>
<h3 id="constraints-限制">Constraints / 限制</h3>
<ul>
<li><p>这个版本使用类似GCC的约束来定义每个指令的限制条件。</p></li>
<li><p>不支持内存约束。</p></li>
<li><p>别名可以像GCC一样在输入操作数中指定。</p></li>
<li><p>即使没有明确指定别名，同一个寄存器可以用作输入和输出。</p></li>
<li><p>如果一个操作扩展为多个目标指令，需要注意避免破坏输入值。</p></li>
<li><p>支持GCC风格的"早期占用"输出，使用'<code>&amp;</code>'符号。</p></li>
<li><p>目标可以定义特定的寄存器或常量约束。</p></li>
<li><p>如果一个操作使用不允许所有常量的常量输入约束，为了有备用选项，必须同时接受寄存器。
（If an operation uses a constant input constraint which does not allow
all constants, it must also accept registers in order to have a
fallback.）</p></li>
<li><p>约束'<code>i</code>'是通用定义的，接受任何常量。</p></li>
<li><p>约束'<code>r</code>'没有通用定义，但每个后端一致使用它来表示所有寄存器。</p></li>
<li><p>movi_i32和movi_i64操作必须接受任何常量。</p></li>
<li><p>mov_i32和mov_i64操作必须接受相同类型的任何寄存器。</p></li>
<li><p>ld/st/sti指令必须接受带符号的32位常量偏移量。</p></li>
<li><p>如果偏移量太大，可以通过保留一个特定的寄存器来计算地址。</p></li>
<li><p>ld/st指令必须接受任何目标寄存器（ld）或源寄存器（st）。</p></li>
<li><p>sti指令可能会因无法存储给定的常量而失败。</p></li>
</ul>
<h3 id="function-call-assumptions-函数调用的假设">Function call
assumptions / 函数调用的假设</h3>
<ul>
<li>参数和返回值的支持类型仅限于32位和64位整数以及指针。</li>
<li>栈向下增长。</li>
<li>前N个参数通过寄存器传递。</li>
<li>接下来的参数通过将它们存储为字节的方式通过栈传递。</li>
<li>在调用期间，一些寄存器的值可能会被覆盖。</li>
<li>函数可以在寄存器中返回0或1个值。在32位目标平台上，函数必须能够以寄存器返回2个值，用于64位返回类型。</li>
</ul>
<h2 id="recommended-coding-rules-for-best-performance">Recommended
coding rules for best performance</h2>
<ul>
<li><p>使用全局变量来表示经常被修改的QEMU
CPU状态的部分，例如整数寄存器和条件码。</p></li>
<li><p>TCG将能够使用主机寄存器来存储它们。</p></li>
<li><p>对于复杂或不常用的客户指令，不要犹豫使用辅助函数。</p></li>
<li><p>在使用TCG实现的客户指令中，使用超过约二十条TCG指令的性能优势很小。</p></li>
<li><p>需要注意的是，这个经验法则更适用于执行复杂逻辑或算术运算的辅助函数，因为C编译器可以进行有效的优化；在大部分是加载和存储操作的指令中，这个规则的适用性较小，并且在这些情况下，内联TCG仍然可能比较长的序列更快。</p></li>
<li><p>如果你知道TCG无法证明在给定程序点上某个全局变量是"无用"的，可以使用"discard"指令。</p></li>
<li><p>x86客户机使用它来改进条件码的优化。</p></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2023/05/18/Qemu%E7%BF%BB%E8%AF%91%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2023/05/18/Qemu%E7%BF%BB%E8%AF%91%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">Qemu翻译器的内部机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-18 19:23:50" itemprop="dateCreated datePublished" datetime="2023-05-18T19:23:50+08:00">2023-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:50" itemprop="dateModified" datetime="2023-07-30T18:15:50+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/Qemu/" itemprop="url" rel="index"><span itemprop="name">Qemu</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="translator-internals-翻译器的内部机制">Translator Internals /
翻译器的内部机制</h1>
<ul>
<li><p>QEMU是一个动态翻译器。</p></li>
<li><p>当它首次遇到一段代码时，它会将其转换为宿主机指令集。</p></li>
<li><p>通常，动态翻译器非常复杂且高度依赖于CPU。</p></li>
<li><p>QEMU使用一些技巧使其相对容易进行移植和简化，同时实现良好的性能。</p></li>
<li><p>QEMU的动态翻译后端称为TCG（Tiny Code Generator），见另一篇文章TCG
IR。</p></li>
<li><p>以下部分概述了QEMU动态翻译器的一些显著特点和实现细节。</p></li>
</ul>
<h1 id="cpu-state-optimisations-cpu状态优化">CPU state optimisations /
CPU状态优化</h1>
<ul>
<li>目标CPU具有许多内部状态，这些状态会影响它们执行指令的方式。</li>
<li>为了实现良好的速度，翻译阶段考虑到虚拟CPU的某些状态信息在其中不会改变。</li>
<li>状态信息被记录在翻译块（Translation Block，TB）中。</li>
<li>如果状态发生变化（例如特权级别），将生成一个新的TB，并且之前的TB将不再使用，直到状态与之前记录在先的TB中的状态匹配。</li>
<li>对于CPU状态的其他方面也可以应用相同的思想。例如，在x86架构中，如果SS、DS和ES段具有零基址，那么翻译器甚至不会为段基址生成一个加法操作。</li>
</ul>
<h2 id="direct-block-chaining-直接块链接">Direct block chaining /
直接块链接</h2>
<ul>
<li><p>在每个已执行的翻译的基本块之后，QEMU使用模拟的程序计数器（PC）和其他CPU状态信息（例如CS段基址）来找到下一个基本块。</p></li>
<li><p>在简单且未经优化的形式中，这是通过退出当前的翻译块，经过翻译块的收尾处理，然后返回到主循环来完成的。</p></li>
<li><p>在主循环中，QEMU寻找要执行的下一个翻译块，如果它尚未在内存中，则将其从客户体系结构翻译出来。</p></li>
<li><p>然后，QEMU继续执行下一个翻译块，从序言开始，然后继续执行已翻译的指令。</p></li>
<li><p>以这种方式退出翻译块将导致在执行其他指令之前重新评估<code>cpu_exec_interrupt()</code>回调函数。</p></li>
<li><p>在发生可能解除中断屏蔽的任何CPU状态更改后，以这种方式退出是必需的。</p></li>
<li><p>为了加速当新的模拟PC对应的翻译块已经可用的情况，QEMU具有机制允许直接链接多个翻译块，而无需返回到上述的主循环。这些机制包括：</p></li>
</ul>
<h3 id="lookup_and_goto_ptr"><code>lookup_and_goto_ptr</code></h3>
<ul>
<li>调用<code>tcg_gen_lookup_and_goto_ptr()</code>将生成对<code>helper_lookup_tb_ptr</code>的调用。</li>
<li>该辅助函数将查找与当前CPU状态匹配的现有翻译块。</li>
<li>如果目标翻译块可用，则返回其代码地址；否则返回JIT（即时编译）收尾部分的地址。</li>
<li>在调用辅助函数之后，总是紧随着tcg
<code>goto_ptr</code>指令，它会跳转到返回的地址。</li>
<li>这样，我们要么跳转到下一个翻译块，要么返回到主循环。</li>
</ul>
<h3 id="goto_tb-exit_tb"><code>goto_tb + exit_tb</code></h3>
<ul>
<li><p>翻译代码通常通过以下步骤来实现分支：</p>
<ol type="1">
<li>调用<code>tcg_gen_goto_tb()</code>，并将跳转槽索引（0或1）作为参数传递。</li>
<li>发出TCG指令来更新CPU状态，其中包括已假定为常量且主循环需要正确定位和执行下一个翻译块所需的信息。对于大多数客户机，这仅仅是分支目标的PC，但其他一些客户机可能会存储附加数据。在此步骤中更新的信息必须可以从<code>cpu_get_tb_cpu_state()</code>和<code>cpu_restore_state()</code>中推断出来。</li>
<li>调用<code>tcg_gen_exit_tb()</code>，再次传递当前翻译块的地址和跳转槽索引。</li>
</ol></li>
<li><p>第1步<code>tcg_gen_goto_tb()</code>将生成一个<code>goto_tb</code>
TCG指令，稍后会被翻译为跳转到与指定跳转槽相关联的地址。</p></li>
<li><p>初始时，这是第2步的指令的地址，用于更新CPU状态信息。</p></li>
<li><p>第3步<code>tcg_gen_exit_tb()</code>从当前翻译块退出，并返回由上一个执行的翻译块地址和跳转槽索引组成的标记指针。</p></li>
<li><p>第一次执行整个序列时，第1步简单地跳转到第2步。</p></li>
<li><p>然后，CPU状态信息会被更新，并从当前翻译块退出。</p></li>
<li><p>结果，行为与前面在本节中描述的较少优化的形式非常相似。</p></li>
<li><p>接下来，主循环使用当前CPU状态信息寻找要执行的下一个翻译块（如果尚未可用，则创建该翻译块），并在开始执行新翻译块的指令之前，通过将其跳转槽之一（在调用<code>tcg_gen_exit_tb()</code>时指定）与新翻译块的地址关联起来，来修补先前执行的翻译块。</p></li>
<li><p>下一次执行这个先前的翻译块，并到达同样的<code>goto_tb</code>步骤时，它将已经被修补（假设目标翻译块仍然在内存中），并直接跳转到目标翻译块的第一条指令，而无需返回到主循环。</p></li>
<li><p>要使用<code>goto_tb + exit_tb</code>机制，需要满足以下条件：</p>
<ul>
<li><p>CPU状态的更改必须是常量，例如直接分支而不是间接分支。</p></li>
<li><p>直接分支不能跨越页边界。内存映射可能会改变，导致目标地址的代码发生变化。</p></li>
</ul></li>
<li><p>需要注意的是，在第3步（<code>tcg_gen_exit_tb()</code>）中，除了跳转槽索引之外，还返回了刚刚执行的翻译块的地址。</p></li>
<li><p>这个地址对应于将要被修补的翻译块；如果该翻译块已经链接到其他翻译块，那么它可能与直接从主循环执行的翻译块不同。</p></li>
<li><p>Note that, on step 3 (<code>tcg_gen_exit_tb()</code>), in
addition to the jump slot index, the address of the TB just executed is
also returned.</p></li>
<li><p>This address corresponds to the TB that will be patched; it may
be different than the one that was directly executed from the main loop
if the latter had already been chained to other TBs.</p></li>
</ul>
<h2
id="self-modifying-code-and-translated-code-invalidation-自修改代码和翻译代码失效">Self-modifying
code and translated code invalidation / 自修改代码和翻译代码失效</h2>
<ul>
<li><p>在x86仿真中，自修改代码是一个特殊的挑战，因为当代码被修改时，应用程序不会向系统发出指示来使指令缓存失效。</p></li>
<li><p>在用户模式仿真中，每当为基本块生成翻译代码时，会将主机页面标记为写保护（如果它尚未是只读）。</p></li>
<li><p>然后，如果对该页面进行写访问，Linux会触发一个SEGV信号。</p></li>
<li><p>然后，QEMU会使该页面中的所有翻译代码失效，并允许对该页面进行写访问。</p></li>
<li><p>对于系统仿真，写保护是通过软件MMU实现的。</p></li>
<li><p>通过维护一个链接列表来高效地进行正确的翻译代码失效，该列表包含在给定页面中的每个翻译块。</p></li>
<li><p>还维护其他链接列表以撤消直接块链接。</p></li>
<li><p>Correct translated code invalidation is done efficiently by
maintaining a linked list of every translated block contained in a given
page.</p></li>
<li><p>Other linked lists are also maintained to undo direct block
chaining.</p></li>
<li><p>在RISC目标中，正确编写的软件使用内存屏障和缓存刷新，因此上述保护措施可能不是必需的。</p></li>
<li><p>然而，QEMU仍然要求生成的代码始终与目标指令在内存中匹配，以便正确处理异常情况。</p></li>
</ul>
<h2 id="exception-support-异常支持">Exception support / 异常支持</h2>
<ul>
<li><p>在遇到诸如除零等异常时，会使用longjmp()函数。</p></li>
<li><p>主机的SIGSEGV和SIGBUS信号处理程序用于获取无效的内存访问。</p></li>
<li><p>QEMU保持了一个从主机程序计数器（PC）到目标程序计数器（PC）的映射，并根据异常点处的主机程序计数器查找异常发生的位置。</p></li>
<li><p>在某些目标平台上，虚拟CPU状态的某些位直到翻译块结束之前才会刷新到内存中。</p></li>
<li><p>这是为了保存内部仿真状态，该状态很少直接被程序访问，且在翻译块的执行过程中经常发生变化，例如x86上的条件码、SPARC上的延迟槽、Arm上的条件执行等。</p></li>
<li><p>这些状态针对每个目标指令进行存储，并在发生异常时进行查找。</p></li>
</ul>
<h2 id="mmu-emulation-mmumemory-management-unit仿真">## MMU emulation /
MMU（Memory Management Unit）仿真</h2>
<ul>
<li><p>在系统仿真中，QEMU使用软件MMU。</p></li>
<li><p>在这种模式下，MMU会在每次内存访问时进行虚拟地址到物理地址的转换。</p></li>
<li><p>为了加快转换速度并避免在MMU映射发生变化时每次都刷新已翻译的代码，QEMU使用地址转换缓存（TLB）。</p></li>
<li><p>在QEMU中，所有缓存都是物理索引的，这意味着每个基本块都与其物理地址相关联。</p></li>
<li><p>为了避免在MMU映射发生变化时使基本块链无效，只有当跳转目标与执行跳转的基本块共享同一页时，才会执行链式操作。</p></li>
<li><p>MMU还可以区分RAM（随机存储器）和ROM（只读存储器）区域与MMIO（内存映射输入/输出）内存区域。</p></li>
<li><p>对于RAM和ROM的访问速度更快，因为转换缓存还存储了来宾地址和主机内存之间的偏移量。</p></li>
<li><p>而对MMIO内存区域的访问则调用C代码进行设备仿真。</p></li>
<li><p>最后，MMU有助于跟踪脏页和被翻译块引用的页。</p></li>
<li><p>这样可以有效地管理内存页面，并进行必要的操作，如脏页回写或内存页面回收。</p></li>
</ul>
<h2 id="profiling-jitted-code-对jit即时编译代码进行性能分析">Profiling
JITted code / 对JIT（即时编译）代码进行性能分析</h2>
<ul>
<li><p>Linux的perf工具在处理JIT（即时编译）代码时会将其视为单个代码块，因为与主要代码不同，它无法使用调试信息将单个程序计数器样本与较大的函数关联起来。</p></li>
<li><p>为了克服这个限制，可以使用<code>-perfmap</code>或<code>-jitdump</code>选项生成映射文件。</p></li>
<li><p><code>-perfmap</code>是轻量级的，只生成客户机-主机映射关系。</p></li>
<li><p><code>-jitdump</code>除此之外，还会保存JIT代码和客户机调试信息（如果有的话）；它的输出需要与<code>perf.data</code>文件集成，然后才能查看最终的报告。</p></li>
<li><p>示例代码如下：</p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">perf record $QEMU -perfmap $REMAINING_ARGS</span><br><span class="line">perf report</span><br><span class="line"></span><br><span class="line">perf record -k 1 $QEMU -jitdump $REMAINING_ARGS</span><br><span class="line">DEBUGINFOD_URLS= perf inject -j -i perf.data -o perf.data.jitted</span><br><span class="line">perf report -i perf.data.jitted</span><br></pre></td></tr></table></figure>
<ul>
<li><p>请注意，qemu-system仅为ELF格式的<code>-kernel</code>文件生成映射。</p></li>
<li><p>使用这些命令和选项，可以将JIT代码的性能分析结果与perf工具的报告集成在一起，以便更好地理解和分析JIT代码的性能。这将帮助开发人员针对性地进行优化和改进，提高QEMU的性能。</p></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2023/05/18/CPU%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2023/05/18/CPU%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD/" class="post-title-link" itemprop="url">CPU体系结构专业术语</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-18 11:23:50" itemprop="dateCreated datePublished" datetime="2023-05-18T11:23:50+08:00">2023-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:18" itemprop="dateModified" datetime="2023-07-30T18:15:18+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/Qemu/" itemprop="url" rel="index"><span itemprop="name">Qemu</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>353</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="mmiomemory-mapped-io">MMIO（Memory-Mapped I/O）</h1>
<ul>
<li><p>代表内存映射输入/输出。</p></li>
<li><p>它是一种计算机系统中用于与外部设备进行通信的技术。在MMIO中，外部设备的寄存器或状态被映射到计算机的内存地址空间中的特定区域。通过读取或写入这些内存地址，计算机可以与外部设备进行数据交换和控制操作。</p></li>
<li><p>MMIO的基本原理是通过在内存地址空间中保留一些特定的地址范围，让计算机能够直接访问外部设备的寄存器或状态。当计算机读取或写入这些地址时，数据被传递到或从外部设备进行处理。这种方式相对于使用专门的I/O指令进行输入/输出操作，提供了更简化和统一的编程界面。</p></li>
<li><p>常见的MMIO设备包括网络接口卡、图形显示控制器、声卡、串口控制器等。通过使用MMIO技术，计算机可以通过内存访问方式与这些设备进行通信，从而实现数据传输、设备控制和信息交换等功能。</p></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2023/05/18/Qemu%20icount/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2023/05/18/Qemu%20icount/" class="post-title-link" itemprop="url">Qemu icount</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-18 11:23:50" itemprop="dateCreated datePublished" datetime="2023-05-18T11:23:50+08:00">2023-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:50" itemprop="dateModified" datetime="2023-07-30T18:15:50+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/Qemu/" itemprop="url" rel="index"><span itemprop="name">Qemu</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="tcg-instruction-counting-tcg指令计数">TCG Instruction Counting /
TCG指令计数</h1>
<ul>
<li><p>TCG长期支持一种称为icount的功能，允许在执行过程中进行指令计数。</p></li>
<li><p>这与周期精确的仿真不应混淆——QEMU不会尝试模拟指令在实际硬件上所需的时间。这是其他更详细（但更慢）的工具来模拟微体系结构的工作。</p></li>
<li><p>这个功能仅适用于系统仿真，并且与多线程TCG不兼容。它可用于更好地与挂钟时间（wall-clock
time）对齐执行时间，以防止“慢速”设备在现代硬件上运行过快。它还提供了一定程度的确定性执行，并且是QEMU中记录/回放支持的关键部分。</p></li>
</ul>
<h2 id="core-concepts-核心概念">Core Concepts / 核心概念</h2>
<ul>
<li><p>icount本质上是一个在QEMU计时器子系统的TimersState中存储的已执行指令计数。</p></li>
<li><p>已执行指令的数量可以用来计算QEMU_CLOCK_VIRTUAL，该值表示自执行开始以来系统中经过的时间。根据icount模式，这可能是每条指令固定的纳秒数，或者在执行过程中进行调整，以保持挂钟时间和虚拟时间同步。</p></li>
<li><p>为了能够计算已执行指令的数量，翻译器首先分配一定数量的待执行指令预算。指令预算受限于下一个定时器到期之前的时间长度。我们将这个预算作为vCPU的icount_decr字段的一部分进行存储，该字段与处理cpu_exit()的机制共享。在每个翻译块的开始处检查整个字段，并在退出时返回到外部循环以处理导致退出的原因。</p></li>
<li><p>对于icount，再检查标志之前，我们会减去翻译块将要执行的指令数。如果这会导致指令预算变为负数，我们将退出主循环，并重新生成一个新的翻译块，其中包含恰好足够数量的指令，使预算减为0，这意味着无论何时我们退出主运行循环，定时器都将会在该时刻到期。</p></li>
</ul>
<h2 id="dealing-with-mmio-处理mmio">Dealing with MMIO / 处理MMIO</h2>
<ul>
<li><p>虽然我们可以调整已知事件（如计时器到期）的指令预算，但对于MMIO来说我们无法做到同样的调整。</p></li>
<li><p>我们执行的每个加载/存储操作都可能触发一个I/O事件，在这种情况下，我们需要一个最新且准确的icount数的读取。</p></li>
<li><p>为了处理这种情况，当进行I/O访问时，我们会：</p>
<ol type="1">
<li>将未执行的指令恢复到icount预算中</li>
<li>为当前PC重新编译一个[1]指令块</li>
<li>退出CPU循环并执行重新编译的块</li>
</ol></li>
<li><p>新的块被创建时带有CF_LAST_IO编译标志，确保最终的指令转换从调用gen_io_start()开始，这样我们就不会进入一个永久循环，不断重新编译一个单独的指令块。对于使用常见的translator_loop的翻译器，这是自动完成的。</p></li>
</ul>
<h2 id="other-io-operations-其他io操作">Other I/O operations /
其他IO操作</h2>
<ul>
<li><p>MMIO不是唯一可能需要正确和准确时钟的操作类型。</p></li>
<li><p>IO端口指令和对系统寄存器的访问是常见的例子。</p></li>
<li><p>这些指令必须由具有了解哪些操作是I/O操作的各个翻译器处理。</p></li>
<li><p>当翻译器处理此类指令时：</p>
<ul>
<li>如果启用了icount，它必须在实际执行I/O操作的代码生成之前的某个时刻调用gen_io_start()，使用类似以下代码片段的代码：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tb_cflags(s-&gt;base.tb) &amp; CF_USE_ICOUNT) &#123;</span><br><span class="line">    gen_io_start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>必须立即结束该TB（翻译块）在执行完这条指令之后。</li>
</ul></li>
<li><p>以上是处理这类指令的要求。通过调用gen_io_start()，我们可以确保在执行I/O操作之前记录正确的icount计数，并且在完成指令后结束TB以防止进一步执行不必要的指令。</p></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2023/04/12/Chiplets/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2023/04/12/Chiplets/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-12 00:00:00" itemprop="dateCreated datePublished" datetime="2023-04-12T00:00:00+08:00">2023-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:18" itemprop="dateModified" datetime="2023-07-30T18:15:18+08:00">2023-07-30</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>34 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>该论文讨论了系统级芯片（SoC）的复杂性和硅成本的增加促使将SoC分解为更小的“芯片块”。基于芯片块的SoC设计过程有望通过使用先进的封装技术将多个不同的芯片（例如CPU、GPU、内存、FPGA）紧密集成到一起来实现快速的SoC构建。然而，当将芯片块组装成单个SoC时，由于芯片块之间路由的复杂性增加，会出现正确性和性能问题。该论文提出了一种模块化但无死锁的路由方法，用于具有各种拓扑结构的基于芯片块的系统。</p>
<h1 id="introduction">INTRODUCTION</h1>
<p>在越来越复杂的工艺技术中，大型片上系统（SoC）的成本不断上升，这促使了基于“芯片”设计的SoC的出现。这个概念将传统的单片式SoC分解成几个更小的芯片，每个芯片都可以更便宜地开发，更容易在多个产品中重复使用，并使用最合适的工艺技术进行实现。芯片方法正在学术界[1]-[4]、工业界[5]-[11]和政府机构[12]中得到积极的研究
基于芯片的体系结构存在许多研究和工程挑战；我们关注其中一个具体但关键的问题。遵循模块化设计方法，每个单独的芯片都应该在不了解整个系统的情况下进行设计和验证。当从多个芯片构建SoC时，即使每个单独的组件都经过了正确的验证，完全集成的系统仍然可能存在正确性问题。互连网络特别容易受到这种影响。每个单独的芯片可能包含其自己的本地网络芯片（NoC），该NoC对于芯片内部流量是本地死锁自由且正常运行的。但是，连接多个NoC在一起可能会引入新的资源周期，从而导致跨芯片的循环依赖关系。”
虽然已经宣布了相对简单的基于芯片的体系结构[13]，或者甚至已经可用[14]，但这项工作进一步展望了基于在活动硅中间层上堆叠多个芯片的新兴体系结构（尽管我们也解释了如何将我们的方法应用于更接近的集成方法，例如被动中间层）。我们首先提供一些有关芯片的背景，并描述现有多芯片体系结构所涉及的模块化挑战。然后，我们介绍了一种新的基于芯片的路由方法，使每个芯片都可以独立设计，而不需要了解其他芯片或中间层的NoC细节，这是先前技术不支持的关键属性。我们的可组合路由方法利用了一个简单而强大的见解：从单个芯片的角度来看，整个系统可以抽象为单个虚拟节点。转向限制仅应用于连接芯片与虚拟节点之间的边界路由器，从而实现了以单个芯片为粒度的可处理分析和优化。
# II. CHIPLET-BASED SYSTEMS
“摩尔定律”和“丹纳德缩放定律”的减速使得先进工艺技术变得越来越复杂和昂贵。为了抵消缩放的减速，许多芯片变得更大，以继续在功能和性能上进行世代改进；最近的例子是使用了815平方毫米芯片的NVidia“Volta”GPU
[15]。最近，行业和政府正在追求和倡导基于“芯片组”的SoC设计概念，其中一个大型昂贵的SoC可以分解成多个较小、产量更高、成本更低的芯片组，然后使用先进的封装技术重新组装起来。这些技术包括AMD的超级计算APU愿景[6]，[10]，NVidia的MCM-GPU
[11]，TSMC的CoWoS（芯片-在-晶片-在-基板）服务，Marvell的MoChiTM（模块化芯片）架构[7]，[8]和DARPA的CHIPS项目[12]。芯片组方法还使得SoC可以结合来自不同公司的硅，例如最近宣布的Intel
Core处理器与AMD Radeon
Graphics技术[13]。计算机体系结构研究文献也反映了这些趋势，涉及使用被动硅中间层[16]、带微流控冷却的被动中间层[17]、有源硅中间层[2]、[18]和光子芯片组[3]、[4]等芯片组类似体系结构的研究。
## A. Active-interposer Chiplet SoCs
尽管当前的多芯片架构采用硅中间层[6]和多芯片模块[11]，[14]等被动集成技术，但本文展望了基于新兴活性硅中间层的芯片组SoC设计，如图1所示（我们在第VI节中探讨了其他封装技术）。尽管被动基板（仅有线而没有逻辑）[19]-[21]是近期商业关注的焦点，但越来越多的学术界[2]，[4]，[22]，工业界和政府研究机构[23]-[28]正在关注活性中间层。已经展示了一种带有3D
NoC的工作活性中间层原型[29]。
多常见的SoC功能可以移动到有源中间层，例如外部存储器接口、芯片间连接（即NoC）、外部IO和系统管理和调试（例如复位、JTAG）。这使得单个芯片可以更简单（减少设计时间）和更小（提高产量/成本）。如果芯片在更昂贵的技术节点（例如14nm）上实现，而中间层在更成熟和更便宜的工艺（例如28nm、20nm）上实现，则从更昂贵的芯片中移动逻辑到中间层可以获得额外的成本效益[2]。最近的分析得出结论，与被动硅中间层相比，有源中间层对于大型SoC来说也可以具有成本效益[30]。
## B. Baseline Assumptions
虽然我们提出的方法适用于各种可能的基于芯片的SoC，但我们专注于特定的架构作为工作示例。我们考虑了一个多芯片异构计算系统（“APU”），由CPU和GPU组件组成。图2显示了针对GPU计算进行优化的基线系统。有四个GPU芯片，每个芯片提供16个GPU
SIMD计算单元（CUs），以及一个中央CPU芯片，用于支持GPGPU工作负载的CPU阶段。这五个芯片堆叠在一个实现自己的NoC以相互连接芯片和其他常见系统功能的活动中间层上。
我们的基线配置使用网格拓扑结构来连接芯片和互连器的NoC子网络。每个GPU芯片的16个CU排列成4×4网格，互连器层也有一个4×4网格连接芯片。所有NoC组件都使用静态路由，采用路由表实现，这是当前商业系统（例如HyperTransport
[31]或QuickPath
Interconnect（QPI）[32]）的典型特征。每个芯片的本地网格和互连器网格使用X-Y路由。有关其他详细信息，例如NoC路由器配置（例如缓冲区大小，管道深度），请参见第V-A节。我们的基线提供了一个APU，其中包含64个GPU计算单元，4个CPU核心和8个外部内存通道，同时保持相对简单的结构以帮助我们的解释、评估和分析。
# 3. MOTIVATION ## A -
NoC提供了一种统一的接口，用于连接不同系统组件。与强制系统设计者在每对通信块之间实现特定接口并(更糟糕的是)验证每个接口的正确行为相比,NoC方法使得更模块化和可扩展的设计方法成为可能，这是将不同芯片连接在一起的自然选择。
- 路由可以显著影响网络性能、可靠性和功能性
。设计不良的路由算法可能会导致网络中的资源依赖关系，从而导致死锁，这可能对系统产生致命影响。我们在基于芯片片的系统中开发了一种模块化但无死锁的路由方法，该方法具有各种拓扑结构。
## B. Chiplet Composability Challenges -
对于多芯片SoC，小芯片可能来自不同的供应商[13]，即使由单个供应商提供，也可能由不同的团队独立设计。小芯片可能部署在多个产品中，包括在小芯片设计时甚至没有定义的未来产品，全局SoC路由信息可能不可用。因此，设计用于可扩展SoC或拓扑的小芯片变得极具挑战性，因为尽管每个小芯片的NoC可能是无死锁的，但它们仍然可以以在最终SoC中引入死锁的方式连接在一起。图3a显示了一个例子，其中两个4×4网状小芯片通过额外的链路连接。尽管每个单独的小芯片使用无死锁的X-Y路由，但仍然存在可能导致死锁的信道依赖性。图3b显示了一个基于两个小芯片插入器的系统，其中突出显示了一些潜在的依赖循环
-
大多数现有的无死锁路由算法都假设有完整的系统级信息可用，而这在基于小芯片的系统中并不一定有效。因此，这些方法不适用于路由可在多种SoC设计和拓扑中重复使用的模块化、独立设计的小芯片。我们解决了这个问题，并为未来SoC的模块化设计提出了一种可组合的路由算法。
## C. Deadlock Avoidance -
死锁是通过防止NoC的资源依赖关系图中的循环来避免的。有两种主要技术可以避免循环依赖：（1）<code>虚拟通道</code>（<code>VC</code>）方法[34]，以及（2）转弯模型[35]，[36]。转向模型不依赖于额外的虚拟通道来防止死锁。相反，它们对某些路径施加转向限制，以防止循环形成。在这项工作中，我们利用转弯限制来确保多芯片、基于插入器的NoC的死锁自由度，但我们引入了一种路由方法，该方法只需要在小芯片和插入器之间的“边界”处选择一些转弯限制。我们现在讨论相关工作，并在基于可重复使用的模块化小芯片的SoC的背景下解释其限制。
### VC-based Approaches -
基于VC的方法以<em>时间复用</em>的方式将物理信道划分为多个虚拟信道。每个VC都是独立管理的，并且在每个NoC路由器中都有专用的（每个VC）微片缓冲区。通过将不同的网络流分配给不相交的VC来消除循环依赖。请注意，除了避免协议级死锁所需的虚拟网络之外，还有路由死锁自由的VC。因此，对于需要复杂一致性协议的异构系统，所需的VC数量可能相当大（影响NoC路由器面积、功率等）。对于可组合的基于小芯片的系统，<em>必须预先配置VC数量，以支持最大的系统</em>，系统中的所有个体都必须为最大数量的VC实现这一点，导致小型系统的过度供应和单个小芯片的更高成本。
-
增加VC的数量会直接影响NoC路由器的面积和功率，因为每个VC都有自己的输入缓冲器，并且仲裁逻辑会随着VC的数量而扩展。从基于小芯片的系统的角度来看，单个小芯片的NoC可以设计成具有不同数量的VC，以保证死锁自由，这取决于本地拓扑和路由方案；这使得在集成多个这样的网络时设计和验证VC分配/仲裁逻辑极其复杂。为了使用VC消除死锁，设计人员需要提前了解完整的系统细节，过度配置VC，和/或限制每个小芯片和/或插入器的允许NoC。出于这些原因，我们寻求基于VC的方法的替代方案，以解决多芯片、基于插入器的SoC中的死锁。
### Flat Networks -
将整个系统作为一个平面网络，并应用统一的全局路由算法。在这种背景下，已经提出了许多拓扑不可知的路由算法。第一个这样的算法是up<em>/down</em>[37]，它使用由根节点形成的广度优先搜索（BFS）生成树。指向根的链接是上行链路，而其余的是下行链路。通过禁止消息从下行链路切换到上行链路来避免信道依赖性。上行*/下行路由需要以全局方式分析和编程所有路由表，这<strong>不允许单个芯片使用（更好的）本地路由决策。这也严重降低了系统的模块性和可组合性</strong>。我们还发现，上下路由会导致<strong>流量不平衡</strong>，因为<strong>根节点附近的链路往往比叶节点附近的更拥塞</strong>。
-
基于分段的路由将网络划分为子网，将子网划分为分段，并在每个分段内设置双向切换限制[38]。对于形成循环的起始段，除了起始路由器外，任何路由器都可以设置转弯限制；对于常规段，通过在任何路由器上设置双向转向限制来打破循环；对于仅由一条链路组成的一个路段，不允许任何流量穿过该链路（因此，在链路的一侧，必须在该链路和其他相邻链路之间设置双向转弯限制）。优化是可能的，因为转弯限制可以在一个路段内自由设置，而不依赖于其他路段。
-
Nue[39]是InfiniBand的一种基于目的地的遗忘路由实现。在网络的完全信道依赖图（CDG）的基础上，Nue构建了一个生成树，保证了死锁的自由性和连通性。然后，它使用Dijkstra算法计算从一个源节点到完整CDG中所有其他节点的最短路径，同时保持无循环约束。Nue不依赖VC来提供死锁自由，尽管额外的VC确实提高了负载平衡和性能
### ALL -
所有这些平面路由方法都需要目标SoC的全局信息来构建CDG，在CDG上可以实现死锁自由。对CDG进行全面分析的成本可能高得令人望而却步[40]。如前所述，完整的SoC配置和拓扑信息预计不可用于基于小芯片的系统（例如，小芯片可能用于未来尚未指定的SoC）。虽然我们提供了与其中几种方法的实验比较，但我们强调，这些现有方法都不能满足实现真正模块化和可重复使用的小芯片与独立优化的小芯片本地NoC的目标。
### Hierarchical Approaches: -
另一种方法是将NoC拓扑分解为几个层次结构层。在内部路由中，设计者可以自由地为单个级别选择任何现有的路由算法；并且每个节点只知道其级别内的本地节点。目的地为另一个级别的消息首先转发到连接到另一个层次结构级别的富时路由器。消息从源边界路由器指向其目的地通过其他边界路由器。分层路由的一个优点是独立分析本地网络的每一级，并且可以应用局部最优路由算法。然而，正如我们前面所讨论的，当<strong>将单个网络组合在一起时，全局网络仍然可能出现死锁</strong>。因此，必须小心避免全局死锁，这通常会导致对所有可能的全局路由路径进行逐案分析[41]，[42]。先前的工作提出了基于规则拓扑（如总线、环形、网格和树）的分层NoC[42]-[44]。然而，<strong>来自不同制造商的小芯片可能没有使用规则NoC进行设计，并且集成SoC系统可能不是对称的</strong>。因此，系统级的死锁避免仍然需要付出很大的努力，而且很容易出错。
## D. Comparison of Modularity -
虽然“模块化”可能有很多可能的定义，但我们将重点放在表I中列出的关键属性上。
- Table I: Comparison of deadlock avoidance approaches</p>
<table style="width:100%;">
<colgroup>
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>Independently Designed Chiplets</th>
<th>Enables Local Op-timization</th>
<th>Global CDG</th>
<th>Not Required Future-proof Chiplets</th>
<th>HW Cost</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>VC-based</td>
<td>-</td>
<td>++</td>
<td>+</td>
<td>-</td>
<td>High</td>
</tr>
<tr class="even">
<td>Flat NoCs</td>
<td>--</td>
<td>-</td>
<td>--</td>
<td>-</td>
<td>Low</td>
</tr>
<tr class="odd">
<td>Hierarchical</td>
<td>-</td>
<td>+</td>
<td>-</td>
<td>--</td>
<td>Low</td>
</tr>
<tr class="even">
<td>Composable(this work)</td>
<td>+</td>
<td>++</td>
<td>++</td>
<td>++</td>
<td>Low</td>
</tr>
</tbody>
</table>
<h3 id="independently-designed-chiplets">Independently Designed
Chiplets:</h3>
<ul>
<li>单个芯片的架构师应该能够设计和优化他们的本地NoC，而对整个SoC的其余部分知之甚少。基于VC的方法要求小芯片架构要么拥有整个SoC组织的信息（小芯片设计不再独立），要么过度提供VC的数量，以支持所有可能使用小芯片的SoC。扁平和分层的NoC通常也需要完整的SoC信息来分析和确保锁定自由
### Enables Local Optimization</li>
<li>模块化设计方法应允许小芯片架构师在独立于最终SoC组织的情况下局部优化一个chiplet的NoC。扁平化方法需要全局SoC信息，因此影响本地拓扑、路由算法、负载平衡等的芯片内优化，不能孤立地进行。分层NoC确实实现了一定程度的局部小芯片级优化，尽管这可能仍然受到完整CDG的全局分析的限制，以消除死锁。基于VC的方法以及本文提出的可组合方案有效地允许任意小芯片级别的NoC组织和优化
### Global CDG Not Required</li>
<li>平面和分层的NoC不是模块化的，因为构建依赖图需要所有通道的连接，并且在所有小芯片网络最终确定之前无法执行路由分配。在不影响全局路由决策的情况下优化本地NoC也是极其困难的，因为修改本地网络会改变全局CDG。基于VC的方法在局部优化方面提供了更大的灵活性，并且不需要全局CDG；他们需要一些全局信息来分配VC。我们的可组合方法要求与SoC集成商共享关于小芯片的一些有限信息（但远低于全套信道依赖性），并要求在独立的小芯片设计之间共享节点依赖性信息。
### Future-proof Chiplets</li>
<li>一个小芯片可能会集成到未来尚未设计的SoC中。由于扁平化和分层NoC方法需要全局CDG，小芯片将很难重复使用，因为本地NoC设计和优化可能已经固定。基于风险投资的方法可能会更好，但为尚未考虑的SoC过度提供风险投资可能会很昂贵。我们的可组合方法将与到/从中介器到SoC设计时间的流量相关的NoC决策延迟绑定（与设计小芯片时相反），从而在新的SoC组织中部署小芯片所需的效率和返工最少
### Hardware Cost:</li>
<li>除了基于VC的设计外，其他方法修改不同NoC组件的路由表，因此硬件开销很小。对于基于VC的方法，特别是如果需要为未来的系统进行超额配置，则支持更多VC的区域影响可能会相对昂贵。</li>
</ul>
<h1 id="iv.-multi-chiplet-routing">IV. MULTI-CHIPLET ROUTING</h1>
<p>在本节中，我们为芯片组系统提出了一种可组合、拓扑无关、无死锁的路由方法。关键的洞察力是简单而强大的：从任何单个芯片的角度来看，整个系统（与其他芯片的总数或中间层复杂性无关）都可以抽象成一个单一的虚拟节点，这使得在芯片粒度上进行可处理性分析、优化和正确性成为可能。我们详细介绍了一种基于芯片的路由具体方法，但这只是我们的关键洞察力所能实现的一种可能解决方案。
## A. Overview - Before describing our methodology, we define some
terms. ### 定义1： -
芯片组的边界路由器通过边界链路将芯片组连接到中间层。从中间层到芯片组的流量称为入站流量；从芯片组到中间层的流量称为出站流量。
### 定义2： -
边界路由器b的入站可达性InR(b)是从中间层通过路由器b可以到达的芯片上路由器的比例；0
&lt; <em>InR(b)</em> ≤ 1。 ### 定义3： -
边界路由器b的出站可达性OutR(b)是可以通过路由器b到达中间层的芯片上路由器的比例；0
&lt; <em>OutR(b)</em> ≤ 1。 ### 定义4： -
<em>InD(r)</em>是芯片路由器r的入站距离，是从最近的可以到达r的边界路由器到路由器r的拓扑距离。
### 定义5： -
芯片上路由器r的出站距离<em>OutD(r)</em>是从r到其最近可达边界路由器的拓扑距离。</p>
<p>这段话是在讨论可组合路由方法的目标。该方法的目标是尽可能地隔离单个芯片和中间层的设计，允许对每个芯片和中间层进行独立的负载平衡优化，同时为整个系统提供无死锁路由。</p>
<p>具体来说，我们在每个芯片上的边界路由器上放置单向转向限制。当应用转向限制时，系统的其余部分被抽象为一个与所有边界路由器相连的单个节点。转向限制确定了每个边界路由器的入站和出站可达性，并保证每个芯片内不存在循环通道依赖关系。然后，可达性信息传播到中间层，中间层负责将消息从一个边界路由器路由到另一个边界路由器。有了边界路由器可达性的知识，消息就会被转发到正确的目标芯片。一旦消息到达目标边界路由器，本地芯片NoC将把消息路由到其最终目的地。这种分层方法使用两组路由表来为每个芯片提供服务。第一组表用于在同一芯片内本地路由消息（这是常规的芯片内部路由），而第二组表则将出站消息引导到适当的边界路由器。本节末提供了更多实现细节。与第一条路由表（芯片内部）相对应的路由决策可以完全独立于系统的其余部分进行，这可能甚至尚未定义。
## B. Chiplet Design Guidelines
在设计芯片级NoC时，边界路由器的数量和位置是两个关键的设计参数，它们可以影响整个系统的性能。这些与芯片和中介器之间的垂直（微颗粒）链接数量有关
### Number of Boundary Routers: -
边界路由器的数量决定了芯片可以维持发送/接收离片流量的吞吐量；边界路由器越多，离片流量带宽就越高。一个极端情况是将芯片上的每个路由器都连接到中介器上，使每个路由器都成为边界路由器，这是先前其他人考虑过的[2]，[22]。然而，这样的设计可能会超额配置预期的离片流量，并可能受到可用微颗粒密度的限制。
-
在确定每个芯片的边界路由器数量时，一个关键观察是，虽然可能的边界路由器最大数量是芯片面积的函数，但最大有用带宽是其周长的函数。对于一个n×n网格的芯片，我们已经分析确定，在本文考虑的中介器拓扑结构下，n个边界路由器就足够了（为简洁起见，完整分析被省略）。对于我们大多数实验中假定的4×4芯片，我们每个芯片使用四个边界路由器。虽然我们专注于网格，但我们的方法适用于其他拓扑结构（请参见第VI节）。
### Turn Restrictions at Boundary Routers -
图3中的简单示例表明，通过中介器、其他芯片等，可能存在大量潜在的依赖循环，导致需要分析的可能路径数量爆炸。为了使单个芯片级别的路由决策成为可能，并使芯片间依赖分析可行，我们将系统的其余部分抽象为单个节点，并将所有边界路由器连接到抽象节点上（图4）。与之前的工作不同，这种新颖的抽象步骤是实现芯片独立设计的关键，而不需要全局CDG信息。
-
我们使用转向限制来打破包含抽象节点和一对边界路由器的循环。抽象节点代表单个芯片设计者不需要了解的系统的其余部分，因此<strong>转向限制不适用于抽象节点</strong>。在为边界路由器选择禁止转向时，必须保持连通性（即，每个芯片路由器到抽象节点之间必须存在路径，反之亦然），因此<strong>禁止导致断开NoC的转向限制</strong>。
-
在保持连通性的同时打破所有循环足以确保与该芯片相关的操作的正确性。但是，为了性能原因，仍然需要仔细选择转向限制和路由。可以采用不同的启发式方法；我们描述了一种在实践中表现良好的可能方法。我们考虑负载平衡的入站和出站可达性。不平衡的入站或出站可达性可能会导致芯片和/或中介器拥塞。同时，所有芯片路由器的入站和出站距离的平均值应该最小化，因为当路由到芯片外时，如果消息有多个边界路由器候选，则首选最近的边界路由器。总体而言，在选择禁止转向时，我们的目标是最小化平均距离/平均可达性，其中距离和可达性在第IV-A节中定义，并且平均值是在所有芯片上计算的。具体而言，平均距离是芯片上所有路由器的入站和出站距离的平均值。平均可达性类似地计算每个边界路由器的入站和出站可达性。我们的启发式方法选择具有较低平均距离和较高平均可达性的组合。
-
为了可视化指标，图4给出了一个4×4网格的示例，其中有3个边界路由器a、b和c；其余的系统用x表示。假设本地芯片NoC采用X-Y路由，禁止转弯的箭头在边界路由器处被划掉。包含x和任意一对边界路由器的循环通过禁止某些转弯来打破。
在此示例中，a 的入站可达性 (InR(a)) 为
1/2，因为其入站转向限制与小芯片的本地 X-Y
路由相结合，使得小芯片的左半部分无法从节点 x 通过 a 到达。
由于a没有出站转向限制，其出站可达性OutR(a)为1，即每台路由器都可以通过a到达x。
x → a → c → x 的环路在 c 处因出站转弯限制而中断，导致 OutR(c) = 1/2。
或者，不是在路由器 c 处断开环路，而是可以在路由器 a 处放置入站转弯限制 x
→ a → (3, 3) 以断开相同的环路，为此 InR(a) 变为 1/4（仅列 编号 2
可通过路由器 a
到达，因为两个单独的入站转弯限制用于打破两个不同的环路），并且 OutR©
变为 1。 路由器 m 的入站距离为 3，从边界路由器 b 测量； 出站距离为 3，到
a 或 b。 同样，从路由器c测得的路由器InD(n)=1； OutD(n) = 2 到路由器 a。
虽然此示例出于说明目的有些特别，但我们提供了一个具体的算法来确定下面的所有这些。
### Boundary Router Placement -
给定一个内部芯片级路由算法，边界路由器的选择会影响它们的入站和出站可达性以及芯片上的流量分布。我们提出了以下选择边界路由器的准则。
首先，避免将边界路由器聚集在一起，以减少创建网络热点的机会。
其次，应该以一种使所有边界路由器的入站/出站可达性保持平衡的方式放置边界路由器。
第三，更喜欢具有较低基数的路由器。
前两个准则旨在优化网络性能和吞吐量。第三个准则旨在最小化电路复杂性。例如，在图4中，芯片中间的四个路由器每个都有五个端口（四个连接到相邻路由器，第五个连接到它连接的网络端点，例如GPU
CU）。向其中一个“内部”路由器添加垂直链接将强制该路由器实现六个端口，这会增加面积并可能影响电路时序。但是，向芯片边缘上的任何一个路由器添加垂直链接都可以使所有路由器继续具有五个或更少的端口。
### Boundary Router Placement and Turn Restriction Algorithm - 算法1
确定每个芯片的边界路由器位置和转向限制。
PlaceBoundaryRouter通过调用SetTurns迭代所有边界路由器位置，以查找更好的位置和转向限制。
对于每个放置，函数identifyAllBoundaryTurns枚举所有可能的边界转弯并将它们存储在列表bturn
[]中。另一个列表pturn
[]存储禁止的边界转弯，这在SetTurns中递归更新。变量max是消除所有死锁所需的最大禁止边界转弯数。
- 过程 SetTurns
使用启发式方法检查所有边界转弯组合，如果当前限制改进了用户指定的目标函数，则更新迄今为止找到的最佳位置。
我们使用 CDG [39]、[45] 的矩阵表示。 最初，允许所有边界转弯。
更新函数（第 16 行）使用 Floyd Warshall 全对最短路径算法 [46]
传播到整个图的通道连接的禁止边界转弯列表 pt[] 更新 CDG。
这提供了来自更新的 CDG 的连接信息、边界路由器可达性和跳数。
下一步检查用户指定的目标函数是否得到改进（第 17 行）。 在第 19
行，connected 函数检查 CDG
是否仍然连接，因为任何导致网络断开的转向限制都应该被丢弃。
如果图是连通的，hasLoop
会检测入站通道（从抽象节点到边界路由器）是否连接到出站通道（从边界路由器到抽象节点）。
如果没有找到循环，则在第 22 行更新最佳位置，递归终止。 第 24
行控制递归的深度，因为只需要一定数量的边界限制就可以消除死锁。 如果 CDG
已连接但循环仍然存在，则第 27-29 行调用对 SetTurns
的递归调用以根据需要添加更多转弯限制。 ## C. Interposer NoC
Configuration -
确定了芯片的进出转向限制后，我们现在解释如何编程中继器的路由表。请注意，当单独考虑中继器网络（不包括芯片）时，中继器网络本身也应该是无死锁的。中继器负责将消息从一个边界路由器路由到另一个边界路由器。为此，必须向中继器提供某些芯片级别的信息。
首先，我们需要知道每个单独边界路由器可达的芯片节点（终端节点）。我们使用这个来确保消息从可以到达目的地的芯片边界路由器路由。其次，我们可以选择使用每个边界路由器和其可达芯片节点之间的拓扑距离来优化路由距离和负载平衡。请注意，这些信息可以简单地以“列表”格式列出（例如，节点x可以从边界节点y到达）；不需要芯片的本地NoC的完整细节（例如，网络的拓扑和请求如何从y到x的路由决策），并且这些信息独立于interposer和任何其他芯片。
我们现在描述我们的互连路由方案。对于每个目标路由器的消息，以下算法决定将该消息发送到目标芯片的哪个边界路由器。如果目标只能通过单个边界路由器到达，则中间件必须将消息路由到该特定边界路由器。否则，我们选择边界路由器以在边界路由器之间平衡网络负载（平均利用芯片-中间件带宽），同时最小化路径长度（避免发送消息在高度迂回的情况下只是为了负载平衡）。下面，我们正式指定算法。
- 对于给定的边界路由器i，仅由i可到达的节点集合称为Ai。 -
对于可以被多个边界路由器到达的其余节点，列表Ci包含所有节点，这些节点在拓扑上比任何其他边界路由器更接近i。对于不同的边界路由器j和k，Cj∩Ck=∅。
-
剩余的节点与至少两个边界路由器等距。设Ei，j是同时等距于边界路由器i和j的节点列表。虽然可能等距于两个以上的边界路由器，但为简单起见，我们仅考虑两个路由器的情况。
• 执行以下步骤将芯片上的节点分配给边界路由器。 -
第1步。在所有边界路由器中，选择具有Ai中最小项目数的路由器i。 -
第2步。逐个将Ci中的节点分配给Ai，直到Ai中的项目数不再是最小值。将项目分配给Ai时，从Ci中删除该项。如果Ai仍然具有最小数量的项目，则逐个从Ei，j中分配节点到Ai。将项目分配给Ai后，从Ei，j和Ej，i中删除该项。
-
第3步。如果无法进行进一步分配，则完成对边界路由器i的节点分配。重复步骤1-3，直到Ci
= ∅且Ei，j = ∅对于所有边界路由器i和j。
完成后，每个边界路由器的节点分配信息都存储在Ai中。通过参考这些信息，配置相应的中间层路由表。系统集成商可以自由选择任何对于中间层网络来说是死锁自由的底层路由算法。
- 考虑图4中的示例。对于边界路由器a、b和c，Aa = {(2, 0),(2, 1),(2, 2),
a}，Ab = {(0, 0),(0, 1), m,(0, 3), b,(1, 1),(1, 2),(1, 3)}，Ac = ∅；Ca =
{(3, 3)}，Cb = ∅，Cc = {(3, 0), c,
n}。在这个网络中没有等距集。节点分配从边界路由器c开始，因为Ac为空。Cc中的所有元素都分配给Ac，Ac
= {(3, 0), c,
n}。对于c，不能进行进一步的分配，因此算法选择下一个路由器a。Ca中唯一的元素被分配给Aa，Aa
= {(2, 0),(2, 1),(2, 2), a,(3,
3)}。到目前为止，每个芯片上的节点都被分配给了一个边界路由器；这些分配存储在Aa、Ab和Ac中。有了上述信息，互连器就能将消息路由到正确的边界路由器（a、b或c），如果消息是发送到该芯片的话。
## D. Deadlock Freedom and Connectivity -
现在我们展示可组合路由方案是无死锁且连通的。假设存在一个循环r1，l1，r2，l2，…，rn，ln，其中r表示路由器，l是连接到r的链接。如果所有路由器和链接都属于同一个芯片，则与基本假设芯片级网络无死锁相矛盾。否则，如果循环的子集属于插板和其他芯片，则可以用单个节点x来抽象这个子集。因此，该循环转换为r1，l1，…，rj，x，rk，lk，…，rn，ln。因为删除了包含x的循环中的所有循环依赖项，所以新循环是无死锁的。因此，可组合路由方案是无死锁的。
-
单个芯片内的任何网络都是连接的，因为边界路由器转向限制不影响内部芯片网络。芯片上的任何节点都能通过至少一个边界路由器到达中间层。中间层网络是通过构造连接的（即，每个中间层路由器都可以到达其他中间层路由器）。对于任何一对芯片节点，都存在一条路径。因此，该系统是连接的。
## E. Microarchitectural Issues -
每个芯片需要实现两个不同的路由表。第一个处理从不到达互连器的芯片内部流量。这个路由表可以以芯片设计者认为合适的任何方式填充。第二个路由表将出站流量定向到适当的边界路由器。这种组织方式假定整个系统中所有路由器端点都有全局ID空间。类似于用于检测系统中所有内存和计算资源（特别是在多插槽SMP系统中）的引导序列，可组合的基于互连器的SoC需要一个类似的系统配置协议。这个过程的一部分将是检测可用的NoC端点，为每个端点分配唯一ID，并计算和填充次级路由表。与系统引导不同，这个过程只会由SoC集成器在物理组装SoC后执行一次（尽管也可以提供钩子以在以后的某个时间点更新表，例如处理失败的链接[32]）
-
在我们的设计中，每个网络接口（NI）都有一个查找表，将出站数据包的目标ID映射到边界路由器ID。然后将边界路由器ID嵌入标题flit中，并用于芯片内路由，直到数据包离开芯片。关于面积/功率开销，每个NI中的查找表需要针对给定产品的最大系统大小进行配置。路由表通常比其他路由器组件（如缓冲区和交叉点）小得多。此外，每个芯片中第二个路由表的大小仅与边界路由器的数量成比例；因此，它比第一个路由表小得多。有几种实现互连路由器的方法：1）为最大系统大小提供路由表，导致相对较大的互连路由表；或2）添加另一层目标映射以将目标ID转换为目标边界路由器ID，导致更小的路由表但更复杂的边界路由器。总体而言，与规范的两级路由器相比，我们的设计不应产生显着的额外功率/面积/时间影响。
# V. EVALUATION ## A. Experimental Methodology -
为了评估网络性能，我们使用由 gem5 [47] 和 GPU 模型 [48] 的修改版本组成的
APU 模拟平台进行周期级执行驱动模拟。 我们使用 Garnet [49]
来模拟使用每通道 4-flit 缓冲区的 2 级路由器的网络。 我们的初始实验使用图
2 所示的多芯片 APU 配置，包括四个 GPU 芯片、一个 CPU
芯片和一个有源中介层。 CPU chiplet 由 CPU 内核、专用 CPU L1 和 L2
缓存以及末级缓存组成。 每个 GPU 小芯片由 16 个计算单元 (CU) 和 8 个 GPU
L2 缓存组组成。 我们的内存模型使用内置的 gem5 模型
[50]，每个通道有八个内存通道和八个存储体。 图 2 还显示了由我们的算法从第
IV 节确定的边界节点的位置。 -
我们同时使用合成流量和基于应用程序的模拟。对于合成流量，每个数据包宽度为8个flits，并且网络模拟了200万个周期。对于系统级（非合成）模拟，我们使用AMD
SDK [51]、Rodinia [52]和Pannotia
[53]套件中的APU应用程序，其中芯片外通信包括GPU
CUs之间的缓存一致性和到主存储器的流量。 ## B. Comparison Points -
即使从定性上看，基于VC的方法是昂贵且不太吸引人的，但为了完整性，我们提供了一个比较。使用与EbDa
[40]类似的方法，我们实现了一个支持最小路径自适应路由的VC-based死锁避免机制：对于单个2D网格，需要两个VC来避免死锁；通过在芯片和interposer之间引入垂直连接，需要两个更多的VC来隔离入站和出站流量。我们还实现了第III-C节中描述的三种全局路由算法：up<em>/down</em>
[37]、基于段[38]和Nue路由[39]。请注意，所有三种算法都需要完整的CDG知识，并且不支持独立设计和芯片复用。我们将其与之进行比较作为我们所知道的最相关的工作，但它们无法满足我们的关键芯片模块化标准。
-
在应用转向限制之前，通过找到与所有其他节点的平均距离最小的节点来选择上<em>/下</em>路由中的根节点。基于段的路由中的起始段是从系统的左上角（左上GPU芯片的左上路由器）形成的。在我们的可组合路由方案中，本地芯片算法和互连器算法都使用维度排序路由。为了与基于VC的方法进行公平比较，我们为每个基于转向的方案提供了四个VC。
-
我们还将我们的结果与理想化系统（表示为最短路径）进行比较，该系统使用不切实际的大量虚拟通道来避免死锁。
路由表是使用全对最短路径 (APSP)
算法配置的（与现有技术和我们自己提出的一些路由可能不是最短的方案形成对比）。
请注意，这个理想化的系统不一定能提供真正的最佳性能，因为 APSP
仍然会导致某些链路中的拥塞程度高于其他链路。
然而在实践中，我们发现这种最短路径配置通常优于实际的替代方案，因此它提供了一个乐观的性能目标来进行比较。</p>
<h2
id="c.-basic-throughput-evaluations-with-synthetic-traffic-使用合成流量进行基本吞吐量评估">C.
Basic Throughput Evaluations with Synthetic Traffic
使用合成流量进行基本吞吐量评估</h2>
<ul>
<li>在本节中，我们评估了一个由四个芯片组成的64-CU系统，每个芯片组由16个CU组成，组织为4×4网格。每个芯片组通过四个边界路由器连接到中间层。中间层网络是4×4网格。</li>
<li>图5a和图5b显示了均匀随机和位补码流量下的负载延迟曲线。我们观察到，许多异构多芯片工作负载与均匀随机流量相似：实际系统具有混合的芯片内、芯片间、芯片到互连器和芯片到内存的流量，涵盖了一致性和主存储器请求和响应；这些在总体上“平均”，使得均匀随机流量的高级性能趋势与我们的几项应用驱动研究大致相符。位补码流量模式强制所有数据包离开芯片，因此进一步加重了互连器的压力并创建了网络热点。我们运行了其他合成流量模式，但总体趋势非常相似，因此没有显示。</li>
<li>我们的可组合方案优于up<em>/down</em>、基于段的和VC-based方法。在相同数量的虚拟通道下，可组合方案的性能优于VC-based方法，主要是因为额外的虚拟通道减少了头阻塞。典型的一致性协议需要3-5个虚拟网络，每个虚拟网络都需要四个VC以实现死锁自由。异构架构的一致性协议可能需要更多的虚拟网络，使得VC-based方法变得更加昂贵。虽然VC-based方法需要每个虚拟网络四个VC以实现正确性，但是由于VC-based和可组合方案之间的性能差距，需要更多的VC以实现更好的性能。</li>
<li>基于段的路由在零负载延迟方面存在问题，并且具有最低的饱和吞吐量。这主要是因为它是为2D网格状网络设计和优化的。虽然评估系统由多个网格网络组成，但全局拓扑结构仍然不规则，因此基于段的路由无法有效处理它。基线基于段的算法并不总是形成最优段；从边界路由器向中间件开始的段可能会绕到同一芯片上的路由器上结束，或者通过另一个芯片跨越多个跳跃，直到到达属于现有段的路由器。这样的链式段在较大的系统中可能非常长，并且在段内断开任何双向转弯将导致更多的非最小路径（对于基线APU，我们观察到平均路由距离近11个跳跃，而其他方法则为∼8个跳跃）。虽然拓扑感知优化可能会改善基于段的路由性能，但这超出了本文的范围。¹</li>
<li>上行<em>/下行</em>
路由具有低零负载延迟，这表明消息可能会在评估系统中采用最少的路由。
然而，与其他方法相比，它相对较早地饱和。
根节点附近的链路本质上比叶节点附近的链路更拥塞。
当注入率增加时，这些环节会饱和并成为瓶颈。 Nue
路由优于我们的可组合方法，但这只是因为它具有利用完整 CDG
知识优化其路由的优势，从而导致与理想的最短路径算法类似的行为。
有了足够的
VC（我们为其提供），它会找到优化的路径来平衡网络工作负载。</li>
<li>我们的组合方案优于up<em>/down和基于段的路由，因为芯片和互连网络更加负载平衡，芯片和互连器之间的垂直链接也是如此。Nue提供更好的负载平衡，因此表现接近理想的最短路径路由，但与其他先前的工作一样，它不适用于独立设计和重用芯片以进行模块化SoC构建。与理想的最短路径路由相比，我们的方案覆盖了从up/down</em>到理想化最短路径路由的吞吐量差距的大部分，但仍然存在一些余地。这是因为1）由于转向限制而仍然存在一些负载不平衡，以及2）理想化网络具有更多的虚拟通道以改善头部阻塞。总体而言，尽管我们提出的方法没有实现全局负载平衡优化的全部性能，但我们的结果表明，我们的方案确保了正确性，并提供了高性能的多芯片SoC，它独特地实现了一种模块化芯片设计方法论，不需要对整个系统的CDG有先验知识。
## D. Application-level Impact ### Network Latency:
我们使用执行驱动模拟对非合成工作负载评估了我们的可组合路由方案。图6a显示了平均网络延迟，归一化为理想的最短路径方法。基于段的路由未显示，因为在给定的系统大小下，它始终表现出色并且明显优于其余方法。我们省略了基于VC的方案，因为评估的异构系统需要大量的VC才能避免路由和协议级死锁，同时保持性能。总体而言，我们的可组合方法实现的网络延迟几乎与最短路径相同。在一些情况下（bfs、nw、srad），可组合路由比最短路径表现略好；正如前面所讨论的，最短路径并不是真正的最优解，有时会出现局部流量突发（这种情况在GPU工作负载中比传统CPU应用程序更常见），会导致最短路径配置中的拥塞/负载不平衡。
由于根节点在高负载下成为瓶颈，因此上下行方法的大多数基准测试的平均网络延迟增加了50%以上，如第V-C节所讨论的。这种瓶颈限制了系统的有效带宽，并导致了显着的网络缓冲延迟。
### Application Performance:
图6b显示了程序执行时间，归一化为理想的最短路径方法。总体而言，可组合路由与最短路径相比实现了类似（在1%以内）的系统性能。虽然APU/GPGPU应用程序会生成大量的NoC/内存流量（这对于压力网络来说非常好），但对应用程序执行时间的总体影响却很小，因为大多数GPU应用程序本质上对延迟不太敏感（即，丰富的SIMD并行性可以更容易地容忍增加的延迟）。虽然有流量突发，但应用程序的大部分部分不会使NoC接近饱和，因此对总执行时间的影响较小。尽管如此，我们仍然观察到一些工作负载使用up<em>/down</em>路由时性能下降了5-10%，而我们的方法在大约与最短路径方法相同的水平上执行。
### Case Study – HotSpot:
图7显示了执行HotSpot时最常用的链接的最大链接利用率。仅显示了互连网络和GPU芯片上的边界路由器，因为其余部分利用率较低。对于每个10000个周期，我们对每个链接的利用率进行了采样。链接的最大利用率是整个程序执行过程中观察到的最大采样结果。最大链接利用率向我们展示了在突发流量行为下最糟糕的链接拥塞发生在哪里，从而使我们能够可视化全局网络流量并定位任何NoC瓶颈。一般来说，可组合路由比最短路径具有更少的拥塞链接。但是，前者在互连器上具有略微不平衡的流量分布，这表明最大链接利用率更大。这是由于转向限制偏向边界路由器的可达性（即，某些边界路由器接收更多流量）。对于上<em>/下</em>路由，根节点位于互连器上。如预期所示，靠近根节点的链接比其他链接更加利用。
# VI. BROADER APPLICABILITY 更广泛的适用性
前一节展示了我们方法在一个特定的芯片组SoC上的有效性。在本节中，我们提供了额外的实验结果，因为各种系统假设被修改，然后我们还讨论了如何将该提议应用于没有活动互连器的芯片组系统。
## A. Design Guideline Justification 设计指南的证明
在第IV-B节中，我们描述了如何确定边界路由器的数量、选择转向限制的目标函数以及边界路由器的放置。为了证明所提出的指南的有效性，我们使用均匀随机流量评估了其他设计方案。图8a显示了从2个边界路由器增加到8个路由器时吞吐量的提高。在所有情况下，互连网络保持相同的大小；当有8个边界路由器时，2个边界路由器集中到一个互连路由器上，这增加了路由器的复杂性和面积。从4个边界路由器到8个边界路由器的改进要比从2个边界路由器到4个边界路由器的改进小得多。不足的边界路由器可能会影响系统吞吐量。通过提供更多的边界路由器，可以增加芯片外带宽，从而减少与芯片内通信的干扰。在16个边界路由器的极端情况下，每个芯片路由器都有一个垂直连接，与芯片外通信不会影响芯片内通信/拥塞。然而，这样的设计是不切实际的，因为需要大量垂直线。总体而言，在性能和硬件成本方面，4个边界路由器是一个合理的设计选择。
图8b比较了不同目标函数的系统吞吐量，包括最小化平均距离、最大化平均可达性和我们提出的度量（即最小化平均距离/平均可达性）。结果表明，我们提出的目标函数是有效的，并且与其他度量相比提供了最佳性能。仅考虑平均距离或平均可达性往往会创建不平衡的芯片内流量。
在某些情况下，设计者可能没有自由选择边界路由器放置位置的自由（例如，布局限制，物理设计约束）。图8c考虑了边界路由器位置已移动到较不理想的位置（例如，聚集在一起），分散到角落，位于同一行（即与我们的方法分配给它们的位置不同）。我们重新运行了确定转向限制的算法。结果表明，边界路由器的随机放置最终导致某些链接被使用得比其他链接更多，从而影响了系统吞吐量，但死锁自由仍然得以保持。
## B. Sensitivity Studies 我们考虑了以下基线的变体：
系统规模：基线具有4个GPU芯片，每个芯片有16个CU，总计算能力为64个CU。我们还考虑了两种128-CU配置（CPU数量保持不变），分别由（1）每个芯片32个CU的4个芯片和（2）每个芯片16个CU的8个芯片组成。在这两种情况下，每个芯片仍然有四个边界路由器。
Interposer
NoC拓扑结构：为了支持这一论点，即中介器的NoC可以独立于芯片设计，我们评估了基线系统，但将中介器的网状NoC替换为“双蝴蝶”拓扑结构[22]
不规则芯片拓扑结构：为了支持芯片的NoC拓扑结构可以独立设计的类似主张，我们评估了一个系统，其中每个GPU芯片都实现了一个不同的本地NoC拓扑结构，包括网格、环、蝴蝶和树形拓扑结构
结果：本节中的分析仅呈现了均匀随机流量的负载延迟曲线。我们也进行了应用程序级别的实验，但总体趋势非常一致，因此我们由于空间原因和重复性而省略了这些附加图形。这些实验的主要目的是证明我们的提议是一种在广泛的基于芯片组的系统可能性范围内实现高性能并确保死锁自由的强大方法。
图9a和b显示了更大的128-CU配置的结果，我们的组合方法轻松地优于上/下路由。这两个配置之间的主要区别是芯片内和芯片间流量的比例。与最短路径相比，我们的组合方法对流量分布不太敏感，因为具有更好的芯片级和互连器级负载平衡。”
的中文翻译是：“图9a和b显示了更大的128-CU配置的结果，我们的组合方法轻松地优于上/下路由。这两个配置之间的主要区别是芯片内和芯片间流量的比例。与最短路径相比，我们的组合方法对流量分布不太敏感，因为具有更好的芯片级和互连器级负载平衡。
图9c显示了当插层NoC具有蝴蝶式拓扑结构时的结果。结果与网格的基准系统类似，总体上这有助于证明可以轻松地独立设计单个芯片，而不受插层NoC拓扑结构的影响。
图9d显示了当每个GPU芯片组具有不同的本地NoC拓扑时的结果。这里的结果更有趣，因为我们的提议导致的饱和吞吐量比具有丰富虚拟通道和最短路径路由的“理想”情况更高。这是因为在处理芯片间通信时，最短路径会偏向于靠近互连器中心的边界路由器，而我们的提议方法实现了更好的互连器流量分布。”
的中文翻译是
“图9d显示了当每个GPU芯片组具有不同的本地NoC拓扑时的结果。这里的结果更有趣，因为我们的提议导致的饱和吞吐量比具有丰富虚拟通道和最短路径路由的“理想”情况更高。这是因为在处理芯片间通信时，最短路径会偏向于靠近互连器中心的边界路由器，而我们的提议方法实现了更好的互连器流量分布。
## C. Other Chiplet Packaging Options
到目前为止，我们的研究集中在基于新兴活性硅中间层技术构建的芯片组系统上。虽然活性硅中间层可能是实用的，特别是如果可以将用于逻辑的总中间层面积最小化[2]，[30]，但近期芯片组系统可能会受到被动基板的限制。无论是使用被动硅中间层[19]-[21]还是更传统的封装基板[7]，[11]，[14]，[54]，一个可能的担忧是芯片组下方缺乏活性层可能会限制我们方法的适用性。
图10a显示了一个在被动基板上具有芯片的示例系统。此布局假定提供了常见功能的中央芯片（否则将放置在活动互连器上，例如内存控制器、NoC、系统管理），计算芯片以星形拓扑结构从中央芯片向外扩展。使用这种类型的布局，我们的建议方法可以直接应用于此系统，无需进行任何修改，方法是将中央芯片与我们之前的工作示例中的活动互连器相同对待。选择最佳边界节点放置的过程可以更有效，因为芯片上可供选择的合理节点较少（即最靠近中央芯片的节点）。
## D. Other Chiplet Topologies
即使对于非星型拓扑的芯片，他们的方法也可以进行适应。图10b显示了一个基于芯片的系统，其中两个CPU芯片具有额外的点对点链接（例如，用于低延迟高速缓存一致性），这些链接不通过中央芯片进行路由。为了支持这一点，这两个CPU芯片被有效地视为单个虚拟芯片，以应用他们的方法来确定路由限制。仍然需要CPU芯片设计人员确保两个CPU芯片之间的直接路由是正确的（即无死锁），但设计人员无需担心从/到中央芯片进入/离开任一芯片的流量，因为他们的方法确定适当的转向限制以确保整个SoC的正常运行。
同样，图10c显示了一个没有单个“中央”芯片的系统，而是有两个芯片连接到其他芯片。在这里，我们应用了类似的技术，其中两个芯片被视为单个虚拟芯片，以便于此方法。与上面的两个CPU芯片示例类似，SoC设计人员必须确保一对芯片是相互/本地死锁自由的，但是任何剩余的与其他芯片的连接都将得到正确处理。大多数合理的芯片拓扑都可以迭代地合并，直到将拓扑转换为类似星形的组织为止，此时我们的方法可以直接应用。
# VII. RELATED WORK
平面网络：在第III-C节中，我们介绍了一种避免死锁的平面网络方法。对up<em>/down</em>路由的进一步优化已被提出：Koibuchi等人基于BFS生成树构建了一个从左到右的有向图，并在根节点周围分配流量[55]；Sancho等人使用深度优先搜索（DFS）生成树[56]；他们通过在每个周期中单独删除每个方向上的通道依赖关系来改善流量平衡[57]。
分层网络：HiRA
[41]是一种用于分层NoC中无死锁路由的方法。在HiRA中，网络被划分为子网（具有独立无死锁路由算法的网络）和外部链接（子网之间的链接）。通过在每个子网中选择安全边界节点并在边界节点上应用转向限制来避免死锁。当连接到其他子网时，如果边界节点不会发生死锁并且可以保证连通性而不修改子网的内部路由算法，则边界节点是安全的。在应用边界节点上的转向限制时，使用包含所有边界节点的CDG。虽然HiRA可应用于具有被动互连器的芯片组系统，但对于两个主要原因，它不适用于主动互连器SoC。首先，仍需要系统级CDG，并且转向限制在很大程度上取决于子网路由算法。其次，HiRA缺乏中央网络（即主动互连器）的路由算法，该网络连接到所有芯片组。
“3D NoC中的路由：常规3D
NoC的死锁避免技术包括DoR和基于转向的路由[35]，[58] -
[60]和基于VC的方法[61] -
[63]。其中许多技术不直接适用，因为它们的基于转向的算法要求每个路由器在堆栈中具有垂直连接（我们不做出这种假设），这会增加每个芯片TSV区域开销。其他3D
VC技术创建与芯片在堆叠中的垂直位置相关联的单调VC排序；芯片在中间层上的物理拓扑结构使得很难强制实施总排序。我们不提供这些作品的实验评估，因为不明显如何将它们适应不仅由单个垂直3D芯片堆栈组成的拓扑结构。”
# VIII. CONCLUSIONS
基于芯片组的复杂SoCs的构建非常令人兴奋，因为它可以实现各种类型的系统，但这些系统必须易于设计和组装。当使用来自第三方硅IP供应商的黑盒芯片构建系统时，确保正确性变得更加具有挑战性和重要性。本文对基于芯片组的SoC设计方法论做出了重大贡献，重点是互连；然而，仍有其他有益的研究领域。如果系统中的不同芯片要具有高速缓存一致性，则必须设计一个正确运行并跨不同物理芯片扩展（以性能为准）的高速缓存一致性协议。虽然不是严格的正确性问题，但可能需要设计服务质量机制，以确保不同的芯片集成在一起“友好地协作”，特别是在实时组件（例如图形和音频）或更高级别的性能目标（例如数据中心服务级别协议）方面。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2023/03/22/Clion%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2023/03/22/Clion%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">Clion使用指南!</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-22 11:00:50" itemprop="dateCreated datePublished" datetime="2023-03-22T11:00:50+08:00">2023-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:18" itemprop="dateModified" datetime="2023-07-30T18:15:18+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/Clion/" itemprop="url" rel="index"><span itemprop="name">Clion</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>73</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="常用快捷键">常用快捷键</h2>
<table>
<thead>
<tr class="header">
<th>｜shortcut</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>cmd + opt + -&gt; / &lt;-</td>
<td>恢复/撤销光标上次操作</td>
</tr>
<tr class="even">
<td>cmd+shift+ -</td>
<td>折叠所有代码块</td>
</tr>
</tbody>
</table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2023/03/21/Effective%20C++(7)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2023/03/21/Effective%20C++(7)/" class="post-title-link" itemprop="url">Effective C++(7)--模版与范型编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-21 11:37:00" itemprop="dateCreated datePublished" datetime="2023-03-21T11:37:00+08:00">2023-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:32" itemprop="dateModified" datetime="2023-07-30T18:15:32+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="条款44-将参数无关的代码抽离templates">条款44
将参数无关的代码抽离templates</h1>
<ul>
<li><code>template</code>可能会带来膨胀的重复的二进制代码</li>
<li>在<code>template</code>代码中，重复是隐晦的 ## EG1.
固定尺寸的正方矩阵的template ### 原始版本</li>
<li>n * n矩阵，元素类型是<code>T</code>，支持矩阵求逆 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;	<span class="comment">/// n * n矩阵，元素类型是T</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/// ...</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">()</span></span>;	<span class="comment">/// 求逆矩阵</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SquareMatrix&lt;<span class="type">double</span>, <span class="number">5</span>&gt; sm1;</span><br><span class="line">sm1.<span class="built_in">invert</span>();	<span class="comment">/// 调用SquareMatrix&lt;double, 5&gt;::invert()</span></span><br><span class="line">SquareMatrix&lt;<span class="type">double</span>, <span class="number">10</span>&gt; sm2;</span><br><span class="line">sm2.<span class="built_in">invert</span>();	<span class="comment">/// 调用SquareMatrix&lt;double, 10&gt;::invert()</span></span><br></pre></td></tr></table></figure></li>
<li>这里具现化两份invert代码，但是除了常量5和10，代码完全相同 ### Mod1.
建立带参数的函数</li>
<li>以5和10调用函数，减少重复代码 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;	<span class="comment">/// 与尺寸无关的base class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">/// ...</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">(std::<span class="type">size_t</span> matrixSize)</span></span>;	<span class="comment">/// 求逆矩阵</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;	<span class="comment">/// n * n矩阵，元素类型是T</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> : <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">using</span> SquareMatrixBase&lt;T&gt;::invert;	<span class="comment">/// 避免遮掩，见条款33</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/// ...</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>-&gt;<span class="built_in">invert</span>(n); &#125;;	<span class="comment">/// inline版的的调用，why this-&gt;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><code>SquareMatrixBase</code>模板只对元素类型T初始化，不对矩阵的尺寸参数初始化</li>
<li>Eg1中的<code>sm1</code>和<code>sm2</code>将共享<code>SquareMatrixBase&lt;double&gt;::invert</code></li>
<li><code>SquareMatrixBase&lt;double&gt;::invert</code>避免派生类代码重复</li>
<li>inline : 额外的调用成本是0</li>
<li>若不使用this-&gt;，模板化基类SquareMatrixBase<T>内的函数名会被派生类遮掩(条款43？)</li>
<li>private继承，仅帮助实现，不是表现is-a的关系(条款39？) #### 问题</li>
<li><code>SquareMatrixBase&lt;T&gt;::invert</code>如何知道矩阵数据在哪
### Mod2. 令SquareMatrixBase储存一个指针 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">SquareMatrixBase</span>(<span class="type">size_t</span> Size, T *pMem) : <span class="built_in">size</span>(Size), <span class="built_in">pData</span>(pMem) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setDataPtr</span><span class="params">(T *PData)</span> </span>&#123; pData = PData; &#125;</span><br><span class="line">	<span class="comment">/// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::<span class="type">size_t</span> size;</span><br><span class="line">	T* pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>这允许Derived Classes决定内存分配方式 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 该版本将矩阵数据存储在SquareMatrix内部</span></span><br><span class="line"><span class="comment">/// 这种类型的对象不需要动态内存分配，但对象自身可能非常大</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;	<span class="comment">/// n * n矩阵，元素类型是T</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> : <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SquareMatrix</span>() : <span class="built_in">SquareMatrixBase</span>&lt;T&gt;(n, data) &#123;&#125;;</span><br><span class="line">	<span class="comment">/// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T data[n * n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 该版本将矩阵数据放入heap</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;	<span class="comment">/// n * n矩阵，元素类型是T</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> : <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SquareMatrix</span>()</span><br><span class="line">		: <span class="built_in">SquareMatrixBase</span>&lt;T&gt;(n, <span class="literal">nullptr</span>), <span class="built_in">pData</span>(<span class="keyword">new</span> T[n * n])</span><br><span class="line">		&#123; <span class="keyword">this</span>-&gt;<span class="built_in">setDataPtr</span>(pData.<span class="built_in">get</span>()); &#125;</span><br><span class="line">	<span class="comment">/// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::array&lt;T&gt; pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
### 总结</li>
<li>SquareMatrix成员函数可以单纯的以inline方式调用base class版本
<ul>
<li>后者由持相同T的矩阵共享</li>
</ul></li>
<li>强行绑定矩阵尺寸的invert[Eg1.]
<ul>
<li>可能有更好的编译器实现和优化，但是会有大量重复的二进制代码</li>
</ul></li>
<li>不绑定尺寸的invert[Mod1., Mod2.]
<ul>
<li>减少执行文件大小</li>
<li>降低程序的working
set大小，(一个在VM下执行的进程所使用的那一组内存页)</li>
<li>强化指令高速缓冲区内的引用集中化(locality) ## 小结</li>
</ul></li>
<li>template不该与造成膨胀的模板参产生关系</li>
<li>non-type template
parameters(非类型模板参数)造成的代码膨胀，往往可以消除，做法是用函数或class成员变量替换template参数
## type parameters(类型参数)也会带来代码膨胀</li>
<li>如许多平台上int和long有相同的二进制表述
<ul>
<li>vector<int>和vector<long>应该共用一份底层实现</li>
</ul></li>
<li>指针往往也具有相同的二进制表述</li>
<li>让有相同的二进制表述的具现类型(instantiation types)共享实现码</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2023/02/07/Qemu%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2023/02/07/Qemu%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">Qemu使用记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-07 17:28:50" itemprop="dateCreated datePublished" datetime="2023-02-07T17:28:50+08:00">2023-02-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-22 21:45:32" itemprop="dateModified" datetime="2023-09-22T21:45:32+08:00">2023-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="qemu说明">1. Qemu说明</h1>
<ul>
<li>通用的开源机器和用户空间模拟器和虚拟器</li>
<li>具体内容见官网<code>https://github.com/qemu/qemu</code></li>
<li>比如：Qemu可以模拟出一个ARM系统中的：CPU. 内存.
IO设备等，然后在这个模拟层之上，可以跑一台ARM虚拟机，这个ARM虚拟机认为自己在和硬件进行打交道，但实际上这些硬件都是Qemu模拟出来的。</li>
</ul>
<h2 id="qemu的两种模式">Qemu的两种模式</h2>
<ol type="1">
<li>用户模式(User
mode)：利用动态代码翻译机制来执行不同主机架构的代码，例如：在x86平台上模拟执行ARM代码，也就是说：我们写一条ARM指令，传入整个模拟器中，模拟器会把整个指令翻译成x86平台的指令，然后在x86的CPU中执行。</li>
<li>系统模式(System mode)：模拟整个电脑系统，利用其它VMM(Xen,
KVM)来使用硬件提供的虚拟化支持，创建接近于主机性能的全功能虚拟机。</li>
</ol>
<h1 id="qemu编译">qemu编译</h1>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">../configure  </span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./compile-aarch64-system.sh</span><br><span class="line">cd build</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<h1 id="qemu执行流程">2. qemu执行流程</h1>
<h2 id="宏">0. 宏</h2>
<ul>
<li><code>#ifdef PPI_QR_FUNC</code> 宏是我们所有改动加的宏 ## 1.
qemu启动</li>
<li>file: softmmu/vl.c</li>
<li>初始化参数</li>
<li>调用vcpu初始化。 ## 2. vcpu初始化</li>
<li>file: target/arm/cpu64.c</li>
<li>func:
<ul>
<li>aarch64_cpu_class_init</li>
<li>aarch64_cpu_instance_init
<ul>
<li>对cpu实例进行初始化</li>
<li>共享内存初始化(包括qemu要用的向gem5传输的共享内存)
<ul>
<li>ringbuf_init 进行初始化环形队列。</li>
<li>第二块共享内存是shm_init。</li>
</ul></li>
<li>每个qemu vcpu会初始化调用一次aarch64_cpu_instance_init
<ul>
<li>eg：run.sh里是16 cpu，那么就调用16次aarch64_cpu_instance_init，所以
也会初始化16个ringbuf_init，共享内存队列，每个核维护一个。key_insoff+channel_d+i是每个共享内存的id。</li>
</ul></li>
<li>这里面的cpu以及cpu-&gt;env就是
qemu的vcpu，其中cpu-&gt;env就是cpuarmstate。这个时候已经初始化完毕。 ##
3. 翻译</li>
</ul></li>
</ul></li>
<li>初始化之后开始主流程翻译</li>
<li>翻译是两步，
<ol type="1">
<li>guest-&gt;ir</li>
<li>ir-&gt;host</li>
</ol>
<ul>
<li>eg: 也就是比如 用户程序是 arm，arm-&gt;ir ir-&gt;x86
code，host运行x86
code。如果是用户程序是x86，host也是，那么不用翻译，直接在host上执行。
### guest-&gt;ir</li>
</ul></li>
</ul>
<ol type="1">
<li>调用<code>tb_find</code>[accel/tcg/cpu-exec.c]
<ul>
<li>找是否有翻译过,若无则进行2.(刚开始肯定无)</li>
</ul></li>
<li>调用<code>tb_gen_code</code>[accel/tcg/cpu-exec.c]
<ul>
<li>翻译主函数</li>
</ul></li>
<li>这个又调用gen_intermediate_code，
<ul>
<li>进行guest-&gt;ir的翻译。</li>
</ul></li>
<li>上面又继续调用translator_loop
<ul>
<li>来到accel/tcg/translator.c。</li>
<li>translator_loop 函数 对tb里的每一个指令 进行翻译。</li>
<li>while (true)就是每条指令循环翻译。</li>
</ul></li>
<li>aarch64_tr_translate_insn函数。
<ul>
<li>添加函数名，target/arm/translate-a64.c</li>
</ul></li>
<li>调用disas_a64_insn
<ul>
<li>就是每个指令进行decoder</li>
<li>里面switch (extract32(insn, 25, 4)) { 看是哪类指令。</li>
</ul></li>
</ol>
<ul>
<li>至此完成了 guest-&gt;ir的翻译。 ### ir-&gt;host的暂不考虑</li>
</ul>
<h2 id="执行">4. 执行</h2>
<ul>
<li>翻译之后，host代码已经生成，需要执行。</li>
<li>我们采用在guest的tb开始和结束前插callback函数的方式
<ul>
<li>target/arm/translate.c 里的函数
<ul>
<li>helper_start_callback插在tb执行开始前的。插在它tb guest的开头，</li>
<li><code>helper_end_callback</code>在结尾</li>
<li>会随tb一起翻译。</li>
</ul></li>
</ul></li>
<li>那么执行就是先 helper_start_callback -&gt; tb -&gt;
helper_end_callback</li>
<li>当执行helper_end_callback的时候，整个tb都执行好了。</li>
<li>所以可以对下一个执行的tb进行预测。</li>
<li>tb-&gt;tt里存放我们记下来的tb的trace，包括 pc insn。</li>
<li>env-&gt;sendbuf-&gt;real_insn_num记了tb的实际指令数。</li>
<li>helper_end_callback调用lookupAndUpdateNextPC预测。</li>
<li>执行tb 是一串二进制代码，无法代码操作。 只能通过cb来操作。</li>
<li>bt-&gt;IsControl 是true 说明是分支指令，需要存。所以在这里可以存cpu
state</li>
</ul>
<h3 id="内存处理">内存处理</h3>
<ul>
<li>主函数如果是ld st指令</li>
<li>mem信息我们额外插了cb进行收集mem 访存信息。</li>
<li>ppi_insert_mem_st[tcg/tcg-op.c]进行ld st插桩。
<ul>
<li>函数体insert_mem_st[target/arm/translate.c]<br />
</li>
</ul></li>
<li><code>helper_load_callback</code> 里，env-&gt;sendbuf 是 cpu
armstate结构体里划出来的一块临时内存。</li>
<li>mem cb里会将mem trace 记在这里。</li>
<li>env里是否有mem的寄存器信息？</li>
<li>到end
cb的时候，helper_load_callback里的所有东西都记好了，env的sendbuf里有完整的tb里的mem
insn trace</li>
</ul>
<h2 id="qemu主函数调用">qemu主函数调用</h2>
<ol type="1">
<li><p>main[./softmmu/vl.c]</p></li>
<li><p>aarch64_cpu_instance_init[target/arm/cpu64.c]</p></li>
<li><p>aarch64_cpu_class_init[target/arm/cpu64.c]</p></li>
<li><p>cpu_exec[accel/tcg/cpu-exec.c]</p>
<ul>
<li>main execution loop</li>
</ul>
<ol type="1">
<li>tb_gen_code[accel/tcg/translate-all.c]
<ul>
<li>生成下一个tb块代码</li>
</ul>
<ol type="1">
<li>cpu_loop_exit[accel/tcg/cpu-exec-common.c]
<ul>
<li>exit the current TB</li>
<li>抛出异常时触发</li>
</ul>
<ol type="1">
<li>helper_end_callback[target/arm/translate.c]
<ul>
<li>移植了gem5的分支预测器</li>
</ul></li>
</ol></li>
</ol></li>
<li>cpu_loop_exec_tb[accel/tcg/cpu-exec.c]
<ol type="1">
<li>cpu_tb_exec[accel/tcg/cpu-exec.c]</li>
</ol></li>
</ol></li>
<li><p>cpu_exec_exit[accel/tcg/cpu-exec.c]</p></li>
</ol>
<ul>
<li>退出qemu<code>ctrl+A+X</code></li>
</ul>
<h1 id="问题">问题</h1>
<p>分支预测加在了每个tb运行结束的末尾，在运行到tb末尾时进行预测
当下一个tb运行完之后，取出该tb的头地址，并与上次预测结果比对验证</p>
<p>checkpoint是系统层面的快照接口 在程序内部调用不好处理</p>
<p>接下来首先篡改执行的tb路径，即迫使qemu按照分支预测结果执行</p>
<p>在cpu_exec中主循环通过调用tb_lookup/tb_gen_code来获得下一个执行的tb
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tb = tb_lookup(cpu, pc, cs_base, flags, cflags);</span><br><span class="line">tb = tb_gen_code(cpu, pc, cs_base, flags, cflags);</span><br></pre></td></tr></table></figure>
我们可以通过改变cpu的pc来控制下一个tb，既可以迫使其走上错误分支，也可以再恢复状态后安排它执行正确的pc
pc在这里取出<code>cpu_get_tb_cpu_state(cpu-&gt;env_ptr, &amp;pc, &amp;cs_base, &amp;flags);</code>，根据<code>cpu-&gt;env_ptr</code>内的值
这个指针实际指向CPUARMState
cpu_get_tb_cpu_state[target/arm/helper.c]中pc的值分两种情况 pc /
regs[15] 怎么选取?</p>
<p>core的时候打屏可以 写文件不行</p>
<ul>
<li>s0, add a new file to do the following things</li>
<li>s1, todo: secondery pointer, deep copy the whole struct</li>
<li>s2, todo: backup the memory</li>
<li>s3, checkpoint?</li>
<li>当前仅修改pc，不做备份，只为了篡改执行路径</li>
</ul>
<p>分支当前的pc是tb块的最后一条指令(有时为跳转指令)的pc</p>
<p>Tiny Code Generator (TCG)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tb_trace</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> insn_num;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> pc_start;     <span class="comment">/* tb first pc */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trace_info</span> <span class="title">ti</span>[512];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TranslationBlock</span> &#123;</span></span><br><span class="line">    target_ulong pc;   <span class="comment">/* simulated PC corresponding to this block (EIP + CS base) */</span></span><br><span class="line">    target_ulong cs_base; <span class="comment">/* CS base for this block */</span></span><br><span class="line">    <span class="type">uint32_t</span> flags; <span class="comment">/* flags defining in which context the code was generated */</span></span><br><span class="line">    <span class="type">uint32_t</span> cflags;    <span class="comment">/* compile flags */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Per-vCPU dynamic tracing state used to generate this TB */</span></span><br><span class="line">    <span class="type">uint32_t</span> trace_vcpu_dstate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Above fields used for comparing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* size of target code for this block (1 &lt;= size &lt;= TARGET_PAGE_SIZE) */</span></span><br><span class="line">    <span class="type">uint16_t</span> size;</span><br><span class="line">    <span class="type">uint16_t</span> icount;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tb_tc</span> <span class="title">tc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* first and second physical page containing code. The lower bit</span></span><br><span class="line"><span class="comment">       of the pointer tells the index in page_next[].</span></span><br><span class="line"><span class="comment">       The list is protected by the TB&#x27;s page(&#x27;s) lock(s) */</span></span><br><span class="line">    <span class="type">uintptr_t</span> page_next[<span class="number">2</span>];</span><br><span class="line">    <span class="type">tb_page_addr_t</span> page_addr[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* jmp_lock placed here to fill a 4-byte hole. Its documentation is below */</span></span><br><span class="line">    QemuSpin jmp_lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The following data are used to directly call another TB from</span></span><br><span class="line"><span class="comment">     * the code of this one. This can be done either by emitting direct or</span></span><br><span class="line"><span class="comment">     * indirect native jump instructions. These jumps are reset so that the TB</span></span><br><span class="line"><span class="comment">     * just continues its execution. The TB can be linked to another one by</span></span><br><span class="line"><span class="comment">     * setting one of the jump targets (or patching the jump instruction). Only</span></span><br><span class="line"><span class="comment">     * two of such jumps are supported.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint16_t</span> jmp_reset_offset[<span class="number">2</span>]; <span class="comment">/* offset of original jump target */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TB_JMP_RESET_OFFSET_INVALID 0xffff <span class="comment">/* indicates no jump generated */</span></span></span><br><span class="line">    <span class="type">uintptr_t</span> jmp_target_arg[<span class="number">2</span>];  <span class="comment">/* target address or offset */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Each TB has a NULL-terminated list (jmp_list_head) of incoming jumps.</span></span><br><span class="line"><span class="comment">     * Each TB can have two outgoing jumps, and therefore can participate</span></span><br><span class="line"><span class="comment">     * in two lists. The list entries are kept in jmp_list_next[2]. The least</span></span><br><span class="line"><span class="comment">     * significant bit (LSB) of the pointers in these lists is used to encode</span></span><br><span class="line"><span class="comment">     * which of the two list entries is to be used in the pointed TB.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * List traversals are protected by jmp_lock. The destination TB of each</span></span><br><span class="line"><span class="comment">     * outgoing jump is kept in jmp_dest[] so that the appropriate jmp_lock</span></span><br><span class="line"><span class="comment">     * can be acquired from any origin TB.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * jmp_dest[] are tagged pointers as well. The LSB is set when the TB is</span></span><br><span class="line"><span class="comment">     * being invalidated, so that no further outgoing jumps from it can be set.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * jmp_lock also protects the CF_INVALID cflag; a jump must not be chained</span></span><br><span class="line"><span class="comment">     * to a destination TB that has CF_INVALID set.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uintptr_t</span> jmp_list_head;</span><br><span class="line">    <span class="type">uintptr_t</span> jmp_list_next[<span class="number">2</span>];</span><br><span class="line">    <span class="type">uintptr_t</span> jmp_dest[<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PPI_QR_FUNC</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tb_trace</span> *<span class="title">tt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tb_mem</span> *<span class="title">tm</span>;</span></span><br><span class="line">    <span class="type">int</span> cpu_id;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>{standard input}: Assembler messages: {standard input}:166160:
Warning: end of file not at end of a line; newline inserted {standard
input}:166333: Error: expected comma after name
`_ZNSt8_Rb_treeIiSt4pairIKiSt3setI11met' in .size directive
x86_64-xxx-linux-g++: internal compiler error: Killed (program cc1plus)
Please submit a full bug report, with preprocessed source if
appropriate. See for instructions. make[3]: *** [mds/Server.lo] Error 1
make[3]: *** Waiting for unfinished jobs....</p>
<p>这个错误的原因通常是，host机器内存不够导致的。
解决的办法是增加内存。硬件上的增加内存可以解决，或者kill系统当前其他的applications。甚至重新启动host，给编译器一个较为宽松的运行环境</p>
<p>QEMU以TB为单位进行翻译并执行。这也就是说每当在code
cache执行完一个TB之后，控制权必须交还给QEMU。这很没有效率。所以只要TB执行完之后，它的跳跃目标确定且该跳跃目标也已经在code
cache里，那我们就把这两个TB串接起来。这个就叫做block
chaining。有时QEMU开始执行一个基本块，然后被中断。然后，它可能会从一开始就重新执行该块，或者转换尚未执行的块的一部分并执行它。这将导致edge
map中出现一些额外的edge。所以首先禁用QEMU的chaining特性。</p>
<p>Tcgout branch生成两条 条件分支 一条b翻译成四条 非条件 条件 8条 jmmj
tcg_out_bl 条件跳转 翻译成call指令 改pc calue target
Guest知道bb最后一条</p>
<p>Tcg gencode预测 翻译的时候记录指令 在此之前disas已经完成
在这里插入跳转指令</p>
<p>2&gt; 输出系统错误</p>
<p>guest -&gt; ir -&gt; host</p>
<p>printf会影响回调函数的个数?</p>
<ol type="1">
<li>start_callback
是当前block执行前执行的函数，在里面对当前block的最后一条分支指令进行分支预测。</li>
<li>在当前block跳转指令执行前确定分支指令的跳转情况，用这个真实的跳转信息更新预测器</li>
<li>修改ir的目标地址，使得下一个block为预测方向的block</li>
<li>在错误路径执行N个block后恢复上次保存的信息，恢复到正常流程(N可以先写个固定的interval
比如5个block)</li>
</ol>
<ul>
<li>cpu_gen_code 負責 guest binary → TCG IR → host binary 的翻譯。
<ul>
<li>gen_intermediate_code_internal (target-*/translate.c) 初始化並呼叫
disas_insn 反組譯 guest binary 成 TCG IR。
<ul>
<li>disas_insn 呼叫 tcg_gen_xxx (tcg/tcg-op.h) 產生 TCG IR。分別將
opcode 寫入 gen_opc_ptr 指向的緩衝區 (translate-all.c 裡的 gen_opc_buf);
operand 寫入 gen_opparam_ptr 指向的緩衝區 (translate-all.c 裡的
gen_opparam_buf )。</li>
</ul></li>
<li>tcg_gen_code (tcg/tcg.c) 呼叫 tcg_gen_code_common (tcg/tcg.c) 將 TCG
IR 轉成 host binary</li>
</ul></li>
<li>tb_find_fast/slow 傳回 translation block 後，交給 tcg_qemu_tb_exec
執行。</li>
</ul>
<ol start="0" type="1">
<li>插桩 start_cb, 插在BB块开始的部分，会随着BB一起翻译、执行</li>
<li>翻译代码 Guest ---(teg_gen)--&gt; IR ---(tcg_out)--&gt; Host
<ul>
<li>aarch64_tr_translate_insn 调用tcg_gen</li>
<li>在tcg_out_xxx中插桩，在执行阶段中会被执行</li>
</ul></li>
<li>执行host代码</li>
</ol>
<h2 id="以cbz指令为例">以cbz指令为例</h2>
<p>Guest(arrch64) ---(teg_gen)--&gt; IR ---(tcg_out)--&gt; Host(i386)
tcg_gen_brcondi_i64(tcg/tcg-op.c)生成 ir</p>
<p>brcond_i64 tmp2,<span class="math inline">\(0x0,eq,\)</span>L1</p>
<p>目标 找到一条arrch64的分支指令究竟被翻译成了哪些IR
这些IR又变成了哪些host指令(i386) 然后
在tcg_out中插桩，获得我想要的真实信息，篡改执行的BB块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tcg_out_op</span><span class="params">(TCGContext* s, TCGOpcode opc, <span class="type">const</span> TCGArg* args, <span class="type">const</span> <span class="type">int</span>* const_args)</span></span><br><span class="line">&#123;</span><br><span class="line">    TCGArg a0, a1, a2;</span><br><span class="line">    <span class="type">int</span> c, const_a2, vexop, rexw = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取最常见的参数 Hoist the loads of the most common arguments.  */</span></span><br><span class="line">    a0 = args[<span class="number">0</span>];     <span class="comment">// = TCG_REG_EBP, 代表要比较的寄存器</span></span><br><span class="line">    a1 = args[<span class="number">1</span>];    <span class="comment">// = 0, 要比较的常数</span></span><br><span class="line">    a2 = args[<span class="number">2</span>];    <span class="comment">// = 0x9, 表示分支的条件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (opc) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> INDEX_op_brcond_i32:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            a2: 表示分支条件; </span></span><br><span class="line"><span class="comment">            a0 a1为要比较的变量和值, </span></span><br><span class="line"><span class="comment">            const_args[1]: 表示a1是否为常数</span></span><br><span class="line"><span class="comment">            arg_label(args[3]): 表示跳转目标的标签</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        tcg_out_brcond32(s, a2, a0, a1, const_args[<span class="number">1</span>], arg_label(args[<span class="number">3</span>]), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">accel/tcg/translate-all.c::tb_gen_code --&gt;&gt; </span><br><span class="line">tcg/tcg.c::tcg_gen_code --&gt;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TCGContext</span> &#123;</span></span><br><span class="line">    ...;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> gen_next_op_idx;    <span class="comment">//写入下一个操作码的位置</span></span><br><span class="line">    <span class="type">int</span> gen_next_parm_idx;    <span class="comment">//写入下一个操作数的位置</span></span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line"></span><br><span class="line">    TCGOp gen_op_buf[OPC_BUF_SIZE]; <span class="comment">//保存生成的中间指令</span></span><br><span class="line">    TCGArg gen_opparam_buf[OPPARAM_BUF_SIZE];   <span class="comment">//保存中间指令的操作数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> gen_insn_end_off[TCG_MAX_INSNS];</span><br><span class="line">    target_ulong gen_insn_data[TCG_MAX_INSNS][TARGET_INSN_START_WORDS];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line">    <span class="comment">/// 放Host指令的地方</span></span><br><span class="line">    <span class="type">void</span> *code_gen_buffer;      <span class="comment">//保存生成的指令的缓冲区</span></span><br><span class="line">    <span class="type">size_t</span> code_gen_buffer_size;    <span class="comment">//缓冲区大小</span></span><br><span class="line">    <span class="type">void</span> *code_gen_ptr;     <span class="comment">//写入下一个生成指令的位置, 位于code_gen_buffer内部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TCGCond</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    <span class="comment">/* non-signed */</span></span><br><span class="line">    TCG_COND_NEVER  = <span class="number">0</span> | <span class="number">0</span> | <span class="number">0</span> | <span class="number">0</span>,</span><br><span class="line">    TCG_COND_ALWAYS = <span class="number">0</span> | <span class="number">0</span> | <span class="number">0</span> | <span class="number">1</span>,</span><br><span class="line">    TCG_COND_EQ     = <span class="number">8</span> ,</span><br><span class="line">    TCG_COND_NE     = <span class="number">9</span>,</span><br><span class="line">    <span class="comment">/* signed */</span></span><br><span class="line">    TCG_COND_LT     = <span class="number">0</span> | <span class="number">0</span> | <span class="number">2</span> | <span class="number">0</span>,</span><br><span class="line">    TCG_COND_GE     = <span class="number">0</span> | <span class="number">0</span> | <span class="number">2</span> | <span class="number">1</span>,</span><br><span class="line">    TCG_COND_LE     = <span class="number">8</span> | <span class="number">0</span> | <span class="number">2</span> | <span class="number">0</span>,</span><br><span class="line">    TCG_COND_GT     = <span class="number">8</span> | <span class="number">0</span> | <span class="number">2</span> | <span class="number">1</span>,</span><br><span class="line">    <span class="comment">/* unsigned */</span></span><br><span class="line">    TCG_COND_LTU    = <span class="number">0</span> | <span class="number">4</span> | <span class="number">0</span> | <span class="number">0</span>,</span><br><span class="line">    TCG_COND_GEU    = <span class="number">0</span> | <span class="number">4</span> | <span class="number">0</span> | <span class="number">1</span>,</span><br><span class="line">    TCG_COND_LEU    = <span class="number">8</span> | <span class="number">4</span> | <span class="number">0</span> | <span class="number">0</span>,</span><br><span class="line">    TCG_COND_GTU    = <span class="number">8</span> | <span class="number">4</span> | <span class="number">0</span> | <span class="number">1</span>,</span><br><span class="line">&#125; TCGCond;</span><br></pre></td></tr></table></figure>
<p>armv8指令手册 page202 Unconditional branch BL Branch with link BR
Branch to register BLR Branch with link to register</p>
<p>Conditional branch B.cond Branch conditionally CBNZ Compare and
branch if nonzero CBZ Compare and branch if zero TBNZ Test bit and
branch if nonzero TBZ Test bit and branch if zero</p>
<p>翻译的时候已经拿到预测结果 所以可以强行在tcg_out加跳转指令，
但是同时还需要知道真实的跳转指令，以便决定后面是否需要恢复
我可以利用重定向来进行篡改</p>
<h1 id="prologue初始化">prologue初始化</h1>
<ul>
<li>prologue 用来切换 qemu 代码和 code cache 的代码上下文，在
tcg_prologue_init(tcg_ctx) 调用 host 的 tcg_target_qemu_prologue
来组装这块代码。</li>
</ul>
<p>在x86上组装出来的代码如下: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0x5644ca0ab000:  push   %rbp               //函数调用过程中将callee saved的入栈保存,完成了callee本身需要做的事情，因此在执行tb代码时可以使用所有的寄存器，在tb执行过程中不遵循函数调用的接口规范了</span><br><span class="line">0x5644ca0ab001:  push   %rbx  </span><br><span class="line">0x5644ca0ab002:  push   %r12  </span><br><span class="line">0x5644ca0ab004:  push   %r13  </span><br><span class="line">0x5644ca0ab006:  push   %r14  </span><br><span class="line">0x5644ca0ab008:  push   %r15  </span><br><span class="line">0x5644ca0ab00a:  mov    %rdi,%r14      //env到r14中，本身指向CPULOONGARCHState的对象，tb操作的对象都在</span><br><span class="line">0x5644ca0ab00d:  add    $0xfffffffffffffb78,%rsp      //</span><br><span class="line">0x5644ca0ab014:  jmpq   *%rsi      //跳转的tb的起始位置</span><br><span class="line"></span><br><span class="line">0x5644ca0ab016:  xor    %eax,%eax           //epilogue位置，返回值为0. 主要是为了goto_ptr使用</span><br><span class="line">0x5644ca0ab018:  add    $0x488,%rsp      //正常退出</span><br><span class="line">0x5644ca0ab01f:  emms   </span><br><span class="line">0x5644ca0ab022:  pop    %r15          //saved寄存器出栈</span><br><span class="line">0x5644ca0ab024:  pop    %r14  </span><br><span class="line">0x5644ca0ab026:  pop    %r13  </span><br><span class="line">0x5644ca0ab028:  pop    %r12  </span><br><span class="line">0x5644ca0ab02a:  pop    %rbx  </span><br><span class="line">0x5644ca0ab02b:  pop    %rbp  </span><br><span class="line">0x5644ca0ab02c:  retq                    //退出到qemu中</span><br></pre></td></tr></table></figure></p>
<h1 id="frontend的翻译">frontend的翻译</h1>
<ul>
<li>在target指令翻译过程TB以跳转指令结束，其他指令只需要根据语义翻译成IR指令就可以。
<ul>
<li>其中比较特殊的是跳转指令，TB开始和TB结束时的一些特殊代码. ##
TB开始位置: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gen_tb_start</span><br><span class="line">    ld_i32 tmp0,env,$0xffffffffffffffe4        //env指向CPULOONGARCHState，偏移是CPUState.icount_decr.u32相对于env的偏移;</span><br><span class="line">    movi_i32 tmp1,$0x0</span><br><span class="line">    brcond_i32 tmp0,tmp1,lt,$L0        //如果icount_decr.u32小于0则跳转到label 0处</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<p>参考文档:
https://qemu.readthedocs.io/en/latest/devel/tcg-icount.html</p>
<ul>
<li>icount只有在SOFTMMU中才有用，并且不能用在multi-threaded TCG
中，主要用于执行过程中指令的计数，后面详细再讲。</li>
</ul>
<h2 id="tb结束">TB结束:</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gen_tb_end</span><br><span class="line">   set_label $L0            //生成一个label 0，给`br $label`或者`brcond_i32/i64 label`，`goto_tb`这些提供錨点</span><br><span class="line">   exit_tb $0x55f975f8bec3     //退出到tb_ret_addr</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2023/02/07/C%E8%AF%AD%E8%A8%80%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2023/02/07/C%E8%AF%AD%E8%A8%80%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/" class="post-title-link" itemprop="url">C语言内联汇编</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-07 17:28:50" itemprop="dateCreated datePublished" datetime="2023-02-07T17:28:50+08:00">2023-02-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:18" itemprop="dateModified" datetime="2023-07-30T18:15:18+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/C-C-asm/" itemprop="url" rel="index"><span itemprop="name">C/C++ asm</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>877</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="basic-inline.">0. Basic Inline.</h1>
<ul>
<li>The format of basic inline assembly is very much straight forward.
Its basic form is ## 基本形式: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;assembly code&quot;</span>);</span><br></pre></td></tr></table></figure> ## Example. <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;movl %ecx %eax&quot;</span>); <span class="comment">/* moves the contents of ecx to eax */</span></span><br></pre></td></tr></table></figure>
## 说明:</li>
</ul>
<ol type="1">
<li>asm的语法规定mov的方向是从左到右，即<code>mov %src %dst</code> # 1.
extended assembly</li>
</ol>
<ul>
<li>可指定输入、输出,与asm外部的C程序交互 ## 基本形式: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> ( assembler template </span><br><span class="line">    : output operands                  <span class="comment">/* optional */</span></span><br><span class="line">    : input operands                   <span class="comment">/* optional */</span></span><br><span class="line">    : <span class="built_in">list</span> of clobbered registers      <span class="comment">/* optional */</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure> ##
说明:</li>
</ul>
<ol type="1">
<li>output
operands代表输出值，即该值可在执行中从asm寄存器获取到外部C程序中</li>
<li>input
operands代表输入值，即该值可从外部C程序传递给asm中的寄存器</li>
<li>list of clobbered
registers代表这段内联汇编执行后，哪些寄存器的值被破坏，来告知编译器做好备份和恢复工作
## Example</li>
</ol>
<ul>
<li>Example1: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>, b;</span><br><span class="line"><span class="keyword">asm</span> (<span class="string">&quot;movl %1, %%eax; </span></span><br><span class="line"><span class="string">      movl %%eax, %0;&quot;</span></span><br><span class="line">     :<span class="string">&quot;=r&quot;</span>(b)        <span class="comment">/* output */</span></span><br><span class="line">     :<span class="string">&quot;r&quot;</span>(a)         <span class="comment">/* input */</span></span><br><span class="line">     :<span class="string">&quot;%eax&quot;</span>         <span class="comment">/* clobbered register */</span></span><br><span class="line">     );  </span><br></pre></td></tr></table></figure>
<ul>
<li>第一行将a的内容写入<code>%eax</code></li>
<li>第二行将<code>%eax</code>的内容输出到b</li>
<li><code>%1</code>,<code>%0</code>是占位符，会根据顺序和位置在下面的output、input匹配对应的的变量
<ul>
<li><code>%src</code>匹配input ；<code>%dst</code>匹配output</li>
</ul></li>
</ul></li>
</ul>
<p>Check out the <a
target="_blank" rel="noopener" href="https://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">GCC
Inline Assembly</a> for more info on how to get the most out of ASM.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/zyhjy/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/zyhjy/">1</a><span class="space">&hellip;</span><a class="page-number" href="/zyhjy/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/zyhjy/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/zyhjy/page/8/">8</a><a class="extend next" rel="next" href="/zyhjy/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yuhang Zhang"
      src="/zyhjy/images/zyhjy.png">
  <p class="site-author-name" itemprop="name">Yuhang Zhang</p>
  <div class="site-description" itemprop="description">爱小雅，爱生活，爱物理!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/zyhjy/archives/">
        
          <span class="site-state-item-count">75</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/zyhjy/categories/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/zyhjy/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/zyhjy/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuhang Zhang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">407k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">11:19</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/zyhjy/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>

<script src="/zyhjy/js/utils.js"></script>


<script src="/zyhjy/js/schemes/pisces.js"></script>


<script src="/zyhjy/js/next-boot.js"></script>




  




  
<script src="/zyhjy/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>


</body>
</html>
