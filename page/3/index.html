<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
<meta name="referrer" content="no-referrer">
  <link rel="apple-touch-icon" sizes="180x180" href="/zyhjy/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/zyhjy/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/zyhjy/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/zyhjy/images/logo.svg" color="#222">

<link rel="stylesheet" href="/zyhjy/css/main.css">

<link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css?family=Comic Sans MS:300,300italic,400,400italic,700,700italic|Noto Serif SC:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/zyhjy/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zyh-eric.gitee.io","root":"/zyhjy/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="爱小雅，爱生活，爱物理!">
<meta property="og:type" content="website">
<meta property="og:title" content="ZYHJY">
<meta property="og:url" content="https://zyh-eric.gitee.io/zyhjy/page/3/">
<meta property="og:site_name" content="ZYHJY">
<meta property="og:description" content="爱小雅，爱生活，爱物理!">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yuhang Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zyh-eric.gitee.io/zyhjy/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>ZYHJY</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/zyhjy/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ZYHJY</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/zyhjy/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/zyhjy/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/zyhjy/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/zyhjy/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/zyhjy/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2023/03/21/Effective%20C++(7)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2023/03/21/Effective%20C++(7)/" class="post-title-link" itemprop="url">Effective C++(7)--模版与范型编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-21 11:37:00" itemprop="dateCreated datePublished" datetime="2023-03-21T11:37:00+08:00">2023-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:32" itemprop="dateModified" datetime="2023-07-30T18:15:32+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="条款44-将参数无关的代码抽离templates"><a href="#条款44-将参数无关的代码抽离templates" class="headerlink" title="条款44 将参数无关的代码抽离templates"></a>条款44 将参数无关的代码抽离templates</h1><ul>
<li><code>template</code>可能会带来膨胀的重复的二进制代码</li>
<li>在<code>template</code>代码中，重复是隐晦的</li>
</ul>
<h2 id="EG1-固定尺寸的正方矩阵的template"><a href="#EG1-固定尺寸的正方矩阵的template" class="headerlink" title="EG1. 固定尺寸的正方矩阵的template"></a>EG1. 固定尺寸的正方矩阵的template</h2><h3 id="原始版本"><a href="#原始版本" class="headerlink" title="原始版本"></a>原始版本</h3><ul>
<li>n * n矩阵，元素类型是<code>T</code>，支持矩阵求逆<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;	<span class="comment">/// n * n矩阵，元素类型是T</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/// ...</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">()</span></span>;	<span class="comment">/// 求逆矩阵</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SquareMatrix&lt;<span class="type">double</span>, <span class="number">5</span>&gt; sm1;</span><br><span class="line">sm1.<span class="built_in">invert</span>();	<span class="comment">/// 调用SquareMatrix&lt;double, 5&gt;::invert()</span></span><br><span class="line">SquareMatrix&lt;<span class="type">double</span>, <span class="number">10</span>&gt; sm2;</span><br><span class="line">sm2.<span class="built_in">invert</span>();	<span class="comment">/// 调用SquareMatrix&lt;double, 10&gt;::invert()</span></span><br></pre></td></tr></table></figure></li>
<li>这里具现化两份invert代码，但是除了常量5和10，代码完全相同</li>
</ul>
<h3 id="Mod1-建立带参数的函数"><a href="#Mod1-建立带参数的函数" class="headerlink" title="Mod1.  建立带参数的函数"></a>Mod1.  建立带参数的函数</h3><ul>
<li>以5和10调用函数，减少重复代码<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;	<span class="comment">/// 与尺寸无关的base class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">/// ...</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">(std::<span class="type">size_t</span> matrixSize)</span></span>;	<span class="comment">/// 求逆矩阵</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;	<span class="comment">/// n * n矩阵，元素类型是T</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> : <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">using</span> SquareMatrixBase&lt;T&gt;::invert;	<span class="comment">/// 避免遮掩，见条款33</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/// ...</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>-&gt;<span class="built_in">invert</span>(n); &#125;;	<span class="comment">/// inline版的的调用，why this-&gt;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><code>SquareMatrixBase</code>模板只对元素类型T初始化，不对矩阵的尺寸参数初始化</li>
<li>Eg1中的<code>sm1</code>和<code>sm2</code>将共享<code>SquareMatrixBase&lt;double&gt;::invert</code></li>
<li><code>SquareMatrixBase&lt;double&gt;::invert</code>避免派生类代码重复</li>
<li>inline : 额外的调用成本是0</li>
<li>若不使用this-&gt;，模板化基类SquareMatrixBase<T>内的函数名会被派生类遮掩(条款43？)</li>
<li>private继承，仅帮助实现，不是表现is-a的关系(条款39？)</li>
</ul>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul>
<li><code>SquareMatrixBase&lt;T&gt;::invert</code>如何知道矩阵数据在哪</li>
</ul>
<h3 id="Mod2-令SquareMatrixBase储存一个指针"><a href="#Mod2-令SquareMatrixBase储存一个指针" class="headerlink" title="Mod2.  令SquareMatrixBase储存一个指针"></a>Mod2.  令SquareMatrixBase储存一个指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">SquareMatrixBase</span>(<span class="type">size_t</span> Size, T *pMem) : <span class="built_in">size</span>(Size), <span class="built_in">pData</span>(pMem) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setDataPtr</span><span class="params">(T *PData)</span> </span>&#123; pData = PData; &#125;</span><br><span class="line">	<span class="comment">/// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::<span class="type">size_t</span> size;</span><br><span class="line">	T* pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>这允许Derived Classes决定内存分配方式<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 该版本将矩阵数据存储在SquareMatrix内部</span></span><br><span class="line"><span class="comment">/// 这种类型的对象不需要动态内存分配，但对象自身可能非常大</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;	<span class="comment">/// n * n矩阵，元素类型是T</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> : <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SquareMatrix</span>() : <span class="built_in">SquareMatrixBase</span>&lt;T&gt;(n, data) &#123;&#125;;</span><br><span class="line">	<span class="comment">/// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T data[n * n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 该版本将矩阵数据放入heap</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;	<span class="comment">/// n * n矩阵，元素类型是T</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> : <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SquareMatrix</span>()</span><br><span class="line">		: <span class="built_in">SquareMatrixBase</span>&lt;T&gt;(n, <span class="literal">nullptr</span>), <span class="built_in">pData</span>(<span class="keyword">new</span> T[n * n])</span><br><span class="line">		&#123; <span class="keyword">this</span>-&gt;<span class="built_in">setDataPtr</span>(pData.<span class="built_in">get</span>()); &#125;</span><br><span class="line">	<span class="comment">/// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::array&lt;T&gt; pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>SquareMatrix成员函数可以单纯的以inline方式调用base class版本<ul>
<li>后者由持相同T的矩阵共享</li>
</ul>
</li>
<li>强行绑定矩阵尺寸的invert[Eg1.]<ul>
<li>可能有更好的编译器实现和优化，但是会有大量重复的二进制代码</li>
</ul>
</li>
<li>不绑定尺寸的invert[Mod1., Mod2.]<ul>
<li>减少执行文件大小</li>
<li>降低程序的working set大小，(一个在VM下执行的进程所使用的那一组内存页)</li>
<li>强化指令高速缓冲区内的引用集中化(locality)</li>
</ul>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>template不该与造成膨胀的模板参产生关系</li>
<li>non-type template parameters(非类型模板参数)造成的代码膨胀，往往可以消除，做法是用函数或class成员变量替换template参数</li>
</ul>
<h2 id="type-parameters-类型参数-也会带来代码膨胀"><a href="#type-parameters-类型参数-也会带来代码膨胀" class="headerlink" title="type parameters(类型参数)也会带来代码膨胀"></a>type parameters(类型参数)也会带来代码膨胀</h2><ul>
<li>如许多平台上int和long有相同的二进制表述<ul>
<li>vector<int>和vector<long>应该共用一份底层实现</li>
</ul>
</li>
<li>指针往往也具有相同的二进制表述</li>
<li>让有相同的二进制表述的具现类型(instantiation types)共享实现码</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2023/02/07/Qemu%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2023/02/07/Qemu%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">Qemu使用记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-07 17:28:50" itemprop="dateCreated datePublished" datetime="2023-02-07T17:28:50+08:00">2023-02-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:18" itemprop="dateModified" datetime="2023-07-30T18:15:18+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-Qemu说明"><a href="#1-Qemu说明" class="headerlink" title="1. Qemu说明"></a>1. Qemu说明</h1><ul>
<li>通用的开源机器和用户空间模拟器和虚拟器</li>
<li>具体内容见官网<code>https://github.com/qemu/qemu</code></li>
<li>比如：Qemu可以模拟出一个ARM系统中的：CPU. 内存. IO设备等，然后在这个模拟层之上，可以跑一台ARM虚拟机，这个ARM虚拟机认为自己在和硬件进行打交道，但实际上这些硬件都是Qemu模拟出来的。</li>
</ul>
<h2 id="Qemu的两种模式"><a href="#Qemu的两种模式" class="headerlink" title="Qemu的两种模式"></a>Qemu的两种模式</h2><ol>
<li>用户模式(User mode)：利用动态代码翻译机制来执行不同主机架构的代码，例如：在x86平台上模拟执行ARM代码，也就是说：我们写一条ARM指令，传入整个模拟器中，模拟器会把整个指令翻译成x86平台的指令，然后在x86的CPU中执行。</li>
<li>系统模式(System mode)：模拟整个电脑系统，利用其它VMM(Xen, KVM)来使用硬件提供的虚拟化支持，创建接近于主机性能的全功能虚拟机。</li>
</ol>
<h1 id="2-qemu执行流程"><a href="#2-qemu执行流程" class="headerlink" title="2. qemu执行流程"></a>2. qemu执行流程</h1><h2 id="0-宏"><a href="#0-宏" class="headerlink" title="0. 宏"></a>0. 宏</h2><ul>
<li><code>#ifdef PPI_QR_FUNC</code> 宏是我们所有改动加的宏</li>
</ul>
<h2 id="1-qemu启动"><a href="#1-qemu启动" class="headerlink" title="1. qemu启动"></a>1. qemu启动</h2><ul>
<li>file: softmmu&#x2F;vl.c</li>
<li>初始化参数</li>
<li>调用vcpu初始化。</li>
</ul>
<h2 id="2-vcpu初始化"><a href="#2-vcpu初始化" class="headerlink" title="2. vcpu初始化"></a>2. vcpu初始化</h2><ul>
<li>file: target&#x2F;arm&#x2F;cpu64.c</li>
<li>func:<ul>
<li>aarch64_cpu_class_init</li>
<li>aarch64_cpu_instance_init<ul>
<li>对cpu实例进行初始化</li>
<li>共享内存初始化(包括qemu要用的向gem5传输的共享内存)<ul>
<li>ringbuf_init  进行初始化环形队列。</li>
<li>第二块共享内存是shm_init。</li>
</ul>
</li>
<li>每个qemu vcpu会初始化调用一次aarch64_cpu_instance_init<ul>
<li>eg：run.sh里是16 cpu，那么就调用16次aarch64_cpu_instance_init，所以 也会初始化16个ringbuf_init，共享内存队列，每个核维护一个。key_insoff+channel_d+i是每个共享内存的id。</li>
</ul>
</li>
<li>这里面的cpu以及cpu-&gt;env就是 qemu的vcpu，其中cpu-&gt;env就是cpuarmstate。这个时候已经初始化完毕。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-翻译"><a href="#3-翻译" class="headerlink" title="3. 翻译"></a>3. 翻译</h2><ul>
<li>初始化之后开始主流程翻译</li>
<li>翻译是两步，<ol>
<li>guest-&gt;ir</li>
<li>ir-&gt;host</li>
</ol>
<ul>
<li>eg: 也就是比如 用户程序是 arm，arm-&gt;ir  ir-&gt;x86 code，host运行x86 code。如果是用户程序是x86，host也是，那么不用翻译，直接在host上执行。</li>
</ul>
</li>
</ul>
<h3 id="guest-ir"><a href="#guest-ir" class="headerlink" title="guest-&gt;ir"></a>guest-&gt;ir</h3><ol>
<li>调用<code>tb_find</code>[accel&#x2F;tcg&#x2F;cpu-exec.c]<ul>
<li>找是否有翻译过,若无则进行2.(刚开始肯定无)</li>
</ul>
</li>
<li>调用<code>tb_gen_code</code>[accel&#x2F;tcg&#x2F;cpu-exec.c]<ul>
<li>翻译主函数</li>
</ul>
</li>
<li>这个又调用gen_intermediate_code，<ul>
<li>进行guest-&gt;ir的翻译。</li>
</ul>
</li>
<li>上面又继续调用translator_loop<ul>
<li>来到accel&#x2F;tcg&#x2F;translator.c。</li>
<li>translator_loop 函数 对tb里的每一个指令 进行翻译。</li>
<li>while (true)就是每条指令循环翻译。</li>
</ul>
</li>
<li>aarch64_tr_translate_insn函数。<ul>
<li>添加函数名，target&#x2F;arm&#x2F;translate-a64.c</li>
</ul>
</li>
<li>调用disas_a64_insn  <ul>
<li>就是每个指令进行decoder</li>
<li>里面switch (extract32(insn, 25, 4)) {  看是哪类指令。</li>
</ul>
</li>
</ol>
<ul>
<li>至此完成了 guest-&gt;ir的翻译。</li>
</ul>
<h3 id="ir-host的暂不考虑"><a href="#ir-host的暂不考虑" class="headerlink" title="ir-&gt;host的暂不考虑"></a>ir-&gt;host的暂不考虑</h3><h2 id="4-执行"><a href="#4-执行" class="headerlink" title="4. 执行"></a>4. 执行</h2><ul>
<li>翻译之后，host代码已经生成，需要执行。</li>
<li>我们采用在guest的tb开始和结束前插callback函数的方式<ul>
<li>target&#x2F;arm&#x2F;translate.c 里的函数<ul>
<li>helper_start_callback插在tb执行开始前的。插在它tb guest的开头，</li>
<li><code>helper_end_callback</code>在结尾</li>
<li>会随tb一起翻译。</li>
</ul>
</li>
</ul>
</li>
<li>那么执行就是先 helper_start_callback -&gt; tb -&gt; helper_end_callback</li>
<li>当执行helper_end_callback的时候，整个tb都执行好了。</li>
<li>所以可以对下一个执行的tb进行预测。</li>
<li>tb-&gt;tt里存放我们记下来的tb的trace，包括 pc insn。</li>
<li>env-&gt;sendbuf-&gt;real_insn_num记了tb的实际指令数。</li>
<li>helper_end_callback调用lookupAndUpdateNextPC预测。</li>
<li>执行tb 是一串二进制代码，无法代码操作。 只能通过cb来操作。</li>
<li>bt-&gt;IsControl 是true 说明是分支指令，需要存。所以在这里可以存cpu state</li>
</ul>
<h3 id="内存处理"><a href="#内存处理" class="headerlink" title="内存处理"></a>内存处理</h3><ul>
<li>主函数如果是ld st指令</li>
<li>mem信息我们额外插了cb进行收集mem 访存信息。 </li>
<li>ppi_insert_mem_st[tcg&#x2F;tcg-op.c]进行ld st插桩。<ul>
<li>函数体insert_mem_st[target&#x2F;arm&#x2F;translate.c]</li>
</ul>
</li>
<li><code>helper_load_callback</code> 里，env-&gt;sendbuf 是 cpu armstate结构体里划出来的一块临时内存。</li>
<li>mem cb里会将mem trace 记在这里。</li>
<li>env里是否有mem的寄存器信息？</li>
<li>到end cb的时候，helper_load_callback里的所有东西都记好了，env的sendbuf里有完整的tb里的mem insn trace</li>
</ul>
<h2 id="qemu主函数调用"><a href="#qemu主函数调用" class="headerlink" title="qemu主函数调用"></a>qemu主函数调用</h2><ol>
<li><p>main[.&#x2F;softmmu&#x2F;vl.c]</p>
</li>
<li><p>aarch64_cpu_instance_init[target&#x2F;arm&#x2F;cpu64.c]</p>
</li>
<li><p>aarch64_cpu_class_init[target&#x2F;arm&#x2F;cpu64.c]</p>
</li>
<li><p>cpu_exec[accel&#x2F;tcg&#x2F;cpu-exec.c]</p>
<ul>
<li>main execution loop</li>
</ul>
<ol>
<li>tb_gen_code[accel&#x2F;tcg&#x2F;translate-all.c]<ul>
<li>生成下一个tb块代码</li>
</ul>
<ol>
<li>cpu_loop_exit[accel&#x2F;tcg&#x2F;cpu-exec-common.c]<ul>
<li>exit the current TB</li>
<li>抛出异常时触发</li>
</ul>
<ol>
<li>helper_end_callback[target&#x2F;arm&#x2F;translate.c]<ul>
<li>移植了gem5的分支预测器</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li>cpu_loop_exec_tb[accel&#x2F;tcg&#x2F;cpu-exec.c]<ol>
<li>cpu_tb_exec[accel&#x2F;tcg&#x2F;cpu-exec.c]</li>
</ol>
</li>
</ol>
</li>
<li><p>cpu_exec_exit[accel&#x2F;tcg&#x2F;cpu-exec.c]</p>
</li>
</ol>
<ul>
<li>退出qemu<code>ctrl+A+X</code></li>
</ul>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>分支预测加在了每个tb运行结束的末尾，在运行到tb末尾时进行预测<br>当下一个tb运行完之后，取出该tb的头地址，并与上次预测结果比对验证</p>
<p>checkpoint是系统层面的快照接口 在程序内部调用不好处理</p>
<p>接下来首先篡改执行的tb路径，即迫使qemu按照分支预测结果执行</p>
<p>在cpu_exec中主循环通过调用tb_lookup&#x2F;tb_gen_code来获得下一个执行的tb</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tb = tb_lookup(cpu, pc, cs_base, flags, cflags);</span><br><span class="line">tb = tb_gen_code(cpu, pc, cs_base, flags, cflags);</span><br></pre></td></tr></table></figure>
<p>我们可以通过改变cpu的pc来控制下一个tb，既可以迫使其走上错误分支，也可以再恢复状态后安排它执行正确的pc<br>pc在这里取出<code>cpu_get_tb_cpu_state(cpu-&gt;env_ptr, &amp;pc, &amp;cs_base, &amp;flags);</code>，根据<code>cpu-&gt;env_ptr</code>内的值<br>这个指针实际指向CPUARMState<br>cpu_get_tb_cpu_state[target&#x2F;arm&#x2F;helper.c]中pc的值分两种情况 pc &#x2F; regs[15]  怎么选取?</p>
<p>core的时候打屏可以 写文件不行</p>
<ul>
<li>s0, add a new file to do the following things</li>
<li>s1, todo: secondery pointer, deep copy the whole struct</li>
<li>s2, todo: backup the memory</li>
<li>s3, checkpoint?</li>
<li>当前仅修改pc，不做备份，只为了篡改执行路径</li>
</ul>
<p>分支当前的pc是tb块的最后一条指令(有时为跳转指令)的pc </p>
<p>Tiny Code Generator (TCG)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tb_trace</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> insn_num;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> pc_start;     <span class="comment">/* tb first pc */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trace_info</span> <span class="title">ti</span>[512];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TranslationBlock</span> &#123;</span></span><br><span class="line">    target_ulong pc;   <span class="comment">/* simulated PC corresponding to this block (EIP + CS base) */</span></span><br><span class="line">    target_ulong cs_base; <span class="comment">/* CS base for this block */</span></span><br><span class="line">    <span class="type">uint32_t</span> flags; <span class="comment">/* flags defining in which context the code was generated */</span></span><br><span class="line">    <span class="type">uint32_t</span> cflags;    <span class="comment">/* compile flags */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Per-vCPU dynamic tracing state used to generate this TB */</span></span><br><span class="line">    <span class="type">uint32_t</span> trace_vcpu_dstate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Above fields used for comparing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* size of target code for this block (1 &lt;= size &lt;= TARGET_PAGE_SIZE) */</span></span><br><span class="line">    <span class="type">uint16_t</span> size;</span><br><span class="line">    <span class="type">uint16_t</span> icount;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tb_tc</span> <span class="title">tc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* first and second physical page containing code. The lower bit</span></span><br><span class="line"><span class="comment">       of the pointer tells the index in page_next[].</span></span><br><span class="line"><span class="comment">       The list is protected by the TB&#x27;s page(&#x27;s) lock(s) */</span></span><br><span class="line">    <span class="type">uintptr_t</span> page_next[<span class="number">2</span>];</span><br><span class="line">    <span class="type">tb_page_addr_t</span> page_addr[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* jmp_lock placed here to fill a 4-byte hole. Its documentation is below */</span></span><br><span class="line">    QemuSpin jmp_lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The following data are used to directly call another TB from</span></span><br><span class="line"><span class="comment">     * the code of this one. This can be done either by emitting direct or</span></span><br><span class="line"><span class="comment">     * indirect native jump instructions. These jumps are reset so that the TB</span></span><br><span class="line"><span class="comment">     * just continues its execution. The TB can be linked to another one by</span></span><br><span class="line"><span class="comment">     * setting one of the jump targets (or patching the jump instruction). Only</span></span><br><span class="line"><span class="comment">     * two of such jumps are supported.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint16_t</span> jmp_reset_offset[<span class="number">2</span>]; <span class="comment">/* offset of original jump target */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TB_JMP_RESET_OFFSET_INVALID 0xffff <span class="comment">/* indicates no jump generated */</span></span></span><br><span class="line">    <span class="type">uintptr_t</span> jmp_target_arg[<span class="number">2</span>];  <span class="comment">/* target address or offset */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Each TB has a NULL-terminated list (jmp_list_head) of incoming jumps.</span></span><br><span class="line"><span class="comment">     * Each TB can have two outgoing jumps, and therefore can participate</span></span><br><span class="line"><span class="comment">     * in two lists. The list entries are kept in jmp_list_next[2]. The least</span></span><br><span class="line"><span class="comment">     * significant bit (LSB) of the pointers in these lists is used to encode</span></span><br><span class="line"><span class="comment">     * which of the two list entries is to be used in the pointed TB.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * List traversals are protected by jmp_lock. The destination TB of each</span></span><br><span class="line"><span class="comment">     * outgoing jump is kept in jmp_dest[] so that the appropriate jmp_lock</span></span><br><span class="line"><span class="comment">     * can be acquired from any origin TB.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * jmp_dest[] are tagged pointers as well. The LSB is set when the TB is</span></span><br><span class="line"><span class="comment">     * being invalidated, so that no further outgoing jumps from it can be set.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * jmp_lock also protects the CF_INVALID cflag; a jump must not be chained</span></span><br><span class="line"><span class="comment">     * to a destination TB that has CF_INVALID set.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uintptr_t</span> jmp_list_head;</span><br><span class="line">    <span class="type">uintptr_t</span> jmp_list_next[<span class="number">2</span>];</span><br><span class="line">    <span class="type">uintptr_t</span> jmp_dest[<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PPI_QR_FUNC</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tb_trace</span> *<span class="title">tt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tb_mem</span> *<span class="title">tm</span>;</span></span><br><span class="line">    <span class="type">int</span> cpu_id;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>{standard input}: Assembler messages:<br>{standard input}:166160: Warning: end of file not at end of a line; newline inserted<br>{standard input}:166333: Error: expected comma after name &#96;_ZNSt8_Rb_treeIiSt4pairIKiSt3setI11met’ in .size directive<br>x86_64-xxx-linux-g++: internal compiler error: Killed (program cc1plus)<br>Please submit a full bug report,<br>with preprocessed source if appropriate.<br>See for instructions.<br>make[3]: *** [mds&#x2F;Server.lo] Error 1<br>make[3]: *** Waiting for unfinished jobs….</p>
<p>这个错误的原因通常是，host机器内存不够导致的。 解决的办法是增加内存。硬件上的增加内存可以解决，或者kill系统当前其他的applications。甚至重新启动host，给编译器一个较为宽松的运行环境</p>
<p>QEMU以TB为单位进行翻译并执行。这也就是说每当在code cache执行完一个TB之后，控制权必须交还给QEMU。这很没有效率。所以只要TB执行完之后，它的跳跃目标确定且该跳跃目标也已经在code cache里，那我们就把这两个TB串接起来。这个就叫做block chaining。有时QEMU开始执行一个基本块，然后被中断。然后，它可能会从一开始就重新执行该块，或者转换尚未执行的块的一部分并执行它。这将导致edge map中出现一些额外的edge。所以首先禁用QEMU的chaining特性。</p>
<p>Tcgout branch生成两条<br>条件分支<br>一条b翻译成四条 非条件<br>条件 8条 jmmj<br>tcg_out_bl 条件跳转 翻译成call指令<br>改pc calue target<br>Guest知道bb最后一条</p>
<p>Tcg gencode预测<br>翻译的时候记录指令<br>在此之前disas已经完成<br>在这里插入跳转指令</p>
<p>2&gt; 输出系统错误</p>
<p>guest -&gt; ir -&gt; host</p>
<p>printf会影响回调函数的个数?</p>
<ol>
<li>start_callback 是当前block执行前执行的函数，在里面对当前block的最后一条分支指令进行分支预测。</li>
<li>在当前block跳转指令执行前确定分支指令的跳转情况，用这个真实的跳转信息更新预测器</li>
<li>修改ir的目标地址，使得下一个block为预测方向的block</li>
<li>在错误路径执行N个block后恢复上次保存的信息，恢复到正常流程(N可以先写个固定的interval 比如5个block)</li>
</ol>
<ul>
<li><p>cpu_gen_code 負責 guest binary → TCG IR → host binary 的翻譯。</p>
<ul>
<li>gen_intermediate_code_internal (target-*&#x2F;translate.c) 初始化並呼叫 disas_insn 反組譯 guest binary 成 TCG IR。<ul>
<li>disas_insn 呼叫 tcg_gen_xxx (tcg&#x2F;tcg-op.h) 產生 TCG IR。分別將 opcode 寫入 gen_opc_ptr 指向的緩衝區 (translate-all.c 裡的 gen_opc_buf); operand 寫入 gen_opparam_ptr 指向的緩衝區 (translate-all.c 裡的 gen_opparam_buf )。</li>
</ul>
</li>
<li>tcg_gen_code (tcg&#x2F;tcg.c) 呼叫 tcg_gen_code_common (tcg&#x2F;tcg.c) 將 TCG IR 轉成 host binary</li>
</ul>
</li>
<li><p>tb_find_fast&#x2F;slow 傳回 translation block 後，交給 tcg_qemu_tb_exec 執行。</p>
</li>
</ul>
<ol start="0">
<li>插桩 start_cb, 插在BB块开始的部分，会随着BB一起翻译、执行</li>
<li>翻译代码 Guest —(teg_gen)–&gt; IR —(tcg_out)–&gt; Host<ul>
<li>aarch64_tr_translate_insn 调用tcg_gen</li>
<li>在tcg_out_xxx中插桩，在执行阶段中会被执行</li>
</ul>
</li>
<li>执行host代码</li>
</ol>
<h2 id="以cbz指令为例"><a href="#以cbz指令为例" class="headerlink" title="以cbz指令为例"></a>以cbz指令为例</h2><p>Guest(arrch64) —(teg_gen)–&gt; IR —(tcg_out)–&gt; Host(i386)<br>tcg_gen_brcondi_i64(tcg&#x2F;tcg-op.c)生成 ir</p>
<p>brcond_i64 tmp2,$0x0,eq,$L1</p>
<p>目标 找到一条arrch64的分支指令究竟被翻译成了哪些IR 这些IR又变成了哪些host指令(i386)<br>然后 在tcg_out中插桩，获得我想要的真实信息，篡改执行的BB块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tcg_out_op</span><span class="params">(TCGContext* s, TCGOpcode opc, <span class="type">const</span> TCGArg* args, <span class="type">const</span> <span class="type">int</span>* const_args)</span></span><br><span class="line">&#123;</span><br><span class="line">    TCGArg a0, a1, a2;</span><br><span class="line">    <span class="type">int</span> c, const_a2, vexop, rexw = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取最常见的参数 Hoist the loads of the most common arguments.  */</span></span><br><span class="line">    a0 = args[<span class="number">0</span>];     <span class="comment">// = TCG_REG_EBP, 代表要比较的寄存器</span></span><br><span class="line">    a1 = args[<span class="number">1</span>];    <span class="comment">// = 0, 要比较的常数</span></span><br><span class="line">    a2 = args[<span class="number">2</span>];    <span class="comment">// = 0x9, 表示分支的条件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (opc) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> INDEX_op_brcond_i32:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            a2: 表示分支条件; </span></span><br><span class="line"><span class="comment">            a0 a1为要比较的变量和值, </span></span><br><span class="line"><span class="comment">            const_args[1]: 表示a1是否为常数</span></span><br><span class="line"><span class="comment">            arg_label(args[3]): 表示跳转目标的标签</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        tcg_out_brcond32(s, a2, a0, a1, const_args[<span class="number">1</span>], arg_label(args[<span class="number">3</span>]), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">accel/tcg/translate-all.c::tb_gen_code --&gt;&gt; </span><br><span class="line">tcg/tcg.c::tcg_gen_code --&gt;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TCGContext</span> &#123;</span></span><br><span class="line">    ...;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> gen_next_op_idx;    <span class="comment">//写入下一个操作码的位置</span></span><br><span class="line">    <span class="type">int</span> gen_next_parm_idx;    <span class="comment">//写入下一个操作数的位置</span></span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line"></span><br><span class="line">    TCGOp gen_op_buf[OPC_BUF_SIZE]; <span class="comment">//保存生成的中间指令</span></span><br><span class="line">    TCGArg gen_opparam_buf[OPPARAM_BUF_SIZE];   <span class="comment">//保存中间指令的操作数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> gen_insn_end_off[TCG_MAX_INSNS];</span><br><span class="line">    target_ulong gen_insn_data[TCG_MAX_INSNS][TARGET_INSN_START_WORDS];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line">    <span class="comment">/// 放Host指令的地方</span></span><br><span class="line">    <span class="type">void</span> *code_gen_buffer;      <span class="comment">//保存生成的指令的缓冲区</span></span><br><span class="line">    <span class="type">size_t</span> code_gen_buffer_size;    <span class="comment">//缓冲区大小</span></span><br><span class="line">    <span class="type">void</span> *code_gen_ptr;     <span class="comment">//写入下一个生成指令的位置, 位于code_gen_buffer内部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TCGCond</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    <span class="comment">/* non-signed */</span></span><br><span class="line">    TCG_COND_NEVER  = <span class="number">0</span> | <span class="number">0</span> | <span class="number">0</span> | <span class="number">0</span>,</span><br><span class="line">    TCG_COND_ALWAYS = <span class="number">0</span> | <span class="number">0</span> | <span class="number">0</span> | <span class="number">1</span>,</span><br><span class="line">    TCG_COND_EQ     = <span class="number">8</span> ,</span><br><span class="line">    TCG_COND_NE     = <span class="number">9</span>,</span><br><span class="line">    <span class="comment">/* signed */</span></span><br><span class="line">    TCG_COND_LT     = <span class="number">0</span> | <span class="number">0</span> | <span class="number">2</span> | <span class="number">0</span>,</span><br><span class="line">    TCG_COND_GE     = <span class="number">0</span> | <span class="number">0</span> | <span class="number">2</span> | <span class="number">1</span>,</span><br><span class="line">    TCG_COND_LE     = <span class="number">8</span> | <span class="number">0</span> | <span class="number">2</span> | <span class="number">0</span>,</span><br><span class="line">    TCG_COND_GT     = <span class="number">8</span> | <span class="number">0</span> | <span class="number">2</span> | <span class="number">1</span>,</span><br><span class="line">    <span class="comment">/* unsigned */</span></span><br><span class="line">    TCG_COND_LTU    = <span class="number">0</span> | <span class="number">4</span> | <span class="number">0</span> | <span class="number">0</span>,</span><br><span class="line">    TCG_COND_GEU    = <span class="number">0</span> | <span class="number">4</span> | <span class="number">0</span> | <span class="number">1</span>,</span><br><span class="line">    TCG_COND_LEU    = <span class="number">8</span> | <span class="number">4</span> | <span class="number">0</span> | <span class="number">0</span>,</span><br><span class="line">    TCG_COND_GTU    = <span class="number">8</span> | <span class="number">4</span> | <span class="number">0</span> | <span class="number">1</span>,</span><br><span class="line">&#125; TCGCond;</span><br></pre></td></tr></table></figure>





<p>armv8指令手册 page202<br>Unconditional branch<br>BL Branch with link<br>BR Branch to register<br>BLR Branch with link to register</p>
<p>Conditional branch<br>B.cond Branch conditionally<br>CBNZ Compare and branch if nonzero<br>CBZ Compare and branch if zero<br>TBNZ Test bit and branch if nonzero<br>TBZ Test bit and branch if zero</p>
<p>翻译的时候已经拿到预测结果 所以可以强行在tcg_out加跳转指令，<br>但是同时还需要知道真实的跳转指令，以便决定后面是否需要恢复<br>我可以利用重定向来进行篡改</p>
<h1 id="prologue初始化"><a href="#prologue初始化" class="headerlink" title="prologue初始化"></a>prologue初始化</h1><ul>
<li>prologue 用来切换 qemu 代码和 code cache 的代码上下文，在 tcg_prologue_init(tcg_ctx) 调用 host 的 tcg_target_qemu_prologue 来组装这块代码。</li>
</ul>
<p>在x86上组装出来的代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0x5644ca0ab000:  push   %rbp               //函数调用过程中将callee saved的入栈保存,完成了callee本身需要做的事情，因此在执行tb代码时可以使用所有的寄存器，在tb执行过程中不遵循函数调用的接口规范了</span><br><span class="line">0x5644ca0ab001:  push   %rbx  </span><br><span class="line">0x5644ca0ab002:  push   %r12  </span><br><span class="line">0x5644ca0ab004:  push   %r13  </span><br><span class="line">0x5644ca0ab006:  push   %r14  </span><br><span class="line">0x5644ca0ab008:  push   %r15  </span><br><span class="line">0x5644ca0ab00a:  mov    %rdi,%r14      //env到r14中，本身指向CPULOONGARCHState的对象，tb操作的对象都在</span><br><span class="line">0x5644ca0ab00d:  add    $0xfffffffffffffb78,%rsp      //</span><br><span class="line">0x5644ca0ab014:  jmpq   *%rsi      //跳转的tb的起始位置</span><br><span class="line"></span><br><span class="line">0x5644ca0ab016:  xor    %eax,%eax           //epilogue位置，返回值为0. 主要是为了goto_ptr使用</span><br><span class="line">0x5644ca0ab018:  add    $0x488,%rsp      //正常退出</span><br><span class="line">0x5644ca0ab01f:  emms   </span><br><span class="line">0x5644ca0ab022:  pop    %r15          //saved寄存器出栈</span><br><span class="line">0x5644ca0ab024:  pop    %r14  </span><br><span class="line">0x5644ca0ab026:  pop    %r13  </span><br><span class="line">0x5644ca0ab028:  pop    %r12  </span><br><span class="line">0x5644ca0ab02a:  pop    %rbx  </span><br><span class="line">0x5644ca0ab02b:  pop    %rbp  </span><br><span class="line">0x5644ca0ab02c:  retq                    //退出到qemu中</span><br></pre></td></tr></table></figure>

<h1 id="frontend的翻译"><a href="#frontend的翻译" class="headerlink" title="frontend的翻译"></a>frontend的翻译</h1><ul>
<li>在target指令翻译过程TB以跳转指令结束，其他指令只需要根据语义翻译成IR指令就可以。<ul>
<li>其中比较特殊的是跳转指令，TB开始和TB结束时的一些特殊代码.</li>
</ul>
</li>
</ul>
<h2 id="TB开始位置"><a href="#TB开始位置" class="headerlink" title="TB开始位置:"></a>TB开始位置:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gen_tb_start</span><br><span class="line">    ld_i32 tmp0,env,$0xffffffffffffffe4        //env指向CPULOONGARCHState，偏移是CPUState.icount_decr.u32相对于env的偏移;</span><br><span class="line">    movi_i32 tmp1,$0x0</span><br><span class="line">    brcond_i32 tmp0,tmp1,lt,$L0        //如果icount_decr.u32小于0则跳转到label 0处</span><br></pre></td></tr></table></figure>

<p>参考文档: <a target="_blank" rel="noopener" href="https://qemu.readthedocs.io/en/latest/devel/tcg-icount.html">https://qemu.readthedocs.io/en/latest/devel/tcg-icount.html</a></p>
<ul>
<li>icount只有在SOFTMMU中才有用，并且不能用在multi-threaded TCG 中，主要用于执行过程中指令的计数，后面详细再讲。</li>
</ul>
<h2 id="TB结束"><a href="#TB结束" class="headerlink" title="TB结束:"></a>TB结束:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gen_tb_end</span><br><span class="line">   set_label $L0            //生成一个label 0，给`br $label`或者`brcond_i32/i64 label`，`goto_tb`这些提供錨点</span><br><span class="line">   exit_tb $0x55f975f8bec3     //退出到tb_ret_addr</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2023/02/07/C%E8%AF%AD%E8%A8%80%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2023/02/07/C%E8%AF%AD%E8%A8%80%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/" class="post-title-link" itemprop="url">C语言内联汇编</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-07 17:28:50" itemprop="dateCreated datePublished" datetime="2023-02-07T17:28:50+08:00">2023-02-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:18" itemprop="dateModified" datetime="2023-07-30T18:15:18+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/C-C-asm/" itemprop="url" rel="index"><span itemprop="name">C/C++ asm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="0-Basic-Inline"><a href="#0-Basic-Inline" class="headerlink" title="0. Basic Inline."></a>0. Basic Inline.</h1><ul>
<li>The format of basic inline assembly is very much straight forward. Its basic form is</li>
</ul>
<h2 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式:"></a>基本形式:</h2><pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;assembly code&quot;</span>);</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example."></a>Example.</h2><pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;movl %ecx %eax&quot;</span>); <span class="comment">/* moves the contents of ecx to eax */</span></span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h2><ol>
<li>asm的语法规定mov的方向是从左到右，即<code>mov %src %dst</code></li>
</ol>
<h1 id="1-extended-assembly"><a href="#1-extended-assembly" class="headerlink" title="1. extended assembly"></a>1. extended assembly</h1><ul>
<li>可指定输入、输出,与asm外部的C程序交互</li>
</ul>
<h2 id="基本形式-1"><a href="#基本形式-1" class="headerlink" title="基本形式:"></a>基本形式:</h2><pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> ( assembler template </span><br><span class="line">    : output operands                  <span class="comment">/* optional */</span></span><br><span class="line">    : input operands                   <span class="comment">/* optional */</span></span><br><span class="line">    : <span class="built_in">list</span> of clobbered registers      <span class="comment">/* optional */</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="说明-1"><a href="#说明-1" class="headerlink" title="说明:"></a>说明:</h2><ol>
<li>output operands代表输出值，即该值可在执行中从asm寄存器获取到外部C程序中</li>
<li>input operands代表输入值，即该值可从外部C程序传递给asm中的寄存器</li>
<li>list of clobbered registers代表这段内联汇编执行后，哪些寄存器的值被破坏，来告知编译器做好备份和恢复工作</li>
</ol>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h2><ul>
<li>Example1:  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>, b;</span><br><span class="line"><span class="keyword">asm</span> (<span class="string">&quot;movl %1, %%eax; </span></span><br><span class="line"><span class="string">      movl %%eax, %0;&quot;</span></span><br><span class="line">     :<span class="string">&quot;=r&quot;</span>(b)        <span class="comment">/* output */</span></span><br><span class="line">     :<span class="string">&quot;r&quot;</span>(a)         <span class="comment">/* input */</span></span><br><span class="line">     :<span class="string">&quot;%eax&quot;</span>         <span class="comment">/* clobbered register */</span></span><br><span class="line">     );  </span><br></pre></td></tr></table></figure>
<ul>
<li>第一行将a的内容写入<code>%eax</code></li>
<li>第二行将<code>%eax</code>的内容输出到b</li>
<li><code>%1</code>,<code>%0</code>是占位符，会根据顺序和位置在下面的output、input匹配对应的的变量<ul>
<li><code>%src</code>匹配input ；<code>%dst</code>匹配output</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Check out the <a target="_blank" rel="noopener" href="https://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">GCC Inline Assembly</a> for more info on how to get the most out of ASM.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2023/02/07/Qemu%E7%BF%BB%E8%AF%91%E5%AE%9E%E4%BE%8B--%E4%BB%A5arrch64%20--%3E%3E%20x86-64%E4%B8%BA%E4%BE%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2023/02/07/Qemu%E7%BF%BB%E8%AF%91%E5%AE%9E%E4%BE%8B--%E4%BB%A5arrch64%20--%3E%3E%20x86-64%E4%B8%BA%E4%BE%8B/" class="post-title-link" itemprop="url">Qemu翻译实例--以arrch64 -->> x86-64为例</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-07 17:28:50" itemprop="dateCreated datePublished" datetime="2023-02-07T17:28:50+08:00">2023-02-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:50" itemprop="dateModified" datetime="2023-07-30T18:15:50+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Qemu翻译实例–以arrch64-–-i386为例"><a href="#Qemu翻译实例–以arrch64-–-i386为例" class="headerlink" title="Qemu翻译实例–以arrch64 –&gt;&gt; i386为例"></a>Qemu翻译实例–以arrch64 –&gt;&gt; i386为例</h1><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h2><ul>
<li><p>QEMU 是一个仿真器(emulator)，可以user mode 或是system mode 运行。 </p>
<ul>
<li>user mode 可以运行不同ISA 同一OS 的binary; </li>
<li>system mode 可以在当前作业系统上运行另外一个OS.</li>
</ul>
</li>
<li><p>对QEMU 而言，被仿真的平台被称为guest，又称target; 运行QEMU 的平台称为host。</p>
<ul>
<li>QEMU 是利用动态翻译(dynamic translation) 的技术将guest binary 动态翻译成host binary，并交由host 运行翻译所得的host binary。</li>
<li>Tiny Code Generator (TCG) 是QEMU 中负责动态翻译的组件。<ul>
<li>对TCG 而言，target 有不同的含意，它代表TCG 是针对哪一个host 生成host binary。</li>
</ul>
</li>
</ul>
</li>
<li><p>QEMU 极为依赖macro，这使得直接阅读源代码通常无法确定其函数呼叫，或是执行流程倒底为何。</p>
</li>
<li><p>请在编译QEMU 的时候加上<code>--extra-cflags=&quot;-save-temps&quot;</code>，如此可得展开marco 的 <code>*.i</code> 档。</p>
</li>
</ul>
<h2 id="1-TCG"><a href="#1-TCG" class="headerlink" title="1. TCG"></a>1. TCG</h2><ul>
<li>TCG 是QEMU 的核心。其基本流程如下:<ul>
<li>guest binary -&gt; TCG IR -&gt; host binary</li>
</ul>
</li>
</ul>
<h3 id="1-1-TCG-IR"><a href="#1-1-TCG-IR" class="headerlink" title="1.1 TCG IR"></a>1.1 TCG IR</h3><ul>
<li><p>TCG 定义了一组IR (intermediate representation)，熟悉GCC 的各位对此应该不陌生。</p>
</li>
<li><p>TCG IR 大致分成以下几类:</p>
<ul>
<li>Move Operation: mov, movi, …</li>
<li>Logic Operation: and, or, xor, shl, shr, …</li>
<li>Arithmetic peration: add, sub, mul, div, …</li>
<li>Branch Operation: jmp, br, brcond</li>
<li>Fuction call: call</li>
<li>Memory Operation: ld, st</li>
<li>QEMU specific Operation: tb_exit, goto_tb, qemu_ld&#x2F;qemu_st</li>
</ul>
</li>
<li><p>请见tcg&#x2F;*，特别是tcg.i，可以看到TCGOpcode。</p>
</li>
<li><p>tcg&#x2F;README 也别忘了。</p>
</li>
<li><p>TCG 在翻译guest binary 的时候是以一个translation block (tb) 为单位，其结尾通常是分支指令。</p>
</li>
<li><p>target&#x2F;ARCH&#x2F;* 定义了如何将ARCH binary 反汇编成TCG IR。</p>
<ul>
<li>target&#x2F;arm</li>
</ul>
</li>
<li><p>tcg&#x2F;ARCH 定义了如何将TCG IR 翻译成ARCH binary。</p>
<ul>
<li>tcg&#x2F;i386</li>
</ul>
</li>
</ul>
<h3 id="1-2-TCG-Flow"><a href="#1-2-TCG-Flow" class="headerlink" title="1.2 TCG Flow"></a>1.2 TCG Flow</h3><ul>
<li><p>gen_opc_buf 和gen_opparam_buf (translate-all.c) 分别放置TCG Opcode 和Operand。</p>
</li>
<li><p>如果使用静态配置的缓冲区，static_code_gen_buffer (exec.c) 即为code cache，放置host binary。</p>
</li>
<li><p>在跳入&#x2F;出code cache 执行之前&#x2F;后，要执行prologue&#x2F;epilogue，请见code_gen_prologue (exec.c)。</p>
</li>
<li><p>这边的prologue&#x2F;epilogue 就是指function prologue&#x2F;epilogue。</p>
</li>
<li><p>QEMU 将跳至code cache (host binary) 执行的过程看成是函式呼叫，故有此prologue&#x2F;epilogue。</p>
</li>
<li><p>以qemu-arm 为例，流程大致如下:</p>
<ul>
<li><p>main() &#x2F;&#x2F; vl.c</p>
</li>
<li><p>–&gt;&gt; main_loop() &#x2F;&#x2F; vl.c</p>
</li>
<li><p>–&gt;&gt; arm_cpu_realizefn() &#x2F;&#x2F; target&#x2F;arm&#x2F;cpu.c，实例化虚拟机CPU设备模型 [GUEST]_cpu_realizefn</p>
</li>
<li><p>–&gt;&gt; qemu_init_vcpu() &#x2F;&#x2F; softmmu&#x2F;cpus.c，KVM没有enable，并且启_cpu_thread_fn用了TCG的情况下，tcg_enabled()</p>
</li>
<li><p>–&gt;&gt; qemu_tcg_init_vcpu() &#x2F;&#x2F; 启动VCPU线程，线程处理函数为qemu_tcg_cpu_thread_fn</p>
</li>
<li><p>–&gt;&gt; qemu_tcg_cpu_thread_fn()</p>
</li>
<li><p>–&gt;&gt; tcg_exec_all()</p>
</li>
<li><p>–&gt;&gt; tcg_cpu_exec()</p>
</li>
<li><p>–&gt;&gt; cpu_exec() &#x2F;&#x2F;cpu-exee.c</p>
</li>
<li><p>user mode:</p>
<ul>
<li>main (linux-user&#x2F;main.c) -&gt; cpu_create -&gt; tcg_prologue_init (tcg&#x2F;tcg.c) -&gt; cpu_loop (linux-user&#x2F;main.c)</li>
</ul>
</li>
</ul>
</li>
<li><p>这边只介绍tcg_prologue_init (tcg&#x2F;tcg.c) -&gt; cpu_loop (linux-user&#x2F;arm&#x2F;cpu_loop.c) 这一段，因为这一段跟TCG 较为相关。</p>
</li>
<li><p>容我先讲cpu_loop (linux-user&#x2F;arm&#x2F;cpu_loop.c)。</p>
</li>
<li><p>cpu_loop(CPUARMState *env) (linux-user&#x2F;arm&#x2F;cpu_loop.c) -&gt; cpu_exec (accel&#x2F;tcg&#x2F;cpu-exec.c)。</p>
</li>
<li><p>cpu_exec 是主要执行回圈，其结构大致如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* prepare setjmp context for exception handling */</span> </span><br><span class="line"><span class="keyword">if</span> (sigsetjmp(cpu-&gt;jmp_env, <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!cpu_handle_exception(cpu, &amp;ret)) &#123;</span><br><span class="line">    <span class="keyword">while</span> (!cpu_handle_interrupt(cpu, &amp;last_tb)) &#123; </span><br><span class="line">        tb = tb_lookup(cpu, pc, cs_base, flags, cflags); <span class="comment">// 寻找下一个TB</span></span><br><span class="line">        <span class="keyword">if</span> (tb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            tb = tb_gen_code(cpu, pc, cs_base, flags, cflags);</span><br><span class="line">        &#125;</span><br><span class="line">        cpu_loop_exec_tb(cpu, tb, &amp;last_tb, &amp;tb_exit);<span class="comment">// 跳至code cache 执行。</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">cpu_exec_exit(cpu);</span><br></pre></td></tr></table></figure></li>
<li><p>tcg_prologue_init (tcg&#x2F;tcg.c) -&gt; tcg_target_qemu_prologue (tcg&#x2F;arm&#x2F;tcg-target.c.inc)。</p>
</li>
<li><p>如前所述，QEMU 将跳至code cache (host binary) 执行的过程看成是函式呼叫。</p>
</li>
<li><p>不同平台的calling convention 各有不同，tcg_prologue_init 将产生prologue&#x2F;epilogue 的工作转交tcg_target_qemu_prologue。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tcg_target_qemu_prologue</span><span class="params">(TCGContext *s)</span> &#123; </span><br><span class="line">    <span class="comment">/* Calling convention requires us to save r4-r11 and lr.  */</span></span><br><span class="line">    <span class="comment">/* stmdb sp!, &#123; r4 - r11, lr &#125; */</span></span><br><span class="line">    tcg_out32(s, (COND_AL &lt;&lt; <span class="number">28</span>) | <span class="number">0x092d4ff0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reserve callee argument and tcg temp space.  */</span></span><br><span class="line">    tcg_out_dat_rI(s, COND_AL, ARITH_SUB, TCG_REG_CALL_STACK,</span><br><span class="line">                   TCG_REG_CALL_STACK, STACK_ADDEND, <span class="number">1</span>);</span><br><span class="line">    tcg_set_frame(s, TCG_REG_CALL_STACK, TCG_STATIC_CALL_ARGS_SIZE,</span><br><span class="line">                  CPU_TEMP_BUF_NLONGS * <span class="keyword">sizeof</span>(<span class="type">long</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* QEMU (cpu_exec) -&gt; 入栈*/</span> </span><br><span class="line">    tcg_out_mov(s, TCG_TYPE_PTR, TCG_AREG0, tcg_target_call_iarg_regs[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tcg_target_call_iarg_regs 是函式呼叫负责传递参数的暂存器。</span></span><br><span class="line">    <span class="comment">// 跳至code cache 执行。</span></span><br><span class="line">    tcg_out_bx(s, COND_AL, tcg_target_call_iarg_regs[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 此时，s-&gt;code_ptr 指向code_gen_prologue 中prologue 和jmp to code cache 之后的位址。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Return path for goto_ptr. Set return value to 0, a-la exit_tb,</span></span><br><span class="line"><span class="comment">     * and fall through to the rest of the epilogue.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    tcg_code_gen_epilogue = tcg_splitwx_to_rx(s-&gt;code_ptr);</span><br><span class="line">    tcg_out_movi(s, TCG_TYPE_PTR, TCG_REG_R0, <span class="number">0</span>);</span><br><span class="line">    tcg_out_epilogue(s); <span class="comment">/* 出栈-&gt; 返回QEMU (cpu_exec)，确切的讲是返回tcg_qemu_tb_exec */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这边小结一下。</p>
<ul>
<li>QEMU -&gt; prologue -&gt; code cache -&gt; epilogue -&gt; QEMU</li>
</ul>
</li>
<li><p>在介绍cpu_exec 之前，我先介绍几个QEMU 资料结构，请善用SOURCEARCHIVE.com。</p>
</li>
<li><p>我们要知道所谓仿真或是虚拟化一个CPU (ISA)，简单来说就是用一个资料结构(struct) 储存该CPU的状态。</p>
</li>
<li><p>执行该虚拟CPU，就是从内存中读取该虚拟CPU的资料结构，运算后再存回去。</p>
</li>
<li><p>CPUX86State: 保存x86 register，eflags，eip，cs，…。</p>
</li>
<li><p>不同ISA 之间通用的资料结构被QEMU #define 成CPU_COMMON。</p>
</li>
<li><p>一般称此资料结构为CPUState。下文所提env 即为CPUState。</p>
</li>
<li><p>QEMU 运行虚拟CPU 都会利用env 这个变数。</p>
</li>
<li><p>TranslationBlock: 之前说过，QEMU 是以一个translation block 为单位进行翻译。</p>
</li>
<li><p>其中保存此translation block 对应guest binary 的pc, cs_base, eflags。</p>
</li>
<li><p>另外，tc_ptr 指向code cache (host binary)。其它栏位待以后再谈。</p>
</li>
<li><p>PageDesc: 主要保存guest page 中的第一个tb (TranslationBlock *)。</p>
</li>
<li><p>这跟QEMU 内部运作机制有关。某些情况下，guest page (guest binary) 可能被替换或是被写。</p>
</li>
<li><p>这个时候，QEMU 会以guest page (guest binary) 为单位，清空与它相关联的TB (code cache)。</p>
</li>
<li><p>这时再回来讲 TranslationBlock。TranslationBlock 有底下两个栏位:</p>
<ul>
<li>page_addr[2]: 存放TranslationBlock 对应guest binary 所在的guest page。注意! guest binary 有可能跨guest page，故这里有两个栏位。</li>
<li>page_next[2]: 当透过PageDesc-&gt;first_tb 找到该guest page 的第一个tb，tb-&gt;page_next 就被用来找寻该guest page 的下一个tb。</li>
</ul>
</li>
<li><p>再回来讲PageDesc。QEMU 替PageDesc 维护了一个二级页表l1_map。page_find 这个函式根据输入的address 搜寻l1_map，返回PageDesc。这在以guest page (guest binary) 为单位，清空与它相关联的TB (code cache) 的时候会用到。有一个名字很像的资料结构叫PhysPageDesc，QEMU 也替它维护一个二级页表l1_phys_map。这是在system mode 做地址转换之用，这边不谈。</p>
</li>
<li><p>TCGContext: 生成TCG IR 时会用到。</p>
</li>
<li><p>DisasContext: 反汇编guest binary 时会用到</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2023/01/14/spec2006%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2023/01/14/spec2006%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/" class="post-title-link" itemprop="url">SPEC2006交叉编译</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-14 17:28:50" itemprop="dateCreated datePublished" datetime="2023-01-14T17:28:50+08:00">2023-01-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:18" itemprop="dateModified" datetime="2023-07-30T18:15:18+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-SPEC2006说明"><a href="#1-SPEC2006说明" class="headerlink" title="1. SPEC2006说明"></a>1. SPEC2006说明</h1><ul>
<li>CPU Benchmark</li>
<li>用例具体内容见官网<code>http://www.spec.org/cpu2006/docs/用例名.html</code></li>
<li>运行时注意不要漏掉参数(Input)</li>
<li>例:</li>
</ul>
<table>
<thead>
<tr>
<th>子项目</th>
<th>类别</th>
<th>语言</th>
<th>说明</th>
<th>Web</th>
</tr>
</thead>
<tbody><tr>
<td>462.libquantum</td>
<td>物理：量子计算</td>
<td>ISO&#x2F;IEC 9899:1999(“C99”)</td>
<td>libquantum是模拟量子计算机的库文件，用来进行量子计算机应用的研究</td>
<td><a target="_blank" rel="noopener" href="http://www.spec.org/cpu2006/docs/462.libquantum.html">http://www.spec.org/cpu2006/docs/462.libquantum.html</a></td>
</tr>
</tbody></table>
<h1 id="2-交叉编译"><a href="#2-交叉编译" class="headerlink" title="2. 交叉编译"></a>2. 交叉编译</h1><ol>
<li><p>解压下载的SPEC2006压缩包</p>
</li>
<li><p>安装SPEC <code>./install.sh</code></p>
</li>
<li><p>安装aarch64交叉编译环境</p>
<ul>
<li>gcc、g++、gfortran</li>
<li><code>sudo apt install gfortran-8-aarch64-linux-gnu</code></li>
</ul>
</li>
<li><p>加载环境变量</p>
<ul>
<li>只要需要用到SPEC2006的指令，都需要在打开终端时加入<code>source ./shrc</code></li>
</ul>
</li>
<li><p>交叉编译配置</p>
<ol>
<li>进入<code>config</code>目录下，复制<code>Example-linux64-amd64-gcc43+</code>的配置文件（这个文件的选择根据Gem5中模拟的核模型来选择），将其重命名为<code>aarch64.cfg</code>（可以任意命名为其它名称）</li>
<li>修改配置文件<code>aarch64.cfg</code>，指定编译工具<ul>
<li>分别找到CC，CXX，FC</li>
<li>改成如下格式：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CC =  your-cross-compiler-gcc</span><br><span class="line"></span><br><span class="line">CXX = your-cross-compiler-g++</span><br><span class="line"></span><br><span class="line">FC = your-cross-compiler-gfortran</span><br></pre></td></tr></table></figure></li>
<li>在gem5中运行的样例需要静态编译，故对COPTIMIZE、CXXOPTIMIZE、FOPTIMIZE加上<code>-static</code>标签</li>
<li>修改完后保存退出，其他地方不用改。</li>
</ul>
</li>
</ol>
</li>
<li><p>编译speccpu:</p>
</li>
</ol>
<ul>
<li><p><code>runspec --action=build --config=aarch64.cfg --tune=base int</code> （只编译int型benchmark，不运行）</p>
</li>
<li><p>生成可执行文件<code>runspec --config=&lt;你的配置文件名&gt; --size=ref --noreportable --tune=base --iterations=1 &lt;样例名称&gt;</code></p>
</li>
</ul>
<ol start="7">
<li>将编译好的文件（在源码目录下，如<code>benchspec/CPU2006/400.perlbench/build/</code>）拷贝出来就可以在目标板或者模拟器上运行了。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2022/11/15/ARM64%E6%B1%87%E7%BC%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2022/11/15/ARM64%E6%B1%87%E7%BC%96/" class="post-title-link" itemprop="url">ARM64汇编</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-15 22:28:50" itemprop="dateCreated datePublished" datetime="2022-11-15T22:28:50+08:00">2022-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:18" itemprop="dateModified" datetime="2023-07-30T18:15:18+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/c/" itemprop="url" rel="index"><span itemprop="name">c++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><ul>
<li>在arm64架构下，所有的寄存器都是64位，并且每个寄存器都有名字的，按照功能来划分，可分为一下几类，分别为：<ol>
<li>通用寄存器</li>
<li>程序计数器</li>
<li>堆栈指针</li>
<li>链接寄存器</li>
<li>程序状态寄存器</li>
<li>零寄存器</li>
</ol>
</li>
<li>下面分别说明这些寄存器的作用</li>
</ul>
<h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><ul>
<li>64bit : x0 ~ x28 ，每个寄存器都是64bit</li>
<li>32bit：w0 ~ w28，实际上是x0~x28寄存器的低32bit</li>
<li>x0~x7：通过用来存储函数的参数，如果函数有更多的参数使用堆栈来传递</li>
<li>x0：通常用来存放函数的返回值</li>
</ul>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><ul>
<li>程序计数器叫<code>Program Counter</code>，俗称<code>PC</code>，也就是<code>x32</code>寄存器，存储着CPU当前正在执行的地址。</li>
</ul>
<h2 id="堆栈指针"><a href="#堆栈指针" class="headerlink" title="堆栈指针"></a>堆栈指针</h2><ul>
<li><code>SP</code> (<code>Stack Pointer</code>)，就是<code>x31</code>寄存器，存储的是栈顶的地址</li>
<li><code>FP</code> (<code>Frame Pointer</code>)，<code>FP</code>也就是<code>x29</code>寄存器，存储着栈底的地址</li>
<li>随着函数的调用，<code>SP</code>、<code>FP</code>会不断的变化。</li>
</ul>
<h2 id="链接寄存器"><a href="#链接寄存器" class="headerlink" title="链接寄存器"></a>链接寄存器</h2><p><code>LR</code>（<code>Link Register</code>），也就是<code>x30</code>寄存器，存储着函数的返回地址。</p>
<ul>
<li>当函数结束时，就是通过LR寄存器的值，跳转到调用函数的位置继续往下执行。</li>
</ul>
<h2 id="程序状态寄存器"><a href="#程序状态寄存器" class="headerlink" title="程序状态寄存器"></a>程序状态寄存器</h2><ul>
<li><code>CPSR</code> (<code>Current Program Status Register</code>)</li>
<li><code>SPSR</code> (<code>Saved Program Status Register</code>)，在异常状态下使用，当发生异常时，会把<code>CPSR</code>的内容写入<code>SPSR</code>, 等异常恢复之后，又会把<code>SPSR</code>写会到<code>CPSR</code>中。</li>
</ul>
<p>零寄存器<br>WZR<br>XZR<br>里面存储的值都是0。</p>
<p>常用指令<br>算术运算指令<br>mov 赋值指令</p>
<p>mov x0, #2  &#x2F;&#x2F; 把2这个值赋值给x0寄存器<br>mov x0, x1  &#x2F;&#x2F; 把x1寄存器中的值赋值给x0寄存器中<br>add<br>两个操作数相加，相加的结果存放到一个寄存器中</p>
<p>add, x2, x0, x1 &#x2F;&#x2F;把x0的值与x1的值相加，得到的结果存放到x2寄存器中<br>add, x2, x0, #3 &#x2F;&#x2F; 把x0的值与3相加，得到的结果存放到x2寄存器中<br>sub<br>第一个操作数减第一个操作数，得到的结果存放到一个寄存器中</p>
<p>sub, x2, x1, x0 &#x2F;&#x2F; x1的值减去x0的值，得到的结果存放到<em>x2</em>寄存器中<br>sub, x2, x1, #4 &#x2F;&#x2F; x1的值减去4，得到的结果存放到x2寄存器中<br>mul 乘法指令</p>
<p>mul x3, x1, x2  &#x2F;&#x2F; x1 乘以 x2 的结果存放在 x3 中<br>sdiv 除法指令</p>
<p>sdiv    w0, w0, w1 &#x2F;&#x2F; w0 除以 w1 的结果存放在 w0 中<br>逻辑运算指令<br>这里的运算是指位运算</p>
<p>LSL 逻辑左移<br>按操作数所指定的数量向左移位，低位用零来填充<br>ASL 算术左移<br>通逻辑左移，ASL 与 LSL等价<br>lsl x0, x0, #1<br>asl x1, x1, x0<br>LSR 逻辑右移<br>按操作数所指定的数量向右移位，左端用零来填充。</p>
<p>ASR 算术右移<br>按操作数所指定的数量向右移位，左端用最高位位的值来填充 ，如果是负数，最高位为1</p>
<p>lsr w1, w2, #1<br>asr x1, x2, #2<br>ROR 循环右移<br>按操作数所指定的数量向右循环移位， 左端用右端移出的位来填充。其中，操作数可以是通用寄存器，也可以是立即数。 当进行寄存器bit位数的循环右移操作时，通用寄存器中的值不改变。<br>ror x0, #6<br>ror w0, #32  &#x2F;&#x2F; 循环移动了32位，w0的值不变<br>跳转指令<br>ret<br>相当于高级编程语言的return，函数返回。</p>
<p>cmp<br>将两个操作数相减，相减的结果会影响cpsr 寄存器的标志位，当结果小于0时，CPSR寄存器的N位为1， 等于0时， CPSR寄存器的Z为位1。<br>cmp x0, x1</p>
<p>b<br>跳转指令，跳转找指定的标记处执行；可以带条件跳转，一般跟cmp配合使用，使用到的条件域如下：</p>
<p>EQ：equal<br>NE：not equal<br>GT：great than<br>GE：great equal<br>LT：less than<br>LE：less equal<br>普通跳转<br>b testCode，testCode是汇编代码中的一个标记</p>
<p>条件跳转，当x0和x1的值相等时，才跳转到testCode标记处执行代码</p>
<p>cmp x0, x1<br>beq testCode<br>bl<br>带返回值的跳转指令，这个指令会做两个操作</p>
<p>将下一条指令的地址存储到lr （x30）寄存器中<br>跳转到标记处开始执行代码<br>bl testCode，当执行完testCode标记处代码后，又会返回来执行bl指令下面的指令。<br>内存操作<br>load从内存中读取数据</p>
<p>ldr 地址没有偏移或者偏移为正数时使用<br>ldur 地址偏移为负数时使用<br>a) str x5 [x0] x0中是内存的地址，读取的值存放在x5寄存器中, x寄存器读取8个字节<br>b）str w6 [x0] x0中是内存的地址，读取的值存放在w5寄存器中, w寄存器读取4个字节<br>说明: 地址还可以偏移 str x5 [x0, #0x4] , stur x5 [x0, #-0x4] , 偏移量为正数往高地址偏移，使用str指令、偏移量为负数往低地址偏移，使用stur指令。</p>
<p>ldp 从指定内存中读取数据到一对寄存器中， p 是 pair的意思，这一对寄存器必须是同类型的，要么x类型, 要么w类型。其中低位读取到第一个寄存器、高位读取到第二个寄存器<br>ldp w5, w6, [x0] , 地址可以偏移 ldp x5, x6, [x0, #-x04]<br>store 往指定的内存写入数据</p>
<p>str<br>str x1, [x0]<br>str w2, [x1]<br>str w3, [x1, #4]<br>stur<br>stur x3, [x0, #-4]<br>stur w2, [x1, #-4]<br>stp<br>stp x2, x3, [x0]<br>stp w4, w5, [x0]<br>使用方法与从内存中读取数据类似，只不过是往内存写入数据。</p>
<p>总结<br>本文整理了一些在逆向iOS程序时常见的一些汇编指令，当然在实际逆向的过程所看到的汇编指令更加复杂，比如还有函数调用栈，这是下篇的内容。如有错误请指正。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2022/11/15/Effective%20C++(6)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2022/11/15/Effective%20C++(6)/" class="post-title-link" itemprop="url">Effective C++(6)--继承与面向对象设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-15 22:28:50" itemprop="dateCreated datePublished" datetime="2022-11-15T22:28:50+08:00">2022-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:32" itemprop="dateModified" datetime="2023-07-30T18:15:32+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/c/" itemprop="url" rel="index"><span itemprop="name">c++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="条款32-确定public继承塑模出is-a关系"><a href="#条款32-确定public继承塑模出is-a关系" class="headerlink" title="条款32 确定public继承塑模出is-a关系"></a>条款32 确定public继承塑模出is-a关系</h1><ul>
<li>public继承意味”is-a”</li>
<li>Liskov替换原则<ul>
<li>class D : class B { … }</li>
<li>适用于B身上的每一件事也适用于D，反之不然</li>
</ul>
</li>
</ul>
<h1 id="条款33-避免遮掩继承而来的名称"><a href="#条款33-避免遮掩继承而来的名称" class="headerlink" title="条款33 避免遮掩继承而来的名称"></a>条款33 避免遮掩继承而来的名称</h1><h2 id="继承体系内的”名称可视性”"><a href="#继承体系内的”名称可视性”" class="headerlink" title="继承体系内的”名称可视性”"></a>继承体系内的”名称可视性”</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>base class内所有名为mf1和mf3的函数都被derived class内的mf1和mf3函数遮掩了<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.<span class="built_in">mf1</span>();    <span class="comment">/// ok</span></span><br><span class="line">d.<span class="built_in">mf1</span>(x);   <span class="comment">/// error, Base::mf1被遮掩</span></span><br><span class="line">d.<span class="built_in">mf2</span>();    <span class="comment">/// ok, Base::mf2</span></span><br><span class="line">d.<span class="built_in">mf3</span>();    <span class="comment">/// ok, Derived::mf3</span></span><br><span class="line">d.<span class="built_in">mf3</span>(x);   <span class="comment">/// error, Base::mf3被遮掩</span></span><br></pre></td></tr></table></figure></li>
<li>该机制的目的在于提醒base和derived class之间的is-a关系</li>
</ul>
<h2 id="override缺省遮掩行为"><a href="#override缺省遮掩行为" class="headerlink" title="override缺省遮掩行为"></a>override缺省遮掩行为</h2><ul>
<li>一般不在public继承下使用，破坏了is-a的关系</li>
<li>在private继承下有用</li>
</ul>
<h3 id="使用using声明式"><a href="#使用using声明式" class="headerlink" title="使用using声明式"></a>使用using声明式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::mf1;    <span class="comment">/// 让Base class内名为mf1和mf3的所有东西</span></span><br><span class="line">    <span class="keyword">using</span> Base::mf3;    <span class="comment">/// 在Derived作用域内可见(且public)</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.<span class="built_in">mf1</span>();    <span class="comment">/// ok，Derived::mf1</span></span><br><span class="line">d.<span class="built_in">mf1</span>(x);   <span class="comment">/// ok, Base::mf1</span></span><br><span class="line">d.<span class="built_in">mf2</span>();    <span class="comment">/// ok, Base::mf2</span></span><br><span class="line">d.<span class="built_in">mf3</span>();    <span class="comment">/// ok, Derived::mf3</span></span><br><span class="line">d.<span class="built_in">mf3</span>(x);   <span class="comment">/// ok, Base::mf3</span></span><br></pre></td></tr></table></figure>
<h3 id="转交函数-forwarding-function"><a href="#转交函数-forwarding-function" class="headerlink" title="转交函数(forwarding function)"></a>转交函数(forwarding function)</h3><ul>
<li>Derived private继承Base，且只想继承无参数版本的的mf1<ul>
<li>using会导入所有同名函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span>  <span class="comment">/// 转交函数</span></span></span><br><span class="line"><span class="function">    </span>&#123; Base::mf1; &#125;      <span class="comment">/// 暗自成为inline函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">d.<span class="built_in">mf1</span>();    <span class="comment">/// ok，Derived::mf1</span></span><br><span class="line">d.<span class="built_in">mf1</span>(x);   <span class="comment">/// error, Base::mf1被遮掩</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="条款34-区分接口继承和实现继承"><a href="#条款34-区分接口继承和实现继承" class="headerlink" title="条款34 区分接口继承和实现继承"></a>条款34 区分接口继承和实现继承</h1><ul>
<li>声明一个pure virtual函数的目的是为了让derived class只继承函数接口。<ul>
<li>1个构造函数 + 1个析构函数 + n个赋值操作</li>
</ul>
</li>
<li>做法B<ul>
<li>n个构造函数 + n个析构函数</li>
</ul>
</li>
<li>当classes的一个赋值成本低于一组构造+析构成本，做法A大体而言比较高效</li>
<li>此外A造成w的作用域比B更大，会对易维护性造成冲突</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li>当满足以下两点时使用方法A，否则使用方法B<ol>
<li>赋值成本低于构造+析构</li>
<li>代码对效率高度敏感</li>
</ol>
</li>
</ul>
<h1 id="条款27-尽量少做转型动作"><a href="#条款27-尽量少做转型动作" class="headerlink" title="条款27 尽量少做转型动作"></a>条款27 尽量少做转型动作</h1><ul>
<li>C++规则的设计目标之一:<ul>
<li>保证<em>类型错误</em>绝不可能发生</li>
</ul>
</li>
<li>C风格转型&#x2F;旧式转型  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(T)<span class="function">expression</span></span><br><span class="line"><span class="function"><span class="title">T</span><span class="params">(expression)</span> <span class="comment">/// 二者等价，将expression转型为T类型</span></span></span><br></pre></td></tr></table></figure></li>
<li>新式转型(<em>C++-style casts</em>)  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">const_cast</span>&lt;T&gt;( expression )         </span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;T&gt;( expression )</span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;T&gt;( expression )</span><br><span class="line"><span class="built_in">static_cast</span>&lt;T&gt;( expression )</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="新式转型更受欢迎"><a href="#新式转型更受欢迎" class="headerlink" title="新式转型更受欢迎:"></a>新式转型更受欢迎:</h3><ol>
<li>易辨识</li>
<li>转型动作的目标越窄化，编译器越可能诊断出错误的运用</li>
</ol>
<h3 id="唯一使用旧式转型的时机"><a href="#唯一使用旧式转型的时机" class="headerlink" title="唯一使用旧式转型的时机"></a>唯一使用旧式转型的时机</h3><ul>
<li>调用一个explicit构造函数将一个对象传递给一个函数  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(<span class="type">int</span> size)</span></span>; </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomeWork</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>;</span><br><span class="line"><span class="built_in">doSomeWork</span>(<span class="built_in">Widget</span>(<span class="number">15</span>));</span><br><span class="line"><span class="built_in">doSomeWork</span>(<span class="built_in">static_cast</span>&lt;Widget&gt;(<span class="number">15</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><ul>
<li>常量性转除</li>
<li>唯一有此功能的新式转型</li>
</ul>
<h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><ul>
<li>安全向下转型(safe downcasting)</li>
<li>唯一无法由旧式语法执行的动作</li>
<li>唯一可能耗费重大运行成本的转型动作</li>
</ul>
<h3 id="实现-一个普遍的版本"><a href="#实现-一个普遍的版本" class="headerlink" title="实现(一个普遍的版本)"></a>实现(一个普遍的版本)</h3><ul>
<li>基于class名称的字符串比较<ul>
<li>调用strcmp</li>
<li>深度、多重继承体系成本更高</li>
</ul>
</li>
</ul>
<h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><ul>
<li>执行低级转型</li>
<li>不可移植<ul>
<li>实际动作及结果取决于编译器</li>
<li>如将<code>pointer to int</code>转化为<code>int</code></li>
</ul>
</li>
</ul>
<h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><ul>
<li>强迫隐式转换(implicit conversion)<ul>
<li>non-const –&gt; const</li>
<li>void* –&gt; typed*</li>
<li>pointer-to-base –&gt; pointer-to-derived</li>
</ul>
</li>
</ul>
<h2 id="转型往往真的令编译器编译出运行期执行的码"><a href="#转型往往真的令编译器编译出运行期执行的码" class="headerlink" title="转型往往真的令编译器编译出运行期执行的码"></a>转型往往真的令编译器编译出运行期执行的码</h2><ul>
<li>不只是告诉编译器将某种类型视为另一种类型<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">...</span><br><span class="line"><span class="type">double</span> d = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(x) / y;</span><br></pre></td></tr></table></figure></li>
<li>将int转型为double几乎肯定会产生代码<ul>
<li>在大部分计算机体系结构中，int的底层表述不同于double<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; ... &#125;;</span><br><span class="line">Derived d;</span><br><span class="line">Base* pb = &amp;d; <span class="comment">/// 隐喻地将Derived*转换为Base*</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>同一个对象的Derived指针与Base指针值可能并不相同<ul>
<li>与编译器如何实现有关</li>
<li>有时候存在一个偏移量</li>
<li>运行时会计算偏移量以转型</li>
<li>多重继承中几乎必然发生，单一继承中可能发生</li>
</ul>
</li>
<li>避免做出“对象在C++中如何布局”的假设</li>
</ul>
<h1 id="条款28-避免返回handles指向对象内部分"><a href="#条款28-避免返回handles指向对象内部分" class="headerlink" title="条款28 避免返回handles指向对象内部分"></a>条款28 避免返回handles指向对象内部分</h1><h1 id="条款29-Strive-for-exception-safe-code"><a href="#条款29-Strive-for-exception-safe-code" class="headerlink" title="条款29 Strive for exception-safe code."></a>条款29 Strive for exception-safe code.</h1><ul>
<li>不泄露任何资源</li>
<li>不允许数据败坏</li>
</ul>
<h2 id="异常安全函数提供以下三个保证之一"><a href="#异常安全函数提供以下三个保证之一" class="headerlink" title="异常安全函数提供以下三个保证之一:"></a>异常安全函数提供以下三个保证之一:</h2><ol>
<li>基本承诺:<ul>
<li>异常抛出时，程序内的任何事物仍然保持在有效状态下。</li>
<li>但在哪个有效状态不可预料</li>
</ul>
</li>
<li>强烈保证:<ul>
<li>异常抛出时，程序状态不改变。</li>
<li>成功 –&gt; 完全成功</li>
<li>失败 –&gt; 回复到</li>
<li>往往以copy-and-swap实现</li>
<li>并非对所有函数都可实现或具备意义</li>
</ul>
</li>
<li>不抛掷(nothrow)保证:<ul>
<li>承诺绝不抛出异常</li>
<li>内置类型的操作均遵守</li>
</ul>
</li>
</ol>
<h1 id="条款30-透彻了解inline的里里外外"><a href="#条款30-透彻了解inline的里里外外" class="headerlink" title="条款30 透彻了解inline的里里外外"></a>条款30 透彻了解inline的里里外外</h1><h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>免除函数调用成本</li>
<li>编译器最优化机制通常用于浓缩“不含函数调用的代码”</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>增加<code>object code</code>的大小<ul>
<li>可能导致额外的的换页</li>
<li>降低cache命中率</li>
</ul>
</li>
</ul>
<h2 id="inline是对编译器的一个申请，不是强制命令"><a href="#inline是对编译器的一个申请，不是强制命令" class="headerlink" title="inline是对编译器的一个申请，不是强制命令"></a>inline是对编译器的一个申请，不是强制命令</h2><ul>
<li>编译器拒绝inline复杂函数<ul>
<li>如递归、循环、virtual(运行期决定)</li>
</ul>
</li>
<li>编译器无法inline将给出告警</li>
</ul>
<h3 id="隐式申请"><a href="#隐式申请" class="headerlink" title="隐式申请"></a>隐式申请</h3><ul>
<li>将函数定义为class定义式内<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">age</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> theAge; &#125; <span class="comment">// 一个隐喻的inline申请</span></span><br><span class="line">    ...                                <span class="comment">// age被定义与class定义式内</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> theAge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>这样的函数通常是成员函数，但是friend函数也可定义与class内(见 条款46)</li>
</ul>
<h3 id="显式申请"><a href="#显式申请" class="headerlink" title="显式申请"></a>显式申请</h3><ul>
<li>在定义式前加上关键字inline<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;algorithm&gt;</span></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">inline</span> <span class="type">const</span> T&amp; <span class="title">max</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="inline函数通常被置于头文件内"><a href="#inline函数通常被置于头文件内" class="headerlink" title="inline函数通常被置于头文件内"></a>inline函数通常被置于头文件内</h2><ul>
<li>编译期进行inline</li>
<li>方便编译器将函数调用替换为函数本体</li>
<li>template的具现化与inline无关<ul>
<li>通常被置于头文件内，方便编译器具现化</li>
</ul>
</li>
</ul>
<h2 id="有时即便编译器inline某个函数，可能还是为该函数生成一个函数本体"><a href="#有时即便编译器inline某个函数，可能还是为该函数生成一个函数本体" class="headerlink" title="有时即便编译器inline某个函数，可能还是为该函数生成一个函数本体"></a>有时即便编译器inline某个函数，可能还是为该函数生成一个函数本体</h2><ul>
<li>例如要取某个inline函数的地址时</li>
<li>编译器不对通过函数指针进行的调用实施inline  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="built_in">void</span> ( *pf ) = f;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">f</span>();        <span class="comment">// inline</span></span><br><span class="line"><span class="built_in">pf</span>();       <span class="comment">// outline</span></span><br></pre></td></tr></table></figure></li>
<li>编译器有时会自动生成inline函数的ouline副本<ul>
<li>比如生成构造和析构函数的副本，这样在array中可使用函数指针进行构造和析构</li>
</ul>
</li>
</ul>
<h2 id="构造函数和析构函数时inline糟糕的候选人"><a href="#构造函数和析构函数时inline糟糕的候选人" class="headerlink" title="构造函数和析构函数时inline糟糕的候选人"></a>构造函数和析构函数时inline糟糕的候选人</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::srting bm1, bm2;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123; &#125;;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::srting dm1, dm2, dm3;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>看起来构造函数和析构函数没有什么代码量，但其实不然</li>
<li>例如，一种可能的编译器实现:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Derived::<span class="built_in">Derived</span>() &#123;</span><br><span class="line">    Base::<span class="built_in">Base</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123; dm1.std::string::<span class="built_in">string</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123; </span><br><span class="line">        Base::~<span class="built_in">Base</span>();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123; dm2.std::string::<span class="built_in">string</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123; </span><br><span class="line">        Base::~<span class="built_in">Base</span>();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123; dm3.std::string::<span class="built_in">string</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123; </span><br><span class="line">        Base::~<span class="built_in">Base</span>();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="条款31-将文件间的编译依存关系降至最低"><a href="#条款31-将文件间的编译依存关系降至最低" class="headerlink" title="条款31 将文件间的编译依存关系降至最低"></a>条款31 将文件间的编译依存关系降至最低</h1><h2 id="编译依存关系"><a href="#编译依存关系" class="headerlink" title="编译依存关系"></a>编译依存关系</h2><ul>
<li>class的定义式不只详细描述了class接口，还包括十足的实现细目<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name. <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;    <span class="comment">/// 实现细目</span></span><br><span class="line">    Date theBirthDate;      <span class="comment">/// 实现细目</span></span><br><span class="line">    Address theAddress;     <span class="comment">/// 实现细目</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>C++将实现细目置于定义式中<ul>
<li>编译器需要根据定义式确定分配多大空间</li>
</ul>
</li>
<li>Person若要通过编译，需要classes string，Date，Address的定义式  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;date.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;address.h&quot;</span></span></span><br></pre></td></tr></table></figure></li>
<li>但是，如此一来，Person定义文件和其含入文件形成了编译依存关系<ul>
<li>如果这些头文件有一个被改变，或者这些头文件所依赖的其他文件有任何改变，那么每一个含入和使用Person class的文件也必须重新编译</li>
</ul>
</li>
</ul>
<h2 id="编译依存性最小化-–-接口与实现分离"><a href="#编译依存性最小化-–-接口与实现分离" class="headerlink" title="编译依存性最小化 – 接口与实现分离"></a>编译依存性最小化 – 接口与实现分离</h2><ul>
<li>通过Handle classes和Interface classes解除了接口和实现之间的耦合，降低了文件之间的编译依存性</li>
</ul>
<h3 id="pimpl-idiom-–-Handle-class"><a href="#pimpl-idiom-–-Handle-class" class="headerlink" title="pimpl idiom – Handle class"></a>pimpl idiom – <code>Handle class</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>   <span class="comment">// 标准程序组件不该被前置声明</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>   <span class="comment">// for shared_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PresonImpl</span>;   <span class="comment">// Person实现类的前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;         <span class="comment">// Person接口用到的classes的前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;PresonImpl&gt; pImpl_;</span><br><span class="line">&#125;;</span><br><span class="line">Person::<span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr)</span><br><span class="line">    : <span class="built_in">pImpl</span>(<span class="keyword">new</span> <span class="built_in">PresonImpl</span>(name, birthday, addr))</span><br><span class="line">    &#123;&#125;</span><br><span class="line"><span class="function">std::string <span class="title">Person::name</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pImpl-&gt;<span class="built_in">name</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Person的客户端完全与Date，Address以及Person的实现细目分开</li>
</ul>
<h3 id="抽象基类-abstract-base-class、Interface-class"><a href="#抽象基类-abstract-base-class、Interface-class" class="headerlink" title="抽象基类(abstract base class、Interface class)"></a>抽象基类(abstract base class、Interface class)</h3><ul>
<li>详细一一描述derived class的接口<ul>
<li>一组pure virtual函数</li>
</ul>
</li>
<li>通常不带成员变量，也没有构造函数</li>
<li>只有一个virtual析构函数(见条款7)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>客户必须以Person的pointers和references来撰写应用程序<ul>
<li>除非Interface class修改，否则不用编译</li>
</ul>
</li>
<li>客户必须有办法为这种class创建新对象<ul>
<li>工厂函数<ul>
<li>返回指针指向动态分配所得的对象</li>
<li>往往在Interface class中声明为static  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;Person&gt; <span class="title">create</span><span class="params">(<span class="type">const</span> std::string&amp; name, </span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> Date&amp; birthday, </span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> Address&amp; addr)</span></span>; <span class="comment">// why shared_ptr;见条款18</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 客户如此使用</span></span><br><span class="line">std::string; name, </span><br><span class="line">Date dateodBirth, </span><br><span class="line">Address address;</span><br><span class="line">...</span><br><span class="line"><span class="function">std::shared_ptr&lt;Person&gt; <span class="title">pp</span><span class="params">(Person::create(name, dateodBirth, address))</span></span>;</span><br><span class="line">...</span><br><span class="line">std::cout &lt;&lt; pp-&gt;<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>当然，支持Interface class接口的那个具象类(<code>concrete class</code>)必须被定义出来<ul>
<li>一切都在virtual构造函数的实现码所在文件内秘密发生  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealPerson</span> : <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RealPerson</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr)</span><br><span class="line">        : <span class="built_in">theName</span>(name), <span class="built_in">theBirthDate</span>(birthday), <span class="built_in">theAddress</span>(addr)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">RealPerson</span>() &#123;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;    </span><br><span class="line">    Date theBirthDate;      </span><br><span class="line">    Address theAddress;     </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> std::shared_ptr&lt;Person&gt; <span class="title">Person::create</span><span class="params">(<span class="type">const</span> std::string&amp; name, </span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">const</span> Date&amp; birthday, </span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">const</span> Address&amp; addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> <span class="built_in">RealPerson</span>(name, dateodBirth, addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>更现实的Person::create实现代码会创建不同的derived class</li>
</ul>
</li>
</ul>
<h3 id="开销"><a href="#开销" class="headerlink" title="开销"></a>开销</h3><h4 id="Handle-classes"><a href="#Handle-classes" class="headerlink" title="Handle classes"></a>Handle classes</h4><ol>
<li>成员函数必须通过implementation pointer取得对象数据，<ul>
<li>每次访问增加一次间接性</li>
</ul>
</li>
<li>每个对象的内存消耗多一个implementation pointer的大小</li>
<li>implementation pointer必须初始化，指向动态分配的implementation内存<ul>
<li>涉及到动态分配</li>
</ul>
</li>
</ol>
<h4 id="Interface-class"><a href="#Interface-class" class="headerlink" title="Interface class"></a>Interface class</h4><ol>
<li>virtual函数带来间接跳跃(见条款7)</li>
<li>派生类对象有一个vptr(见条款7)</li>
</ol>
<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><ul>
<li>声明的依存性 替换 定义的依存性</li>
<li>尽量让头文件自我满足，做不到则让它与其他头文件内的声明式而非定义式相依</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="如果使用object-reference-pointer可以完成任务，就不要使用object"><a href="#如果使用object-reference-pointer可以完成任务，就不要使用object" class="headerlink" title="如果使用object reference&#x2F;pointer可以完成任务，就不要使用object"></a>如果使用object reference&#x2F;pointer可以完成任务，就不要使用object</h3><ul>
<li>前者仅需声明，后者需要定义</li>
</ul>
<h3 id="如果能够，尽量用class声明式替换class定义式"><a href="#如果能够，尽量用class声明式替换class定义式" class="headerlink" title="如果能够，尽量用class声明式替换class定义式"></a>如果能够，尽量用class声明式替换class定义式</h3><ul>
<li>注意，当声明一个函数而它用到某个class的定义时，并不需要该class的定义  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;                         <span class="comment">// class声明式</span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span></span>;                       <span class="comment">// 没问题，这里并不需要Date的定义式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="为声明式和定义式提供不同的头文件"><a href="#为声明式和定义式提供不同的头文件" class="headerlink" title="为声明式和定义式提供不同的头文件"></a>为声明式和定义式提供不同的头文件</h3><ul>
<li>程序库客户应该总是#include一个声明文件而非前置声明若干class或函数  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;datafw.h&quot;</span>  <span class="comment">// 这个头文件内声明单未定义class Date</span></span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span></span>;                      </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>只含声明式的头文件名为”datefw.h”,命名方式取法C++标准库的<iosfwd><ul>
<li><iosfwd>内含iostream各组件的声明式，其定义则分布在相应的头文件，包括<sstream>,<streambuf>,<fstream>,<iostream></li>
</ul>
</li>
<li>此方法同样适用于template<ul>
<li>export关键字同样可以，但很少使用</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2022/11/15/Effective%20C++(5)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2022/11/15/Effective%20C++(5)/" class="post-title-link" itemprop="url">Effective C++(5)--实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-15 10:28:50" itemprop="dateCreated datePublished" datetime="2022-11-15T10:28:50+08:00">2022-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:32" itemprop="dateModified" datetime="2023-07-30T18:15:32+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/c/" itemprop="url" rel="index"><span itemprop="name">c++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="条款26-尽量延后变量定义式出现的时间"><a href="#条款26-尽量延后变量定义式出现的时间" class="headerlink" title="条款26 尽量延后变量定义式出现的时间"></a>条款26 尽量延后变量定义式出现的时间</h1><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法A 定义于循环外</span></span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    w = 取决于某个i的值;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法B 定义于循环内</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="function">Widget <span class="title">w</span><span class="params">(取决于某个i的值)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul>
<li>做法A<ul>
<li>1个构造函数 + 1个析构函数 + n个赋值操作</li>
</ul>
</li>
<li>做法B<ul>
<li>n个构造函数 + n个析构函数</li>
</ul>
</li>
<li>当classes的一个赋值成本低于一组构造+析构成本，做法A大体而言比较高效</li>
<li>此外A造成w的作用域比B更大，会对易维护性造成冲突</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li>当满足以下两点时使用方法A，否则使用方法B<ol>
<li>赋值成本低于构造+析构</li>
<li>代码对效率高度敏感</li>
</ol>
</li>
</ul>
<h1 id="条款27-尽量少做转型动作"><a href="#条款27-尽量少做转型动作" class="headerlink" title="条款27 尽量少做转型动作"></a>条款27 尽量少做转型动作</h1><ul>
<li>C++规则的设计目标之一:<ul>
<li>保证<em>类型错误</em>绝不可能发生</li>
</ul>
</li>
<li>C风格转型&#x2F;旧式转型  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(T)<span class="function">expression</span></span><br><span class="line"><span class="function"><span class="title">T</span><span class="params">(expression)</span> <span class="comment">/// 二者等价，将expression转型为T类型</span></span></span><br></pre></td></tr></table></figure></li>
<li>新式转型(<em>C++-style casts</em>)  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">const_cast</span>&lt;T&gt;( expression )         </span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;T&gt;( expression )</span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;T&gt;( expression )</span><br><span class="line"><span class="built_in">static_cast</span>&lt;T&gt;( expression )</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="新式转型更受欢迎"><a href="#新式转型更受欢迎" class="headerlink" title="新式转型更受欢迎:"></a>新式转型更受欢迎:</h3><ol>
<li>易辨识</li>
<li>转型动作的目标越窄化，编译器越可能诊断出错误的运用</li>
</ol>
<h3 id="唯一使用旧式转型的时机"><a href="#唯一使用旧式转型的时机" class="headerlink" title="唯一使用旧式转型的时机"></a>唯一使用旧式转型的时机</h3><ul>
<li>调用一个explicit构造函数将一个对象传递给一个函数  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(<span class="type">int</span> size)</span></span>; </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomeWork</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>;</span><br><span class="line"><span class="built_in">doSomeWork</span>(<span class="built_in">Widget</span>(<span class="number">15</span>));</span><br><span class="line"><span class="built_in">doSomeWork</span>(<span class="built_in">static_cast</span>&lt;Widget&gt;(<span class="number">15</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><ul>
<li>常量性转除</li>
<li>唯一有此功能的新式转型</li>
</ul>
<h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><ul>
<li>安全向下转型(safe downcasting)</li>
<li>唯一无法由旧式语法执行的动作</li>
<li>唯一可能耗费重大运行成本的转型动作</li>
</ul>
<h3 id="实现-一个普遍的版本"><a href="#实现-一个普遍的版本" class="headerlink" title="实现(一个普遍的版本)"></a>实现(一个普遍的版本)</h3><ul>
<li>基于class名称的字符串比较<ul>
<li>调用strcmp</li>
<li>深度、多重继承体系成本更高</li>
</ul>
</li>
</ul>
<h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><ul>
<li>执行低级转型</li>
<li>不可移植<ul>
<li>实际动作及结果取决于编译器</li>
<li>如将<code>pointer to int</code>转化为<code>int</code></li>
</ul>
</li>
</ul>
<h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><ul>
<li>强迫隐式转换(implicit conversion)<ul>
<li>non-const –&gt; const</li>
<li>void* –&gt; typed*</li>
<li>pointer-to-base –&gt; pointer-to-derived</li>
</ul>
</li>
</ul>
<h2 id="转型往往真的令编译器编译出运行期执行的码"><a href="#转型往往真的令编译器编译出运行期执行的码" class="headerlink" title="转型往往真的令编译器编译出运行期执行的码"></a>转型往往真的令编译器编译出运行期执行的码</h2><ul>
<li>不只是告诉编译器将某种类型视为另一种类型<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">...</span><br><span class="line"><span class="type">double</span> d = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(x) / y;</span><br></pre></td></tr></table></figure></li>
<li>将int转型为double几乎肯定会产生代码<ul>
<li>在大部分计算机体系结构中，int的底层表述不同于double<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; ... &#125;;</span><br><span class="line">Derived d;</span><br><span class="line">Base* pb = &amp;d; <span class="comment">/// 隐喻地将Derived*转换为Base*</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>同一个对象的Derived指针与Base指针值可能并不相同<ul>
<li>与编译器如何实现有关</li>
<li>有时候存在一个偏移量</li>
<li>运行时会计算偏移量以转型</li>
<li>多重继承中几乎必然发生，单一继承中可能发生</li>
</ul>
</li>
<li>避免做出“对象在C++中如何布局”的假设</li>
</ul>
<h1 id="条款28-避免返回handles指向对象内部分"><a href="#条款28-避免返回handles指向对象内部分" class="headerlink" title="条款28 避免返回handles指向对象内部分"></a>条款28 避免返回handles指向对象内部分</h1><h1 id="条款29-Strive-for-exception-safe-code"><a href="#条款29-Strive-for-exception-safe-code" class="headerlink" title="条款29 Strive for exception-safe code."></a>条款29 Strive for exception-safe code.</h1><ul>
<li>不泄露任何资源</li>
<li>不允许数据败坏</li>
</ul>
<h2 id="异常安全函数提供以下三个保证之一"><a href="#异常安全函数提供以下三个保证之一" class="headerlink" title="异常安全函数提供以下三个保证之一:"></a>异常安全函数提供以下三个保证之一:</h2><ol>
<li>基本承诺:<ul>
<li>异常抛出时，程序内的任何事物仍然保持在有效状态下。</li>
<li>但在哪个有效状态不可预料</li>
</ul>
</li>
<li>强烈保证:<ul>
<li>异常抛出时，程序状态不改变。</li>
<li>成功 –&gt; 完全成功</li>
<li>失败 –&gt; 回复到</li>
<li>往往以copy-and-swap实现</li>
<li>并非对所有函数都可实现或具备意义</li>
</ul>
</li>
<li>不抛掷(nothrow)保证:<ul>
<li>承诺绝不抛出异常</li>
<li>内置类型的操作均遵守</li>
</ul>
</li>
</ol>
<h1 id="条款30-透彻了解inline的里里外外"><a href="#条款30-透彻了解inline的里里外外" class="headerlink" title="条款30 透彻了解inline的里里外外"></a>条款30 透彻了解inline的里里外外</h1><h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>免除函数调用成本</li>
<li>编译器最优化机制通常用于浓缩“不含函数调用的代码”</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>增加<code>object code</code>的大小<ul>
<li>可能导致额外的的换页</li>
<li>降低cache命中率</li>
</ul>
</li>
</ul>
<h2 id="inline是对编译器的一个申请，不是强制命令"><a href="#inline是对编译器的一个申请，不是强制命令" class="headerlink" title="inline是对编译器的一个申请，不是强制命令"></a>inline是对编译器的一个申请，不是强制命令</h2><ul>
<li>编译器拒绝inline复杂函数<ul>
<li>如递归、循环、virtual(运行期决定)</li>
</ul>
</li>
<li>编译器无法inline将给出告警</li>
</ul>
<h3 id="隐式申请"><a href="#隐式申请" class="headerlink" title="隐式申请"></a>隐式申请</h3><ul>
<li>将函数定义为class定义式内<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">age</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> theAge; &#125; <span class="comment">// 一个隐喻的inline申请</span></span><br><span class="line">    ...                                <span class="comment">// age被定义与class定义式内</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> theAge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>这样的函数通常是成员函数，但是friend函数也可定义与class内(见 条款46)</li>
</ul>
<h3 id="显式申请"><a href="#显式申请" class="headerlink" title="显式申请"></a>显式申请</h3><ul>
<li>在定义式前加上关键字inline<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;algorithm&gt;</span></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">inline</span> <span class="type">const</span> T&amp; <span class="title">max</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="inline函数通常被置于头文件内"><a href="#inline函数通常被置于头文件内" class="headerlink" title="inline函数通常被置于头文件内"></a>inline函数通常被置于头文件内</h2><ul>
<li>编译期进行inline</li>
<li>方便编译器将函数调用替换为函数本体</li>
<li>template的具现化与inline无关<ul>
<li>通常被置于头文件内，方便编译器具现化</li>
</ul>
</li>
</ul>
<h2 id="有时即便编译器inline某个函数，可能还是为该函数生成一个函数本体"><a href="#有时即便编译器inline某个函数，可能还是为该函数生成一个函数本体" class="headerlink" title="有时即便编译器inline某个函数，可能还是为该函数生成一个函数本体"></a>有时即便编译器inline某个函数，可能还是为该函数生成一个函数本体</h2><ul>
<li>例如要取某个inline函数的地址时</li>
<li>编译器不对通过函数指针进行的调用实施inline  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="built_in">void</span> ( *pf ) = f;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">f</span>();        <span class="comment">// inline</span></span><br><span class="line"><span class="built_in">pf</span>();       <span class="comment">// outline</span></span><br></pre></td></tr></table></figure></li>
<li>编译器有时会自动生成inline函数的ouline副本<ul>
<li>比如生成构造和析构函数的副本，这样在array中可使用函数指针进行构造和析构</li>
</ul>
</li>
</ul>
<h2 id="构造函数和析构函数时inline糟糕的候选人"><a href="#构造函数和析构函数时inline糟糕的候选人" class="headerlink" title="构造函数和析构函数时inline糟糕的候选人"></a>构造函数和析构函数时inline糟糕的候选人</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::srting bm1, bm2;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123; &#125;;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::srting dm1, dm2, dm3;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>看起来构造函数和析构函数没有什么代码量，但其实不然</li>
<li>例如，一种可能的编译器实现:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Derived::<span class="built_in">Derived</span>() &#123;</span><br><span class="line">    Base::<span class="built_in">Base</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123; dm1.std::string::<span class="built_in">string</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123; </span><br><span class="line">        Base::~<span class="built_in">Base</span>();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123; dm2.std::string::<span class="built_in">string</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123; </span><br><span class="line">        Base::~<span class="built_in">Base</span>();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123; dm3.std::string::<span class="built_in">string</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123; </span><br><span class="line">        Base::~<span class="built_in">Base</span>();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="条款31-将文件间的编译依存关系降至最低"><a href="#条款31-将文件间的编译依存关系降至最低" class="headerlink" title="条款31 将文件间的编译依存关系降至最低"></a>条款31 将文件间的编译依存关系降至最低</h1><h2 id="编译依存关系"><a href="#编译依存关系" class="headerlink" title="编译依存关系"></a>编译依存关系</h2><ul>
<li>class的定义式不只详细描述了class接口，还包括十足的实现细目<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name. <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;    <span class="comment">/// 实现细目</span></span><br><span class="line">    Date theBirthDate;      <span class="comment">/// 实现细目</span></span><br><span class="line">    Address theAddress;     <span class="comment">/// 实现细目</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>C++将实现细目置于定义式中<ul>
<li>编译器需要根据定义式确定分配多大空间</li>
</ul>
</li>
<li>Person若要通过编译，需要classes string，Date，Address的定义式  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;date.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;address.h&quot;</span></span></span><br></pre></td></tr></table></figure></li>
<li>但是，如此一来，Person定义文件和其含入文件形成了编译依存关系<ul>
<li>如果这些头文件有一个被改变，或者这些头文件所依赖的其他文件有任何改变，那么每一个含入和使用Person class的文件也必须重新编译</li>
</ul>
</li>
</ul>
<h2 id="编译依存性最小化-–-接口与实现分离"><a href="#编译依存性最小化-–-接口与实现分离" class="headerlink" title="编译依存性最小化 – 接口与实现分离"></a>编译依存性最小化 – 接口与实现分离</h2><ul>
<li>通过Handle classes和Interface classes解除了接口和实现之间的耦合，降低了文件之间的编译依存性</li>
</ul>
<h3 id="pimpl-idiom-–-Handle-class"><a href="#pimpl-idiom-–-Handle-class" class="headerlink" title="pimpl idiom – Handle class"></a>pimpl idiom – <code>Handle class</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>   <span class="comment">// 标准程序组件不该被前置声明</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>   <span class="comment">// for shared_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PresonImpl</span>;   <span class="comment">// Person实现类的前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;         <span class="comment">// Person接口用到的classes的前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;PresonImpl&gt; pImpl_;</span><br><span class="line">&#125;;</span><br><span class="line">Person::<span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr)</span><br><span class="line">    : <span class="built_in">pImpl</span>(<span class="keyword">new</span> <span class="built_in">PresonImpl</span>(name, birthday, addr))</span><br><span class="line">    &#123;&#125;</span><br><span class="line"><span class="function">std::string <span class="title">Person::name</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pImpl-&gt;<span class="built_in">name</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Person的客户端完全与Date，Address以及Person的实现细目分开</li>
</ul>
<h3 id="抽象基类-abstract-base-class、Interface-class"><a href="#抽象基类-abstract-base-class、Interface-class" class="headerlink" title="抽象基类(abstract base class、Interface class)"></a>抽象基类(abstract base class、Interface class)</h3><ul>
<li>详细一一描述derived class的接口<ul>
<li>一组pure virtual函数</li>
</ul>
</li>
<li>通常不带成员变量，也没有构造函数</li>
<li>只有一个virtual析构函数(见条款7)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>客户必须以Person的pointers和references来撰写应用程序<ul>
<li>除非Interface class修改，否则不用编译</li>
</ul>
</li>
<li>客户必须有办法为这种class创建新对象<ul>
<li>工厂函数<ul>
<li>返回指针指向动态分配所得的对象</li>
<li>往往在Interface class中声明为static  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;Person&gt; <span class="title">create</span><span class="params">(<span class="type">const</span> std::string&amp; name, </span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> Date&amp; birthday, </span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> Address&amp; addr)</span></span>; <span class="comment">// why shared_ptr;见条款18</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 客户如此使用</span></span><br><span class="line">std::string; name, </span><br><span class="line">Date dateodBirth, </span><br><span class="line">Address address;</span><br><span class="line">...</span><br><span class="line"><span class="function">std::shared_ptr&lt;Person&gt; <span class="title">pp</span><span class="params">(Person::create(name, dateodBirth, address))</span></span>;</span><br><span class="line">...</span><br><span class="line">std::cout &lt;&lt; pp-&gt;<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>当然，支持Interface class接口的那个具象类(<code>concrete class</code>)必须被定义出来<ul>
<li>一切都在virtual构造函数的实现码所在文件内秘密发生  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealPerson</span> : <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RealPerson</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr)</span><br><span class="line">        : <span class="built_in">theName</span>(name), <span class="built_in">theBirthDate</span>(birthday), <span class="built_in">theAddress</span>(addr)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">RealPerson</span>() &#123;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;    </span><br><span class="line">    Date theBirthDate;      </span><br><span class="line">    Address theAddress;     </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> std::shared_ptr&lt;Person&gt; <span class="title">Person::create</span><span class="params">(<span class="type">const</span> std::string&amp; name, </span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">const</span> Date&amp; birthday, </span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">const</span> Address&amp; addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> <span class="built_in">RealPerson</span>(name, dateodBirth, addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>更现实的Person::create实现代码会创建不同的derived class</li>
</ul>
</li>
</ul>
<h3 id="开销"><a href="#开销" class="headerlink" title="开销"></a>开销</h3><h4 id="Handle-classes"><a href="#Handle-classes" class="headerlink" title="Handle classes"></a>Handle classes</h4><ol>
<li>成员函数必须通过implementation pointer取得对象数据，<ul>
<li>每次访问增加一次间接性</li>
</ul>
</li>
<li>每个对象的内存消耗多一个implementation pointer的大小</li>
<li>implementation pointer必须初始化，指向动态分配的implementation内存<ul>
<li>涉及到动态分配</li>
</ul>
</li>
</ol>
<h4 id="Interface-class"><a href="#Interface-class" class="headerlink" title="Interface class"></a>Interface class</h4><ol>
<li>virtual函数带来间接跳跃(见条款7)</li>
<li>派生类对象有一个vptr(见条款7)</li>
</ol>
<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><ul>
<li>声明的依存性 替换 定义的依存性</li>
<li>尽量让头文件自我满足，做不到则让它与其他头文件内的声明式而非定义式相依</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="如果使用object-reference-pointer可以完成任务，就不要使用object"><a href="#如果使用object-reference-pointer可以完成任务，就不要使用object" class="headerlink" title="如果使用object reference&#x2F;pointer可以完成任务，就不要使用object"></a>如果使用object reference&#x2F;pointer可以完成任务，就不要使用object</h3><ul>
<li>前者仅需声明，后者需要定义</li>
</ul>
<h3 id="如果能够，尽量用class声明式替换class定义式"><a href="#如果能够，尽量用class声明式替换class定义式" class="headerlink" title="如果能够，尽量用class声明式替换class定义式"></a>如果能够，尽量用class声明式替换class定义式</h3><ul>
<li>注意，当声明一个函数而它用到某个class的定义时，并不需要该class的定义  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;                         <span class="comment">// class声明式</span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span></span>;                       <span class="comment">// 没问题，这里并不需要Date的定义式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="为声明式和定义式提供不同的头文件"><a href="#为声明式和定义式提供不同的头文件" class="headerlink" title="为声明式和定义式提供不同的头文件"></a>为声明式和定义式提供不同的头文件</h3><ul>
<li>程序库客户应该总是#include一个声明文件而非前置声明若干class或函数  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;datafw.h&quot;</span>  <span class="comment">// 这个头文件内声明单未定义class Date</span></span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span></span>;                      </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>只含声明式的头文件名为”datefw.h”,命名方式取法C++标准库的<iosfwd><ul>
<li><iosfwd>内含iostream各组件的声明式，其定义则分布在相应的头文件，包括<sstream>,<streambuf>,<fstream>,<iostream></li>
</ul>
</li>
<li>此方法同样适用于template<ul>
<li>export关键字同样可以，但很少使用</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2022/11/13/Tomasulo%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2022/11/13/Tomasulo%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">Tomasulo算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-13 22:00:05" itemprop="dateCreated datePublished" datetime="2022-11-13T22:00:05+08:00">2022-11-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:18" itemprop="dateModified" datetime="2023-07-30T18:15:18+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/CPU-pipeline/" itemprop="url" rel="index"><span itemprop="name">CPU pipeline</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul>
<li>流水线运行的一个主要限制是：它们使用循序指令发射与执行的方式</li>
</ul>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><ul>
<li>动态调度</li>
</ul>
<h3 id="乱序执行"><a href="#乱序执行" class="headerlink" title="乱序执行"></a>乱序执行</h3><ul>
<li>操作数可用时立即执行程序</li>
<li>指令的循序发射以及乱序执行</li>
</ul>
<h3 id="寄存器重命名"><a href="#寄存器重命名" class="headerlink" title="寄存器重命名"></a>寄存器重命名</h3><ul>
<li>在写结果时，先将计算结果写到CDB（公共数据总线）中。然后CDB上进行广播，看这个计算结果有没有作为是其他指令源操作数的。如果保留站发现有，就会更新保留站源操作数的值。这样就代替了流水线寄存器。</li>
</ul>
<h3 id="循序提交"><a href="#循序提交" class="headerlink" title="循序提交"></a>循序提交</h3><ul>
<li>引入ROB(重排缓冲区, Reorder Buffer)</li>
<li>允许指令乱序执行，但必须循序提交</li>
<li>支持分支预测<ul>
<li>对于推测错误就很好处理了，<ul>
<li>因为哪怕已经执行了分支之后的命令，由于之前的指令还没有执行完毕，分支之后的指令就无法提交，所以很容易的就程序计数器改为正确的分支地址，而不影响其他指令结果。</li>
</ul>
</li>
<li>预测错误的概率还是相对较低的，在Intel Core i7的分支预测器中错误预测率平均在5%以下</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zyh-eric.gitee.io/zyhjy/2022/11/13/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E5%99%A8-TAGE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/zyhjy/2022/11/13/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E5%99%A8-TAGE/" class="post-title-link" itemprop="url">分支预测器-TAGE</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-13 22:00:05" itemprop="dateCreated datePublished" datetime="2022-11-13T22:00:05+08:00">2022-11-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-30 18:15:18" itemprop="dateModified" datetime="2023-07-30T18:15:18+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/zyhjy/categories/CPU-pipeline/" itemprop="url" rel="index"><span itemprop="name">CPU pipeline</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><ul>
<li>conditional branch predicor<ul>
<li>combine several predictions</li>
<li>adder tree?</li>
</ul>
</li>
<li>文章实现了一个组合预测器<ul>
<li>预测器的下标代表该预测器对应的history length</li>
</ul>
</li>
</ul>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul>
<li>流水线运行的一个主要限制是：它们使用循序指令发射与执行的方式</li>
</ul>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><ul>
<li>动态调度</li>
</ul>
<h3 id="乱序执行"><a href="#乱序执行" class="headerlink" title="乱序执行"></a>乱序执行</h3><ul>
<li>操作数可用时立即执行程序</li>
<li>指令的循序发射以及乱序执行</li>
</ul>
<h3 id="寄存器重命名"><a href="#寄存器重命名" class="headerlink" title="寄存器重命名"></a>寄存器重命名</h3><ul>
<li>在写结果时，先将计算结果写到CDB（公共数据总线）中。然后CDB上进行广播，看这个计算结果有没有作为是其他指令源操作数的。如果保留站发现有，就会更新保留站源操作数的值。这样就代替了流水线寄存器。</li>
</ul>
<h3 id="循序提交"><a href="#循序提交" class="headerlink" title="循序提交"></a>循序提交</h3><ul>
<li>引入ROB(重排缓冲区, Reorder Buffer)</li>
<li>允许指令乱序执行，但必须循序提交</li>
<li>支持分支预测<ul>
<li>对于推测错误就很好处理了，<ul>
<li>因为哪怕已经执行了分支之后的命令，由于之前的指令还没有执行完毕，分支之后的指令就无法提交，所以很容易的就程序计数器改为正确的分支地址，而不影响其他指令结果。</li>
</ul>
</li>
<li>预测错误的概率还是相对较低的，在Intel Core i7的分支预测器中错误预测率平均在5%以下</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/zyhjy/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/zyhjy/">1</a><a class="page-number" href="/zyhjy/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/zyhjy/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/zyhjy/page/6/">6</a><a class="extend next" rel="next" href="/zyhjy/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yuhang Zhang"
      src="/zyhjy/images/zyhjy.png">
  <p class="site-author-name" itemprop="name">Yuhang Zhang</p>
  <div class="site-description" itemprop="description">爱小雅，爱生活，爱物理!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/zyhjy/archives/">
        
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/zyhjy/categories/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/zyhjy/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuhang Zhang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/zyhjy/lib/anime.min.js"></script>

<script src="/zyhjy/js/utils.js"></script>


<script src="/zyhjy/js/schemes/pisces.js"></script>


<script src="/zyhjy/js/next-boot.js"></script>




  















  

  

</body>
</html>
