<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
<meta name="referrer" content="no-referrer">
  <link rel="apple-touch-icon" sizes="180x180" href="/zyhjy/images/relativity128.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/zyhjy/images/relativity32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/zyhjy/images/relativity16.png">
  <link rel="mask-icon" href="/zyhjy/images/logo.svg" color="#222">

<link rel="stylesheet" href="/zyhjy/css/main.css">

<link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css?family=Comic Sans MS:300,300italic,400,400italic,700,700italic|Noto Serif SC:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/zyhjy/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/zyhjy/lib/pace/pace-theme-minimal.min.css">
  <script src="/zyhjy/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"eric-zhang-c.github.io","root":"/zyhjy/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1. 在main函数执行之前和之后执行的代码可能是什么 在main函数执行之前  运行时环境的初始化：操作系统和运行时环境会在程序启动时进行初始化工作，例如加载程序、复制.data段和初始化.bss段、设置程序的入口点、栈指针、命令行参数的解析等。 全局对象和静态对象的构造函数：构造函数按照它们的定义顺序调用。这包括全局变量、静态成员变量和静态变量（全局 &amp; 局部）。 __attribu">
<meta property="og:type" content="article">
<meta property="og:title" content="cpp面试问题合集">
<meta property="og:url" content="https://eric-zhang-c.github.io/zyhjy/2024/05/25/cppquestions/">
<meta property="og:site_name" content="ZYHJY">
<meta property="og:description" content="1. 在main函数执行之前和之后执行的代码可能是什么 在main函数执行之前  运行时环境的初始化：操作系统和运行时环境会在程序启动时进行初始化工作，例如加载程序、复制.data段和初始化.bss段、设置程序的入口点、栈指针、命令行参数的解析等。 全局对象和静态对象的构造函数：构造函数按照它们的定义顺序调用。这包括全局变量、静态成员变量和静态变量（全局 &amp; 局部）。 __attribu">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-05-25T04:22:50.000Z">
<meta property="article:modified_time" content="2024-07-18T15:05:07.730Z">
<meta property="article:author" content="Yuhang Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://eric-zhang-c.github.io/zyhjy/2024/05/25/cppquestions/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>cpp面试问题合集 | ZYHJY</title><meta name="robots" content="noindex">
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-J17VP3T2B4"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-J17VP3T2B4');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/zyhjy/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ZYHJY</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/zyhjy/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/zyhjy/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/zyhjy/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/zyhjy/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/zyhjy/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-solutions">

    <a href="/zyhjy/solutions/" rel="section"><i class="fa fa-code fa-fw"></i>算法题解</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://eric-zhang-c.github.io/zyhjy/2024/05/25/cppquestions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          cpp面试问题合集
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-25 12:22:50" itemprop="dateCreated datePublished" datetime="2024-05-25T12:22:50+08:00">2024-05-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-18 23:05:07" itemprop="dateModified" datetime="2024-07-18T23:05:07+08:00">2024-07-18</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>31 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="section"></h1>
<h2 id="在main函数执行之前和之后执行的代码可能是什么">1.
在<code>main</code>函数执行之前和之后执行的代码可能是什么</h2>
<h3 id="在main函数执行之前">在<code>main</code>函数执行之前</h3>
<ol type="1">
<li>运行时环境的初始化：操作系统和运行时环境会在程序启动时进行初始化工作，例如加载程序、复制<code>.data</code>段和初始化<code>.bss</code>段、设置程序的入口点、栈指针、命令行参数的解析等。</li>
<li>全局对象和静态对象的构造函数：构造函数按照它们的定义顺序调用。这包括全局变量、静态成员变量和静态变量（全局
&amp; 局部）。</li>
<li><code>__attribute__(constructor)</code> : gcc编译器特性</li>
<li>C++标准库的初始化：C++标准库中的一些组件可能需要在程序启动时进行初始化，以确保其在<code>main()</code>函数执行之前可用。这可能包括标准I/O流对象（如<code>std::cin</code>和<code>std::cout</code>）以及其他全局对象。</li>
</ol>
<h3 id="在main函数执行之后">在<code>main</code>函数执行之后</h3>
<ol type="1">
<li><p>全局对象和静态对象的析构函数</p></li>
<li><p><code>__attribute__(destructor)</code>: gcc编译器特性</p></li>
<li><p><code>at_exit</code>：<code>at_exit</code> 是一个在 C++
标准库中的函数，用于注册在程序退出时执行的函数。它接受一个函数指针作为参数，并在程序终止时调用该函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">atexit</span>(cleanupFunction);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="tips-1.1-.data段和.bss段">tips 1.1:
<code>.data</code>段和<code>.bss</code>段</h4>
<p>数据段（data段）： - 数据段用于存储已经初始化的全局变量和静态变量。 -
在编译时，这些变量会被赋予特定的初始值，并且这些初始值会在程序加载时保持不变。
-
已初始化的静态变量和全局变量会占用可执行文件的空间，并在程序加载时将其内容复制到数据段。
-
具有静态存储期的局部静态变量（在函数内部声明的静态变量）也存储在数据段。</p>
<p>BSS段（bss段, Block Started by Symbol）： -
BSS段用于存储未初始化的全局变量和静态变量，也称为零初始化段。 -
在编译时，这些变量并不赋予特定的初始值，而是将它们的值默认设置为零（对于基本数据类型）或空（对于指针和类类型）。
-
未初始化的静态变量和全局变量不占用可执行文件的空间，而是在程序加载时动态分配。
-
运行时环境在程序加载时会将BSS段的内存空间清零，以确保这些变量的初始值为零或空。</p>
<hr />
<h2 id="结构体内存对齐">2. 结构体内存对齐</h2>
<ul>
<li><p>关键字<code>alignof</code>:计算出类型的对齐方式</p></li>
<li><p>关键字<code>alignas</code>：指定结构体的对齐方式（需要大于等于默认对齐的大小）</p></li>
<li><p><code>__attribute__((packed))</code>：指定结构体为单字节对齐</p></li>
</ul>
<hr />
<h2 id="指针与引用">3. 指针与引用</h2>
<ul>
<li>编译器在处理引用时：
<ol type="1">
<li>直接操作内存地址 （参数传递、返回引用、成员引用）</li>
<li>转为指针处理（局部引用）</li>
</ol></li>
</ul>
<hr />
<h2 id="newdelete-mallocfree">4. <code>new</code>/<code>delete</code> |
<code>malloc</code>/<code>free</code></h2>
<table>
<thead>
<tr class="header">
<th></th>
<th><code>new</code>/<code>delete</code></th>
<th><code>malloc</code>/<code>free</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>本质</td>
<td>运算符</td>
<td>标准库函数</td>
</tr>
<tr class="even">
<td>分配空间大小</td>
<td>自动计算</td>
<td>手动计算</td>
</tr>
<tr class="odd">
<td>是否类型安全</td>
<td>类型安全</td>
<td>非类型安全</td>
</tr>
<tr class="even">
<td>构造/析构？</td>
<td>自动调用构造/析构函数</td>
<td></td>
</tr>
<tr class="odd">
<td>返回类型</td>
<td>具体类型指针</td>
<td>void类型指针</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="c和python的区别">5. C++和python的区别</h2>
<ol type="1">
<li>语言类型：C++
是一种<strong>静态类型</strong>的编程语言，它在<strong>编译时进行类型检查</strong>，并要求显式声明变量的类型。Python
是一种<strong>动态类型</strong>的编程语言，它在<strong>运行时进行类型检查</strong>，不需要显式声明变量的类型。</li>
<li>语法和风格：C++
的语法更为严格和复杂，需要注意分号、大括号等细节。它遵循面向对象编程（OOP）和过程式编程范式。Python
的语法相对简洁和易读，使用缩进来表示代码块。它支持面向对象编程和函数式编程范式。</li>
<li>性能：C++ 通常比 Python 执行速度更快，因为 C++
是<strong>编译型语言</strong>，可以直接编译成机器码执行。Python
是<strong>解释型语言</strong>，需要通过解释器逐行解释执行，相对而言运行速度较慢。</li>
<li>内存管理：C++ 需要手动进行内存管理，包括手动分配和释放内存。Python
使用自动的垃圾回收机制，开发者不需要显式地管理内存。</li>
</ol>
<hr />
<h2 id="c和c的区别">6. C++和C的区别</h2>
<ol type="1">
<li>面向对象编程：C++
是一种支持面向对象编程（OOP）范式的语言，它提供了类、继承、封装、多态等特性，能够更方便地组织和管理代码。C
语言则不直接支持面向对象编程，更偏向于过程式编程。</li>
<li>类型检查：C++
在编译时进行类型检查，要求显式声明变量的类型，并提供强类型检查。C
语言的类型检查相对较弱，变量的类型可以更灵活地进行隐式转换。</li>
<li>标准库：C++ 标准库相对于 C
语言更加丰富，包括了很多容器、算法、字符串处理、输入输出等功能，提供了更高级的抽象和便利性。C
语言的标准库相对较小，主要包括了一些基本的输入输出和字符串处理函数。</li>
<li>异常处理：C++ 支持异常处理机制，可以使用 <code>try-catch</code>
块来捕获和处理异常。C
语言没有内置的异常处理机制，通常使用错误码或返回值来处理错误情况。</li>
<li>内存管理：C++
提供了更高级的内存管理机制，包括了自动变量的生命周期管理（通过构造函数和析构函数），以及动态内存分配和释放（通过
<code>new</code> 和 <code>delete</code> 运算符）。C
语言则需要手动进行内存管理，使用 <code>malloc</code> 和
<code>free</code> 函数进行动态内存分配和释放。</li>
<li>兼容性：C++ 是 C 的超集，这意味着几乎所有的 C 代码都可以在 C++
中编译和运行。C++ 语言增加了一些新的关键字和语法，因此某些 C
代码可能需要进行一些调整以在 C++ 中运行。</li>
</ol>
<hr />
<h2 id="c和java的区别">7. C++和Java的区别</h2>
<ol type="1">
<li>平台依赖性：C++
是一种跨平台的编程语言，可以在不同的操作系统上进行开发和运行，但需要编译后运行。Java
也是跨平台的，但是通过 Java 虚拟机（JVM）实现了平台无关性，Java
代码在不同的操作系统上可以通过 JVM 进行解释执行。</li>
<li>内存管理：C++
要求开发者手动进行内存管理，包括手动分配和释放内存。Java
使用自动的垃圾回收机制，开发者不需要显式地管理内存，垃圾回收器会自动回收不再使用的内存。</li>
<li>运行速度：通常情况下，C++ 的执行速度比 Java 快，因为 C++
是编译型语言，可以直接编译成机器码执行。Java 是解释型语言，需要通过 JVM
解释执行字节码。</li>
<li>适用场景：C++ 更适合对性能要求高、控制精细、底层开发等场景。Java
更适合跨平台开发、企业级应用开发、大型系统开发等场景，注重开发效率和可维护性。</li>
</ol>
<hr />
<h2 id="class与struct">8. <code>class</code>与<code>struct</code></h2>
<ul>
<li><code>class</code>默认<code>private</code>继承，<code>struct</code>默认<code>public</code>继承</li>
<li>（<code>class</code>成员默认<code>private</code>，<code>struct</code>成员默认<code>public</code>）</li>
<li>C中的<code>struct</code>只能封装数据（没有权限设置，也没有成员函数）</li>
</ul>
<hr />
<h2 id="define与const">9. <code>define</code>与<code>const</code></h2>
<p><code>define</code>
是一个预处理指令，用于在编译之前对标识符进行替换。它没有类型检查，仅仅进行简单的文本替换，不会为常量分配内存。<code>define</code>
的定义是全局的，可以在源代码的任何地方使用。</p>
<p><code>const</code> 是 C++
中的关键字，用于定义具有常量值的变量。<code>const</code>
声明的常量具有类型，并在编译时进行类型检查。常量使用 <code>const</code>
关键字进行声明，它们在内存中通常被分配为静态存储，不可修改。<code>const</code>
常量的作用域限定在声明所在的作用域内。</p>
<p>主要区别如下：</p>
<ol type="1">
<li><p><strong>类型检查</strong>：<code>const</code>
声明的常量具有类型检查，可以在编译时捕获类型错误，而 <code>define</code>
没有类型检查。</p></li>
<li><p><strong>作用域</strong>：<code>define</code>
定义的常量是全局的，可以在源代码的任何地方使用，而 <code>const</code>
常量的作用域限定在声明所在的作用域内。</p></li>
<li><p><strong>内存分配</strong>：<code>define</code>
并不会为常量分配内存，而是进行简单的文本替换，而 <code>const</code>
常量在内存中通常被分配为静态存储。</p></li>
<li><p><strong>替换方式</strong>：<code>define</code>
是简单的文本替换，没有表达式求值的概念，而 <code>const</code>
常量可以包含表达式，并在编译时求值。</p></li>
</ol>
<h4 id="tips9.1-静态存储和动态存储">tips9.1 静态存储和动态存储:</h4>
<p>静态存储和动态存储是计算机编程中的两种不同的内存分配方式。</p>
<p><strong>静态存储</strong>是指在<strong>程序开始执行之前</strong>就分配好内存，并在整个程序的执行期间一直存在的内存空间。这种内存分配方式适用于全局变量、静态变量和静态常量等。静态存储区的内存分配在编译时完成，分配的内存空间在程序执行期间一直存在，直到<strong>程序结束才会被释放</strong>。</p>
<p>静态存储区包括以下几个部分：</p>
<ol type="1">
<li><p><strong>全局变量</strong>区：用于存储全局变量，这些变量在整个程序执行期间都是可见的（也包括命名空间中的变量）。</p></li>
<li><p><strong>静态变量</strong>区：用于存储在函数内部定义的静态变量。</p></li>
<li><p><strong>静态常量</strong>区：用于存储在程序中定义的静态常量，这些常量的值在程序执行期间不会改变。</p></li>
</ol>
<p><strong>动态存储</strong>是指在程序<strong>运行时</strong>根据需要进行内存<strong>分配和释放</strong>的方式。</p>
<p>动态存储区包括以下几个部分：</p>
<ol type="1">
<li><p>堆（Heap）：用于存储动态分配的对象和数组。程序员需要手动分配和释放堆内存。</p></li>
<li><p>栈（Stack）：用于存储函数的局部变量和函数调用的上下文信息。栈上的内存分配和释放由编译器自动管理。</p></li>
</ol>
<hr />
<h2 id="static与const">10. <code>static</code>与<code>const</code></h2>
<h3 id="static">10.1 <code>static</code></h3>
<h4 id="c语言部分">C语言部分</h4>
<ol type="1">
<li>静态变量：
<ul>
<li>在函数内部：使用 <code>static</code>
关键字声明的变量是静态变量，其生命周期与程序的执行期间相同，不会随着函数的调用而创建和销毁。静态变量在第一次执行声明语句时被初始化，之后保持其值不变。</li>
<li>在全局（文件）作用域：使用 <code>static</code>
关键字声明的全局变量具有文件作用域，只能在声明它的源文件中访问，对其他文件是不可见的。它们在程序启动时被初始化，并在整个程序的执行期间一直存在。</li>
</ul></li>
<li>静态函数：
<ul>
<li>在函数内部：使用 <code>static</code>
关键字声明的函数是静态函数，它们只能在声明它们的源文件中调用，对其他文件是不可见的。</li>
</ul></li>
</ol>
<h4 id="c部分">C++部分</h4>
<ol type="1">
<li>静态成员变量：
<ul>
<li>在类中声明的静态成员变量属于类本身，而不是类的实例。它在程序执行期间只分配一次内存，并在整个程序的执行期间保持存在。静态成员变量可以通过类名和作用域解析运算符
<code>::</code> 来访问，也可以通过类的对象访问。需要在类外初始化。</li>
</ul></li>
<li>静态成员函数：
<ul>
<li>静态成员函数属于类本身，而不是类的实例。它们不依赖于任何特定的对象实例，并且可以直接通过类名来调用，而不需要创建对象。静态成员函数只能访问静态成员变量和其他静态成员函数，不能访问非静态成员变量和非静态成员函数。不能访问this指针。不能被声明为const、虚函数、volatile</li>
</ul></li>
<li>静态修饰符：
<ul>
<li>在命名空间中：在命名空间中声明的变量或函数可以使用
<code>static</code>
关键字进行静态修饰。静态修饰符将限定标识符的作用域为当前命名空间，使其在其他源文件中不可见。</li>
</ul></li>
</ol>
<h3 id="const">10.2 <code>const</code></h3>
<h4 id="c语言部分-1">C语言部分</h4>
<ol type="1">
<li>声明常量：
<ul>
<li>使用 <code>const</code>
关键字声明的变量是常量，其值在声明后不能被修改。常量在程序执行期间保持不变。</li>
</ul></li>
<li><code>const</code>形参</li>
</ol>
<h4 id="c部分-1">C++部分</h4>
<ol type="1">
<li>修饰类成员函数：
<ul>
<li>表示该成员函数不会修改类的成员变量。这样的成员函数被称为常量成员函数，它们可以在常量对象上调用，但不能修改对象的状态。</li>
<li>可以改变<code>mutable</code>修饰的成员变量</li>
</ul></li>
<li>修饰类成员变量：
<ul>
<li>类内部定义时初始化，或使用初始化列表</li>
</ul></li>
<li>常量对象
<ul>
<li>不能调用非const成员函数</li>
</ul></li>
</ol>
<h4 id="tips10.3-static-data-member的初始化问题">tips10.3
<code>static data member</code>的初始化问题</h4>
<ul>
<li>non-const static data member must be initialized out of line</li>
<li>非常量静态数据成员必须在类外进行初始化。这是因为非常量静态数据成员在内存中有一个唯一的实例，需要在<strong>全局范围</strong>内进行定义和初始化。如果在类内初始化非常量静态数据成员，会被static隐藏在作用域中，因此编译器将会报错。</li>
<li>可以通过<code>const</code>,
<code>constexpr</code>修饰静态成员变量，<code>const</code>变量是全局的，因此可在类内初始化。</li>
</ul>
<h4 id="tips10.4-static-constexpr-string无法在类内初始化">tips10.4
<code>static constexpr string</code>无法在类内初始化</h4>
<p>对于静态成员变量，C++
允许在类内初始化静态整型常量（<code>static const int</code>）成员，但不允许在类内初始化静态字符串常量（<code>static constexpr std::string</code>）成员。这是由于
C++ 语言的规定和语义差异导致的。</p>
<p>静态整型常量成员可以在类内初始化是因为整型常量的值在编译时就可以确定，且在运行时不可修改。因此，可以在类的声明中直接提供初始值。这种初始化方式在
C++11 之前就是允许的。</p>
<p>然而，静态字符串常量成员的初始化涉及到字符串的存储和复制。C++
中的字符串是一个复杂的数据结构，需要在<strong>运行时分配内存</strong>和进行复制操作，无法在编译时确定。因此，C++
不允许在类内直接初始化静态字符串常量成员。</p>
<h4 id="tips10.5-constexpr与const">tips10.5
<code>constexpr</code>与<code>const</code></h4>
<ol type="1">
<li>定义：
<ul>
<li><code>const</code> 关键字用于声明不可修改的常量。一旦变量被声明为
<code>const</code>，其值在声明后不能被修改。常量可以是编译时常量也可以是运行时常量。</li>
<li><code>constexpr</code>
关键字用于声明在编译时就可以计算出结果的常量表达式。它的值在编译期间就确定，并且必须由编译器求值，不能包含运行时的操作。</li>
</ul></li>
<li>编译时求值：
<ul>
<li><code>const</code>
变量的值可以在运行时计算或通过函数调用获得，因此它可以是<strong>运行时常量</strong>。编译器不会对
<code>const</code>
变量进行特殊处理，而是将其视为普通变量，只是在语法上强制要求不修改其值。</li>
<li><code>constexpr</code>
变量必须在<strong>编译时</strong>求值，并且只能使用编译时已知的值和操作来计算结果。编译器会在编译期间对
<code>constexpr</code> 表达式进行求值，并将其嵌入到生成的代码中。</li>
</ul></li>
<li>函数：
<ul>
<li><code>const</code>
修饰成员函数时，表示该成员函数不会修改类的非静态成员变量。它可以在常量对象上调用，但不能修改对象的状态。</li>
<li><code>constexpr</code>
修饰函数时，表示该函数可以在编译时求值，并且其参数和返回值必须是编译时已知的常量表达式。<code>constexpr</code>
函数可以用于在编译期间执行计算，生成编译时常量。</li>
</ul></li>
<li>用途：
<ul>
<li><code>const</code>
适用于声明各种类型的常量，包括基本数据类型、用户自定义类型、指针等。它可以用于<strong>任何需要常量的地方</strong>。</li>
<li><code>constexpr</code>
主要用于声明编译时常量，例如数组大小、枚举值、模板参数等。它可以在编译期间进行求值，用于要求<strong>编译时常量</strong>的上下文。</li>
</ul></li>
</ol>
<hr />
<h2 id="数组名和指向首个元素的指针">11. 数组名和指向首个元素的指针</h2>
<ol type="1">
<li>数组名：
<ul>
<li>数组名是一个常量指针（const pointer），它指向数组的首个元素。</li>
<li>当数组名出现在<strong>表达式</strong>中时，它会被<strong>隐式转换为指向首个元素的指针</strong>。</li>
<li>数组名可以用于取数组的地址，即 <code>&amp;array</code>。</li>
<li>数组名不能进行自增（<code>++</code>）或自减（<code>--</code>）操作。</li>
</ul></li>
<li>指向首个元素的指针：
<ul>
<li>指向首个元素的指针是一个变量，该变量存储数组首个元素的地址。</li>
<li>指针可以被重新赋值，指向数组中的不同元素。</li>
<li>指针可以进行自增（<code>++</code>）或自减（<code>--</code>）操作，以访问数组中的其他元素。</li>
<li>指针可以用于指针算术运算，如指针加法、减法等。</li>
<li>指向首个元素的指针可以通过取数组的地址或使用数组名来获取。</li>
</ul></li>
</ol>
<hr />
<h2 id="class">12. <code>Class</code></h2>
<h3 id="构造函数的类型">1. 构造函数的类型</h3>
<h4 id="默认构造函数">1.默认构造函数：</h4>
<p>默认构造函数没有参数，用于创建对象时不需要提供任何初始值。</p>
<h5 id="隐式声明">1. 隐式声明</h5>
<p>如果没有对类类型提供任何用户声明的构造函数，那么编译器将<strong>始终声明</strong>一个作为它的类的<code>inline public</code>
成员的默认构造函数。</p>
<h5 id="隐式定义">2. 隐式定义</h5>
<p>如果默认构造函数是<strong>隐式声明</strong>的 (C++11
前)隐式声明的或<strong>显式预置</strong>的默认构造函数没有被定义为弃置的
(C++11 起)，那么当它<strong>被 <a
target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/definition#ODR_.E4.BD.BF.E7.94.A8">ODR
使用</a></strong>或者被<strong><a
target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/constant_expression#.E5.B8.B8.E9.87.8F.E6.B1.82.E5.80.BC.E6.89.80.E9.9C.80.E8.A6.81.E7.9A.84.E5.87.BD.E6.95.B0.E4.B8.8E.E5.8F.98.E9.87.8F">常量求值所需要</a>
</strong>(C++11
起)时，编译器会定义它（即生成函数体并编译），且它与拥有空函数体和空初始化器列表的用户定义的构造函数有严格相同的效果。即它调用这个类的各<strong>基类和各非静态成员</strong>的默认构造函数。</p>
<h5 id="弃置的默认构造函数">3. 弃置的默认构造函数</h5>
<p>用户显式<code>delete</code>。</p>
<p>包含无法默认初始化的非静态成员变量，如成员或包含有非静态的引用限定/const限定的成员变量。</p>
<h4 id="参数化构造函数">2. 参数化构造函数：</h4>
<ul>
<li>参数化构造函数接受一个或多个参数，用于在对象创建时提供初始值。</li>
<li>参数化构造函数可以根据提供的参数不同而重载，以支持不同类型或数量的参数。</li>
</ul>
<h4 id="拷贝复制构造函数">3. 拷贝（复制）构造函数：</h4>
<ul>
<li>拷贝构造函数用于创建一个对象，并将其初始化为同类的另一个对象的副本。</li>
<li>拷贝构造函数接受一个同类对象的引用作为参数，用于执行深拷贝。</li>
<li>类可以拥有多个拷贝构造函数，如 T::T(const T&amp;) 和
T::T(T&amp;)。</li>
</ul>
<h5 id="隐式声明-1">1. 隐式声明</h5>
<p>如果没有向类类型提供任何用户定义的拷贝构造函数，那么编译器总是会声明一个拷贝构造函数作为这个类的非
explicit的 inline public
成员。如果满足下列所有条件，那么这个隐式声明的拷贝构造函数拥有形式
T::T(const T&amp;)：</p>
<ul>
<li><code>T</code>
的每个直接<strong>基类</strong>和<strong>虚基类</strong> <code>B</code>
均拥有形参类型是 <strong>const B&amp;</strong> 或 <strong>const volatile
B&amp; </strong>的拷贝构造函数；</li>
<li><code>T</code>
的每个类类型或类类型数组的<strong>非静态数据成员</strong> <code>M</code>
均拥有形参类型是 <strong>const M&amp;</strong> 或 <strong>const volatile
M&amp;</strong> 的拷贝构造函数。</li>
</ul>
<p>否则，隐式声明的拷贝构造函数是 T::T(T&amp;)。</p>
<h5 id="弃置">2. 弃置</h5>
<p>声明了<a
target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/move_constructor">移动构造函数</a>或<a
target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/move_assignment">移动赋值运算符</a>的情况下会被弃置。</p>
<p>类中存在无法复制的非静态数据成员（如具有右值引用类型的非静态数据成员）会被弃置。</p>
<h5 id="为什么不能传值">4. 为什么不能传值</h5>
<p>如果拷贝构造函数接受值参数而不是引用，那么在调用拷贝构造函数时，将会触发另一个拷贝构造函数的调用，这将导致无限递归。</p>
<h5 id="阻止编译器自动生成的拷贝构造函数的方法">5.
阻止编译器自动生成的拷贝构造函数的方法</h5>
<p>阻止编译器自动生成的拷贝构造函数有以下几种方法：</p>
<ol type="1">
<li><p>将拷贝构造函数声明为私有（private）。这样一来，只有类内部的成员函数或友元函数可以访问和使用拷贝构造函数。</p></li>
<li><p>将拷贝构造函数声明为删除（delete）。</p></li>
<li><p>继承自不可拷贝的基类：如果一个类继承自另一个类，而后者拥有私有的或已删除的拷贝构造函数，那么子类也将无法自动生成拷贝构造函数。这样可以通过间接继承来阻止拷贝构造函数的生成。</p></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NonCopyable</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">NonCopyable</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">NonCopyable</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">NonCopyable</span>(<span class="type">const</span> NonCopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    NonCopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NonCopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">private</span> NonCopyable &#123;</span><br><span class="line">    <span class="comment">// 其他成员函数和定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复制赋值运算符copy-assignment-operator">4. 复制赋值运算符（Copy
assignment operator）</h4>
<h5 id="隐式声明弃置">1. 隐式声明&amp;弃置</h5>
<p>如果没有对类类型提供任何用户定义的复制赋值运算符，那么编译器将始终声明一个复制赋值运算符作为类的
inline public 成员。</p>
<p>参数的类型以及弃置条件和复制构造函数相同。</p>
<h4 id="移动构造函数">5. 移动构造函数：</h4>
<ul>
<li>移动构造函数用于创建一个对象，并从同类的另一个对象“移动”或“窃取”资源。</li>
<li>移动构造函数接受一个同类对象的右值引用作为参数，用于高效地转移资源所有权。</li>
</ul>
<h5 id="隐式声明-2">1. 隐式声明</h5>
<p>如果不对类类型提供任何用户定义的移动构造函数，且满足下列所有条件：</p>
<ul>
<li>没有用户声明的<a
target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/copy_constructor">复制构造函数</a>；</li>
<li>没有用户声明的<a
target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/copy_assignment">复制赋值运算符</a>；</li>
<li>没有用户声明的<a
target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/move_assignment">移动赋值运算符</a>；</li>
<li>没有用户声明的<a
target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/destructor">析构函数</a>；</li>
</ul>
<p>那么编译器将声明一个移动构造函数作为这个类的非 <a
target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/explicit">explicit</a>
的 inline public 成员，签名是 T::T(T&amp;&amp;)。</p>
<h5 id="弃置-1">2. 弃置</h5>
<p>存在无法<strong>移动构造</strong>的数据成员时被弃置。</p>
<h5
id="为什么具有引用类型的非静态数据成员会导致默认的移动赋值运算符被弃置但会不导致移动构造函数被弃置">3.
为什么具有引用类型的非静态数据成员会导致默认的移动赋值运算符被弃置，但会不导致移动构造函数被弃置</h5>
<p>这是因为引用类型的成员无法被移动赋值。引用是一种别名，它引用了其他对象，而不是拥有自己的独立存储空间。因此，当使用移动赋值运算符时，无法将引用重新绑定到新的对象上，因为引用一旦绑定，就无法更改。</p>
<p>但是，移动构造函数并不受引用类型的成员的影响。移动构造函数负责将对象从一个右值引用移动到另一个对象，不涉及引用的重新绑定。因此，即使类中存在引用类型的成员，编译器仍然会生成默认的移动构造函数。</p>
<h4 id="移动赋值函数">6. 移动赋值函数：</h4>
<h5 id="隐式声明-3">1. 隐式声明</h5>
<p>如果没有对类类型提供任何用户定义的移动赋值运算符，且满足下列所有条件：</p>
<ul>
<li>没有用户声明的<a
target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/copy_constructor">复制构造函数</a>；</li>
<li>没有用户声明的<a
target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/move_constructor">移动构造函数</a>；</li>
<li>没有用户声明的<a
target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/copy_assignment">复制赋值运算符</a>；</li>
<li>没有用户声明的<a
target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/destructor">析构函数</a>，</li>
</ul>
<p>那么编译器将声明一个，作为类的 inline public 成员，并拥有签名 T&amp;
T::operator=(T&amp;&amp;)。</p>
<h5 id="弃置-2">2. 弃置</h5>
<p>存在无法被<strong>移动赋值</strong>的数据成员时被弃置。</p>
<h3 id="virtual关键字">12.3 <code>virtual</code>关键字</h3>
<h4 id="虚函数">1 虚函数</h4>
<ul>
<li><code>virtual</code>函数的地址保存在<code>virtual table</code>中。</li>
<li>当使用<strong>基类指针指向派生类对象</strong>时，如果调用虚函数，则会根据对象的虚表指针找到虚表中对应的虚函数，这样一来就实现了多态。</li>
<li>将虚函数声明为<code>inline</code>，需要分类讨论：
<ol type="1">
<li>使用对象调用的虚函数，编译期确定，没有多态性，将会执行内联。</li>
<li>当编译器无法确定时，不会执行内联。</li>
</ol></li>
</ul>
<h4 id="析构函数-构造函数">2. 析构函数 &amp;&amp; 构造函数</h4>
<ul>
<li>如果基类的析构函数是虚函数，调用<code>delete</code>销毁指向派生类对象的基类指针，才会准确调用派生类的析构函数，释放资源。如果基类的析构函数不是虚函数，则只会调用基类的析构函数，而派生类的相关资源没有得到释放。</li>
<li>析构函数可以是纯虚函数，但要额外的定义，以供编译器链接需要；因此最好<strong>不要将析构函数设置为纯虚函数</strong>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="number">0</span>;  <span class="comment">// 纯虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Base::~<span class="built_in">Base</span>() = <span class="keyword">default</span>;  <span class="comment">// 编译器链接需要，不会执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derived</span>() <span class="keyword">override</span> &#123;</span><br><span class="line">        <span class="comment">// 派生类的析构函数实现</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>构造函数不能是虚函数：虚函数需要通过虚表调用，如果构造函数是虚函数，则需要通过虚表调用虚函数；但是对象此时还没有初始化，没有虚表指针。</li>
<li>不要在构造和析构函数中调用虚函数，在进入基类的构造/析构函数时，对象也是基类类型，虚函数没有意义。</li>
<li>构造函数和析构函数声明为<code>inline</code>是无用的。</li>
<li>抛出异常：
<ul>
<li>在C++中，构造函数和析构函数可以抛出异常。</li>
<li>构造函数可以在对象的创建过程中抛出异常，这通常用于指示对象的创建失败或初始化错误。当构造函数抛出异常时，对象的创建会被中断，不会完成对象的构造过程，已经执行过的构造函数会被自动调用析构函数进行清理。</li>
<li>析构函数在对象销毁时被调用，可以释放资源、执行清理操作。析构函数也可以抛出异常，这样做会导致原本正在处理的异常被中断并重新引发新的异常。但是，为了避免异常在析构函数内传播出去导致不可预期的行为，通常建议在析构函数中不要抛出异常。</li>
<li>需要注意的是，如果在析构函数中抛出异常并未被捕获处理，程序将会调用
<code>std::terminate()</code>
函数来终止程序。因此，如果析构函数抛出异常，应该确保在析构函数内部进行适当的异常处理，或者确保不抛出异常。</li>
</ul></li>
</ul>
<h4 id="虚函数表">3. 虚函数表</h4>
<p>虚函数表对于每个类，全局只有一个，在编译时确定，并存储在<code>rodata</code>中。（虚函数本身在代码段中）</p>
<h4 id="虚拟继承">4. 虚拟继承</h4>
<p>虚拟继承是C++中用于处理多重继承中的菱形继承问题的一种特殊继承方式。当一个类通过多条路径继承同一个基类时，如果不使用虚拟继承，就会导致基类在派生类中有多个实例，称为菱形继承问题。</p>
<p>虚拟继承通过在派生类对基类进行声明时使用 <code>virtual</code>
关键字来解决菱形继承问题。当一个类使用虚拟继承时，它的派生类只会包含一个基类的实例，而不是多个实例。</p>
<p>可以和<code>public</code>等关键字组合使用。</p>
<hr />
<h2 id="内联函数和宏定义的区别">13. 内联函数和宏定义的区别</h2>
<ol type="1">
<li>编译时机：
<ul>
<li>内联函数在<strong>编译时</strong>展开，类似于普通函数的调用，编译器会将函数的代码直接插入到调用点处。</li>
<li>宏定义是在预处理阶段展开，简单地将宏定义的文本替换为相应的代码。</li>
</ul></li>
<li>类型安全：
<ul>
<li>内联函数是<strong>类型安全</strong>的，编译器会进行<strong>参数类型检查和隐式类型转换</strong>。</li>
<li>宏定义只是简单的文本替换，没有类型检查或转换，可能导致意外的行为。</li>
</ul></li>
<li>可读性和调试：
<ul>
<li>内联函数在代码中保留了函数的结构，因此具有良好的<strong>可读性</strong>。在<strong>调试</strong>时，可以直接跟踪到内联函数的<strong>调用点</strong>。</li>
<li>宏定义只是简单的文本替换，可能导致代码可读性降低，调试时无法跟踪到宏的展开点。</li>
</ul></li>
<li>名字空间：
<ul>
<li>内联函数可以位于命名空间中，因此可以通过命名空间来限定函数的<strong>作用域</strong>。</li>
<li>宏定义没有命名空间的概念，它是全局的，可能导致命名冲突或不可预测的行为。</li>
</ul></li>
<li>错误报告：
<ul>
<li>内联函数在编译时会进行类型检查，因此可以生成<strong>更准确的编译错误信息</strong>。</li>
<li>宏定义在预处理阶段展开，编译器可能无法提供准确的错误信息，而且错误可能会在展开后的代码中隐藏起来。</li>
</ul></li>
<li>模板支持：
<ul>
<li>内联函数可以使用<strong>模板</strong>进行泛型编程，可以根据不同的类型生成相应的代码。</li>
<li>宏定义不能直接支持模板，需要使用宏的技巧来模拟泛型。</li>
</ul></li>
</ol>
<hr />
<h2 id="继承权限">14. 继承权限</h2>
<table>
<thead>
<tr class="header">
<th>继承权限  基类成员权限</th>
<th><code>public</code></th>
<th><code>protected</code></th>
<th><code>private</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>public</code></td>
<td><code>public</code></td>
<td><code>protected</code></td>
<td>不可见</td>
</tr>
<tr class="even">
<td><code>protected</code></td>
<td><code>protected</code></td>
<td><code>protected</code></td>
<td>不可见</td>
</tr>
<tr class="odd">
<td><code>private</code></td>
<td><code>private</code></td>
<td><code>private</code></td>
<td>不可见</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="new">15. <code>new</code></h2>
<h3 id="常规的-new-运算符">1. 常规的 <code>new</code> 运算符：</h3>
<ul>
<li>当内存分配失败时，常规的 <code>new</code> 运算符会引发
<code>std::bad_alloc</code> 异常</li>
</ul>
<h3 id="定位-new-运算符">2. 定位 <code>new</code> 运算符：</h3>
<ul>
<li>定位 <code>new</code> 运算符用于在指定的内存位置上创建对象。</li>
<li>它的语法是 <code>new (address) T</code>，其中 <code>address</code>
是要放置对象的指针或地址。</li>
<li>定位 <code>new</code>
运算符不会进行内存分配，而是在给定的地址上直接调用构造函数进行对象的初始化。</li>
<li>使用定位 <code>new</code> 创建的对象不需要使用 <code>delete</code>
运算符进行内存释放，而是使用对应的 <code>placement delete</code>
或手动进行析构函数的调用。</li>
</ul>
<p>示例用法： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* memory = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(T));  <span class="comment">// 分配内存</span></span><br><span class="line">T* ptr = <span class="built_in">new</span> (memory) T;           <span class="comment">// 在给定的内存位置上创建类型为 T 的对象</span></span><br><span class="line"><span class="comment">// 使用对象...</span></span><br><span class="line"></span><br><span class="line">ptr-&gt;~<span class="built_in">T</span>();                        <span class="comment">// 调用析构函数</span></span><br><span class="line"><span class="built_in">free</span>(memory);                     <span class="comment">// 释放内存</span></span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，定位 <code>new</code>
运算符需要手动管理对象的生命周期，包括显式调用析构函数和释放内存。定位
<code>new</code>
运算符通常用于特定的场景，如在使用自定义的内存分配器或在共享内存区域中创建对象。</p>
<h3 id="new-nothrow-运算符">3. <code>new (nothrow)</code> 运算符。</h3>
<p><code>new (nothrow)</code>
运算符是用于动态分配内存的另一种形式，它与常规的 <code>new</code>
运算符的区别在于<strong>异常处理</strong>。当内存分配失败时，常规的
<code>new</code> 运算符会引发 <code>std::bad_alloc</code> 异常，而
<code>new (nothrow)</code>
运算符会返回一个<strong>空指针</strong>，而不是引发异常。</p>
<p>以下是使用 <code>new (nothrow)</code> 运算符的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T* ptr = <span class="built_in">new</span> (std::nothrow) T;</span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 内存分配失败，采取适当的处理措施</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 内存分配成功，使用对象...</span></span><br><span class="line">    <span class="keyword">delete</span> ptr;  <span class="comment">// 释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="allocator">16. <code>allocator</code></h2>
<p>在 C++ 中，<code>std::allocator</code>
是一个模板类，用于在堆上分配和释放内存。它是 C++
标准库提供的默认内存分配器。</p>
<p><code>std::allocator</code> 类的主要功能是通过 <code>allocate</code>
和 <code>deallocate</code> 成员函数来分配和释放内存，以及通过
<code>construct</code> 和 <code>destroy</code>
成员函数来构造和析构对象。</p>
<p>以下是 <code>std::allocator</code> 的基本用法示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 std::allocator 对象</span></span><br><span class="line">std::allocator&lt;<span class="type">int</span>&gt; myAllocator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配内存</span></span><br><span class="line"><span class="type">int</span>* ptr = myAllocator.<span class="built_in">allocate</span>(<span class="number">5</span>);  <span class="comment">// 分配可以容纳 5 个 int 类型对象的内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    myAllocator.<span class="built_in">construct</span>(&amp;ptr[i], i);  <span class="comment">// 在分配的内存上构造对象</span></span><br><span class="line">    <span class="comment">// 对象使用...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁对象并释放内存</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    myAllocator.<span class="built_in">destroy</span>(&amp;ptr[i]);  <span class="comment">// 销毁对象，但不释放内存</span></span><br><span class="line">&#125;</span><br><span class="line">myAllocator.<span class="built_in">deallocate</span>(ptr, <span class="number">5</span>);  <span class="comment">// 释放分配的内存</span></span><br></pre></td></tr></table></figure>
<p><code>std::allocator</code> 还提供了其他函数，如
<code>max_size</code> 用于获取可分配的最大对象数量，以及
<code>rebind</code> 用于重新绑定到不同类型的分配器。</p>
<hr />
<h2 id="mallocrealloc和calloc">17.
malloc<code>、</code>realloc<code>和</code>calloc</h2>
<ul>
<li><code>malloc</code> 分配指定大小的未初始化内存块。</li>
<li><code>realloc</code>
重新分配已存在的内存块的大小，并尽可能保留原始数据。</li>
<li><code>calloc</code>
分配指定数量和大小的连续内存块，并将其初始化为零。</li>
</ul>
<hr />
<h2 id="初始化列表">18. 初始化列表</h2>
<ol type="1">
<li>顺序：
<ul>
<li>初始化列表中的成员变量初始化顺序是根据它们在类中的声明顺序决定的，而不是根据它们在初始化列表中的顺序。</li>
</ul></li>
</ol>
<hr />
<h2 id="零拷贝">19. 零拷贝</h2>
<ul>
<li>比如<code>vector</code>的<code>emplace_back()</code>成员函数，原地构造元素，避免了潜在的拷贝/移动构造函数。</li>
</ul>
<hr />
<h2 id="面向对象的三大特性">20. 面向对象的三大特性</h2>
<p>面向对象编程（Object-Oriented
Programming，OOP）有三大主要特性，它们是：</p>
<ol type="1">
<li><strong>封装（Encapsulation）</strong>：
<ul>
<li>封装是指将数据和操作数据的方法（函数）绑定在一起，形成一个称为类的容器。</li>
<li>通过封装，对象的内部数据和实现细节被隐藏起来，只对外提供特定的接口（公共方法）来访问和操作数据。</li>
<li>封装提供了信息隐藏和安全性，使得对象的使用者可以专注于对象的接口而不必关心其内部实现细节。</li>
</ul></li>
<li><strong>继承（Inheritance）</strong>：
<ul>
<li>继承允许一个类（称为子类或派生类）继承另一个类（称为父类或基类）的属性和方法。</li>
<li>子类可以继承父类的特性，并可以在此基础上添加新的特性或修改继承的特性。</li>
<li>继承提供了代码重用和<strong>层次化</strong>组织的机制，使得类之间可以建立层次结构，形成更具一般性和特殊性的关系。</li>
</ul></li>
<li><strong>多态（Polymorphism）</strong>：
<ul>
<li>多态允许使用不同的方式来处理不同的数据类型或对象，通过<strong>统一的接口实现对不同对象的通用操作</strong>。</li>
<li>多态性使得可以在父类的引用下引用子类的对象，并根据实际引用对象的类型来调用相应的方法。</li>
<li>多态提供了<strong>灵活性</strong>和<strong>可扩展性</strong>，使得代码可以应对不同类型的对象，同时减少了对具体类型的依赖。</li>
</ul></li>
</ol>
<hr />
<h2 id="offsetof">21. <code>offsetof</code></h2>
<p><code>offsetof</code>
是一个宏定义，用于<strong>获取结构体中成员相对于结构体起始地址的偏移量（offset）</strong>。它是
C 和 C++ 标准库 <code>&lt;cstddef&gt;</code>（或
<code>&lt;stddef.h&gt;</code>）中提供的一个宏。</p>
<p><code>offsetof</code> 宏的声明如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(type, member)   ((size_t) &amp;(((type*)0)-&gt;member))</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>type</code> 是结构体类型的名称。</li>
<li><code>member</code> 是结构体中的成员名称。</li>
</ul>
<p><code>offsetof</code>
宏的工作原理是通过创建一个临时的空指针（<code>0</code>）转换为指向结构体类型的指针，然后使用成员运算符
<code>-&gt;</code> 获取成员的地址。最后，通过将获取到的地址转换为
<code>size_t</code> 类型，得到成员相对于结构体起始地址的偏移量。</p>
<hr />
<h2 id="静态和动态">22. 静态和动态</h2>
<h3 id="类型">22.1 类型</h3>
<ol type="1">
<li><strong>静态类型（Static Type）</strong>：
<ul>
<li>静态类型是在编译时确定的类型，它是变量、表达式或对象在编译阶段被声明或推导出的类型。</li>
<li>静态类型通常是通过变量声明或函数签名来定义，编译器在编译时使用静态类型进行类型检查和编译器优化。</li>
<li>静态类型决定了对象能够调用的方法和属性，它在编译时期就确定了，并且在运行时不会改变。</li>
</ul></li>
<li><strong>动态类型（Dynamic Type）</strong>：
<ul>
<li>动态类型是在运行时确定的类型，它是变量或对象在程序执行过程中实际所引用的类型。</li>
<li>动态类型可以通过对象的实际类型来确定，它可能和对象的静态类型相同，也可能是其派生类型。</li>
<li>动态类型决定了对象在运行时能够调用的实际方法和属性，它可以在运行时根据对象的实际类型发生变化。</li>
</ul></li>
</ol>
<h3 id="绑定">22.2 绑定</h3>
<ol type="1">
<li><strong>静态绑定（Static Binding）</strong>：
<ul>
<li>静态绑定是指在编译时根据变量的静态类型确定调用的方法或函数。</li>
<li>在静态绑定中，编译器在编译时就能够确定使用的方法或函数，无需在运行时进行类型检查。</li>
<li>静态绑定通常用于非虚函数或静态函数的调用，这些函数的调用目标在编译时就已经确定。</li>
</ul></li>
<li><strong>动态绑定（Dynamic Binding）</strong>：
<ul>
<li>动态绑定是指在运行时根据对象的实际类型确定调用的方法或函数。</li>
<li>在动态绑定中，编译器无法在编译时确定使用的方法或函数，需要在运行时通过对象的实际类型进行动态分派。</li>
<li>动态绑定通常用于虚函数的调用，虚函数通过虚函数表（vtable）实现，使得在运行时能够根据对象的实际类型调用适当的函数。</li>
</ul></li>
</ol>
<h3 id="分配">22.3 分配</h3>
<ol type="1">
<li><p><strong>动态分配（运行时分配）</strong>：
动态分配是指在程序运行时根据需要动态地创建对象实例。在大多数编程语言中，使用关键字
<code>new</code>
或类似的机制来进行动态分配。动态分配的对象存储在堆（或者称为自由存储区）上，并通过引用（指针、引用）进行访问。</p>
<p>例如，在 C++ 中，可以使用 <code>new</code>
运算符来动态分配对象，如下所示：</p>
<p>cpp</p>
<p>复制</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass* obj = <span class="keyword">new</span> <span class="built_in">MyClass</span>();  <span class="comment">// 动态分配 MyClass 的对象</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>静态分配（编译时分配）</strong>：
静态分配是指在编译时为对象分配存储空间，对象的生命周期与程序的生命周期相同。静态分配的对象存储在栈上或者作为全局变量存储在静态数据区。</p>
<p>例如，在 C++
中，可以通过简单地声明对象变量来进行静态分配，如下所示：</p>
<p>cpp</p>
<p>复制</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj;  <span class="comment">// 静态分配 MyClass 的对象</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="tips引用也有多态性">tips：引用也有多态性</h4>
<p>考虑以下示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base::print()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived::print()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived derivedObj;</span><br><span class="line">    Base&amp; baseRef = derivedObj;</span><br><span class="line"></span><br><span class="line">    baseRef.<span class="built_in">print</span>();  <span class="comment">// 动态绑定，调用 Derived::print()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，尽管引用本身是静态绑定的，但通过引用的多态性和虚函数的特性，我们可以实现引用的动态绑定，实现基于对象实际类型的方法调用。</p>
<hr />
<h2 id="限制类对象的分配方式">23. 限制类对象的分配方式</h2>
<h3 id="只能静态分配">23.1 只能静态分配</h3>
<h4 id="工厂函数">23.1.1 工厂函数</h4>
<ol type="1">
<li><p>将类的构造函数声明为私有（private）：
这样可以确保类的对象不能通过常规的构造函数来动态分配。私有构造函数只能在类的内部使用，无法从类外部直接访问或调用。</p></li>
<li><p>在类的内部定义一个静态公有（public）的静态成员函数（通常称之为工厂函数）：
这个函数将负责创建类的对象并返回。由于该函数是类的成员函数，它可以访问私有构造函数。</p></li>
<li><p>禁用类的拷贝构造函数和赋值运算符：
这样可以防止通过拷贝构造函数或赋值运算符动态创建类的对象。</p></li>
</ol>
<p>以下是一个示例，展示了如何实现只能静态分配的类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StaticOnlyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">StaticOnlyClass</span>() &#123;&#125;  <span class="comment">// 私有构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> StaticOnlyClass <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">StaticOnlyClass</span>();  <span class="comment">// 静态成员函数负责创建对象</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">StaticOnlyClass</span>(<span class="type">const</span> StaticOnlyClass&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 禁用拷贝构造函数</span></span><br><span class="line">  StaticOnlyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> StaticOnlyClass&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 禁用赋值运算符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，类 <code>StaticOnlyClass</code>
的构造函数被声明为私有，无法从类外部直接访问。通过
<code>createInstance()</code>
静态成员函数，可以在类的内部创建对象并返回。拷贝构造函数和赋值运算符被禁用，防止通过拷贝操作动态创建对象。</p>
<p>这样，使用该类时，只能通过静态分配方式来创建对象，如下所示：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StaticOnlyClass obj = StaticOnlyClass::<span class="built_in">createInstance</span>();  <span class="comment">// 静态分配对象</span></span><br></pre></td></tr></table></figure></p>
<h4 id="重载newdelete运算符">23.1.2
重载<code>new</code>/<code>delete</code>运算符</h4>
<p>重载<code>new</code>/<code>delete</code>运算符为<code>private</code>属性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 重载类的全局 new 运算符</span></span><br><span class="line">  <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自定义的内存分配逻辑</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);  <span class="comment">// 调用默认的 new 运算符</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重载类的全局 delete 运算符</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自定义的内存释放逻辑</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ptr)</span></span>;  <span class="comment">// 调用默认的 delete 运算符</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="只能动态分配">23.2 只能动态分配</h3>
<ol type="1">
<li><p>将类的析构函数声明为私有（private），这样外部代码将无法直接调用该析构函数。</p></li>
<li><p>在类中定义一个静态的公共（public）成员函数，用于创建类的对象。这个函数可以是一个静态的工厂函数，用于动态分配对象，并返回指向对象的指针。</p></li>
<li><p>将类的构造函数声明为私有，这样外部代码将无法直接调用该构造函数。</p></li>
<li><p>在静态的公共成员函数中，使用 <code>new</code>
运算符动态分配类的对象，并返回指向对象的指针。</p></li>
</ol>
<p>下面是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123;&#125;  <span class="comment">// 私有构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> MyClass* <span class="title">createObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MyClass</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行某些操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;&#125;  <span class="comment">// 私有析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过静态成员函数创建对象</span></span><br><span class="line">    MyClass* obj = MyClass::<span class="built_in">createObject</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用对象指针调用成员函数</span></span><br><span class="line">    obj-&gt;<span class="built_in">doSomething</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 delete 运算符释放对象内存</span></span><br><span class="line">    <span class="keyword">delete</span> obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="组合与继承">24. 组合与继承</h2>
<p><strong>组合的优点：</strong></p>
<ol type="1">
<li><p><strong>灵活性和可插拔性</strong>：组合允许对象之间的动态关联，对象可以在运行时进行组装和替换。这提供了更大的灵活性和可插拔性，使得系统能够适应变化的需求。</p></li>
<li><p><strong>解耦合和模块化</strong>：组合通过将对象分解为较小的可管理单元，提供了更好的解耦合和模块化。这样，每个对象只需关注自己的职责，并且更容易理解、测试和维护。</p></li>
<li><p><strong>代码重用</strong>：通过将通用功能放入独立的组件中，可以在不同的上下文中重复使用这些组件。这提高了代码的可重用性，减少了重复编写相似功能的工作量。</p></li>
</ol>
<p><strong>组合的缺点：</strong></p>
<ol type="1">
<li><p><strong>复杂性增加</strong>：使用组合模式时，对象之间的关系变得更加复杂。需要管理和协调多个对象之间的交互，这可能导致代码变得复杂和难以理解。</p></li>
<li><p><strong>性能开销增加</strong>：在组合模式中，对象之间的嵌套层次增加，可能会导致性能开销的增加。这是因为需要遍历整个对象树来执行相关操作。</p></li>
</ol>
<p><strong>继承的优点：</strong></p>
<ol type="1">
<li><p><strong>代码重用</strong>：继承允许子类继承父类的属性和方法，从而实现代码的重用。子类可以使用父类的功能，并可以通过添加新的功能来扩展或修改其行为。</p></li>
<li><p><strong>多态性</strong>：继承支持多态性，即子类可以替代父类的位置，并以不同的方式实现相同的接口。这提供了更大的灵活性和可扩展性。</p></li>
</ol>
<p><strong>继承的缺点：</strong></p>
<ol type="1">
<li><p><strong>紧耦合</strong>：继承引入了紧密的耦合关系，子类与父类之间高度依赖。这意味着对父类的修改可能会对所有子类产生影响，并且子类对父类的实现细节高度敏感。</p></li>
<li><p><strong>单一继承限制</strong>：大多数编程语言只支持单一继承，这限制了代码的灵活性。子类只能从一个父类继承，而无法同时继承多个不同的抽象类。</p></li>
<li><p><strong>继承滥用的风险</strong>：不正确或过度使用继承可能导致继承层次过深、复杂的关系和难以理解的代码结构。这可能增加代码维护和扩展的困难。</p></li>
</ol>
<hr />
<h2 id="template">25. <code>template</code></h2>
<h3 id="声明与定义不分离">1. 声明与定义不分离</h3>
<p>C++中的模板是一种泛型编程的工具，允许在编译时生成不同类型的类或函数。当使用模板类时，编译器需要在编译期间实例化模板，生成对应的具体类型的代码。这意味着<strong>模板类的定义需要在使用它的地方可见</strong>(在<strong>隐式实例化点可见</strong>)，以便编译器可以正确地实例化模板。</p>
<p>当将模板类的声明和定义分离到不同的文件中时，例如将声明放在头文件（.h）中，而将定义放在源文件（.cpp）中，编译器在编译使用模板类的源文件时无法看到模板类的完整定义。这会导致编译器无法实例化模板类，从而引发链接错误。</p>
<h3 id="实例化">2. 实例化</h3>
<p>在要求完整对象类型的语境中引用某个类模板特化时，或在要求函数定义存在的语境中引用某个函数模板特化时，除非模板已经被显式特化或显式实例化，否则模板即被<em>实例化</em>（它的代码被实际编译）。类模板的实例化不会实例化其任何成员函数，除非它们也被使用。在<strong>链接</strong>时，<strong>不同翻译单元</strong>生成的相同实例被<strong>合并</strong>。</p>
<hr />
<h2 id="cout-和-printf的区别">26. <code>cout</code> 和
<code>printf</code>的区别</h2>
<ol type="1">
<li>语法：<code>cout</code> 是 C++
标准库中的输出流对象，使用流插入运算符 <code>&lt;&lt;</code>
进行输出。而 <code>printf</code> 是 C
语言中的函数，使用格式化字符串和参数列表进行输出。</li>
<li>类型安全：<code>cout</code> 提供了类型安全的输出，可以直接输出 C++
中的各种数据类型，包括基本类型、对象和自定义类型，而 <code>printf</code>
的格式化字符串需要与参数列表中的类型严格匹配，类型不匹配可能导致未定义行为。</li>
<li>扩展性：<code>cout</code> 支持通过重载运算符 <code>&lt;&lt;</code>
来扩展输出功能，可以自定义输出运算符，使得用户可以方便地输出自定义类型。而
<code>printf</code>
的格式化字符串功能有限，无法直接输出复杂的自定义类型。</li>
<li>缓冲：<code>cout</code>
是基于缓冲的输出，它会根据需要自动刷新缓冲区。而 <code>printf</code>
默认是行缓冲的，只有在遇到换行符或缓冲区满时才会刷新缓冲区。</li>
<li>可读性：<code>cout</code> 的语法相对较简洁和直观，易于阅读和理解。而
<code>printf</code>
的格式化字符串需要写入特定的占位符，格式复杂一些，可读性稍低。</li>
</ol>
<hr />
<h2 id="运算符">27. 运算符</h2>
<h3 id="运算符-1">27.1 运算符:</h3>
<p>在 C++
中，运算符是一种<strong>特殊的语法结构</strong>，用于在表达式中执行特定的操作。运算符允许操作不同类型的数据，并返回相应的结果。</p>
<p>C++ 中的运算符包括以下几种类型：</p>
<ol type="1">
<li>算术运算符：用于执行基本的算术操作，例如加法、减法、乘法、除法等。例如
<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 等。</li>
<li>关系运算符：用于比较两个值之间的关系，例如相等、不等、大于、小于等。例如
<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code>
等。</li>
<li>逻辑运算符：用于执行逻辑操作，例如逻辑与、逻辑或、逻辑非等。例如
<code>&amp;&amp;</code>、<code>||</code>、<code>!</code> 等。</li>
<li>位运算符：用于对二进制位进行操作，例如按位与、按位或、按位取反等。例如
<code>&amp;</code>、<code>|</code>、<code>~</code> 等。</li>
<li>赋值运算符：用于将一个值赋给一个变量或表达式。例如
<code>=</code>、<code>+=</code>、<code>-=</code> 等。</li>
<li>条件运算符：也称为三元运算符，用于根据条件选择不同的值。例如
<code>condition ? value1 : value2</code>。</li>
<li>成员访问运算符：用于访问类或结构体的成员。例如
<code>.</code>、<code>-&gt;</code> 等。</li>
<li>其他运算符：还有一些其他的特殊运算符，如逗号运算符
<code>,</code>、sizeof
运算符（编译器确定）、类型转换运算符(如<code>dynamic_cast</code>)、内存运算符等。</li>
</ol>
<h3 id="只能作为成员函数进行重载的运算符">27.2
只能作为成员函数进行重载的运算符:</h3>
<ol type="1">
<li>成员访问运算符
(<code>.</code>)：用于访问类的成员变量或成员函数。</li>
<li>箭头成员访问运算符
(<code>-&gt;</code>)：用于通过指针类对象访问成员。</li>
<li>函数调用运算符
(<code>()</code>)：用于将对象作为函数进行调用（对于<code>greater</code>，<code>()</code>时<code>const</code>、<code>constexpr</code>、<code>inline</code>的）。</li>
<li>下标运算符 (<code>[]</code>)：用于类似数组的访问操作。</li>
</ol>
<h3 id="后置">27.3 后置++</h3>
<p>后置递增运算符（后置++）的函数声明应该按照以下方式进行声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">operator</span>++(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>
<p>其中，<code>T</code> 是递增操作后的值类型。函数名为
<code>operator++</code>，并且它接受一个<strong>额外的整数参数</strong>（通常命名为
<code>int</code>），但该参数在函数体内部并<strong>不使用</strong>。这个整数参数的目的是用来<strong>区分</strong>前置递增和后置递增运算符的重载函数。</p>
<h3 id="类型转换运算符dynamic_cast">27.4
类型转换运算符(<code>dynamic_cast</code>)</h3>
<p><code>dynamic_cast</code>并不是std库中的部件，而是C++关键字.</p>
<ul>
<li>用于动态转换<code>shared_ptr</code>的<code>std::dynamic_pointer_cast</code>是<code>std</code>中的部件。其实也是显然的，因为<code>shared_ptr</code>是<code>std</code>中的部件。</li>
</ul>
<hr />
<h2 id="容器">28. 容器</h2>
<p>在 C++
标准库中，容器可以分为两个主要类别：<strong>序列式容器</strong>（Sequence
Containers）和<strong>关联式容器</strong>（Associative
Containers）。</p>
<p>序列式容器（Sequence
Containers）是按照元素的线性顺序存储和访问元素的容器。它们主要关注元素的插入和删除顺序，并提供了顺序访问元素的功能。C++
标准库中的序列式容器包括：</p>
<ol type="1">
<li><code>std::vector</code>：动态数组，支持快速随机访问。</li>
<li><code>std::list</code>：双向链表，支持高效的插入和删除操作。</li>
<li><code>std::deque</code>：双端队列，支持快速随机访问和高效的头尾插入删除操作。</li>
<li><code>std::array</code>：固定大小的数组，大小在编译时确定。</li>
</ol>
<p>关联式容器（Associative
Containers）是通过键来访问和组织元素的容器。它们使用比较函数将元素存储在特定的顺序或结构中，以便快速的查找和访问。C++
标准库中的关联式容器包括：</p>
<ol type="1">
<li><code>std::set</code>：有序集合，不允许重复元素。</li>
<li><code>std::multiset</code>：有序集合，允许重复元素。</li>
<li><code>std::map</code>：有序键值对集合，每个键只能出现一次。</li>
<li><code>std::multimap</code>：有序键值对集合，允许重复键。</li>
</ol>
<p>此外，C++11 引入了两个额外的关联式容器：</p>
<ol type="1">
<li><code>std::unordered_set</code>：无序集合，使用哈希函数进行快速查找。</li>
<li><code>std::unordered_map</code>：无序键值对集合，使用哈希函数进行快速查找。</li>
</ol>
<hr />
<h2 id="section-1"></h2>
<!-- flag of hidden posts -->
    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Yuhang Zhang
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://eric-zhang-c.github.io/zyhjy/2024/05/25/cppquestions/" title="cpp面试问题合集">https://eric-zhang-c.github.io/zyhjy/2024/05/25/cppquestions/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <style>
        #taboola-livere { display: none;}
    </style>
    <div id="lv-container" data-id="city" data-uid="MTAyMC81ODg3Ni8zNTMzOA=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#section"><span class="nav-text"></span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8main%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E4%B9%8B%E5%89%8D%E5%92%8C%E4%B9%8B%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%83%BD%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">1.
在main函数执行之前和之后执行的代码可能是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8main%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E4%B9%8B%E5%89%8D"><span class="nav-text">在main函数执行之前</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8main%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E4%B9%8B%E5%90%8E"><span class="nav-text">在main函数执行之后</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tips-1.1-.data%E6%AE%B5%E5%92%8C.bss%E6%AE%B5"><span class="nav-text">tips 1.1:
.data段和.bss段</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="nav-text">2. 结构体内存对齐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8"><span class="nav-text">3. 指针与引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#newdelete-mallocfree"><span class="nav-text">4. new&#x2F;delete |
malloc&#x2F;free</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c%E5%92%8Cpython%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">5. C++和python的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c%E5%92%8Cc%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">6. C++和C的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c%E5%92%8Cjava%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">7. C++和Java的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#class%E4%B8%8Estruct"><span class="nav-text">8. class与struct</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#define%E4%B8%8Econst"><span class="nav-text">9. define与const</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tips9.1-%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%92%8C%E5%8A%A8%E6%80%81%E5%AD%98%E5%82%A8"><span class="nav-text">tips9.1 静态存储和动态存储:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static%E4%B8%8Econst"><span class="nav-text">10. static与const</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#static"><span class="nav-text">10.1 static</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#c%E8%AF%AD%E8%A8%80%E9%83%A8%E5%88%86"><span class="nav-text">C语言部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c%E9%83%A8%E5%88%86"><span class="nav-text">C++部分</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const"><span class="nav-text">10.2 const</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#c%E8%AF%AD%E8%A8%80%E9%83%A8%E5%88%86-1"><span class="nav-text">C语言部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c%E9%83%A8%E5%88%86-1"><span class="nav-text">C++部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tips10.3-static-data-member%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98"><span class="nav-text">tips10.3
static data member的初始化问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tips10.4-static-constexpr-string%E6%97%A0%E6%B3%95%E5%9C%A8%E7%B1%BB%E5%86%85%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">tips10.4
static constexpr string无法在类内初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tips10.5-constexpr%E4%B8%8Econst"><span class="nav-text">tips10.5
constexpr与const</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%90%8D%E5%92%8C%E6%8C%87%E5%90%91%E9%A6%96%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-text">11. 数组名和指向首个元素的指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#class"><span class="nav-text">12. Class</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">1. 构造函数的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">1.默认构造函数：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E5%A3%B0%E6%98%8E"><span class="nav-text">1. 隐式声明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="nav-text">2. 隐式定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%83%E7%BD%AE%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">3. 弃置的默认构造函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E5%8C%96%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">2. 参数化构造函数：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">3. 拷贝（复制）构造函数：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E5%A3%B0%E6%98%8E-1"><span class="nav-text">1. 隐式声明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%83%E7%BD%AE"><span class="nav-text">2. 弃置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BC%A0%E5%80%BC"><span class="nav-text">4. 为什么不能传值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%BB%E6%AD%A2%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">5.
阻止编译器自动生成的拷贝构造函数的方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6copy-assignment-operator"><span class="nav-text">4. 复制赋值运算符（Copy
assignment operator）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E5%A3%B0%E6%98%8E%E5%BC%83%E7%BD%AE"><span class="nav-text">1. 隐式声明&amp;弃置</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">5. 移动构造函数：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E5%A3%B0%E6%98%8E-2"><span class="nav-text">1. 隐式声明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%83%E7%BD%AE-1"><span class="nav-text">2. 弃置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%85%B7%E6%9C%89%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9D%9E%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E4%BC%9A%E5%AF%BC%E8%87%B4%E9%BB%98%E8%AE%A4%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E8%A2%AB%E5%BC%83%E7%BD%AE%E4%BD%86%E4%BC%9A%E4%B8%8D%E5%AF%BC%E8%87%B4%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%A2%AB%E5%BC%83%E7%BD%AE"><span class="nav-text">3.
为什么具有引用类型的非静态数据成员会导致默认的移动赋值运算符被弃置，但会不导致移动构造函数被弃置</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E5%87%BD%E6%95%B0"><span class="nav-text">6. 移动赋值函数：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E5%A3%B0%E6%98%8E-3"><span class="nav-text">1. 隐式声明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%83%E7%BD%AE-2"><span class="nav-text">2. 弃置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#virtual%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">12.3 virtual关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-text">1 虚函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">2. 析构函数 &amp;&amp; 构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="nav-text">3. 虚函数表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF"><span class="nav-text">4. 虚拟继承</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">13. 内联函数和宏定义的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%9D%83%E9%99%90"><span class="nav-text">14. 继承权限</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new"><span class="nav-text">15. new</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%84%E7%9A%84-new-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">1. 常规的 new 运算符：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%BD%8D-new-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">2. 定位 new 运算符：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new-nothrow-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">3. new (nothrow) 运算符。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#allocator"><span class="nav-text">16. allocator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mallocrealloc%E5%92%8Ccalloc"><span class="nav-text">17.
malloc、realloc和calloc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="nav-text">18. 初始化列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="nav-text">19. 零拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-text">20. 面向对象的三大特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#offsetof"><span class="nav-text">21. offsetof</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%92%8C%E5%8A%A8%E6%80%81"><span class="nav-text">22. 静态和动态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B"><span class="nav-text">22.1 类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A"><span class="nav-text">22.2 绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%85%8D"><span class="nav-text">22.3 分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tips%E5%BC%95%E7%94%A8%E4%B9%9F%E6%9C%89%E5%A4%9A%E6%80%81%E6%80%A7"><span class="nav-text">tips：引用也有多态性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="nav-text">23. 限制类对象的分配方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AA%E8%83%BD%E9%9D%99%E6%80%81%E5%88%86%E9%85%8D"><span class="nav-text">23.1 只能静态分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0"><span class="nav-text">23.1.1 工厂函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BDnewdelete%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">23.1.2
重载new&#x2F;delete运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AA%E8%83%BD%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="nav-text">23.2 只能动态分配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="nav-text">24. 组合与继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#template"><span class="nav-text">25. template</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89%E4%B8%8D%E5%88%86%E7%A6%BB"><span class="nav-text">1. 声明与定义不分离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-text">2. 实例化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cout-%E5%92%8C-printf%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">26. cout 和
printf的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">27. 运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6-1"><span class="nav-text">27.1 运算符:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AA%E8%83%BD%E4%BD%9C%E4%B8%BA%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E9%87%8D%E8%BD%BD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">27.2
只能作为成员函数进行重载的运算符:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E7%BD%AE"><span class="nav-text">27.3 后置++</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6dynamic_cast"><span class="nav-text">27.4
类型转换运算符(dynamic_cast)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8"><span class="nav-text">28. 容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section-1"><span class="nav-text"></span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yuhang Zhang"
      src="/zyhjy/images/zyhjy.png">
  <p class="site-author-name" itemprop="name">Yuhang Zhang</p>
  <div class="site-description" itemprop="description">爱小雅，爱生活，爱物理!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/zyhjy/archives/">
        
          <span class="site-state-item-count">85</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/zyhjy/categories/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/zyhjy/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/zyhjy/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuhang Zhang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">469k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">13:01</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/zyhjy/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>

<script src="/zyhjy/js/utils.js"></script>


<script src="/zyhjy/js/schemes/pisces.js"></script>


<script src="/zyhjy/js/next-boot.js"></script>




  




  
<script src="/zyhjy/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
