<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
<meta name="referrer" content="no-referrer">
  <link rel="apple-touch-icon" sizes="180x180" href="/zyhjy/images/relativity128.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/zyhjy/images/relativity32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/zyhjy/images/relativity16.png">
  <link rel="mask-icon" href="/zyhjy/images/logo.svg" color="#222">

<link rel="stylesheet" href="/zyhjy/css/main.css">

<link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css?family=Comic Sans MS:300,300italic,400,400italic,700,700italic|Noto Serif SC:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/zyhjy/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/zyhjy/lib/pace/pace-theme-minimal.min.css">
  <script src="/zyhjy/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"eric-zhang-c.github.io","root":"/zyhjy/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1. 内存 1. 虚拟地址空间 1. Linux进程虚拟地址空间布局 32位机器   image.png   默认的栈大小通常在1 MB到8 MB之间。 堆区的默认大小通常在1到4 GB之间。  64位机器   image.png   空洞（ canonical address）：  64位机器中，实际上只使用了48位描述虚拟地址空间，用户态空间和内核态空间各128T；多出来的高16位的的地址没有">
<meta property="og:type" content="article">
<meta property="og:title" content="OS面试问题合集">
<meta property="og:url" content="https://eric-zhang-c.github.io/zyhjy/2024/05/28/osquestions/">
<meta property="og:site_name" content="ZYHJY">
<meta property="og:description" content="1. 内存 1. 虚拟地址空间 1. Linux进程虚拟地址空间布局 32位机器   image.png   默认的栈大小通常在1 MB到8 MB之间。 堆区的默认大小通常在1到4 GB之间。  64位机器   image.png   空洞（ canonical address）：  64位机器中，实际上只使用了48位描述虚拟地址空间，用户态空间和内核态空间各128T；多出来的高16位的的地址没有">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://eric-zhang-c.github.io/Users/zyh/Library/Application%20Support/typora-user-images/image-20240620212237307.png">
<meta property="article:published_time" content="2024-05-28T14:32:21.000Z">
<meta property="article:modified_time" content="2024-07-18T15:05:12.402Z">
<meta property="article:author" content="Yuhang Zhang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://eric-zhang-c.github.io/Users/zyh/Library/Application%20Support/typora-user-images/image-20240620212237307.png">

<link rel="canonical" href="https://eric-zhang-c.github.io/zyhjy/2024/05/28/osquestions/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>OS面试问题合集 | ZYHJY</title><meta name="robots" content="noindex">
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-J17VP3T2B4"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-J17VP3T2B4');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/zyhjy/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ZYHJY</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/zyhjy/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/zyhjy/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/zyhjy/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/zyhjy/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/zyhjy/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-solutions">

    <a href="/zyhjy/solutions/" rel="section"><i class="fa fa-code fa-fw"></i>算法题解</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://eric-zhang-c.github.io/zyhjy/2024/05/28/osquestions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/zyhjy/images/zyhjy.png">
      <meta itemprop="name" content="Yuhang Zhang">
      <meta itemprop="description" content="爱小雅，爱生活，爱物理!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYHJY">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          OS面试问题合集
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-28 22:32:21" itemprop="dateCreated datePublished" datetime="2024-05-28T22:32:21+08:00">2024-05-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-18 23:05:12" itemprop="dateModified" datetime="2024-07-18T23:05:12+08:00">2024-07-18</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="内存">1. 内存</h2>
<h3 id="虚拟地址空间">1. 虚拟地址空间</h3>
<h4 id="linux进程虚拟地址空间布局">1. Linux进程虚拟地址空间布局</h4>
<h5 id="位机器">32位机器</h5>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/68763fe509b7adf5987a3ce96c9d12ee.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>默认的栈大小通常在1 MB到8 MB之间。</li>
<li>堆区的默认大小通常在1到4 GB之间。</li>
</ul>
<h5 id="位机器-1">64位机器</h5>
<figure>
<img
src="https://gitee.com/zyh-eric/mypics/raw/master/img/84eb41fc42b790865eb8bc15d3a2892a.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>空洞（ canonical address）：
<ul>
<li>64位机器中，实际上只使用了48位描述虚拟地址空间，用户态空间和内核态空间各128T；多出来的高16位的的地址没有使用，形成了空洞。</li>
</ul></li>
</ul>
<h4 id="linux进程内核虚拟地址空间">2. Linux进程内核虚拟地址空间</h4>
<p>所有内核进程共用同一个内核虚拟地址空间。因此内核进程间的切换不需要切换页表。</p>
<h5 id="直接映射区">1. 直接映射区：</h5>
<ul>
<li>也称线性映射区</li>
<li>直接映射区映射到一块<strong>连续</strong>的物理地址空间中</li>
<li>内核的<strong>代码段</strong>、<strong>数据段</strong>、<strong>BSS段</strong>以及<strong>栈</strong>区都在直接映射中（32位机器）</li>
<li>32位机器的直接映射区大小为896M，会映射到物理地址为0-896M的这块物理内存上
<ul>
<li>分为ZONE_DMA和ZONE_NORMAL两部分。</li>
</ul></li>
<li>64位机器的直接映射区大小为64T</li>
</ul>
<h6 id="内核栈">内核栈</h6>
<ul>
<li>容量小且固定（通常为两页）</li>
<li>每个内核进程都有一个对应的内核栈</li>
</ul>
<h5 id="vmalloc-动态映射区">2. vmalloc 动态映射区</h5>
<p>和用户态进程使用 malloc 申请内存一样，在这块动态映射区内核是使用
vmalloc 进行内存分配。由于动态映射的原因，vmalloc
分配的内存在虚拟内存上是连续的，但是物理内存是不连续的。</p>
<h5 id="永久映射区32位机器">3. 永久映射区（32位机器）</h5>
<p>在内核的这段虚拟地址空间中允许建立与物理高端内存的<strong>长期映射</strong>关系。</p>
<h5 id="固定映射区32位机器">4. 固定映射区（32位机器）</h5>
<p>内核固定分配的虚拟地址范围，这些地址有固定的用途，系统启动时，映射到内核指定的物理地址。</p>
<h5 id="临时映射区32位机器">5. 临时映射区（32位机器）</h5>
<p>内核需要在物理内存之间进行数据拷贝、处理或修改。临时映射区可以临时将源物理内存区域和目标物理内存区域映射到内核空间的虚拟地址，以便进行数据操作和传输。</p>
<h5 id="虚拟内存映射区64位机器">6. 虚拟内存映射区（64位机器）</h5>
<p>用于存放物理页面的描述符 struct page 结构，表示物理内存页。</p>
<h5 id="代码段64位机器">7. 代码段（64位机器）</h5>
<p>是大小为 512M 的区域用于存放内核代码段、全局变量、BSS
等。这里对应到物理内存开始的位置。</p>
<h3 id="页表">2. 页表</h3>
<h4 id="多级页表">1. 多级页表</h4>
<p>如果使用<strong>单级页表</strong>，单级页表要求每一个页表项都存在，那么这张页表巨大，且这张页表占据的物理内存还必须<strong>连续</strong>。</p>
<p>使用<strong>多级页表</strong>可以<strong>压缩页表大小</strong>：当任意一级页表的某个条目为空时，对应的下一级页表不需要存在，即多级页表允许页表结构中存在<strong>空洞</strong>。此外，多级页表的优势在于<strong>不依赖内存页的连续性</strong>。</p>
<p>多级页表节省空间的前提是进程使用的虚拟地址远小于总的虚拟地址空间。</p>
<h3 id="内存管理">3. 内存管理</h3>
<h4 id="伙伴系统buddy-system">1. 伙伴系统（Buddy System）</h4>
<p>将物理内存划分为基本的块，以<strong>块为基本单位</strong>进行划分。每个块都由一个或多个<strong>连续</strong>的<strong>物理页</strong>组成。（最小分配单位是物理页（4K））</p>
<p>在处理分配请求时，大的块可以分成两个小一号的块，这两个块互为<strong>伙伴</strong>。在一个块被释放后，分配器会检查其伙伴块的状态是否能够合并。</p>
<p>伙伴系统的实现通常涉及到一个<strong>空闲链表数组</strong>，数组的每一项指向其对应大小的空闲块链表。</p>
<h4 id="slab分配器">2. SLAB分配器</h4>
<p>SLAB是最初的分配器，SLUB是SLAB的优化，SLOB是SLAB在嵌入式环境下的版本。</p>
<p>SLUB分配器是把伙伴系统分配的大块内存进一步细分成小块内存进行管理，SLUB分配器只分配固定大小的内存块，通常为<span
class="math inline">\(2^n\)</span>字节。对于每一种块大小，SLUB分配器都会使用独立的内存资源池进行分配（将从伙伴系统获得的物理内存块划分为等长的小块内存）。</p>
<h3 id="内存交换和内存覆盖">4. 内存交换和内存覆盖</h3>
<ol type="1">
<li>内存交换（Memory Swapping）：
内存交换是指<strong>将当前不活动的进程或进程的部分从主存（RAM）中移出</strong>，存储到辅助存储设备（如硬盘）上，以便为其他进程腾出足够的内存空间。当需要重新执行被交换出的进程时，系统会将其再次加载到主存中。内存交换在操作系统中起到了动态分配和管理内存资源的作用，以确保系统能够同时运行更多的进程。</li>
<li>内存覆盖（Memory Overlay）（针对单个程序）：
内存覆盖是一种技术，用于解决内存空间不足以容纳整个程序的情况。在有限的内存空间中，程序可能会超过可用的内存容量。为了克服这个问题，<strong>程序被划分为多个逻辑段或模块</strong>，每次只加载和执行当前需要的部分，其他部分则存储在磁盘或其他外部存储设备上。通过在程序执行过程中动态加载不同的模块，实现了在有限内存中运行较大程序的能力。</li>
</ol>
<h3 id="内存分配算法">5. 内存分配算法</h3>
<ol type="1">
<li>首次适应算法
<ul>
<li>空闲分区以<strong>地址递增</strong>的次序排列</li>
</ul></li>
<li>最佳适应算法
<ul>
<li>空闲分区以<strong>容量递增</strong>的次序排列</li>
<li>容易产生小的内存碎片；回收分区后需要排序，算法开销大</li>
</ul></li>
<li>最坏/大适应算法(Largest Fit)
<ul>
<li>空闲分区以<strong>容量递减</strong>的次序排列</li>
<li>大分区容易被用完</li>
</ul></li>
<li>邻近适应算法(Largest Fit)
<ul>
<li>空闲分区以<strong>地址递增</strong>的次序排列，每次查找从上次结束的位置开始</li>
</ul></li>
</ol>
<h3 id="cowcopy-on-write">6. COW（copy on write）</h3>
<p>COW是一种内存管理技术，用于减少对共享数据的复制开销。当多个进程或线程需要共享同一块内存时，最初它们都指向同一个内存区域。当任何一个进程或线程试图修改这个共享内存时，才会进行实际的复制操作。这样可以<strong>避免不必要的复制</strong>，提高内存使用效率。</p>
<p>COW通常用于处理诸如进程间通信、fork操作等场景。</p>
<h3 id="rcuread-copy-update">7. RCU（read copy update）</h3>
<p>RCU是一种读优化的并发编程技术，用于在多线程环境中实现高效的读操作。RCU适用于<strong>读操作频繁、写操作较少</strong>的情况。</p>
<p>在RCU中，读操作不会加锁，而是通过一种机制来保证读操作的一致性。当发生<strong>写</strong>操作时，RCU会创建一个<strong>新的副本</strong>，并将写操作应用于副本，而不是直接修改原始数据。同时，旧的副本仍然可以被正在进行的读操作引用，<strong>直到读操作完成为止</strong>。当没有任何读操作引用旧的副本时，该副本可以被安全地销毁，以释放内存。</p>
<p>RCU通过<strong>读操作无锁化</strong>，避免了读写操作之间的互斥和同步开销，提高了读操作的性能。然而，写操作需要额外的开销来创建新的副本和管理副本的生命周期。</p>
<p>RCU通常用于处理<strong>读多写少的数据结构</strong>，例如在并发编程中的数据缓存、链表等</p>
<h2 id="进程间通信">2. 进程间通信</h2>
<p>包括共享内存、管道、信号量、消息队列、套接字。</p>
<h3 id="共享内存">1.共享内存</h3>
<h4 id="什么是共享内存">1. 什么是共享内存</h4>
<ul>
<li>两个或多个进程在其所在的虚拟地址空间中映射相同的物理页。</li>
<li>共享内存的虚拟地址范围在文件映射段中。（文件映射段专门处理内存到磁盘的映射，<code>mmap</code>所获得的内存也在文件映射段中）。</li>
</ul>
<h4 id="为什么需要共享内存">2. 为什么需要共享内存</h4>
<ul>
<li>主要是出于<strong>性能</strong>的考虑。其他的进程间通信（如消息队列、管道等）都依赖内核提供完整的缓冲数据、接受消息、发送消息等一系列进程间接口，效率较低。而共享内存只需要由内核建立共享区域，之后通信进程就可以通过共享内存交互，不需要经过内核。</li>
</ul>
<h3 id="辅助命令">3. 辅助命令</h3>
<ul>
<li><code>ipcs</code>可报告共享内存、信号量、消息队列信息。
<ul>
<li><code>-l</code>: limit</li>
<li><code>-a</code>: all</li>
<li><code>-u</code>: used</li>
</ul></li>
</ul>
<h2 id="进程线程协程模型">3. 进程、线程、协程模型</h2>
<h3 id="对比">1. 对比</h3>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 39%" />
<col style="width: 23%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>进程</th>
<th>线程</th>
<th>协程</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>定义</td>
<td>操作系统<strong>分配资源</strong>的基本单位，拥有独立的内存空间和系统资源</td>
<td>CPU<strong>调度</strong>、程序<strong>执行</strong>的基本单位</td>
<td><strong>用户态的轻量级线程</strong>，是线程内部调度的基本单位</td>
</tr>
<tr class="even">
<td>切换情况</td>
<td>进程的CPU环境（栈、寄存器、页表、文件句柄等）</td>
<td>PC、寄存器、栈</td>
<td>寄存器和栈</td>
</tr>
<tr class="odd">
<td>调度者</td>
<td>OS</td>
<td>OS</td>
<td>用户</td>
</tr>
<tr class="even">
<td>切换过程</td>
<td>用户态-&gt;内核态-&gt;用户态</td>
<td>用户态-&gt;内核态-&gt;用户态</td>
<td>用户</td>
</tr>
<tr class="odd">
<td>调用栈</td>
<td>内核栈</td>
<td>内核栈</td>
<td>用户栈</td>
</tr>
<tr class="even">
<td>并发性</td>
<td>不同进程切换实现并发（交替执行），各自占用CPU实现并行（同时执行）</td>
<td>一个进程内部的多个线程并发执行</td>
<td>同一时间只能执行一个协程，其他协程属于休眠状态</td>
</tr>
</tbody>
</table>
<h3 id="一个进程最多多少个线程">2. 一个进程最多多少个线程</h3>
<ul>
<li>32bit机器：用户态虚拟空间3G，如果线程栈空间为10M，则最多300个左右</li>
<li>64bit机器：用户态虚拟空间最大128T，仅受系统参数影响</li>
</ul>
<h3 id="进程的状态">3.进程的状态</h3>
<p>创建、运行/就绪/阻塞、结束</p>
<h2 id="中断和异常">4. 中断和异常</h2>
<h3 id="对比-1">1. 对比</h3>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 46%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>中断</th>
<th>异常</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>定义</td>
<td>由<strong>外部设备或硬件</strong>引起的事件，用于打断CPU当前的执行流程，以处理设备请求或其他异步事件</td>
<td>由当前<strong>正在执行的指令</strong>或程序中的错误或非正常条件引起的事件</td>
</tr>
<tr class="even">
<td>来源</td>
<td>键盘输入、定时器到期、时钟中断、输入输出中断或外部设备请求CPU的服务等</td>
<td>除以零、访问无效的内存地址或非法指令、非法指令、页错误、栈溢出等</td>
</tr>
<tr class="odd">
<td>处理方式</td>
<td>当发生中断时，CPU会中断当前的执行流程，保存当前的上下文信息，并跳转到<strong>中断处理程序</strong>（Interrupt
Service
Routine，ISR）来处理中断事件。处理完中断后，CPU会从中断处理程序返回到原来的执行点继续执行。</td>
<td>当发生异常时，CPU会中断当前的执行流程，保存当前的上下文信息，并跳转到<strong>异常处理程序</strong>（Exception
Handler）来处理异常情况。异常处理程序可以是操作系统内核中的异常处理例程，或者是应用程序中的异常处理代码。</td>
</tr>
<tr class="even">
<td>响应时间</td>
<td>中断具有<strong>异步</strong>性，可以随时发生，并且要求系统能够快速响应中断请求，以避免数据丢失或设备响应延迟等问题。</td>
<td>异常在程序执行过程中发生，并且通常是<strong>同步</strong>发生的，即在执行某个指令时引发异常。相对于中断，异常的<strong>响应时间可能更短</strong>，因为异常处理通常直接涉及到当前正在执行的指令或程序。</td>
</tr>
</tbody>
</table>
<h3 id="软中断">软中断</h3>
<p>软中断（Software
Interrupt）：软中断是由<strong>程序主动触发</strong>的中断机制。它并不是由硬件设备发出的信号，而是通过特定的指令或软件调用触发的。软中断常用于操作系统内核提供<strong>系统调用</strong>功能，用户程序可以通过软中断指令或函数调用请求操作系统服务。软中断是由<strong>软件层面</strong>提供的机制。</p>
<h3 id="cpu与设备的交互方式">2. CPU与设备的交互方式</h3>
<h4 id="轮询以循环等待的方式通过设备寄存器查询设备的工作进度">1.
<strong>轮询</strong>：以<strong>循环等待</strong>的方式通过<strong>设备寄存器</strong>查询设备的工作进度</h4>
<ul>
<li>缺点：轮询期间始终占用CPU资源，做无意义的工作</li>
<li>适合设备的相关事件连续发生且高频的场景（如网络包不断到达切足够高频的网卡）</li>
</ul>
<h4 id="中断硬件设备在某些事件发生后再通知cpu">2.
<strong>中断</strong>：硬件设备在某些事件发生后再通知CPU</h4>
<ul>
<li>缺点：频繁中断会造成大量的上下文切换</li>
</ul>
<h3 id="中断合并">3. <strong>中断合并</strong>：</h3>
<ul>
<li><p>设备内部设置了<strong>FIFO缓冲区</strong>，收到数据缓存起来，当数据个数超过一定的阈值或者超过配置的超时时间，设备会触发中断</p></li>
<li><p>显著降低中断的触发频率</p></li>
<li><p>中断响应的延迟有所增加</p></li>
</ul>
<h3 id="new-apinapi">4. <strong>New API</strong>（NAPI）：</h3>
<ul>
<li>在linux中，网卡首先采用中断接收网络包，当OS发现网络包的到达速率达到一定阈值后，改为轮询模式；当网络包的到达速率显著变慢时，改为中断模式</li>
</ul>
<h3 id="中断控制器interupt-controller">5. 中断控制器（Interupt
Controller）</h3>
<p>主要包括以下功能：</p>
<ul>
<li>中断号：映射设备到中断的关系</li>
<li>中断屏蔽</li>
<li>中断优先级</li>
</ul>
<h4
id="arm架构的通用中断控制器generic-interupt-controllergic">ARM架构的通用中断控制器（Generic
Interupt Controller，GIC）</h4>
<p><img src="/Users/zyh/Library/Application Support/typora-user-images/image-20240620212237307.png" alt="image-20240620212237307" style="zoom:50%;" /></p>
<p>GIC由分发器和CPU接口两个模块组成：</p>
<h5 id="分发器distributor">分发器（Distributor）</h5>
<ul>
<li>负责汇聚各个设备的中断请求，并根据路由配置将请求转发给目标核心。</li>
<li>提供全局的中断使能、中断优先级配置。</li>
</ul>
<h5 id="cpu接口cpu-interface">CPU接口（CPU Interface）</h5>
<ul>
<li>CPU接口与核心相连，提供每个核心的本地中断管理能力（如单个核心的中断使能、中断确认）</li>
<li>负责根据中断号在中断向量表中查询对应的中断处理函数</li>
<li>还可发起核间中断</li>
</ul>
<h3 id="中断共享">5. 中断共享</h3>
<p>中断共享（Interrupt
Sharing）是指多个设备或事件<strong>共享同一个中断线</strong>（IRQ）。在计算机系统中，中断线的数量是有限的，为了有效利用中断线资源，多个设备或事件可以被配置为共享同一个中断线。</p>
<p>当多个设备或事件共享同一个中断线时，它们将共同使用相同的中断向量和中断服务程序。当中断线触发时，CPU会通过查询中断向量表来确定要执行的中断服务程序。然后，中断服务程序会根据<strong>中断源的标识符或状态</strong>来区分不同的设备或事件，并执行相应的中断处理逻辑。</p>
<p>中断共享的优点是可以减少中断线的使用，节省硬件资源。然而，中断共享也可能带来一些挑战和潜在问题，包括：</p>
<ol type="1">
<li><p>中断冲突：当多个设备同时触发中断时，可能会发生中断冲突。这可能导致中断丢失或无法正确处理所有中断请求。</p></li>
<li><p>中断延迟：由于多个设备共享同一个中断线，CPU需要按照一定的顺序查询中断源，并依次处理中断。这可能导致中断响应的延迟。</p></li>
<li><p>中断处理程序复杂性：中断服务程序需要能够识别和处理多个设备或事件的中断请求。这可能增加了中断处理程序的复杂性和开发难度。</p></li>
</ol>
<h3 id="核间中断inter-core-interruptipi">6. 核间中断（Inter-Core
Interrupt，IPI）</h3>
<p>IPI（Inter-Processor
Interrupt）是一种用于在多处理器系统中进行核间通信的机制，是指在多核处理器系统中，一个核向另一个核发送中断信号的过程。</p>
<p>在多核处理器系统中，每个核心（或处理器）都有自己的执行单元和本地中断控制器。当一个核心需要与另一个核心进行通信或触发某个操作时，它可以通过发送IPI核间中断来实现。</p>
<p>发送IPI核间中断的核心被称为发送者（Sender），接收IPI中断的核心被称为接收者（Receiver）。</p>
<p>IPI核间中断允许不同核心之间进行快速且低延迟的通信，以实现系统级别的协调和通信。它在多核处理器系统中起到了重要的作用，例如在<strong>任务调度、同步操作、进程间通信</strong>等方面。</p>
<h3 id="中断屏蔽掩码interrupt-masking">7. 中断屏蔽/掩码（Interrupt
Masking）</h3>
<p>中断屏蔽的目的是允许系统在特定情况下忽略或暂停某些中断的处理，以防止其干扰正在进行的关键任务或操作。通过设置中断屏蔽，可以控制中断的优先级和响应情况。</p>
<p>中断屏蔽通常通过中断屏蔽寄存器（或称为中断屏蔽字）来实现。中断屏蔽寄存器的每一位对应一个中断线，可以设置为屏蔽（mask）或解除屏蔽（unmask）的状态。当某个中断线的屏蔽位置为屏蔽状态时，即使该中断发生，CPU也不会响应该中断。</p>
<h2 id="虚拟化">6. 虚拟化</h2>
<p>虚拟化：把一个物理实体转换为多个逻辑实体。</p>
<p>两种方式：时分复用（如多进/线程）和空（如虚拟内存）分复用。</p>
<h3 id="虚拟内存的目的">1. 虚拟内存的目的</h3>
<p>为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p>
<p>程序的逻辑内存的页被映射到不同的磁盘页中，物理内存只需要装入必要的页就能运行程序。</p>
<h2 id="同步">7. 同步</h2>
<h3 id="各种锁以及适用场景">1. 各种锁以及适用场景</h3>
<ol type="1">
<li><strong>互斥锁</strong>（Mutex）：互斥锁用于保护共享资源免受并发访问的影响。它在同一时间只允许一个线程访问被保护的资源，其他线程必须等待锁释放后才能访问。适用于需要<strong>独占资</strong>源的场景，如临界区保护、数据结构的互斥访问等。</li>
<li><strong>读写锁</strong>（Reader-Writer
Lock）：读写锁允许多个线程同时读取共享资源，但只允许一个线程进行写操作。它在读取较为频繁、写入较少的场景下提供了更高的并发性。适用于<strong>读多写少</strong>的数据结构，如缓存、数据库等。</li>
<li><strong>自旋锁</strong>（Spin
Lock）：自旋锁是一种<strong>忙等待锁</strong>，线程在无法获取锁时会一直循环检查，直到成功获取。自旋锁适用于保护共享资源的时间很短，<strong>线程等待锁的时间较短的场景</strong>。它<strong>避免了线程切换的开销</strong>，但在锁竞争激烈的情况下可能会导致CPU资源的浪费。</li>
<li><strong>条件变量</strong>（Condition
Variable）：条件变量用于线程间的同步和通信。它<strong>通常与互斥锁一起使用</strong>，用于<strong>等待条件满足或唤醒</strong>等操作。适用于需要线程间等待和通信的场景，如<strong>生产者-消费者</strong>问题、<strong>多线程任务调度</strong>等。</li>
<li><strong>信号量</strong>（Semaphore）：信号量是一种计数器，用于控制对资源的并发访问。它可以用于限制同时访问资源的线程数量，也可以用于线程间的同步。适用于<strong>控制资源的并发数量</strong>或实现线程间同步的场景，如<strong>连接池、资源池</strong>等。</li>
<li><strong>屏障</strong>（Barrier）：屏障用于<strong>线程间的同步</strong>，它会阻塞线程直到满足特定条件。线程在达到屏障点后会等待，直到所有线程都到达屏障点后才会继续执行。适用于<strong>需要等待所有线程完成某个阶段后再继续执行</strong>的场景，如<strong>并行计算中的同步点</strong>。</li>
</ol>
<h3 id="死锁">2. 死锁</h3>
<h4 id="导致死锁出现的必要条件">1. 导致死锁出现的必要条件</h4>
<ol type="1">
<li>互斥条件（Mutual
Exclusion）：至少有一个资源被标记为只能同时由一个进程（线程）访问和使用，即一次只能有一个进程占有该资源。</li>
<li>请求与保持条件（Hold and
Wait）：一个进程（线程）在持有一部分资源的同时，又请求其他进程（线程）当前正占有的资源。</li>
<li>不可剥夺条件（No
Preemption）：已经分配给一个进程（线程）的资源不能被强制性地剥夺，只能由占有该资源的进程（线程）显式释放。</li>
<li>循环等待条件（Circular
Wait）：存在一个进程（线程）的资源需求链，使得每个进程（线程）都在等待下一个进程（线程）所占有的资源。</li>
</ol>
<h4 id="死锁的场景">2. 死锁的场景</h4>
<ol type="1">
<li><strong>资源竞争</strong>：多个进程同时请求和竞争一组有限资源，并且每个进程都持有一个资源并等待其他进程释放其所需的资源。例如，两个进程分别持有资源A和资源B，同时又请求对方持有的资源，导致死锁。</li>
<li><strong>循环等待</strong>：多个进程形成一个循环链，每个进程都等待下一个进程所持有的资源。例如，进程A等待进程B的资源，进程B等待进程C的资源，而进程C又等待进程A的资源。这种循环等待关系可能导致死锁。</li>
<li>AA死锁：当一个线程已经持有某个锁时，再次请求获取同一把锁时，如果锁不是可重入的（reentrant），可能会被阻塞。</li>
</ol>
<h4 id="死锁预防">3. 死锁预防</h4>
<p>银行家算法：如果系统的剩余资源无法满足该线程所需要的所有资源，则不给该线程分配资源。</p>
<h4 id="死锁检测">4. 死锁检测</h4>
<p>定时检测、超时等待检测</p>
<h2 id="linux系统命令">8. Linux系统命令</h2>
<ol type="1">
<li>查看进程的内存空间布局：<code>cat /proc/PID/maps</code></li>
</ol>
<!-- flag of hidden posts -->
    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Yuhang Zhang
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://eric-zhang-c.github.io/zyhjy/2024/05/28/osquestions/" title="OS面试问题合集">https://eric-zhang-c.github.io/zyhjy/2024/05/28/osquestions/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <style>
        #taboola-livere { display: none;}
    </style>
    <div id="lv-container" data-id="city" data-uid="MTAyMC81ODg3Ni8zNTMzOA=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98"><span class="nav-text">1. 内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-text">1. 虚拟地址空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#linux%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80"><span class="nav-text">1. Linux进程虚拟地址空间布局</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%8D%E6%9C%BA%E5%99%A8"><span class="nav-text">32位机器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%8D%E6%9C%BA%E5%99%A8-1"><span class="nav-text">64位机器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#linux%E8%BF%9B%E7%A8%8B%E5%86%85%E6%A0%B8%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-text">2. Linux进程内核虚拟地址空间</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84%E5%8C%BA"><span class="nav-text">1. 直接映射区：</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A0%88"><span class="nav-text">内核栈</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#vmalloc-%E5%8A%A8%E6%80%81%E6%98%A0%E5%B0%84%E5%8C%BA"><span class="nav-text">2. vmalloc 动态映射区</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B0%B8%E4%B9%85%E6%98%A0%E5%B0%84%E5%8C%BA32%E4%BD%8D%E6%9C%BA%E5%99%A8"><span class="nav-text">3. 永久映射区（32位机器）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%BA%E5%AE%9A%E6%98%A0%E5%B0%84%E5%8C%BA32%E4%BD%8D%E6%9C%BA%E5%99%A8"><span class="nav-text">4. 固定映射区（32位机器）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%B4%E6%97%B6%E6%98%A0%E5%B0%84%E5%8C%BA32%E4%BD%8D%E6%9C%BA%E5%99%A8"><span class="nav-text">5. 临时映射区（32位机器）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%8C%BA64%E4%BD%8D%E6%9C%BA%E5%99%A8"><span class="nav-text">6. 虚拟内存映射区（64位机器）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%AE%B564%E4%BD%8D%E6%9C%BA%E5%99%A8"><span class="nav-text">7. 代码段（64位机器）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8"><span class="nav-text">2. 页表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="nav-text">1. 多级页表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">3. 内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9Fbuddy-system"><span class="nav-text">1. 伙伴系统（Buddy System）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#slab%E5%88%86%E9%85%8D%E5%99%A8"><span class="nav-text">2. SLAB分配器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E5%92%8C%E5%86%85%E5%AD%98%E8%A6%86%E7%9B%96"><span class="nav-text">4. 内存交换和内存覆盖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="nav-text">5. 内存分配算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cowcopy-on-write"><span class="nav-text">6. COW（copy on write）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rcuread-copy-update"><span class="nav-text">7. RCU（read copy update）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-text">2. 进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-text">1.共享内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-text">1. 什么是共享内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-text">2. 为什么需要共享内存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%85%E5%8A%A9%E5%91%BD%E4%BB%A4"><span class="nav-text">3. 辅助命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-text">3. 进程、线程、协程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94"><span class="nav-text">1. 对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E6%9C%80%E5%A4%9A%E5%A4%9A%E5%B0%91%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="nav-text">2. 一个进程最多多少个线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-text">3.进程的状态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="nav-text">4. 中断和异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94-1"><span class="nav-text">1. 对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%B8%AD%E6%96%AD"><span class="nav-text">软中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cpu%E4%B8%8E%E8%AE%BE%E5%A4%87%E7%9A%84%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F"><span class="nav-text">2. CPU与设备的交互方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AE%E8%AF%A2%E4%BB%A5%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85%E7%9A%84%E6%96%B9%E5%BC%8F%E9%80%9A%E8%BF%87%E8%AE%BE%E5%A4%87%E5%AF%84%E5%AD%98%E5%99%A8%E6%9F%A5%E8%AF%A2%E8%AE%BE%E5%A4%87%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%9B%E5%BA%A6"><span class="nav-text">1.
轮询：以循环等待的方式通过设备寄存器查询设备的工作进度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E7%A1%AC%E4%BB%B6%E8%AE%BE%E5%A4%87%E5%9C%A8%E6%9F%90%E4%BA%9B%E4%BA%8B%E4%BB%B6%E5%8F%91%E7%94%9F%E5%90%8E%E5%86%8D%E9%80%9A%E7%9F%A5cpu"><span class="nav-text">2.
中断：硬件设备在某些事件发生后再通知CPU</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%90%88%E5%B9%B6"><span class="nav-text">3. 中断合并：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new-apinapi"><span class="nav-text">4. New API（NAPI）：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8interupt-controller"><span class="nav-text">5. 中断控制器（Interupt
Controller）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#arm%E6%9E%B6%E6%9E%84%E7%9A%84%E9%80%9A%E7%94%A8%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8generic-interupt-controllergic"><span class="nav-text">ARM架构的通用中断控制器（Generic
Interupt Controller，GIC）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%8F%91%E5%99%A8distributor"><span class="nav-text">分发器（Distributor）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#cpu%E6%8E%A5%E5%8F%A3cpu-interface"><span class="nav-text">CPU接口（CPU Interface）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%85%B1%E4%BA%AB"><span class="nav-text">5. 中断共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E9%97%B4%E4%B8%AD%E6%96%ADinter-core-interruptipi"><span class="nav-text">6. 核间中断（Inter-Core
Interrupt，IPI）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%B1%8F%E8%94%BD%E6%8E%A9%E7%A0%81interrupt-masking"><span class="nav-text">7. 中断屏蔽&#x2F;掩码（Interrupt
Masking）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="nav-text">6. 虚拟化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="nav-text">1. 虚拟内存的目的</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5"><span class="nav-text">7. 同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%84%E7%A7%8D%E9%94%81%E4%BB%A5%E5%8F%8A%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">1. 各种锁以及适用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-text">2. 死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81%E5%87%BA%E7%8E%B0%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-text">1. 导致死锁出现的必要条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="nav-text">2. 死锁的场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2"><span class="nav-text">3. 死锁预防</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="nav-text">4. 死锁检测</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4"><span class="nav-text">8. Linux系统命令</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yuhang Zhang"
      src="/zyhjy/images/zyhjy.png">
  <p class="site-author-name" itemprop="name">Yuhang Zhang</p>
  <div class="site-description" itemprop="description">爱小雅，爱生活，爱物理!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/zyhjy/archives/">
        
          <span class="site-state-item-count">85</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/zyhjy/categories/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/zyhjy/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/zyhjy/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuhang Zhang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">469k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">13:01</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/zyhjy/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>

<script src="/zyhjy/js/utils.js"></script>


<script src="/zyhjy/js/schemes/pisces.js"></script>


<script src="/zyhjy/js/next-boot.js"></script>




  




  
<script src="/zyhjy/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
